### **1. Project Context Specification**

You will be provided with a comprehensive dump of the Godot project context, structured as follows. You must parse, understand, and use this context to inform all your responses.

*   **`2. Project Context`**: The technical project dump, including:
    *   `2.1. Project Settings`
    *   `2.2. Resource Files`
    *   `2.3. Scene Structures`
    *   `2.4. Codebase`

---
### **2. Project Context**

#### **2.1. Project Settings**

--- START OF PROJECT SETTINGS ---
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Project Robin Hood"
run/main_scene="uid://c8yq465fd8xvt"
config/features=PackedStringArray("4.4", "GL Compatibility")
config/icon="res://icon.svg"

[autoload]

EventBus="*res://Singletons/EventBus.gd"
GameManager="*res://Singletons/game_manager.tscn"
InteractionManager="*res://Singletons/InteractionManager.gd"
UIManager="*res://UserInterface/UIManager.gd"
SceneManager="*res://Singletons/SceneManager.tscn"
Loggie="*res://addons/loggie/loggie.gd"
PhantomCameraManager="*res://addons/phantom_camera/scripts/managers/phantom_camera_manager.gd"

[display]

window/size/viewport_width=640
window/size/viewport_height=360
window/stretch/mode="canvas_items"

[editor_plugins]

enabled=PackedStringArray("res://addons/GodotAiSuite/plugin.cfg", "res://addons/godot-vision-cone-main/addons/vision_cone_2d/plugin.cfg", "res://addons/gut/plugin.cfg", "res://addons/loggie/plugin.cfg", "res://addons/phantom_camera/plugin.cfg")

[global_group]

hazards=""
player=""
PlayerCamera=""
DialogueBox=""
camera_boundary=""

[input]

ui_accept={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194309,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194310,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":32,"physical_keycode":0,"key_label":0,"unicode":32,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":1,"pressure":0.0,"pressed":true,"script":null)
]
}
ui_cancel={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194305,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":0,"pressure":0.0,"pressed":true,"script":null)
]
}
jump={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":32,"key_label":0,"unicode":32,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":0,"pressure":0.0,"pressed":false,"script":null)
]
}
left={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194319,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":-1,"axis":0,"axis_value":-1.0,"script":null)
]
}
right={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194321,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":-1,"axis":0,"axis_value":1.0,"script":null)
]
}
up={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194320,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":3,"pressure":0.0,"pressed":false,"script":null)
]
}
down={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194322,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":-1,"axis":1,"axis_value":1.0,"script":null)
]
}
shift={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194325,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":-1,"axis":5,"axis_value":1.0,"script":null)
]
}
dash={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":70,"key_label":0,"unicode":102,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":2,"pressure":0.0,"pressed":true,"script":null)
]
}
esc={
"deadzone": 0.2,
"events": [Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":4,"pressure":0.0,"pressed":true,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}
left_bumper={
"deadzone": 0.2,
"events": [Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":9,"pressure":0.0,"pressed":true,"script":null)
]
}
slide={
"deadzone": 0.2,
"events": [Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":10,"pressure":0.0,"pressed":true,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194325,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}
interact={
"deadzone": 0.2,
"events": [Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":1,"pressure":0.0,"pressed":true,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":69,"key_label":0,"unicode":101,"location":0,"echo":false,"script":null)
]
}
pause={
"deadzone": 0.2,
"events": [Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":6,"pressure":0.0,"pressed":true,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}
invisibility={
"deadzone": 0.2,
"events": [Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":9,"pressure":0.0,"pressed":true,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":67,"key_label":0,"unicode":99,"location":0,"echo":false,"script":null)
]
}
interact_world={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":69,"key_label":0,"unicode":101,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":1,"pressure":0.0,"pressed":true,"script":null)
]
}
right_bumper={
"deadzone": 0.2,
"events": [Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":10,"pressure":0.0,"pressed":true,"script":null)
]
}

[rendering]

textures/canvas_textures/default_texture_filter=0
renderer/rendering_method="gl_compatibility"
renderer/rendering_method.mobile="gl_compatibility"
--- END OF PROJECT SETTINGS ---

#### **2.2. Resource Files**

--- START OF RESOURCE FILES ---
--- RESOURCE: res://addons/gut/gui/GutSceneTheme.tres ---
[gd_resource type="Theme" load_steps=2 format=3 uid="uid://cstkhwkpajvqu"]

[ext_resource type="FontFile" uid="uid://c6c7gnx36opr0" path="res://addons/gut/fonts/AnonymousPro-Regular.ttf" id="1_df57p"]

[resource]
default_font = ExtResource("1_df57p")
Label/fonts/font = ExtResource("1_df57p")

--- RESOURCE: res://addons/loggie/assets/theme/loggie_border_box.tres ---
[gd_resource type="StyleBoxFlat" format=3 uid="uid://ckw36egxdynxc"]

[resource]
draw_center = false
border_width_left = 3
border_width_top = 3
border_width_right = 3
border_width_bottom = 3
border_color = Color(0.71, 0.52114, 0.1704, 0.772549)
border_blend = true
corner_radius_top_left = 10
corner_radius_top_right = 10
corner_radius_bottom_right = 10
corner_radius_bottom_left = 10

--- RESOURCE: res://addons/loggie/assets/theme/loggie_theme.tres ---
[gd_resource type="Theme" load_steps=10 format=3 uid="uid://bntkg3oi4b314"]

[ext_resource type="FontFile" uid="uid://btuvtbhws7p8s" path="res://addons/loggie/assets/theme/fonts/PatrickHandSC-Regular.ttf" id="1_ucfms"]
[ext_resource type="Texture2D" uid="uid://bfnp2a0sbhi2x" path="res://addons/loggie/assets/theme/checkbox/checkbox_checked.png" id="2_tqabx"]
[ext_resource type="Texture2D" uid="uid://dqf5cye21gyw8" path="res://addons/loggie/assets/theme/checkbox/checkbox_checked_disabled.png" id="3_plx1a"]
[ext_resource type="Texture2D" uid="uid://bib1lwikra5kr" path="res://addons/loggie/assets/theme/checkbox/checkbox_unchecked.png" id="4_yp55b"]
[ext_resource type="Texture2D" uid="uid://cloe7vx2ej0nf" path="res://addons/loggie/assets/theme/checkbox/checkbox_unchecked_disabled.png" id="5_0424s"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_gb03k"]
bg_color = Color(0.349691, 0.30101, 0.201282, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(0.361244, 0.323458, 0.213348, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8
expand_margin_left = 2.0
expand_margin_top = 1.0
expand_margin_right = 2.0
expand_margin_bottom = 1.0
anti_aliasing_size = 0.537

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_73pt3"]
bg_color = Color(0.767332, 0.598222, 0.330864, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(0.943861, 0.775452, 0.522251, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8
expand_margin_left = 2.0
expand_margin_top = 1.0
expand_margin_right = 2.0
expand_margin_bottom = 1.0
anti_aliasing_size = 0.537

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_xxk7l"]
bg_color = Color(0.661808, 0.507874, 0.261375, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(0.83, 0.629555, 0.3071, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8
expand_margin_left = 2.0
expand_margin_top = 1.0
expand_margin_right = 2.0
expand_margin_bottom = 1.0
anti_aliasing_size = 0.537

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_i1fiu"]
bg_color = Color(0.6, 0.4574, 0.228, 1)
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color(0.83, 0.629555, 0.3071, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8
expand_margin_left = 2.0
expand_margin_top = 1.0
expand_margin_right = 2.0
expand_margin_bottom = 1.0
anti_aliasing_size = 0.537

[resource]
Button/constants/outline_size = 6
Button/font_sizes/font_size = 30
Button/fonts/font = ExtResource("1_ucfms")
Button/styles/disabled = SubResource("StyleBoxFlat_gb03k")
Button/styles/focus = SubResource("StyleBoxFlat_73pt3")
Button/styles/hover = SubResource("StyleBoxFlat_xxk7l")
Button/styles/normal = SubResource("StyleBoxFlat_i1fiu")
CheckBox/icons/checked = ExtResource("2_tqabx")
CheckBox/icons/checked_disabled = ExtResource("3_plx1a")
CheckBox/icons/radio_checked = ExtResource("2_tqabx")
CheckBox/icons/radio_checked_disabled = ExtResource("3_plx1a")
CheckBox/icons/radio_unchecked = ExtResource("4_yp55b")
CheckBox/icons/radio_unchecked_disabled = ExtResource("5_0424s")
CheckBox/icons/unchecked = ExtResource("4_yp55b")
CheckBox/icons/unchecked_disabled = ExtResource("5_0424s")
Label/colors/font_color = Color(0.980392, 0.843137, 0.619608, 1)
Label/constants/outline_size = 3
Label/font_sizes/font_size = 21

--- RESOURCE: res://addons/phantom_camera/examples/resources/tween/fixed_camera_tween.tres ---
[gd_resource type="Resource" script_class="PhantomCameraTween" load_steps=2 format=3 uid="uid://c1v786g5agaw5"]

[ext_resource type="Script" uid="uid://8umksf8e80fw" path="res://addons/phantom_camera/scripts/resources/tween_resource.gd" id="1_ptlie"]

[resource]
script = ExtResource("1_ptlie")
duration = 0.0
transition = 0
ease = 2

--- RESOURCE: res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres ---
[gd_resource type="Resource" script_class="PhantomCameraTween" load_steps=2 format=3 uid="uid://cllveybboaqk5"]

[ext_resource type="Script" uid="uid://8umksf8e80fw" path="res://addons/phantom_camera/scripts/resources/tween_resource.gd" id="1_7yoy0"]

[resource]
script = ExtResource("1_7yoy0")
duration = 0.6
transition = 5
ease = 1

--- RESOURCE: res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres ---
[gd_resource type="Resource" script_class="PhantomCameraTween" load_steps=2 format=3 uid="uid://cecrnq0wnkexh"]

[ext_resource type="Script" uid="uid://8umksf8e80fw" path="res://addons/phantom_camera/scripts/resources/tween_resource.gd" id="1_sq5ls"]

[resource]
script = ExtResource("1_sq5ls")
duration = 0.6
transition = 8
ease = 1

--- RESOURCE: res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_2d_tween.tres ---
[gd_resource type="Resource" script_class="PhantomCameraTween" load_steps=2 format=3 uid="uid://euybd2w0bax"]

[ext_resource type="Script" uid="uid://8umksf8e80fw" path="res://addons/phantom_camera/scripts/resources/tween_resource.gd" id="1_by4ei"]

[resource]
script = ExtResource("1_by4ei")
duration = 0.6
transition = 3
ease = 1

--- RESOURCE: res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres ---
[gd_resource type="Resource" script_class="PhantomCameraTween" load_steps=2 format=3 uid="uid://cptfoggk2ok67"]

[ext_resource type="Script" uid="uid://8umksf8e80fw" path="res://addons/phantom_camera/scripts/resources/tween_resource.gd" id="1_q5tix"]

[resource]
script = ExtResource("1_q5tix")
duration = 0.6
transition = 3
ease = 2

--- RESOURCE: res://addons/phantom_camera/panel/viewfinder/deadzone_style_box.tres ---
[gd_resource type="StyleBoxFlat" format=3 uid="uid://dpa7yvxlq043a"]

[resource]
bg_color = Color(0.227451, 0.72549, 0.603922, 0.2)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.227451, 0.72549, 0.603922, 1)
corner_detail = 1
expand_margin_left = 1.0
expand_margin_top = 1.0
expand_margin_right = 1.0
expand_margin_bottom = 1.0

--- RESOURCE: res://addons/phantom_camera/panel/viewfinder/host_list/host_list_item_group.tres ---
[gd_resource type="ButtonGroup" format=3 uid="uid://dfu0b8jbtyr1n"]

[resource]

--- RESOURCE: res://addons/phantom_camera/themes/button_focus.tres ---
[gd_resource type="StyleBoxFlat" format=3 uid="uid://p058hmj3uut0"]

[resource]
content_margin_left = 8.0
content_margin_top = 4.0
content_margin_right = 8.0
content_margin_bottom = 4.0
bg_color = Color(0.0784314, 0.109804, 0.129412, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.227451, 0.72549, 0.603922, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

--- RESOURCE: res://addons/phantom_camera/themes/button_hover.tres ---
[gd_resource type="StyleBoxFlat" format=3 uid="uid://5weqvkjsfso3"]

[resource]
content_margin_left = 8.0
content_margin_top = 4.0
content_margin_right = 8.0
content_margin_bottom = 4.0
bg_color = Color(0.960784, 0.960784, 0.960784, 1)
border_color = Color(0.227451, 0.72549, 0.603922, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

--- RESOURCE: res://addons/phantom_camera/themes/button_normal.tres ---
[gd_resource type="StyleBoxFlat" format=3 uid="uid://bclbwo3xrdat0"]

[resource]
content_margin_left = 8.0
content_margin_top = 4.0
content_margin_right = 8.0
content_margin_bottom = 4.0
bg_color = Color(0.0784314, 0.109804, 0.129412, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.227451, 0.72549, 0.603922, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

--- RESOURCE: res://addons/phantom_camera/themes/theme.tres ---
[gd_resource type="Theme" load_steps=12 format=3 uid="uid://bhppejri5dbsf"]

[ext_resource type="FontFile" uid="uid://dve7mgsjik4dg" path="res://addons/phantom_camera/fonts/Nunito-Regular.ttf" id="1_5rtjh"]
[ext_resource type="StyleBox" uid="uid://5weqvkjsfso3" path="res://addons/phantom_camera/themes/button_hover.tres" id="2_du6h5"]
[ext_resource type="StyleBox" uid="uid://bclbwo3xrdat0" path="res://addons/phantom_camera/themes/button_normal.tres" id="3_a8j1f"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_ek0y3"]
content_margin_left = 8.0
content_margin_top = 4.0
content_margin_right = 8.0
content_margin_bottom = 4.0
bg_color = Color(0.227451, 0.72549, 0.603922, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_rjkuq"]
content_margin_left = 8.0
content_margin_top = 4.0
content_margin_right = 8.0
content_margin_bottom = 4.0
bg_color = Color(0.227451, 0.72549, 0.603922, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_x7u0w"]
content_margin_top = 2.0
content_margin_right = 8.0
bg_color = Color(0.0784314, 0.109804, 0.129412, 1)
border_width_top = 2
border_width_right = 2
border_color = Color(0.227451, 0.72549, 0.603922, 1)
corner_radius_top_right = 10

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_dln2q"]
content_margin_top = 8.0
content_margin_bottom = 8.0
draw_center = false

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_wk7ot"]
bg_color = Color(0.227451, 0.72549, 0.603922, 1)
border_color = Color(0.227451, 0.72549, 0.603922, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_jidrt"]
bg_color = Color(0.960784, 0.960784, 0.960784, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_o2xwc"]
bg_color = Color(0.960784, 0.960784, 0.960784, 1)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_ul127"]
draw_center = false
border_width_left = 4
border_width_right = 4
border_color = Color(0.8, 0.8, 0.8, 0)

[resource]
default_font = ExtResource("1_5rtjh")
Button/colors/font_color = Color(0.227451, 0.72549, 0.603922, 1)
Button/colors/font_focus_color = Color(0.0784314, 0.109804, 0.129412, 1)
Button/colors/font_hover_color = Color(0.0784314, 0.109804, 0.129412, 1)
Button/colors/font_hover_pressed_color = Color(0.0784314, 0.109804, 0.129412, 1)
Button/colors/font_pressed_color = Color(0.0784314, 0.109804, 0.129412, 1)
Button/colors/icon_focus_color = Color(0.0784314, 0.109804, 0.129412, 1)
Button/colors/icon_hover_color = Color(0.0784314, 0.109804, 0.129412, 1)
Button/colors/icon_hover_pressed_color = Color(0.227451, 0.72549, 0.603922, 1)
Button/colors/icon_normal_color = Color(0.0784314, 0.109804, 0.129412, 1)
Button/colors/icon_pressed_color = Color(0.227451, 0.72549, 0.603922, 1)
Button/styles/focus = SubResource("StyleBoxFlat_ek0y3")
Button/styles/hover = ExtResource("2_du6h5")
Button/styles/hover_pressed = null
Button/styles/normal = ExtResource("3_a8j1f")
Button/styles/pressed = SubResource("StyleBoxFlat_rjkuq")
PanelContainer/styles/panel = SubResource("StyleBoxFlat_x7u0w")
ScrollContainer/styles/panel = SubResource("StyleBoxFlat_dln2q")
VBoxContainer/constants/separation = 8
VScrollBar/styles/grabber = SubResource("StyleBoxFlat_wk7ot")
VScrollBar/styles/grabber_highlight = SubResource("StyleBoxFlat_jidrt")
VScrollBar/styles/grabber_pressed = SubResource("StyleBoxFlat_o2xwc")
VScrollBar/styles/scroll = SubResource("StyleBoxFlat_ul127")

--- RESOURCE: res://Data/hideout_upgrades.tres ---
[gd_resource type="Resource" script_class="HideoutProgressionData" load_steps=2 format=3 uid="uid://wfwljs475tnc"]

[ext_resource type="Script" uid="uid://cisjnutxkesm1" path="res://Data/HideoutProgressionData.gd" id="1_pjwpe"]

[resource]
script = ExtResource("1_pjwpe")
upgrade_costs = Array[int]([10, 250])
max_level = 3
metadata/_custom_type_script = "uid://cisjnutxkesm1"

--- RESOURCE: res://Levels/Hideout/hideout_theme.tres ---
[gd_resource type="Theme" load_steps=2 format=3 uid="uid://cindktpnsryh8"]

[ext_resource type="FontFile" uid="uid://dpa56w0q32n41" path="res://UserInterface/8bitlimr.ttf" id="1_xj80g"]

[resource]
default_font = ExtResource("1_xj80g")
Button/fonts/font = ExtResource("1_xj80g")
Label/font_sizes/font_size = 25
Label/fonts/font = ExtResource("1_xj80g")

--- RESOURCE: res://pixel_theme.tres ---
[gd_resource type="Theme" load_steps=2 format=3 uid="uid://bgx3prsgldcw2"]

[ext_resource type="FontFile" uid="uid://dpa56w0q32n41" path="res://UserInterface/8bitlimr.ttf" id="1_ghajk"]

[resource]
default_font = ExtResource("1_ghajk")
Button/fonts/font = ExtResource("1_ghajk")
Label/fonts/font = ExtResource("1_ghajk")

--- RESOURCE: res://Player/Data/default_camera_stats.tres ---
[gd_resource type="Resource" script_class="CameraStats" load_steps=2 format=3 uid="uid://u5b8dtjrhv5f"]

[ext_resource type="Script" uid="uid://cncohoeprijfe" path="res://Player/Data/CameraStats.gd" id="1_kqdxa"]

[resource]
script = ExtResource("1_kqdxa")
horizontal_deadzone = 500.0
vertical_deadzone = 60.0
smoothing_speed = 4.0
fall_speed_multiplier = 3.0
look_offset = 75.0
look_speed = 6.0
lookahead_distance = 80.0
facing_offset = 50.0
ledge_peek_offset = 50.0
wall_slide_peek_offset = 100.0
recenter_speed = 2.5
upward_velocity_threshold = 100.0
vertical_lookahead_amount = -100.0
vertical_lookahead_speed = 4.5
metadata/_custom_type_script = "uid://cncohoeprijfe"

--- RESOURCE: res://Player/Data/player_stats.tres ---
[gd_resource type="Resource" script_class="PlayerStats" load_steps=2 format=3 uid="uid://st5loweg5geo"]

[ext_resource type="Script" uid="uid://bx05fogp11uwl" path="res://Player/Data/PlayerStats.gd" id="1_byv2g"]

[resource]
script = ExtResource("1_byv2g")
speed = 350.0
air_control_acceleration = 250.0
terminal_velocity = 750.0
acceleration_smoothness = 0.1
friction_smoothness = 0.3
jump_height = 120.0
time_to_apex = 0.5
fall_gravity = 2400.0
jump_cut_multiplier = 0.3
glide_velocity = 300.0
blink_dash_enabled = false
slide_duration = 0.4
standing_slide_speed = 375.0
slide_friction = 0.01
skid_duration = 0.25
skid_friction = 0.25
wall_slip_duration = 0.08
wall_slide_friction = 80.0
crouch_speed_multiplier = 0.5
wall_slide_jump_horizontal_velocity = 600.0
wall_slide_jump_vertical_velocity = -600.0
wall_stick_jump_horizontal_velocity = 900.0
wall_stick_jump_vertical_velocity = -400.0
dash_end_velocity_multiplier = 0.3
invisibility_duration = 2.0
invisibility_cooldown = 5.0
wall_kick_horizontal_velocity = 1200.0
wall_kick_vertical_velocity = -200.0
wall_kick_duration = 0.25
coyote_time_duration = 0.2
wall_coyote_time_duration = 0.18
jump_buffer_duration = 0.1
dash_freeze_duration = 0.08
fall_zoom_delay = 0.3
wall_detach_hang_time = 0.2
wall_detach_gravity_scale = 0.5
metadata/_custom_type_script = "uid://bx05fogp11uwl"

--- RESOURCE: res://VFX/VFXData/dash_prepare.tres ---
[gd_resource type="Resource" script_class="VFXData" load_steps=3 format=3 uid="uid://ccg8jgat5rg5m"]

[ext_resource type="Script" uid="uid://ctlafprqxjjv2" path="res://VFX/VFXData/VFXData.gd" id="1_rao5i"]
[ext_resource type="PackedScene" uid="uid://b65sf7txtiy3x" path="res://VFX/AnimatedEffect.tscn" id="1_tc740"]

[resource]
script = ExtResource("1_rao5i")
effect_scene = ExtResource("1_tc740")
animation_name = "dash_puff"
playback_speed = 1.0
spawn_marker_name = "FootSpawner"
position_offset = Vector2(-15, 0)
flip_h_with_player = true
flip_h_with_wall = false
rotate_with_wall_normal = false
rotation_degrees = 0.0
scale = Vector2(1, 1)
camera_punch_intensity = 0.1
metadata/_custom_type_script = "uid://ctlafprqxjjv2"

--- RESOURCE: res://VFX/VFXData/dash_start.tres ---
[gd_resource type="Resource" script_class="VFXData" load_steps=3 format=3 uid="uid://do1e8ufcym8bj"]

[ext_resource type="PackedScene" uid="uid://b65sf7txtiy3x" path="res://VFX/AnimatedEffect.tscn" id="1_viw41"]
[ext_resource type="Script" uid="uid://ctlafprqxjjv2" path="res://VFX/VFXData/VFXData.gd" id="2_u3og0"]

[resource]
script = ExtResource("2_u3og0")
effect_scene = ExtResource("1_viw41")
animation_name = "jump_puff"
playback_speed = 1.0
spawn_marker_name = "FootSpawner"
position_offset = Vector2(0, 0)
flip_h_with_player = true
flip_h_with_wall = false
rotate_with_wall_normal = false
rotation_degrees = 90.0
scale = Vector2(1, 1)
camera_punch_intensity = 0.0
metadata/_custom_type_script = "uid://ctlafprqxjjv2"

--- RESOURCE: res://VFX/VFXData/jump_puff_vfx.tres ---
[gd_resource type="Resource" script_class="VFXData" load_steps=3 format=3 uid="uid://c52ah0tjgskhb"]

[ext_resource type="Script" uid="uid://ctlafprqxjjv2" path="res://VFX/VFXData/VFXData.gd" id="1_4juc7"]
[ext_resource type="PackedScene" uid="uid://b65sf7txtiy3x" path="res://VFX/AnimatedEffect.tscn" id="1_lh7h6"]

[resource]
script = ExtResource("1_4juc7")
effect_scene = ExtResource("1_lh7h6")
animation_name = "jump_puff"
playback_speed = 1.0
spawn_marker_name = "FootSpawner"
position_offset = Vector2(0, 0)
flip_h_with_player = false
flip_h_with_wall = false
rotate_with_wall_normal = false
rotation_degrees = 0.0
scale = Vector2(1, 1)
camera_punch_intensity = 0.0
metadata/_custom_type_script = "uid://ctlafprqxjjv2"

--- RESOURCE: res://VFX/VFXData/land_puff_vfx.tres ---
[gd_resource type="Resource" script_class="VFXData" load_steps=3 format=3 uid="uid://fow4ncrcxhnu"]

[ext_resource type="Script" uid="uid://ctlafprqxjjv2" path="res://VFX/VFXData/VFXData.gd" id="1_0ydjj"]
[ext_resource type="PackedScene" uid="uid://b65sf7txtiy3x" path="res://VFX/AnimatedEffect.tscn" id="1_hwssi"]

[resource]
script = ExtResource("1_0ydjj")
effect_scene = ExtResource("1_hwssi")
animation_name = "jump_puff"
playback_speed = 1.0
spawn_marker_name = "FootSpawner"
position_offset = Vector2(0, 0)
flip_h_with_player = false
flip_h_with_wall = false
rotate_with_wall_normal = false
rotation_degrees = 0.0
scale = Vector2(1, 1)
camera_punch_intensity = 0.0
metadata/_custom_type_script = "uid://ctlafprqxjjv2"

--- RESOURCE: res://VFX/VFXData/skid_puff.tres ---
[gd_resource type="Resource" script_class="VFXData" load_steps=3 format=3 uid="uid://ci5d3pjnftf5n"]

[ext_resource type="Script" uid="uid://ctlafprqxjjv2" path="res://VFX/VFXData/VFXData.gd" id="1_0j7f5"]
[ext_resource type="PackedScene" uid="uid://b65sf7txtiy3x" path="res://VFX/AnimatedEffect.tscn" id="1_dapgh"]

[resource]
script = ExtResource("1_0j7f5")
effect_scene = ExtResource("1_dapgh")
animation_name = "dash_puff"
playback_speed = 1.0
spawn_marker_name = "FootSpawner"
position_offset = Vector2(0, 0)
flip_h_with_player = false
flip_h_with_wall = false
rotate_with_wall_normal = false
rotation_degrees = 0.0
scale = Vector2(1, 1)
camera_punch_intensity = 0.0
metadata/_custom_type_script = "uid://ctlafprqxjjv2"

--- RESOURCE: res://VFX/VFXData/slide_puff.tres ---
[gd_resource type="Resource" script_class="VFXData" load_steps=3 format=3 uid="uid://cc6t44ykfjjb6"]

[ext_resource type="Script" uid="uid://ctlafprqxjjv2" path="res://VFX/VFXData/VFXData.gd" id="1_0hk10"]
[ext_resource type="PackedScene" uid="uid://b65sf7txtiy3x" path="res://VFX/AnimatedEffect.tscn" id="1_1gfmf"]

[resource]
script = ExtResource("1_0hk10")
effect_scene = ExtResource("1_1gfmf")
animation_name = "dash_puff"
playback_speed = 1.0
spawn_marker_name = "FootSpawner"
position_offset = Vector2(0, 0)
flip_h_with_player = true
flip_h_with_wall = false
rotate_with_wall_normal = false
rotation_degrees = 0.0
scale = Vector2(1, 1)
camera_punch_intensity = 0.0
metadata/_custom_type_script = "uid://ctlafprqxjjv2"

--- RESOURCE: res://VFX/VFXData/wall_jump.tres ---
[gd_resource type="Resource" script_class="VFXData" load_steps=3 format=3 uid="uid://c0644r4j2jcdj"]

[ext_resource type="Script" uid="uid://ctlafprqxjjv2" path="res://VFX/VFXData/VFXData.gd" id="1_bra6a"]
[ext_resource type="PackedScene" uid="uid://b65sf7txtiy3x" path="res://VFX/AnimatedEffect.tscn" id="1_hyebq"]

[resource]
script = ExtResource("1_bra6a")
effect_scene = ExtResource("1_hyebq")
animation_name = "jump_puff"
playback_speed = 1.0
spawn_marker_name = "WallSlideSpawner"
position_offset = Vector2(0, 0)
flip_h_with_player = false
flip_h_with_wall = false
rotate_with_wall_normal = true
rotation_degrees = 0.0
scale = Vector2(1, 1)
camera_punch_intensity = 0.0
metadata/_custom_type_script = "uid://ctlafprqxjjv2"

--- RESOURCE: res://VFX/VFXData/wall_kick_vfx.tres ---
[gd_resource type="Resource" script_class="VFXData" load_steps=3 format=3 uid="uid://c23a6ftkf8xfr"]

[ext_resource type="Script" uid="uid://ctlafprqxjjv2" path="res://VFX/VFXData/VFXData.gd" id="1_g8v3g"]
[ext_resource type="PackedScene" uid="uid://b65sf7txtiy3x" path="res://VFX/AnimatedEffect.tscn" id="1_jxrb7"]

[resource]
script = ExtResource("1_g8v3g")
effect_scene = ExtResource("1_jxrb7")
animation_name = "dash_puff"
playback_speed = 1.0
spawn_marker_name = "WallSlideSpawner"
position_offset = Vector2(0, 0)
flip_h_with_player = false
flip_h_with_wall = true
rotate_with_wall_normal = true
rotation_degrees = 0.0
scale = Vector2(1, 1)
camera_punch_intensity = 0.05
metadata/_custom_type_script = "uid://ctlafprqxjjv2"

--- RESOURCE: res://VFX/VFXData/wall_slide_vfx.tres ---
[gd_resource type="Resource" script_class="VFXData" load_steps=3 format=3 uid="uid://cjmrmfqt44nwm"]

[ext_resource type="Script" uid="uid://ctlafprqxjjv2" path="res://VFX/VFXData/VFXData.gd" id="1_cus0g"]
[ext_resource type="PackedScene" uid="uid://b65sf7txtiy3x" path="res://VFX/AnimatedEffect.tscn" id="1_lmj31"]

[resource]
script = ExtResource("1_cus0g")
effect_scene = ExtResource("1_lmj31")
animation_name = "dash_puff"
playback_speed = 1.0
spawn_marker_name = "WallSlideSpawner"
position_offset = Vector2(0, 0)
flip_h_with_player = false
flip_h_with_wall = true
rotate_with_wall_normal = false
rotation_degrees = 0.0
scale = Vector2(1, 1)
camera_punch_intensity = 0.0
metadata/_custom_type_script = "uid://ctlafprqxjjv2"
--- END OF RESOURCE FILES ---

#### **2.3. Scene Structures**

--- START OF SCENE STRUCTURES ---
--- SCENE: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/enemy.tscn ---
Enemy (CharacterBody2D)
> script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/enemy.gd
> scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/enemy.tscn
> vision_renderer = VisionConeRenderer:<Polygon2D#6347089344099>
> alert_color = (0.6, 0.2706, 0.2471, 0.3686)
> is_rotating = false
> rotation_speed = 0.1
> rotation_angle = 90
> movement_speed = 0.1
> CharacterRenderer (Polygon2D)
> > rotation = -1.57079994678497
> > scale = (2.0, 2.0)
> > color = (0.902, 0.1412, 0.1882, 1.0)
> > polygon = [(-10.0, -10.0), (10.0, -10.0), (0.0, 10.0)]
> VisionCone2D (Node2D)
>   script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d.gd
>   scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d_template.tscn
> > rotation = -1.57079994678497
> > angle_deg = 360
> > ray_count = 100
> > max_distance = 500.0
> > collision_layer_mask = 2
> > write_collision_polygon = VisionConeCollider:<CollisionPolygon2D#6347122900500>
> > write_polygon2d = VisionConeRenderer:<Polygon2D#6347089344099>
> > debug_lines = false
> > debug_shape = false
> > minimum_recalculate_time_msec = 0
> > recalculate_if_static = false
> > static_threshold = 2.0
> > min_distance_sqr = 16.0
>   VisionConeRenderer (Polygon2D)
>   > color = (0.4314, 0.9294, 0.2784, 0.2863)
>   VisionConeArea (Area2D)
>   > collision_layer = 0
>   > monitorable = false
>     VisionConeCollider (CollisionPolygon2D)
>   DebugDraw (Node2D)
>     script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/cone_editor_helper.gd
>   > is_visible = true
>   > color = (1.0, 0.0, 0.0, 1.0)

--- SCENE: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/example.tscn ---
example (Node2D)
> scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/example.tscn
> PatrolPath (Path2D)
> > curve = res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/example.tscn::Curve2D_kvoug
>   PathFollow2D (PathFollow2D)
>   > position = (81.0, 129.0)
>   > rotation = -0.46364799141884
> Enemy (CharacterBody2D)
>   script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/enemy.gd
>   scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/enemy.tscn
> > position = (1055.0, 97.0)
> > vision_renderer = VisionConeRenderer:<Polygon2D#6347726878255>
> > alert_color = (0.6, 0.2706, 0.2471, 0.3686)
> > is_rotating = false
> > rotation_speed = 0.1
> > rotation_angle = 90
> > movement_speed = 0.1
>   CharacterRenderer (Polygon2D)
>   > rotation = -1.57079994678497
>   > scale = (2.0, 2.0)
>   > color = (0.902, 0.1412, 0.1882, 1.0)
>   > polygon = [(-10.0, -10.0), (10.0, -10.0), (0.0, 10.0)]
>   VisionCone2D (Node2D)
>     script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d.gd
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d_template.tscn
>   > rotation = -1.57079994678497
>   > angle_deg = 360
>   > ray_count = 100
>   > max_distance = 500.0
>   > collision_layer_mask = 2
>   > write_collision_polygon = VisionConeCollider:<CollisionPolygon2D#6347760432727>
>   > write_polygon2d = VisionConeRenderer:<Polygon2D#6347726878255>
>   > debug_lines = false
>   > debug_shape = false
>   > minimum_recalculate_time_msec = 0
>   > recalculate_if_static = false
>   > static_threshold = 2.0
>   > min_distance_sqr = 16.0
>     VisionConeRenderer (Polygon2D)
>     > color = (0.4314, 0.9294, 0.2784, 0.2863)
>     VisionConeArea (Area2D)
>     > collision_layer = 0
>     > monitorable = false
>       VisionConeCollider (CollisionPolygon2D)
>     DebugDraw (Node2D)
>       script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/cone_editor_helper.gd
>     > is_visible = true
>     > color = (1.0, 0.0, 0.0, 1.0)
>   Explanation (Label)
>   > visible = false
>   > offset_left = 18.0
>   > offset_top = 13.0
>   > offset_right = 260.0
>   > offset_bottom = 65.0
>   > text = "Full 360 vision cone\nwith static optimization: will not recalculate vision cone if delta movement < static_threshold. Since the target is not rotating this is useful for performance"
>   Explanation2 (Label)
>   > visible = false
>   > offset_left = 36.0
>   > offset_top = 26.0
>   > offset_right = 1227.0
>   > offset_bottom = 78.0
>   > text = "The signal from the vision cone area is connected to the enemy script, which will trigger custom behavior for when the player is visible"
> Enemy2 (CharacterBody2D)
>   script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/enemy.gd
>   scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/enemy.tscn
> > position = (301.0, 705.0)
> > rotation = -1.57079994678497
> > vision_renderer = VisionConeRenderer:<Polygon2D#6347911427675>
> > alert_color = (0.6, 0.2706, 0.2471, 0.3686)
> > is_rotating = true
> > rotation_speed = 1.0
> > rotation_angle = 90
> > movement_speed = 0.1
>   CharacterRenderer (Polygon2D)
>   > rotation = -1.57079994678497
>   > scale = (2.0, 2.0)
>   > color = (0.902, 0.1412, 0.1882, 1.0)
>   > polygon = [(-10.0, -10.0), (10.0, -10.0), (0.0, 10.0)]
>   VisionCone2D (Node2D)
>     script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d.gd
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d_template.tscn
>   > rotation = -1.57079994678497
>   > angle_deg = 45
>   > ray_count = 50
>   > max_distance = 700
>   > collision_layer_mask = 2
>   > write_collision_polygon = VisionConeCollider:<CollisionPolygon2D#6347944983769>
>   > write_polygon2d = VisionConeRenderer:<Polygon2D#6347911427675>
>   > debug_lines = false
>   > debug_shape = false
>   > minimum_recalculate_time_msec = 0
>   > recalculate_if_static = true
>   > static_threshold = 2.0
>   > min_distance_sqr = 16.0
>     VisionConeRenderer (Polygon2D)
>     > color = (0.4314, 0.9294, 0.2784, 0.2863)
>     VisionConeArea (Area2D)
>     > collision_layer = 0
>     > monitorable = false
>       VisionConeCollider (CollisionPolygon2D)
>     DebugDraw (Node2D)
>       script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/cone_editor_helper.gd
>     > is_visible = true
>     > color = (1.0, 0.0, 0.0, 1.0)
>   Explanation (Label)
>   > visible = false
>   > offset_left = 18.0
>   > offset_top = 13.0
>   > offset_right = 260.0
>   > offset_bottom = 39.0
>   > text = "Narrow vision cone (<360 deg)\nThe target is rotating so the vision cone has to be recalculated even if the character is static\nSince the vision cone is smaller than the one with 360 vision, we can use less rays and save on performance"
> Enemy3 (CharacterBody2D)
>   script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/enemy.gd
>   scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/enemy.tscn
> > position = (211.0, 130.0)
> > rotation = -0.48296800255775
> > vision_renderer = VisionConeRenderer:<Polygon2D#6348062420647>
> > alert_color = (0.6, 0.2706, 0.2471, 0.3686)
> > is_rotating = false
> > rotation_speed = 1.0
> > rotation_angle = 90
> > move_on_path = PathFollow2D:<PathFollow2D#6347659769386>
> > movement_speed = 3.0
>   CharacterRenderer (Polygon2D)
>   > rotation = -1.57079994678497
>   > scale = (2.0, 2.0)
>   > color = (0.902, 0.1412, 0.1882, 1.0)
>   > polygon = [(-10.0, -10.0), (10.0, -10.0), (0.0, 10.0)]
>   VisionCone2D (Node2D)
>     script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d.gd
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d_template.tscn
>   > rotation = -1.57079994678497
>   > angle_deg = 45
>   > ray_count = 10
>   > max_distance = 700
>   > collision_layer_mask = 2
>   > write_collision_polygon = VisionConeCollider:<CollisionPolygon2D#6348095976066>
>   > write_polygon2d = VisionConeRenderer:<Polygon2D#6348062420647>
>   > debug_lines = true
>   > debug_shape = true
>   > minimum_recalculate_time_msec = 250
>   > recalculate_if_static = false
>   > static_threshold = 2.0
>   > min_distance_sqr = 16.0
>     VisionConeRenderer (Polygon2D)
>     > color = (0.4314, 0.9294, 0.2784, 0.2863)
>     VisionConeArea (Area2D)
>     > collision_layer = 0
>     > monitorable = false
>       VisionConeCollider (CollisionPolygon2D)
>     DebugDraw (Node2D)
>       script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/cone_editor_helper.gd
>     > is_visible = true
>     > color = (1.0, 0.0, 0.0, 1.0)
>   Explanation (Label)
>   > visible = false
>   > offset_left = 18.0
>   > offset_top = 13.0
>   > offset_right = 260.0
>   > offset_bottom = 39.0
>   > text = "This enemy has a vision cone, but it is not rendering it to a polygon 2d as the write_polygon2d is null. It is still being written to a collider so it can act on it. This is useful if you want to use it for AI, but don\'t want to show the cone to the player. You can still use the debug mode to display an outline while working on it"
>   Explanation2 (Label)
>   > visible = false
>   > offset_left = 36.0
>   > offset_top = 26.0
>   > offset_right = 2460.0
>   > offset_bottom = 52.0
>   > text = "Notice that since this cone is not visualized by the player, the minimum_recalculate_time_msec can be set to a higher value to improve performance, since this can be slightly more approximate than a cone that is visible"
> Player (CharacterBody2D)
>   script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/player_movement.gd
> > position = (600.0, 404.0)
> > speed = 1.0
> > distance = 500.0
>   CharacterRenderer (Polygon2D)
>   > scale = (2.0, 2.0)
>   > color = (0.1333, 0.5059, 0.8431, 1.0)
>   > polygon = [(-10.0, -10.0), (10.0, -10.0), (10.0, 10.0), (-10.0, 10.0)]
>   CharacterCollider (CollisionShape2D)
>   > visible = false
>   > shape = res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/example.tscn::RectangleShape2D_olhq2
> Level (Node2D)
>   Wall (StaticBody2D)
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn
>   > position = (622.0, 279.0)
>   > scale = (8.88, 1.0)
>   > collision_layer = 2
>     WallRenderer (Polygon2D)
>     > scale = (2.0, 2.0)
>     > color = (0.8, 0.7059, 0.9412, 1.0)
>     > polygon = [(-10.0, -10.0), (10.0, -10.0), (10.0, 10.0), (-10.0, 10.0)]
>     CollisionShape2D (CollisionShape2D)
>     > visible = false
>     > shape = res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn::RectangleShape2D_yia6m
>     Explanation (Label)
>     > visible = false
>     > offset_left = 18.0
>     > offset_top = 13.0
>     > offset_right = 260.0
>     > offset_bottom = 39.0
>     > text = "Walls have collision layer 2, and vision cone has collision_layer_mask to include layer 2, so the vision will not pass through them"
>   Wall4 (StaticBody2D)
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn
>   > position = (768.0, 133.0)
>   > scale = (1.0, 2.76)
>   > collision_layer = 2
>     WallRenderer (Polygon2D)
>     > scale = (2.0, 2.0)
>     > color = (0.8, 0.7059, 0.9412, 1.0)
>     > polygon = [(-10.0, -10.0), (10.0, -10.0), (10.0, 10.0), (-10.0, 10.0)]
>     CollisionShape2D (CollisionShape2D)
>     > visible = false
>     > shape = res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn::RectangleShape2D_yia6m
>   Wall3 (StaticBody2D)
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn
>   > position = (1147.0, 279.0)
>   > scale = (8.88, 1.0)
>   > collision_layer = 2
>     WallRenderer (Polygon2D)
>     > scale = (2.0, 2.0)
>     > color = (0.8, 0.7059, 0.9412, 1.0)
>     > polygon = [(-10.0, -10.0), (10.0, -10.0), (10.0, 10.0), (-10.0, 10.0)]
>     CollisionShape2D (CollisionShape2D)
>     > visible = false
>     > shape = res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn::RectangleShape2D_yia6m
>   Window (StaticBody2D)
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn
>   > position = (885.0, 279.0)
>   > scale = (4.08, 1.0)
>   > collision_layer = 4
>     WallRenderer (Polygon2D)
>     > scale = (2.0, 2.0)
>     > color = (0.5451, 0.8039, 0.8824, 0.5725)
>     > polygon = [(-10.0, -10.0), (10.0, -10.0), (10.0, 10.0), (-10.0, 10.0)]
>     CollisionShape2D (CollisionShape2D)
>     > visible = false
>     > shape = res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn::RectangleShape2D_yia6m
>     Explanation (Label)
>     > visible = false
>     > offset_left = 18.0
>     > offset_top = 13.0
>     > offset_right = 260.0
>     > offset_bottom = 39.0
>     > text = "This acts as a window, as its collision layer is 3, so the vision rays will not collide with it, but characters will not be able to pass through"
>   Wall2 (StaticBody2D)
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn
>   > position = (618.0, 559.0)
>   > scale = (8.88, 1.0)
>   > collision_layer = 2
>     WallRenderer (Polygon2D)
>     > scale = (2.0, 2.0)
>     > color = (0.8, 0.7059, 0.9412, 1.0)
>     > polygon = [(-10.0, -10.0), (10.0, -10.0), (10.0, 10.0), (-10.0, 10.0)]
>     CollisionShape2D (CollisionShape2D)
>     > visible = false
>     > shape = res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn::RectangleShape2D_yia6m

--- SCENE: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn ---
Wall (StaticBody2D)
> scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn
> collision_layer = 2
> WallRenderer (Polygon2D)
> > scale = (2.0, 2.0)
> > color = (0.8, 0.7059, 0.9412, 1.0)
> > polygon = [(-10.0, -10.0), (10.0, -10.0), (10.0, 10.0), (-10.0, 10.0)]
> CollisionShape2D (CollisionShape2D)
> > visible = false
> > shape = res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/wall.tscn::RectangleShape2D_yia6m

--- SCENE: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d_template.tscn ---
VisionCone2D (Node2D)
> script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d.gd
> scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d_template.tscn
> angle_deg = 360
> ray_count = 100
> max_distance = 500.0
> collision_layer_mask = 2
> write_collision_polygon = VisionConeCollider:<CollisionPolygon2D#6349740144214>
> write_polygon2d = VisionConeRenderer:<Polygon2D#6349706589754>
> debug_lines = false
> debug_shape = false
> minimum_recalculate_time_msec = 0
> recalculate_if_static = true
> static_threshold = 2.0
> min_distance_sqr = 16.0
> VisionConeRenderer (Polygon2D)
> > color = (0.4314, 0.9294, 0.2784, 0.2863)
> VisionConeArea (Area2D)
> > collision_layer = 0
> > monitorable = false
>   VisionConeCollider (CollisionPolygon2D)
> DebugDraw (Node2D)
>   script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/cone_editor_helper.gd
> > is_visible = true
> > color = (1.0, 0.0, 0.0, 1.0)

--- SCENE: res://addons/gut/gui/BottomPanelShortcuts.tscn ---
BottomPanelShortcuts (Popup)
> script: res://addons/gut/gui/BottomPanelShortcuts.gd
> scene: res://addons/gut/gui/BottomPanelShortcuts.tscn
> title = "Shortcuts"
> size = (500, 350)
> visible = true
> exclusive = true
> unresizable = false
> borderless = false
> Layout (VBoxContainer)
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > offset_left = 5.0
> > offset_right = -5.0
> > offset_bottom = 2.0
>   TopPad (CenterContainer)
>   > custom_minimum_size = (0.0, 5.0)
>   > layout_mode = 2
>   Label2 (Label)
>   > custom_minimum_size = (0.0, 20.0)
>   > layout_mode = 2
>   > text = "Always Active"
>     ColorRect (ColorRect)
>     > show_behind_parent = true
>     > layout_mode = 0
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > color = (0.0, 0.0, 0.0, 0.1961)
>   CPanelButton (HBoxContainer)
>   > layout_mode = 2
>     Label (Label)
>     > custom_minimum_size = (50.0, 0.0)
>     > layout_mode = 2
>     > size_flags_vertical = 7
>     > text = "Show/Hide GUT Panel"
>     ShortcutButton (Control)
>       script: res://addons/gut/gui/ShortcutButton.gd
>       scene: res://addons/gut/gui/ShortcutButton.tscn
>     > custom_minimum_size = (210.0, 30.0)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>       Layout (HBoxContainer)
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>         lblShortcut (Label)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 7
>         > text = "<None>"
>         > horizontal_alignment = 2
>         CenterContainer (CenterContainer)
>         > custom_minimum_size = (10.0, 0.0)
>         > layout_mode = 2
>         SetButton (Button)
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Set"
>         SaveButton (Button)
>         > visible = false
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Save"
>         CancelButton (Button)
>         > visible = false
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Cancel"
>         ClearButton (Button)
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Clear"
>   GutPanelPad (CenterContainer)
>   > custom_minimum_size = (0.0, 5.0)
>   > layout_mode = 2
>   Label (Label)
>   > custom_minimum_size = (0.0, 20.0)
>   > layout_mode = 2
>   > text = "Only Active When GUT Panel Shown"
>     ColorRect2 (ColorRect)
>     > show_behind_parent = true
>     > layout_mode = 0
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > color = (0.0, 0.0, 0.0, 0.1961)
>   TopPad2 (CenterContainer)
>   > custom_minimum_size = (0.0, 5.0)
>   > layout_mode = 2
>   CRunAll (HBoxContainer)
>   > layout_mode = 2
>     Label (Label)
>     > custom_minimum_size = (50.0, 0.0)
>     > layout_mode = 2
>     > size_flags_vertical = 7
>     > text = "Run All"
>     ShortcutButton (Control)
>       script: res://addons/gut/gui/ShortcutButton.gd
>       scene: res://addons/gut/gui/ShortcutButton.tscn
>     > custom_minimum_size = (210.0, 30.0)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>       Layout (HBoxContainer)
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>         lblShortcut (Label)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 7
>         > text = "<None>"
>         > horizontal_alignment = 2
>         CenterContainer (CenterContainer)
>         > custom_minimum_size = (10.0, 0.0)
>         > layout_mode = 2
>         SetButton (Button)
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Set"
>         SaveButton (Button)
>         > visible = false
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Save"
>         CancelButton (Button)
>         > visible = false
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Cancel"
>         ClearButton (Button)
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Clear"
>   CRunCurrentScript (HBoxContainer)
>   > layout_mode = 2
>     Label (Label)
>     > custom_minimum_size = (50.0, 0.0)
>     > layout_mode = 2
>     > size_flags_vertical = 7
>     > text = "Run Current Script"
>     ShortcutButton (Control)
>       script: res://addons/gut/gui/ShortcutButton.gd
>       scene: res://addons/gut/gui/ShortcutButton.tscn
>     > custom_minimum_size = (210.0, 30.0)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>       Layout (HBoxContainer)
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>         lblShortcut (Label)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 7
>         > text = "<None>"
>         > horizontal_alignment = 2
>         CenterContainer (CenterContainer)
>         > custom_minimum_size = (10.0, 0.0)
>         > layout_mode = 2
>         SetButton (Button)
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Set"
>         SaveButton (Button)
>         > visible = false
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Save"
>         CancelButton (Button)
>         > visible = false
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Cancel"
>         ClearButton (Button)
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Clear"
>   CRunCurrentInner (HBoxContainer)
>   > layout_mode = 2
>     Label (Label)
>     > custom_minimum_size = (50.0, 0.0)
>     > layout_mode = 2
>     > size_flags_vertical = 7
>     > text = "Run Current Inner Class"
>     ShortcutButton (Control)
>       script: res://addons/gut/gui/ShortcutButton.gd
>       scene: res://addons/gut/gui/ShortcutButton.tscn
>     > custom_minimum_size = (210.0, 30.0)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>       Layout (HBoxContainer)
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>         lblShortcut (Label)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 7
>         > text = "<None>"
>         > horizontal_alignment = 2
>         CenterContainer (CenterContainer)
>         > custom_minimum_size = (10.0, 0.0)
>         > layout_mode = 2
>         SetButton (Button)
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Set"
>         SaveButton (Button)
>         > visible = false
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Save"
>         CancelButton (Button)
>         > visible = false
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Cancel"
>         ClearButton (Button)
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Clear"
>   CRunCurrentTest (HBoxContainer)
>   > layout_mode = 2
>     Label (Label)
>     > custom_minimum_size = (50.0, 0.0)
>     > layout_mode = 2
>     > size_flags_vertical = 7
>     > text = "Run Current Test"
>     ShortcutButton (Control)
>       script: res://addons/gut/gui/ShortcutButton.gd
>       scene: res://addons/gut/gui/ShortcutButton.tscn
>     > custom_minimum_size = (210.0, 30.0)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>       Layout (HBoxContainer)
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>         lblShortcut (Label)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 7
>         > text = "<None>"
>         > horizontal_alignment = 2
>         CenterContainer (CenterContainer)
>         > custom_minimum_size = (10.0, 0.0)
>         > layout_mode = 2
>         SetButton (Button)
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Set"
>         SaveButton (Button)
>         > visible = false
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Save"
>         CancelButton (Button)
>         > visible = false
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Cancel"
>         ClearButton (Button)
>         > custom_minimum_size = (60.0, 0.0)
>         > layout_mode = 2
>         > text = "Clear"
>   CenterContainer2 (CenterContainer)
>   > custom_minimum_size = (0.0, 5.0)
>   > layout_mode = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>   ShiftDisclaimer (Label)
>   > layout_mode = 2
>   > text = "\"Shift\" cannot be the only modifier for a shortcut."
>   HBoxContainer (HBoxContainer)
>   > layout_mode = 2
>     CenterContainer (CenterContainer)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>     Hide (Button)
>     > custom_minimum_size = (60.0, 30.0)
>     > layout_mode = 2
>     > text = "Close"
>   BottomPad (CenterContainer)
>   > custom_minimum_size = (0.0, 10.0)
>   > layout_mode = 2
>   > size_flags_horizontal = 3

--- SCENE: res://addons/gut/gui/GutBottomPanel.tscn ---
GutBottomPanel (Control)
> script: res://addons/gut/gui/GutBottomPanel.gd
> scene: res://addons/gut/gui/GutBottomPanel.tscn
> custom_minimum_size = (250.0, 250.0)
> anchors_preset = -1
> anchor_left = -0.00258659990504
> anchor_top = -0.00176574999932
> anchor_right = 0.99741297960281
> anchor_bottom = 0.99823397397995
> offset_left = 2.64867997169495
> offset_top = 1.05945003032684
> offset_right = 2.64861989021301
> offset_bottom = 1.05945003032684
> layout (VBoxContainer)
> > layout_mode = 0
> > anchor_right = 1.0
> > anchor_bottom = 1.0
>   ControlBar (HBoxContainer)
>   > layout_mode = 2
>     RunAll (Button)
>     > layout_mode = 2
>     > size_flags_vertical = 11
>     > shortcut = res://addons/gut/gui/GutBottomPanel.tscn::9
>     > text = "Run All"
>     > icon = res://addons/gut/gui/play.png
>     Label (Label)
>     > layout_mode = 2
>     > mouse_filter = 1
>     > text = "Current:  "
>     RunAtCursor (Control)
>       script: res://addons/gut/gui/RunAtCursor.gd
>       scene: res://addons/gut/gui/RunAtCursor.tscn
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       HBox (HBoxContainer)
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > size_flags_horizontal = 3
>       > size_flags_vertical = 3
>         LblNoneSelected (Label)
>         > layout_mode = 2
>         > text = "<None>"
>         BtnRunScript (Button)
>         > visible = false
>         > layout_mode = 2
>         > text = "<script>"
>         > icon = res://addons/gut/gui/play.png
>         Arrow1 (TextureButton)
>         > visible = false
>         > custom_minimum_size = (24.0, 0.0)
>         > layout_mode = 2
>         > texture_normal = res://addons/gut/gui/arrow.png
>         > stretch_mode = 3
>         BtnRunInnerClass (Button)
>         > visible = false
>         > layout_mode = 2
>         > text = "<inner class>"
>         > icon = res://addons/gut/gui/play.png
>         Arrow2 (TextureButton)
>         > visible = false
>         > custom_minimum_size = (24.0, 0.0)
>         > layout_mode = 2
>         > texture_normal = res://addons/gut/gui/arrow.png
>         > stretch_mode = 3
>         BtnRunMethod (Button)
>         > visible = false
>         > layout_mode = 2
>         > text = "<method>"
>         > icon = res://addons/gut/gui/play.png
>     CenterContainer2 (CenterContainer)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     Sep1 (ColorRect)
>     > custom_minimum_size = (1.0, 0.0)
>     > layout_mode = 2
>     RunResultsBtn (Button)
>     > layout_mode = 2
>     > toggle_mode = true
>     > icon = res://addons/gut/gui/GutBottomPanel.tscn::ImageTexture_umaha
>     OutputBtn (Button)
>     > layout_mode = 2
>     > toggle_mode = true
>     > icon = res://addons/gut/gui/GutBottomPanel.tscn::ImageTexture_umaha
>     Settings (Button)
>     > layout_mode = 2
>     > toggle_mode = true
>     > icon = res://addons/gut/gui/GutBottomPanel.tscn::ImageTexture_umaha
>     Sep2 (ColorRect)
>     > custom_minimum_size = (1.0, 0.0)
>     > layout_mode = 2
>     Shortcuts (Button)
>     > layout_mode = 2
>     > size_flags_vertical = 11
>     > icon = res://addons/gut/gui/GutBottomPanel.tscn::ImageTexture_umaha
>   RSplit (HSplitContainer)
>   > layout_mode = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>   > collapsed = true
>     sc (ScrollContainer)
>     > visible = false
>     > custom_minimum_size = (500.0, 0.0)
>     > layout_mode = 2
>     > size_flags_vertical = 3
>       Settings (VBoxContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       > size_flags_vertical = 3
>     CResults (VBoxContainer)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       ControlBar (HBoxContainer)
>       > layout_mode = 2
>         Sep2 (ColorRect)
>         > custom_minimum_size = (1.0, 0.0)
>         > layout_mode = 2
>         Light3D (Control)
>         > custom_minimum_size = (30.0, 30.0)
>         > layout_mode = 2
>         Passing (HBoxContainer)
>         > visible = false
>         > layout_mode = 2
>           Sep (ColorRect)
>           > custom_minimum_size = (1.0, 0.0)
>           > layout_mode = 2
>           label (Label)
>           > layout_mode = 2
>           > text = "Passing"
>           value (Label)
>           > layout_mode = 2
>           > text = "---"
>         Failing (HBoxContainer)
>         > visible = false
>         > layout_mode = 2
>           Sep (ColorRect)
>           > custom_minimum_size = (1.0, 0.0)
>           > layout_mode = 2
>           label (Label)
>           > layout_mode = 2
>           > text = "Failing"
>           value (Label)
>           > layout_mode = 2
>           > text = "---"
>         Pending (HBoxContainer)
>         > visible = false
>         > layout_mode = 2
>           Sep (ColorRect)
>           > custom_minimum_size = (1.0, 0.0)
>           > layout_mode = 2
>           label (Label)
>           > layout_mode = 2
>           > text = "Pending"
>           value (Label)
>           > layout_mode = 2
>           > text = "---"
>         Orphans (HBoxContainer)
>         > visible = false
>         > layout_mode = 2
>           Sep (ColorRect)
>           > custom_minimum_size = (1.0, 0.0)
>           > layout_mode = 2
>           label (Label)
>           > layout_mode = 2
>           > text = "Orphans"
>           value (Label)
>           > layout_mode = 2
>           > text = "---"
>         Errors (HBoxContainer)
>         > visible = false
>         > layout_mode = 2
>           Sep (ColorRect)
>           > custom_minimum_size = (1.0, 0.0)
>           > layout_mode = 2
>           label (Label)
>           > layout_mode = 2
>           > text = "Errors"
>           value (Label)
>           > layout_mode = 2
>           > text = "---"
>         Warnings (HBoxContainer)
>         > visible = false
>         > layout_mode = 2
>           Sep (ColorRect)
>           > custom_minimum_size = (1.0, 0.0)
>           > layout_mode = 2
>           label (Label)
>           > layout_mode = 2
>           > text = "Warnings"
>           value (Label)
>           > layout_mode = 2
>           > text = "---"
>         CenterContainer (CenterContainer)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>       TabBar (HSplitContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       > size_flags_vertical = 3
>         RunResults (Control)
>           script: res://addons/gut/gui/RunResults.gd
>           scene: res://addons/gut/gui/RunResults.tscn
>         > visible = false
>         > custom_minimum_size = (345.0, 0.0)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 3
>           VBox (VBoxContainer)
>           > layout_mode = 0
>           > anchor_right = 1.0
>           > anchor_bottom = 1.0
>             Toolbar (HBoxContainer)
>             > layout_mode = 2
>             > size_flags_horizontal = 0
>               Expand (Button)
>               > layout_mode = 2
>               > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>               Collapse (Button)
>               > layout_mode = 2
>               > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>               Sep (ColorRect)
>               > custom_minimum_size = (2.0, 0.0)
>               > layout_mode = 2
>               LblAll (Label)
>               > layout_mode = 2
>               > text = "All:"
>               ExpandAll (Button)
>               > layout_mode = 2
>               > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>               CollapseAll (Button)
>               > layout_mode = 2
>               > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>               Sep2 (ColorRect)
>               > custom_minimum_size = (2.0, 0.0)
>               > layout_mode = 2
>               HidePassing (CheckBox)
>               > layout_mode = 2
>               > size_flags_horizontal = 4
>               > text = "Passing"
>               Sep3 (ColorRect)
>               > custom_minimum_size = (2.0, 0.0)
>               > layout_mode = 2
>               LblSync (Label)
>               > layout_mode = 2
>               > text = "Sync:"
>               ShowScript (Button)
>               > layout_mode = 2
>               > toggle_mode = true
>               > button_pressed = true
>               > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>               ScrollOutput (Button)
>               > layout_mode = 2
>               > toggle_mode = true
>               > button_pressed = true
>               > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>             Output (Panel)
>             > self_modulate = (1.0, 1.0, 1.0, 0.5412)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             > size_flags_vertical = 3
>               Scroll (ScrollContainer)
>               > layout_mode = 1
>               > anchors_preset = 15
>               > anchor_right = 1.0
>               > anchor_bottom = 1.0
>               > grow_horizontal = 2
>               > grow_vertical = 2
>                 Tree (VBoxContainer)
>                   script: res://addons/gut/gui/ResultsTree.gd
>                   scene: res://addons/gut/gui/ResultsTree.tscn
>                 > custom_minimum_size = (10.0, 10.0)
>                 > layout_mode = 2
>                 > size_flags_horizontal = 3
>                 > size_flags_vertical = 3
>                   Tree (Tree)
>                   > layout_mode = 2
>                   > size_flags_horizontal = 3
>                   > size_flags_vertical = 3
>                   > columns = 2
>                   > hide_root = true
>                     TextOverlay (Label)
>                     > visible = false
>                     > layout_mode = 1
>                     > anchors_preset = 15
>                     > anchor_right = 1.0
>                     > anchor_bottom = 1.0
>                     > grow_horizontal = 2
>                     > grow_vertical = 2
>           FontSampler (Label)
>           > visible = false
>           > layout_mode = 0
>           > offset_right = 40.0
>           > offset_bottom = 14.0
>           > text = "000 of 000 passed"
>         OutputText (VBoxContainer)
>           script: res://addons/gut/gui/OutputText.gd
>           scene: res://addons/gut/gui/OutputText.tscn
>         > visible = false
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 3
>           Toolbar (HBoxContainer)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>             ShowSearch (Button)
>             > layout_mode = 2
>             > tooltip_text = "Search"
>             > toggle_mode = true
>             > icon = res://addons/gut/gui/OutputText.tscn::ImageTexture_42opa
>             ShowSettings (Button)
>             > layout_mode = 2
>             > tooltip_text = "Settings"
>             > toggle_mode = true
>             > text = "..."
>             CenterContainer (CenterContainer)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             LblPosition (Label)
>             > layout_mode = 2
>             CopyButton (Button)
>             > layout_mode = 2
>             > text = " Copy "
>             ClearButton (Button)
>             > layout_mode = 2
>             > text = "  Clear  "
>           Settings (HBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             WordWrap (Button)
>             > layout_mode = 2
>             > tooltip_text = "Word Wrap"
>             > toggle_mode = true
>             > icon = res://addons/gut/gui/OutputText.tscn::ImageTexture_42opa
>             UseColors (Button)
>             > layout_mode = 2
>             > tooltip_text = "Colorized Text"
>             > toggle_mode = true
>             > button_pressed = true
>             > icon = res://addons/gut/gui/OutputText.tscn::ImageTexture_42opa
>           Output (TextEdit)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > size_flags_vertical = 3
>           > deselect_on_focus_loss_enabled = false
>           > virtual_keyboard_enabled = false
>           > middle_mouse_paste_enabled = false
>           > scroll_smooth = true
>           > syntax_highlighter = res://addons/gut/gui/OutputText.tscn::CodeHighlighter_v57hd
>           > highlight_all_occurrences = true
>           > highlight_current_line = true
>           Search (HBoxContainer)
>           > visible = false
>           > layout_mode = 2
>             SearchTerm (LineEdit)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             SearchNext (Button)
>             > layout_mode = 2
>             > text = "Next"
>             SearchPrev (Button)
>             > layout_mode = 2
>             > text = "Prev"
> BottomPanelShortcuts (Popup)
>   script: res://addons/gut/gui/BottomPanelShortcuts.gd
>   scene: res://addons/gut/gui/BottomPanelShortcuts.tscn
> > title = "Shortcuts"
> > size = (500, 350)
> > exclusive = true
> > unresizable = false
> > borderless = false
>   Layout (VBoxContainer)
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = 5.0
>   > offset_right = -5.0
>   > offset_bottom = 2.0
>     TopPad (CenterContainer)
>     > custom_minimum_size = (0.0, 5.0)
>     > layout_mode = 2
>     Label2 (Label)
>     > custom_minimum_size = (0.0, 20.0)
>     > layout_mode = 2
>     > text = "Always Active"
>       ColorRect (ColorRect)
>       > show_behind_parent = true
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > color = (0.0, 0.0, 0.0, 0.1961)
>     CPanelButton (HBoxContainer)
>     > layout_mode = 2
>       Label (Label)
>       > custom_minimum_size = (50.0, 0.0)
>       > layout_mode = 2
>       > size_flags_vertical = 7
>       > text = "Show/Hide GUT Panel"
>       ShortcutButton (Control)
>         script: res://addons/gut/gui/ShortcutButton.gd
>         scene: res://addons/gut/gui/ShortcutButton.tscn
>       > custom_minimum_size = (210.0, 30.0)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>         Layout (HBoxContainer)
>         > layout_mode = 0
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>           lblShortcut (Label)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > size_flags_vertical = 7
>           > text = "<None>"
>           > horizontal_alignment = 2
>           CenterContainer (CenterContainer)
>           > custom_minimum_size = (10.0, 0.0)
>           > layout_mode = 2
>           SetButton (Button)
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Set"
>           SaveButton (Button)
>           > visible = false
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Save"
>           CancelButton (Button)
>           > visible = false
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Cancel"
>           ClearButton (Button)
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Clear"
>     GutPanelPad (CenterContainer)
>     > custom_minimum_size = (0.0, 5.0)
>     > layout_mode = 2
>     Label (Label)
>     > custom_minimum_size = (0.0, 20.0)
>     > layout_mode = 2
>     > text = "Only Active When GUT Panel Shown"
>       ColorRect2 (ColorRect)
>       > show_behind_parent = true
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > color = (0.0, 0.0, 0.0, 0.1961)
>     TopPad2 (CenterContainer)
>     > custom_minimum_size = (0.0, 5.0)
>     > layout_mode = 2
>     CRunAll (HBoxContainer)
>     > layout_mode = 2
>       Label (Label)
>       > custom_minimum_size = (50.0, 0.0)
>       > layout_mode = 2
>       > size_flags_vertical = 7
>       > text = "Run All"
>       ShortcutButton (Control)
>         script: res://addons/gut/gui/ShortcutButton.gd
>         scene: res://addons/gut/gui/ShortcutButton.tscn
>       > custom_minimum_size = (210.0, 30.0)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>         Layout (HBoxContainer)
>         > layout_mode = 0
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>           lblShortcut (Label)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > size_flags_vertical = 7
>           > text = "<None>"
>           > horizontal_alignment = 2
>           CenterContainer (CenterContainer)
>           > custom_minimum_size = (10.0, 0.0)
>           > layout_mode = 2
>           SetButton (Button)
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Set"
>           SaveButton (Button)
>           > visible = false
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Save"
>           CancelButton (Button)
>           > visible = false
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Cancel"
>           ClearButton (Button)
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Clear"
>     CRunCurrentScript (HBoxContainer)
>     > layout_mode = 2
>       Label (Label)
>       > custom_minimum_size = (50.0, 0.0)
>       > layout_mode = 2
>       > size_flags_vertical = 7
>       > text = "Run Current Script"
>       ShortcutButton (Control)
>         script: res://addons/gut/gui/ShortcutButton.gd
>         scene: res://addons/gut/gui/ShortcutButton.tscn
>       > custom_minimum_size = (210.0, 30.0)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>         Layout (HBoxContainer)
>         > layout_mode = 0
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>           lblShortcut (Label)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > size_flags_vertical = 7
>           > text = "<None>"
>           > horizontal_alignment = 2
>           CenterContainer (CenterContainer)
>           > custom_minimum_size = (10.0, 0.0)
>           > layout_mode = 2
>           SetButton (Button)
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Set"
>           SaveButton (Button)
>           > visible = false
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Save"
>           CancelButton (Button)
>           > visible = false
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Cancel"
>           ClearButton (Button)
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Clear"
>     CRunCurrentInner (HBoxContainer)
>     > layout_mode = 2
>       Label (Label)
>       > custom_minimum_size = (50.0, 0.0)
>       > layout_mode = 2
>       > size_flags_vertical = 7
>       > text = "Run Current Inner Class"
>       ShortcutButton (Control)
>         script: res://addons/gut/gui/ShortcutButton.gd
>         scene: res://addons/gut/gui/ShortcutButton.tscn
>       > custom_minimum_size = (210.0, 30.0)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>         Layout (HBoxContainer)
>         > layout_mode = 0
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>           lblShortcut (Label)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > size_flags_vertical = 7
>           > text = "<None>"
>           > horizontal_alignment = 2
>           CenterContainer (CenterContainer)
>           > custom_minimum_size = (10.0, 0.0)
>           > layout_mode = 2
>           SetButton (Button)
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Set"
>           SaveButton (Button)
>           > visible = false
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Save"
>           CancelButton (Button)
>           > visible = false
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Cancel"
>           ClearButton (Button)
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Clear"
>     CRunCurrentTest (HBoxContainer)
>     > layout_mode = 2
>       Label (Label)
>       > custom_minimum_size = (50.0, 0.0)
>       > layout_mode = 2
>       > size_flags_vertical = 7
>       > text = "Run Current Test"
>       ShortcutButton (Control)
>         script: res://addons/gut/gui/ShortcutButton.gd
>         scene: res://addons/gut/gui/ShortcutButton.tscn
>       > custom_minimum_size = (210.0, 30.0)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>         Layout (HBoxContainer)
>         > layout_mode = 0
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>           lblShortcut (Label)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > size_flags_vertical = 7
>           > text = "<None>"
>           > horizontal_alignment = 2
>           CenterContainer (CenterContainer)
>           > custom_minimum_size = (10.0, 0.0)
>           > layout_mode = 2
>           SetButton (Button)
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Set"
>           SaveButton (Button)
>           > visible = false
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Save"
>           CancelButton (Button)
>           > visible = false
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Cancel"
>           ClearButton (Button)
>           > custom_minimum_size = (60.0, 0.0)
>           > layout_mode = 2
>           > text = "Clear"
>     CenterContainer2 (CenterContainer)
>     > custom_minimum_size = (0.0, 5.0)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>     ShiftDisclaimer (Label)
>     > layout_mode = 2
>     > text = "\"Shift\" cannot be the only modifier for a shortcut."
>     HBoxContainer (HBoxContainer)
>     > layout_mode = 2
>       CenterContainer (CenterContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       > size_flags_vertical = 3
>       Hide (Button)
>       > custom_minimum_size = (60.0, 30.0)
>       > layout_mode = 2
>       > text = "Close"
>     BottomPad (CenterContainer)
>     > custom_minimum_size = (0.0, 10.0)
>     > layout_mode = 2
>     > size_flags_horizontal = 3

--- SCENE: res://addons/gut/gui/GutControl.tscn ---
GutControl (Control)
> script: res://addons/gut/gui/GutControl.gd
> scene: res://addons/gut/gui/GutControl.tscn
> offset_right = 295.0
> offset_bottom = 419.0
> bg_color = (0.36, 0.36, 0.36, 1.0)
> Bg (ColorRect)
> > layout_mode = 1
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > color = (0.36, 0.36, 0.36, 1.0)
> VBox (VBoxContainer)
> > layout_mode = 1
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   Tabs (TabContainer)
>   > layout_mode = 2
>   > size_flags_vertical = 3
>   > current_tab = 0
>     Tests (Tree)
>     > visible = false
>     > layout_mode = 2
>     > size_flags_vertical = 3
>     > hide_root = true
>     SettingsScroll (ScrollContainer)
>     > visible = false
>     > layout_mode = 2
>     > size_flags_vertical = 3
>       Settings (VBoxContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       > size_flags_vertical = 3
>   Buttons (HBoxContainer)
>   > layout_mode = 2
>     RunTests (Button)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     > text = "Run All"
>     RunSelected (Button)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     > text = "Run Selected"

--- SCENE: res://addons/gut/gui/GutRunner.tscn ---
GutRunner (Node2D)
> script: res://addons/gut/gui/GutRunner.gd
> scene: res://addons/gut/gui/GutRunner.tscn
> GutLayer (CanvasLayer)
> > layer = 128
>   GutScene (Node2D)
>     script: res://addons/gut/GutScene.gd
>     scene: res://addons/gut/GutScene.tscn
>     Normal (Panel)
>       script: res://addons/gut/gui/gut_gui.gd
>       scene: res://addons/gut/gui/NormalGui.tscn
>     > custom_minimum_size = (500.0, 150.0)
>     > offset_right = 632.0
>     > offset_bottom = 260.0
>     > theme = res://addons/gut/gui/GutSceneTheme.tres
>       MainBox (VBoxContainer)
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>         TitleBar (Panel)
>         > custom_minimum_size = (0.0, 25.0)
>         > layout_mode = 2
>           TitleBox (HBoxContainer)
>           > layout_mode = 0
>           > anchor_right = 1.0
>           > anchor_bottom = 1.0
>           > offset_top = 2.0
>           > offset_bottom = 3.0
>           > grow_horizontal = 2
>           > grow_vertical = 2
>             Spacer1 (CenterContainer)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             Title (Label)
>             > layout_mode = 2
>             > text = "Title"
>             Spacer2 (CenterContainer)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             TimeLabel (Label)
>             > custom_minimum_size = (90.0, 0.0)
>             > layout_mode = 2
>             > text = "999.999s"
>         HBoxContainer (HBoxContainer)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>           VBoxContainer (VBoxContainer)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>             OutputBG (ColorRect)
>             > layout_mode = 2
>             > size_flags_vertical = 3
>             > color = (0.0745, 0.0706, 0.0784, 1.0)
>               HBoxContainer (HBoxContainer)
>               > layout_mode = 0
>               > anchor_right = 1.0
>               > anchor_bottom = 1.0
>               > grow_horizontal = 2
>               > grow_vertical = 2
>                 S2 (CenterContainer)
>                 > custom_minimum_size = (5.0, 0.0)
>                 > layout_mode = 2
>                 TestOutput (RichTextLabel)
>                 > layout_mode = 2
>                 > size_flags_horizontal = 3
>                 > size_flags_vertical = 3
>                 > focus_mode = 2
>                 > bbcode_enabled = true
>                 > scroll_following = true
>                 > autowrap_mode = 0
>                 > selection_enabled = true
>                 S1 (CenterContainer)
>                 > custom_minimum_size = (5.0, 0.0)
>                 > layout_mode = 2
>             ControlBox (HBoxContainer)
>             > layout_mode = 2
>               S1 (CenterContainer)
>               > custom_minimum_size = (5.0, 0.0)
>               > layout_mode = 2
>               ProgressBars (VBoxContainer)
>               > layout_mode = 2
>                 TestBox (HBoxContainer)
>                 > layout_mode = 2
>                   Label (Label)
>                   > custom_minimum_size = (60.0, 0.0)
>                   > layout_mode = 2
>                   > size_flags_horizontal = 3
>                   > text = "Tests"
>                   ProgressTest (ProgressBar)
>                   > custom_minimum_size = (100.0, 0.0)
>                   > layout_mode = 2
>                   > value = 25.0
>                 ScriptBox (HBoxContainer)
>                 > layout_mode = 2
>                   Label (Label)
>                   > custom_minimum_size = (60.0, 0.0)
>                   > layout_mode = 2
>                   > size_flags_horizontal = 3
>                   > text = "Scripts"
>                   ProgressScript (ProgressBar)
>                   > custom_minimum_size = (100.0, 0.0)
>                   > layout_mode = 2
>                   > value = 75.0
>               PathDisplay (VBoxContainer)
>               > layout_mode = 2
>               > size_flags_horizontal = 3
>               > size_flags_vertical = 3
>                 Path (Label)
>                 > layout_mode = 2
>                 > size_flags_vertical = 6
>                 > text = "res://test/integration/whatever"
>                 > text_overrun_behavior = 3
>                 HBoxContainer (HBoxContainer)
>                 > layout_mode = 2
>                 > size_flags_vertical = 3
>                   S3 (CenterContainer)
>                   > custom_minimum_size = (5.0, 0.0)
>                   > layout_mode = 2
>                   File (Label)
>                   > layout_mode = 2
>                   > size_flags_horizontal = 3
>                   > text = "test_this_thing.gd"
>                   > text_overrun_behavior = 3
>               Spacer1 (CenterContainer)
>               > visible = false
>               > layout_mode = 2
>               > size_flags_horizontal = 10
>               Continue (Button)
>               > layout_mode = 2
>               > size_flags_vertical = 4
>               > text = "Continue\n"
>               S3 (CenterContainer)
>               > custom_minimum_size = (5.0, 0.0)
>               > layout_mode = 2
>         BottomPad (CenterContainer)
>         > custom_minimum_size = (0.0, 5.0)
>         > layout_mode = 2
>         Footer (HBoxContainer)
>         > layout_mode = 2
>           SidePad1 (CenterContainer)
>           > custom_minimum_size = (2.0, 0.0)
>           > layout_mode = 2
>           ResizeHandle3 (ColorRect)
>             script: res://addons/gut/gui/ResizeHandle.gd
>             scene: res://addons/gut/gui/ResizeHandle.tscn
>           > custom_minimum_size = (25.0, 25.0)
>           > layout_mode = 2
>           > color = (1.0, 1.0, 1.0, 0.0)
>           > orientation = 0
>           > resize_control = Normal:<Panel#6375744830713>
>           > vertical_resize = true
>           SwitchModes (Button)
>           > layout_mode = 2
>           > text = "Compact\n"
>           CenterContainer (CenterContainer)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           ResizeHandle2 (ColorRect)
>             script: res://addons/gut/gui/ResizeHandle.gd
>             scene: res://addons/gut/gui/ResizeHandle.tscn
>           > custom_minimum_size = (25.0, 25.0)
>           > layout_mode = 2
>           > color = (1.0, 1.0, 1.0, 0.0)
>           > orientation = 1
>           > resize_control = Normal:<Panel#6375744830713>
>           > vertical_resize = true
>           SidePad2 (CenterContainer)
>           > custom_minimum_size = (2.0, 0.0)
>           > layout_mode = 2
>         BottomPad2 (CenterContainer)
>         > custom_minimum_size = (0.0, 2.0)
>         > layout_mode = 2
>     Compact (Panel)
>       script: res://addons/gut/gui/gut_gui.gd
>       scene: res://addons/gut/gui/MinGui.tscn
>     > clip_contents = true
>     > custom_minimum_size = (280.0, 145.0)
>     > offset_left = 5.0
>     > offset_top = 273.0
>     > offset_right = 265.0
>     > offset_bottom = 403.0
>     > theme = res://addons/gut/gui/GutSceneTheme.tres
>       MainBox (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>         TitleBar (Panel)
>         > custom_minimum_size = (0.0, 25.0)
>         > layout_mode = 2
>           TitleBox (HBoxContainer)
>           > layout_mode = 0
>           > anchor_right = 1.0
>           > anchor_bottom = 1.0
>           > offset_top = 2.0
>           > offset_bottom = 3.0
>           > grow_horizontal = 2
>           > grow_vertical = 2
>             Spacer1 (CenterContainer)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             Title (Label)
>             > layout_mode = 2
>             > text = "Title"
>             Spacer2 (CenterContainer)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             TimeLabel (Label)
>             > layout_mode = 2
>             > text = "0.000s"
>         Body (HBoxContainer)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>           LeftMargin (CenterContainer)
>           > custom_minimum_size = (5.0, 0.0)
>           > layout_mode = 2
>           BodyRows (VBoxContainer)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>             ProgressBars (HBoxContainer)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>               HBoxContainer (HBoxContainer)
>               > layout_mode = 2
>               > size_flags_horizontal = 3
>                 Label (Label)
>                 > layout_mode = 2
>                 > text = "T:"
>                 ProgressTest (ProgressBar)
>                 > custom_minimum_size = (100.0, 0.0)
>                 > layout_mode = 2
>                 > size_flags_horizontal = 3
>                 > value = 25.0
>               HBoxContainer2 (HBoxContainer)
>               > layout_mode = 2
>               > size_flags_horizontal = 3
>                 Label (Label)
>                 > layout_mode = 2
>                 > text = "S:"
>                 ProgressScript (ProgressBar)
>                 > custom_minimum_size = (100.0, 0.0)
>                 > layout_mode = 2
>                 > size_flags_horizontal = 3
>                 > value = 75.0
>             PathDisplay (VBoxContainer)
>             > clip_contents = true
>             > layout_mode = 2
>             > size_flags_vertical = 3
>               Path (Label)
>               > layout_mode = 2
>               > text = "res://test/integration/whatever"
>               > clip_text = true
>               > text_overrun_behavior = 3
>               HBoxContainer (HBoxContainer)
>               > clip_contents = true
>               > layout_mode = 2
>                 S3 (CenterContainer)
>                 > custom_minimum_size = (5.0, 0.0)
>                 > layout_mode = 2
>                 File (Label)
>                 > layout_mode = 2
>                 > size_flags_horizontal = 3
>                 > text = "test_this_thing.gd"
>                 > text_overrun_behavior = 3
>             Footer (HBoxContainer)
>             > layout_mode = 2
>               HandleLeft (ColorRect)
>                 script: res://addons/gut/gui/ResizeHandle.gd
>                 scene: res://addons/gut/gui/ResizeHandle.tscn
>               > custom_minimum_size = (20.0, 20.0)
>               > layout_mode = 2
>               > color = (1.0, 1.0, 1.0, 0.0)
>               > orientation = 0
>               > resize_control = Compact:<Panel#6377221225776>
>               > vertical_resize = false
>               SwitchModes (Button)
>               > layout_mode = 2
>               > text = "Expand"
>               CenterContainer (CenterContainer)
>               > layout_mode = 2
>               > size_flags_horizontal = 3
>               Continue (Button)
>               > layout_mode = 2
>               > text = "Continue\n"
>               HandleRight (ColorRect)
>                 script: res://addons/gut/gui/ResizeHandle.gd
>                 scene: res://addons/gut/gui/ResizeHandle.tscn
>               > custom_minimum_size = (20.0, 20.0)
>               > layout_mode = 2
>               > color = (1.0, 1.0, 1.0, 0.0)
>               > orientation = 1
>               > resize_control = Compact:<Panel#6377221225776>
>               > vertical_resize = false
>           RightMargin (CenterContainer)
>           > custom_minimum_size = (5.0, 0.0)
>           > layout_mode = 2
>         CenterContainer (CenterContainer)
>         > custom_minimum_size = (0.0, 2.0)
>         > layout_mode = 2

--- SCENE: res://addons/gut/gui/MinGui.tscn ---
Min (Panel)
> script: res://addons/gut/gui/gut_gui.gd
> scene: res://addons/gut/gui/MinGui.tscn
> clip_contents = true
> custom_minimum_size = (280.0, 145.0)
> offset_right = 280.0
> offset_bottom = 145.0
> theme = res://addons/gut/gui/GutSceneTheme.tres
> MainBox (VBoxContainer)
> > layout_mode = 1
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   TitleBar (Panel)
>   > custom_minimum_size = (0.0, 25.0)
>   > layout_mode = 2
>     TitleBox (HBoxContainer)
>     > layout_mode = 0
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > offset_top = 2.0
>     > offset_bottom = 3.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>       Spacer1 (CenterContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       Title (Label)
>       > layout_mode = 2
>       > text = "Title"
>       Spacer2 (CenterContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       TimeLabel (Label)
>       > layout_mode = 2
>       > text = "0.000s"
>   Body (HBoxContainer)
>   > layout_mode = 2
>   > size_flags_vertical = 3
>     LeftMargin (CenterContainer)
>     > custom_minimum_size = (5.0, 0.0)
>     > layout_mode = 2
>     BodyRows (VBoxContainer)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>       ProgressBars (HBoxContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>         HBoxContainer (HBoxContainer)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>           Label (Label)
>           > layout_mode = 2
>           > text = "T:"
>           ProgressTest (ProgressBar)
>           > custom_minimum_size = (100.0, 0.0)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > value = 25.0
>         HBoxContainer2 (HBoxContainer)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>           Label (Label)
>           > layout_mode = 2
>           > text = "S:"
>           ProgressScript (ProgressBar)
>           > custom_minimum_size = (100.0, 0.0)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > value = 75.0
>       PathDisplay (VBoxContainer)
>       > clip_contents = true
>       > layout_mode = 2
>       > size_flags_vertical = 3
>         Path (Label)
>         > layout_mode = 2
>         > text = "res://test/integration/whatever"
>         > clip_text = true
>         > text_overrun_behavior = 3
>         HBoxContainer (HBoxContainer)
>         > clip_contents = true
>         > layout_mode = 2
>           S3 (CenterContainer)
>           > custom_minimum_size = (5.0, 0.0)
>           > layout_mode = 2
>           File (Label)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > text = "test_this_thing.gd"
>           > text_overrun_behavior = 3
>       Footer (HBoxContainer)
>       > layout_mode = 2
>         HandleLeft (ColorRect)
>           script: res://addons/gut/gui/ResizeHandle.gd
>           scene: res://addons/gut/gui/ResizeHandle.tscn
>         > custom_minimum_size = (20.0, 20.0)
>         > layout_mode = 2
>         > color = (1.0, 1.0, 1.0, 0.0)
>         > orientation = 0
>         > resize_control = Min:<Panel#6380912211561>
>         > vertical_resize = false
>         SwitchModes (Button)
>         > layout_mode = 2
>         > text = "Expand"
>         CenterContainer (CenterContainer)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         Continue (Button)
>         > layout_mode = 2
>         > text = "Continue\n"
>         HandleRight (ColorRect)
>           script: res://addons/gut/gui/ResizeHandle.gd
>           scene: res://addons/gut/gui/ResizeHandle.tscn
>         > custom_minimum_size = (20.0, 20.0)
>         > layout_mode = 2
>         > color = (1.0, 1.0, 1.0, 0.0)
>         > orientation = 1
>         > resize_control = Min:<Panel#6380912211561>
>         > vertical_resize = false
>     RightMargin (CenterContainer)
>     > custom_minimum_size = (5.0, 0.0)
>     > layout_mode = 2
>   CenterContainer (CenterContainer)
>   > custom_minimum_size = (0.0, 2.0)
>   > layout_mode = 2

--- SCENE: res://addons/gut/gui/NormalGui.tscn ---
Large (Panel)
> script: res://addons/gut/gui/gut_gui.gd
> scene: res://addons/gut/gui/NormalGui.tscn
> custom_minimum_size = (500.0, 150.0)
> offset_right = 632.0
> offset_bottom = 260.0
> theme = res://addons/gut/gui/GutSceneTheme.tres
> MainBox (VBoxContainer)
> > layout_mode = 0
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   TitleBar (Panel)
>   > custom_minimum_size = (0.0, 25.0)
>   > layout_mode = 2
>     TitleBox (HBoxContainer)
>     > layout_mode = 0
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > offset_top = 2.0
>     > offset_bottom = 3.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>       Spacer1 (CenterContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       Title (Label)
>       > layout_mode = 2
>       > text = "Title"
>       Spacer2 (CenterContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       TimeLabel (Label)
>       > custom_minimum_size = (90.0, 0.0)
>       > layout_mode = 2
>       > text = "999.999s"
>   HBoxContainer (HBoxContainer)
>   > layout_mode = 2
>   > size_flags_vertical = 3
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>       OutputBG (ColorRect)
>       > layout_mode = 2
>       > size_flags_vertical = 3
>       > color = (0.0745, 0.0706, 0.0784, 1.0)
>         HBoxContainer (HBoxContainer)
>         > layout_mode = 0
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>           S2 (CenterContainer)
>           > custom_minimum_size = (5.0, 0.0)
>           > layout_mode = 2
>           TestOutput (RichTextLabel)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > size_flags_vertical = 3
>           > focus_mode = 2
>           > bbcode_enabled = true
>           > scroll_following = true
>           > autowrap_mode = 0
>           > selection_enabled = true
>           S1 (CenterContainer)
>           > custom_minimum_size = (5.0, 0.0)
>           > layout_mode = 2
>       ControlBox (HBoxContainer)
>       > layout_mode = 2
>         S1 (CenterContainer)
>         > custom_minimum_size = (5.0, 0.0)
>         > layout_mode = 2
>         ProgressBars (VBoxContainer)
>         > layout_mode = 2
>           TestBox (HBoxContainer)
>           > layout_mode = 2
>             Label (Label)
>             > custom_minimum_size = (60.0, 0.0)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             > text = "Tests"
>             ProgressTest (ProgressBar)
>             > custom_minimum_size = (100.0, 0.0)
>             > layout_mode = 2
>             > value = 25.0
>           ScriptBox (HBoxContainer)
>           > layout_mode = 2
>             Label (Label)
>             > custom_minimum_size = (60.0, 0.0)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             > text = "Scripts"
>             ProgressScript (ProgressBar)
>             > custom_minimum_size = (100.0, 0.0)
>             > layout_mode = 2
>             > value = 75.0
>         PathDisplay (VBoxContainer)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 3
>           Path (Label)
>           > layout_mode = 2
>           > size_flags_vertical = 6
>           > text = "res://test/integration/whatever"
>           > text_overrun_behavior = 3
>           HBoxContainer (HBoxContainer)
>           > layout_mode = 2
>           > size_flags_vertical = 3
>             S3 (CenterContainer)
>             > custom_minimum_size = (5.0, 0.0)
>             > layout_mode = 2
>             File (Label)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             > text = "test_this_thing.gd"
>             > text_overrun_behavior = 3
>         Spacer1 (CenterContainer)
>         > visible = false
>         > layout_mode = 2
>         > size_flags_horizontal = 10
>         Continue (Button)
>         > layout_mode = 2
>         > size_flags_vertical = 4
>         > text = "Continue\n"
>         S3 (CenterContainer)
>         > custom_minimum_size = (5.0, 0.0)
>         > layout_mode = 2
>   BottomPad (CenterContainer)
>   > custom_minimum_size = (0.0, 5.0)
>   > layout_mode = 2
>   Footer (HBoxContainer)
>   > layout_mode = 2
>     SidePad1 (CenterContainer)
>     > custom_minimum_size = (2.0, 0.0)
>     > layout_mode = 2
>     ResizeHandle3 (ColorRect)
>       script: res://addons/gut/gui/ResizeHandle.gd
>       scene: res://addons/gut/gui/ResizeHandle.tscn
>     > custom_minimum_size = (25.0, 25.0)
>     > layout_mode = 2
>     > color = (1.0, 1.0, 1.0, 0.0)
>     > orientation = 0
>     > resize_control = Large:<Panel#6383076472425>
>     > vertical_resize = true
>     SwitchModes (Button)
>     > layout_mode = 2
>     > text = "Compact\n"
>     CenterContainer (CenterContainer)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     ResizeHandle2 (ColorRect)
>       script: res://addons/gut/gui/ResizeHandle.gd
>       scene: res://addons/gut/gui/ResizeHandle.tscn
>     > custom_minimum_size = (25.0, 25.0)
>     > layout_mode = 2
>     > color = (1.0, 1.0, 1.0, 0.0)
>     > orientation = 1
>     > resize_control = Large:<Panel#6383076472425>
>     > vertical_resize = true
>     SidePad2 (CenterContainer)
>     > custom_minimum_size = (2.0, 0.0)
>     > layout_mode = 2
>   BottomPad2 (CenterContainer)
>   > custom_minimum_size = (0.0, 2.0)
>   > layout_mode = 2

--- SCENE: res://addons/gut/gui/OutputText.tscn ---
OutputText (VBoxContainer)
> script: res://addons/gut/gui/OutputText.gd
> scene: res://addons/gut/gui/OutputText.tscn
> offset_right = 862.0
> offset_bottom = 523.0
> size_flags_horizontal = 3
> size_flags_vertical = 3
> Toolbar (HBoxContainer)
> > layout_mode = 2
> > size_flags_horizontal = 3
>   ShowSearch (Button)
>   > layout_mode = 2
>   > tooltip_text = "Search"
>   > toggle_mode = true
>   > icon = res://addons/gut/gui/OutputText.tscn::ImageTexture_42opa
>   ShowSettings (Button)
>   > layout_mode = 2
>   > tooltip_text = "Settings"
>   > toggle_mode = true
>   > text = "..."
>   CenterContainer (CenterContainer)
>   > layout_mode = 2
>   > size_flags_horizontal = 3
>   LblPosition (Label)
>   > layout_mode = 2
>   CopyButton (Button)
>   > layout_mode = 2
>   > text = " Copy "
>   ClearButton (Button)
>   > layout_mode = 2
>   > text = "  Clear  "
> Settings (HBoxContainer)
> > visible = false
> > layout_mode = 2
>   WordWrap (Button)
>   > layout_mode = 2
>   > tooltip_text = "Word Wrap"
>   > toggle_mode = true
>   > icon = res://addons/gut/gui/OutputText.tscn::ImageTexture_42opa
>   UseColors (Button)
>   > layout_mode = 2
>   > tooltip_text = "Colorized Text"
>   > toggle_mode = true
>   > button_pressed = true
>   > icon = res://addons/gut/gui/OutputText.tscn::ImageTexture_42opa
> Output (TextEdit)
> > layout_mode = 2
> > size_flags_horizontal = 3
> > size_flags_vertical = 3
> > deselect_on_focus_loss_enabled = false
> > virtual_keyboard_enabled = false
> > middle_mouse_paste_enabled = false
> > scroll_smooth = true
> > syntax_highlighter = res://addons/gut/gui/OutputText.tscn::CodeHighlighter_v57hd
> > highlight_all_occurrences = true
> > highlight_current_line = true
> Search (HBoxContainer)
> > visible = false
> > layout_mode = 2
>   SearchTerm (LineEdit)
>   > layout_mode = 2
>   > size_flags_horizontal = 3
>   SearchNext (Button)
>   > layout_mode = 2
>   > text = "Next"
>   SearchPrev (Button)
>   > layout_mode = 2
>   > text = "Prev"

--- SCENE: res://addons/gut/gui/ResizeHandle.tscn ---
ResizeHandle (ColorRect)
> script: res://addons/gut/gui/ResizeHandle.gd
> scene: res://addons/gut/gui/ResizeHandle.tscn
> custom_minimum_size = (20.0, 20.0)
> color = (1.0, 1.0, 1.0, 0.0)
> orientation = 1
> vertical_resize = true

--- SCENE: res://addons/gut/gui/ResultsTree.tscn ---
ResultsTree (VBoxContainer)
> script: res://addons/gut/gui/ResultsTree.gd
> scene: res://addons/gut/gui/ResultsTree.tscn
> custom_minimum_size = (10.0, 10.0)
> anchor_right = 1.0
> anchor_bottom = 1.0
> offset_right = -70.0
> offset_bottom = -104.0
> grow_horizontal = 2
> grow_vertical = 2
> size_flags_horizontal = 3
> size_flags_vertical = 3
> Tree (Tree)
> > layout_mode = 2
> > size_flags_horizontal = 3
> > size_flags_vertical = 3
> > columns = 2
> > hide_root = true
>   TextOverlay (Label)
>   > visible = false
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2

--- SCENE: res://addons/gut/gui/RunAtCursor.tscn ---
RunAtCursor (Control)
> script: res://addons/gut/gui/RunAtCursor.gd
> scene: res://addons/gut/gui/RunAtCursor.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> offset_right = 1.0
> offset_bottom = -527.0
> grow_horizontal = 2
> grow_vertical = 2
> size_flags_horizontal = 3
> size_flags_vertical = 3
> HBox (HBoxContainer)
> > layout_mode = 0
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > size_flags_horizontal = 3
> > size_flags_vertical = 3
>   LblNoneSelected (Label)
>   > layout_mode = 2
>   > text = "<None>"
>   BtnRunScript (Button)
>   > visible = false
>   > layout_mode = 2
>   > text = "<script>"
>   > icon = res://addons/gut/gui/play.png
>   Arrow1 (TextureButton)
>   > visible = false
>   > custom_minimum_size = (24.0, 0.0)
>   > layout_mode = 2
>   > texture_normal = res://addons/gut/gui/arrow.png
>   > stretch_mode = 3
>   BtnRunInnerClass (Button)
>   > visible = false
>   > layout_mode = 2
>   > text = "<inner class>"
>   > icon = res://addons/gut/gui/play.png
>   Arrow2 (TextureButton)
>   > visible = false
>   > custom_minimum_size = (24.0, 0.0)
>   > layout_mode = 2
>   > texture_normal = res://addons/gut/gui/arrow.png
>   > stretch_mode = 3
>   BtnRunMethod (Button)
>   > visible = false
>   > layout_mode = 2
>   > text = "<method>"
>   > icon = res://addons/gut/gui/play.png

--- SCENE: res://addons/gut/gui/RunResults.tscn ---
RunResults (Control)
> script: res://addons/gut/gui/RunResults.gd
> scene: res://addons/gut/gui/RunResults.tscn
> custom_minimum_size = (345.0, 0.0)
> offset_right = 709.0
> offset_bottom = 321.0
> VBox (VBoxContainer)
> > layout_mode = 0
> > anchor_right = 1.0
> > anchor_bottom = 1.0
>   Toolbar (HBoxContainer)
>   > layout_mode = 2
>   > size_flags_horizontal = 0
>     Expand (Button)
>     > layout_mode = 2
>     > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>     Collapse (Button)
>     > layout_mode = 2
>     > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>     Sep (ColorRect)
>     > custom_minimum_size = (2.0, 0.0)
>     > layout_mode = 2
>     LblAll (Label)
>     > layout_mode = 2
>     > text = "All:"
>     ExpandAll (Button)
>     > layout_mode = 2
>     > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>     CollapseAll (Button)
>     > layout_mode = 2
>     > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>     Sep2 (ColorRect)
>     > custom_minimum_size = (2.0, 0.0)
>     > layout_mode = 2
>     HidePassing (CheckBox)
>     > layout_mode = 2
>     > size_flags_horizontal = 4
>     > text = "Passing"
>     Sep3 (ColorRect)
>     > custom_minimum_size = (2.0, 0.0)
>     > layout_mode = 2
>     LblSync (Label)
>     > layout_mode = 2
>     > text = "Sync:"
>     ShowScript (Button)
>     > layout_mode = 2
>     > toggle_mode = true
>     > button_pressed = true
>     > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>     ScrollOutput (Button)
>     > layout_mode = 2
>     > toggle_mode = true
>     > button_pressed = true
>     > icon = res://addons/gut/gui/RunResults.tscn::ImageTexture_x655i
>   Output (Panel)
>   > self_modulate = (1.0, 1.0, 1.0, 0.5412)
>   > layout_mode = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     Scroll (ScrollContainer)
>     > layout_mode = 1
>     > anchors_preset = 15
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>       Tree (VBoxContainer)
>         script: res://addons/gut/gui/ResultsTree.gd
>         scene: res://addons/gut/gui/ResultsTree.tscn
>       > custom_minimum_size = (10.0, 10.0)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       > size_flags_vertical = 3
>         Tree (Tree)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         > size_flags_vertical = 3
>         > columns = 2
>         > hide_root = true
>           TextOverlay (Label)
>           > visible = false
>           > layout_mode = 1
>           > anchors_preset = 15
>           > anchor_right = 1.0
>           > anchor_bottom = 1.0
>           > grow_horizontal = 2
>           > grow_vertical = 2
> FontSampler (Label)
> > visible = false
> > layout_mode = 0
> > offset_right = 40.0
> > offset_bottom = 14.0
> > text = "000 of 000 passed"

--- SCENE: res://addons/gut/gui/run_from_editor.tscn ---
RunFromEditor (Node2D)
> script: res://addons/gut/gui/run_from_editor.gd
> scene: res://addons/gut/gui/run_from_editor.tscn

--- SCENE: res://addons/gut/gui/Settings.tscn ---
Settings (VBoxContainer)
> scene: res://addons/gut/gui/Settings.tscn
> offset_right = 388.0
> offset_bottom = 586.0
> size_flags_horizontal = 3
> size_flags_vertical = 3

--- SCENE: res://addons/gut/gui/ShortcutButton.tscn ---
ShortcutButton (Control)
> script: res://addons/gut/gui/ShortcutButton.gd
> scene: res://addons/gut/gui/ShortcutButton.tscn
> custom_minimum_size = (210.0, 30.0)
> anchors_preset = -1
> anchor_right = 0.12300000339746
> anchor_bottom = 0.03999999910593
> offset_right = 68.3040008544922
> offset_bottom = 6.07999992370605
> Layout (HBoxContainer)
> > layout_mode = 0
> > anchor_right = 1.0
> > anchor_bottom = 1.0
>   lblShortcut (Label)
>   > layout_mode = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 7
>   > text = "<None>"
>   > horizontal_alignment = 2
>   CenterContainer (CenterContainer)
>   > custom_minimum_size = (10.0, 0.0)
>   > layout_mode = 2
>   SetButton (Button)
>   > custom_minimum_size = (60.0, 0.0)
>   > layout_mode = 2
>   > text = "Set"
>   SaveButton (Button)
>   > visible = false
>   > custom_minimum_size = (60.0, 0.0)
>   > layout_mode = 2
>   > text = "Save"
>   CancelButton (Button)
>   > visible = false
>   > custom_minimum_size = (60.0, 0.0)
>   > layout_mode = 2
>   > text = "Cancel"
>   ClearButton (Button)
>   > custom_minimum_size = (60.0, 0.0)
>   > layout_mode = 2
>   > text = "Clear"

--- SCENE: res://addons/gut/GutScene.tscn ---
GutScene (Node2D)
> script: res://addons/gut/GutScene.gd
> scene: res://addons/gut/GutScene.tscn
> Normal (Panel)
>   script: res://addons/gut/gui/gut_gui.gd
>   scene: res://addons/gut/gui/NormalGui.tscn
> > custom_minimum_size = (500.0, 150.0)
> > offset_right = 632.0
> > offset_bottom = 260.0
> > theme = res://addons/gut/gui/GutSceneTheme.tres
>   MainBox (VBoxContainer)
>   > layout_mode = 0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TitleBar (Panel)
>     > custom_minimum_size = (0.0, 25.0)
>     > layout_mode = 2
>       TitleBox (HBoxContainer)
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_top = 2.0
>       > offset_bottom = 3.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>         Spacer1 (CenterContainer)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         Title (Label)
>         > layout_mode = 2
>         > text = "Title"
>         Spacer2 (CenterContainer)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         TimeLabel (Label)
>         > custom_minimum_size = (90.0, 0.0)
>         > layout_mode = 2
>         > text = "999.999s"
>     HBoxContainer (HBoxContainer)
>     > layout_mode = 2
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>         OutputBG (ColorRect)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>         > color = (0.0745, 0.0706, 0.0784, 1.0)
>           HBoxContainer (HBoxContainer)
>           > layout_mode = 0
>           > anchor_right = 1.0
>           > anchor_bottom = 1.0
>           > grow_horizontal = 2
>           > grow_vertical = 2
>             S2 (CenterContainer)
>             > custom_minimum_size = (5.0, 0.0)
>             > layout_mode = 2
>             TestOutput (RichTextLabel)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             > size_flags_vertical = 3
>             > focus_mode = 2
>             > bbcode_enabled = true
>             > scroll_following = true
>             > autowrap_mode = 0
>             > selection_enabled = true
>             S1 (CenterContainer)
>             > custom_minimum_size = (5.0, 0.0)
>             > layout_mode = 2
>         ControlBox (HBoxContainer)
>         > layout_mode = 2
>           S1 (CenterContainer)
>           > custom_minimum_size = (5.0, 0.0)
>           > layout_mode = 2
>           ProgressBars (VBoxContainer)
>           > layout_mode = 2
>             TestBox (HBoxContainer)
>             > layout_mode = 2
>               Label (Label)
>               > custom_minimum_size = (60.0, 0.0)
>               > layout_mode = 2
>               > size_flags_horizontal = 3
>               > text = "Tests"
>               ProgressTest (ProgressBar)
>               > custom_minimum_size = (100.0, 0.0)
>               > layout_mode = 2
>               > value = 25.0
>             ScriptBox (HBoxContainer)
>             > layout_mode = 2
>               Label (Label)
>               > custom_minimum_size = (60.0, 0.0)
>               > layout_mode = 2
>               > size_flags_horizontal = 3
>               > text = "Scripts"
>               ProgressScript (ProgressBar)
>               > custom_minimum_size = (100.0, 0.0)
>               > layout_mode = 2
>               > value = 75.0
>           PathDisplay (VBoxContainer)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           > size_flags_vertical = 3
>             Path (Label)
>             > layout_mode = 2
>             > size_flags_vertical = 6
>             > text = "res://test/integration/whatever"
>             > text_overrun_behavior = 3
>             HBoxContainer (HBoxContainer)
>             > layout_mode = 2
>             > size_flags_vertical = 3
>               S3 (CenterContainer)
>               > custom_minimum_size = (5.0, 0.0)
>               > layout_mode = 2
>               File (Label)
>               > layout_mode = 2
>               > size_flags_horizontal = 3
>               > text = "test_this_thing.gd"
>               > text_overrun_behavior = 3
>           Spacer1 (CenterContainer)
>           > visible = false
>           > layout_mode = 2
>           > size_flags_horizontal = 10
>           Continue (Button)
>           > layout_mode = 2
>           > size_flags_vertical = 4
>           > text = "Continue\n"
>           S3 (CenterContainer)
>           > custom_minimum_size = (5.0, 0.0)
>           > layout_mode = 2
>     BottomPad (CenterContainer)
>     > custom_minimum_size = (0.0, 5.0)
>     > layout_mode = 2
>     Footer (HBoxContainer)
>     > layout_mode = 2
>       SidePad1 (CenterContainer)
>       > custom_minimum_size = (2.0, 0.0)
>       > layout_mode = 2
>       ResizeHandle3 (ColorRect)
>         script: res://addons/gut/gui/ResizeHandle.gd
>         scene: res://addons/gut/gui/ResizeHandle.tscn
>       > custom_minimum_size = (25.0, 25.0)
>       > layout_mode = 2
>       > color = (1.0, 1.0, 1.0, 0.0)
>       > orientation = 0
>       > resize_control = Normal:<Panel#6394770193505>
>       > vertical_resize = true
>       SwitchModes (Button)
>       > layout_mode = 2
>       > text = "Compact\n"
>       CenterContainer (CenterContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       ResizeHandle2 (ColorRect)
>         script: res://addons/gut/gui/ResizeHandle.gd
>         scene: res://addons/gut/gui/ResizeHandle.tscn
>       > custom_minimum_size = (25.0, 25.0)
>       > layout_mode = 2
>       > color = (1.0, 1.0, 1.0, 0.0)
>       > orientation = 1
>       > resize_control = Normal:<Panel#6394770193505>
>       > vertical_resize = true
>       SidePad2 (CenterContainer)
>       > custom_minimum_size = (2.0, 0.0)
>       > layout_mode = 2
>     BottomPad2 (CenterContainer)
>     > custom_minimum_size = (0.0, 2.0)
>     > layout_mode = 2
> Compact (Panel)
>   script: res://addons/gut/gui/gut_gui.gd
>   scene: res://addons/gut/gui/MinGui.tscn
> > clip_contents = true
> > custom_minimum_size = (280.0, 145.0)
> > offset_left = 5.0
> > offset_top = 273.0
> > offset_right = 265.0
> > offset_bottom = 403.0
> > theme = res://addons/gut/gui/GutSceneTheme.tres
>   MainBox (VBoxContainer)
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TitleBar (Panel)
>     > custom_minimum_size = (0.0, 25.0)
>     > layout_mode = 2
>       TitleBox (HBoxContainer)
>       > layout_mode = 0
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_top = 2.0
>       > offset_bottom = 3.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>         Spacer1 (CenterContainer)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         Title (Label)
>         > layout_mode = 2
>         > text = "Title"
>         Spacer2 (CenterContainer)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>         TimeLabel (Label)
>         > layout_mode = 2
>         > text = "0.000s"
>     Body (HBoxContainer)
>     > layout_mode = 2
>     > size_flags_vertical = 3
>       LeftMargin (CenterContainer)
>       > custom_minimum_size = (5.0, 0.0)
>       > layout_mode = 2
>       BodyRows (VBoxContainer)
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>         ProgressBars (HBoxContainer)
>         > layout_mode = 2
>         > size_flags_horizontal = 3
>           HBoxContainer (HBoxContainer)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>             Label (Label)
>             > layout_mode = 2
>             > text = "T:"
>             ProgressTest (ProgressBar)
>             > custom_minimum_size = (100.0, 0.0)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             > value = 25.0
>           HBoxContainer2 (HBoxContainer)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>             Label (Label)
>             > layout_mode = 2
>             > text = "S:"
>             ProgressScript (ProgressBar)
>             > custom_minimum_size = (100.0, 0.0)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             > value = 75.0
>         PathDisplay (VBoxContainer)
>         > clip_contents = true
>         > layout_mode = 2
>         > size_flags_vertical = 3
>           Path (Label)
>           > layout_mode = 2
>           > text = "res://test/integration/whatever"
>           > clip_text = true
>           > text_overrun_behavior = 3
>           HBoxContainer (HBoxContainer)
>           > clip_contents = true
>           > layout_mode = 2
>             S3 (CenterContainer)
>             > custom_minimum_size = (5.0, 0.0)
>             > layout_mode = 2
>             File (Label)
>             > layout_mode = 2
>             > size_flags_horizontal = 3
>             > text = "test_this_thing.gd"
>             > text_overrun_behavior = 3
>         Footer (HBoxContainer)
>         > layout_mode = 2
>           HandleLeft (ColorRect)
>             script: res://addons/gut/gui/ResizeHandle.gd
>             scene: res://addons/gut/gui/ResizeHandle.tscn
>           > custom_minimum_size = (20.0, 20.0)
>           > layout_mode = 2
>           > color = (1.0, 1.0, 1.0, 0.0)
>           > orientation = 0
>           > resize_control = Compact:<Panel#6396246588682>
>           > vertical_resize = false
>           SwitchModes (Button)
>           > layout_mode = 2
>           > text = "Expand"
>           CenterContainer (CenterContainer)
>           > layout_mode = 2
>           > size_flags_horizontal = 3
>           Continue (Button)
>           > layout_mode = 2
>           > text = "Continue\n"
>           HandleRight (ColorRect)
>             script: res://addons/gut/gui/ResizeHandle.gd
>             scene: res://addons/gut/gui/ResizeHandle.tscn
>           > custom_minimum_size = (20.0, 20.0)
>           > layout_mode = 2
>           > color = (1.0, 1.0, 1.0, 0.0)
>           > orientation = 1
>           > resize_control = Compact:<Panel#6396246588682>
>           > vertical_resize = false
>       RightMargin (CenterContainer)
>       > custom_minimum_size = (5.0, 0.0)
>       > layout_mode = 2
>     CenterContainer (CenterContainer)
>     > custom_minimum_size = (0.0, 2.0)
>     > layout_mode = 2

--- SCENE: res://addons/gut/gut_loader_the_scene.tscn ---
Node (Node2D)
> script: res://addons/gut/gut_loader.gd
> scene: res://addons/gut/gut_loader_the_scene.tscn

--- SCENE: res://addons/gut/UserFileViewer.tscn ---
UserFileViewer (Window)
> script: res://addons/gut/UserFileViewer.gd
> scene: res://addons/gut/UserFileViewer.tscn
> exclusive = true
> FileDialog (FileDialog)
> > access = 1
> > show_hidden_files = true
>   @PopupMenu@34243 (PopupMenu)
> TextDisplay (ColorRect)
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > offset_left = 8.0
> > offset_right = -10.0
> > offset_bottom = -65.0
> > color = (0.2, 0.1882, 0.1882, 1.0)
>   RichTextLabel (RichTextLabel)
>   > layout_mode = 0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > focus_mode = 2
>   > text = "In publishing and graphic design, Lorem ipsum is a placeholder text commonly used to demonstrate the visual form of a document or a typeface without relying on meaningful content. Lorem ipsum may be used before final copy is available, but it may also be used to temporarily replace copy in a process called greeking, which allows designers to consider form without the meaning of the text influencing the design.\n\nLorem ipsum is typically a corrupted version of De finibus bonorum et malorum, a first-century BCE text by the Roman statesman and philosopher Cicero, with words altered, added, and removed to make it nonsensical, improper Latin.\n\nVersions of the Lorem ipsum text have been used in typesetting at least since the 1960s, when it was popularized by advertisements for Letraset transfer sheets. Lorem ipsum was introduced to the digital world in the mid-1980s when Aldus employed it in graphic and word-processing templates for its desktop publishing program PageMaker. Other popular word processors including Pages and Microsoft Word have since adopted Lorem ipsum as well."
>   > selection_enabled = true
> OpenFile (Button)
> > anchors_preset = 3
> > anchor_left = 1.0
> > anchor_top = 1.0
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > offset_left = -158.0
> > offset_top = -50.0
> > offset_right = -84.0
> > offset_bottom = -30.0
> > text = "Open File"
> Home (Button)
> > anchors_preset = 3
> > anchor_left = 1.0
> > anchor_top = 1.0
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > offset_left = -478.0
> > offset_top = -50.0
> > offset_right = -404.0
> > offset_bottom = -30.0
> > text = "Home"
> Copy (Button)
> > anchors_preset = 2
> > anchor_top = 1.0
> > anchor_bottom = 1.0
> > offset_left = 160.0
> > offset_top = -50.0
> > offset_right = 234.0
> > offset_bottom = -30.0
> > text = "Copy"
> End (Button)
> > anchors_preset = 3
> > anchor_left = 1.0
> > anchor_top = 1.0
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > offset_left = -318.0
> > offset_top = -50.0
> > offset_right = -244.0
> > offset_bottom = -30.0
> > text = "End"
> Close (Button)
> > anchors_preset = 2
> > anchor_top = 1.0
> > anchor_bottom = 1.0
> > offset_left = 10.0
> > offset_top = -50.0
> > offset_right = 80.0
> > offset_bottom = -30.0
> > text = "Close"

--- SCENE: res://addons/loggie/version_management/update_prompt_window.tscn ---
UpdatePromptWindow (Panel)
> script: res://addons/loggie/version_management/update_prompt_window.gd
> scene: res://addons/loggie/version_management/update_prompt_window.tscn
> anchor_right = 0.92299997806549
> anchor_bottom = 1.03699994087219
> offset_right = -0.29602101445198
> offset_bottom = 0.02398679964244
> grow_horizontal = 2
> grow_vertical = 2
> animator = AnimationPlayer:<AnimationPlayer#6413980106033>
> host_window_size = (1063.0, 672.0)
> Notice (Control)
> > unique_name_in_owner = true
> > layout_mode = 1
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   Background (TextureRect)
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > texture = res://addons/loggie/assets/updater_bg.png
>   > expand_mode = 1
>   LabelLatestVersion (Label)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = -1
>   > anchor_left = 0.14800000190735
>   > anchor_top = 0.54900002479553
>   > anchor_right = 0.35199999809265
>   > anchor_bottom = 0.73500001430511
>   > offset_left = 0.41497799754143
>   > offset_top = 0.11593600362539
>   > offset_right = -0.12200900167227
>   > offset_bottom = 0.12393199652433
>   > grow_horizontal = 2
>   > grow_vertical = 0
>   > text = "X.Y"
>   LabelCurrentVersion (Label)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = -1
>   > anchor_left = 0.75999999046326
>   > anchor_top = 0.4539999961853
>   > anchor_right = 0.86900001764297
>   > anchor_bottom = 0.57099997997284
>   > offset_left = 0.04498289898038
>   > offset_top = 0.18399000167847
>   > offset_right = 57.0040016174316
>   > offset_bottom = -0.10705599933863
>   > grow_horizontal = 0
>   > grow_vertical = 2
>   > text = "X.Y"
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 1
>   > anchors_preset = -1
>   > anchor_left = 0.22900000214577
>   > anchor_top = 0.78899997472763
>   > anchor_right = 0.77100002765656
>   > anchor_bottom = 0.92599999904633
>   > offset_left = 0.0729828029871
>   > offset_top = -0.2080080062151
>   > offset_right = -0.07305909693241
>   > offset_bottom = 9.72797012329102
>   > grow_horizontal = 2
>     Label (Label)
>     > layout_mode = 2
>     > size_flags_horizontal = 4
>     > text = "a new version of Loggie is available for download."
>     > horizontal_alignment = 1
>     HBoxContainer (HBoxContainer)
>     > layout_mode = 2
>     > size_flags_vertical = 4
>     > alignment = 1
>       NoticeButtons (HBoxContainer)
>       > unique_name_in_owner = true
>       > layout_mode = 2
>       > size_flags_horizontal = 6
>         ReleaseNotesBtn (Button)
>         > unique_name_in_owner = true
>         > visible = false
>         > layout_mode = 2
>         > mouse_default_cursor_shape = 2
>         > text = "release notes"
>         UpdateNowBtn (Button)
>         > unique_name_in_owner = true
>         > layout_mode = 2
>         > mouse_default_cursor_shape = 2
>         > text = "update now"
>         RemindLaterBtn (Button)
>         > unique_name_in_owner = true
>         > layout_mode = 2
>         > mouse_default_cursor_shape = 2
>         > text = "remind later"
>   DontShowAgainCheckbox (CheckBox)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = 1
>   > anchor_left = 1.0
>   > anchor_right = 1.0
>   > offset_left = -289.0
>   > offset_top = 9.0
>   > offset_right = -20.0
>   > offset_bottom = 62.0
>   > grow_horizontal = 0
>   > mouse_default_cursor_shape = 2
>   > text = "do not show this again"
> UpdateMonitor (Control)
> > visible = false
> > layout_mode = 1
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > offset_top = -673.0
> > offset_bottom = -673.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   BackgroundUnder (TextureRect)
>   > modulate = (1.0, 1.0, 1.0, 0.8118)
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > texture = res://addons/loggie/version_management/update_prompt_window.tscn::GradientTexture1D_k1b6u
>   BackgroundOver (TextureRect)
>   > modulate = (1.0, 1.0, 1.0, 0.7529)
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > texture = res://addons/loggie/version_management/update_prompt_window.tscn::GradientTexture2D_p6ad4
>   ProgressBar (ProgressBar)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = 7
>   > anchor_left = 0.5
>   > anchor_top = 1.0
>   > anchor_right = 0.5
>   > anchor_bottom = 1.0
>   > offset_left = -448.5
>   > offset_top = -224.0
>   > offset_right = 449.5
>   > offset_bottom = -160.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>   LabelMainStatus (Label)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -201.0
>   > offset_top = -13.0
>   > offset_right = 201.0
>   > offset_bottom = 63.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > text = "status"
>   > horizontal_alignment = 1
>   LabelOldVersion (Label)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -426.5
>   > offset_top = 77.0
>   > offset_right = -24.5
>   > offset_bottom = 153.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > text = "v_old"
>   LabelNewVersion (Label)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = 33.5
>   > offset_top = 76.0
>   > offset_right = 435.5
>   > offset_bottom = 152.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > text = "V_NEW"
>   > horizontal_alignment = 2
>   LoggieIcon (TextureRect)
>   > layout_mode = 1
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -79.5
>   > offset_top = -213.0
>   > offset_right = 80.5
>   > offset_bottom = -53.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > pivot_offset = (80.0, 84.0)
>   > texture = res://addons/loggie/assets/icon.png
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 1
>   > anchors_preset = 12
>   > anchor_top = 1.0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_top = -140.0
>   > offset_bottom = 77.0001983642578
>   > grow_horizontal = 2
>   > grow_vertical = 0
>     OptionButtons (HBoxContainer)
>     > layout_mode = 2
>     > alignment = 1
>       OptionRetryUpdateBtn (Button)
>       > unique_name_in_owner = true
>       > visible = false
>       > custom_minimum_size = (100.0, 0.0)
>       > layout_mode = 2
>       > mouse_default_cursor_shape = 2
>       > theme = res://addons/loggie/assets/theme/loggie_theme.tres
>       > disabled = true
>       > text = "Retry"
>       OptionRestartGodotBtn (Button)
>       > unique_name_in_owner = true
>       > visible = false
>       > custom_minimum_size = (100.0, 0.0)
>       > layout_mode = 2
>       > mouse_default_cursor_shape = 2
>       > theme = res://addons/loggie/assets/theme/loggie_theme.tres
>       > disabled = true
>       > text = "Reload Godot"
>       OptionExitBtn (Button)
>       > unique_name_in_owner = true
>       > visible = false
>       > custom_minimum_size = (100.0, 0.0)
>       > layout_mode = 2
>       > mouse_default_cursor_shape = 2
>       > theme = res://addons/loggie/assets/theme/loggie_theme.tres
>       > disabled = true
>       > text = "Exit"
>     LabelUpdateStatus (Label)
>     > unique_name_in_owner = true
>     > layout_mode = 2
>     > theme = res://addons/loggie/assets/theme/loggie_theme.tres
>     > text = "UPDATE_STATUS_DETAILED"
>     > horizontal_alignment = 1
>     > autowrap_mode = 2
> AnimationPlayer (AnimationPlayer)
> > unique_name_in_owner = true
> > root_node = ../UpdateMonitor
> > libraries = {"":"<AnimationLibrary#-9223365624032304061>"}

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D/2d_example_scene.tscn ---
ExampleScene2D2 (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D/2d_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> TileMap (TileMap)
> > z_index = -1
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D/2d_example_scene.tscn::TileSet_kf7eg
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Controls (Label)
> > offset_left = 167.0
> > offset_top = -145.0
> > offset_right = 332.0
> > offset_bottom = -81.0
> > text = "[WASD] to move\n[Space] to jump"
> Camera2D (Camera2D)
> > position = (227.0, -28.0)
> > zoom = (1.5, 1.5)
> > process_callback = 0
> > editor_draw_limits = true
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Player (Node)
>   PlayerPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > process_priority = -1
>   > top_level = true
>   > position = (227.0, -28.0)
>   > priority_override = false
>   > priority = 10
>   > follow_mode = 2
>   > follow_target = PlayerVisuals:<Node2D#6420036679251>
>   > follow_targets = []
>   > zoom = (1.5, 1.5)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_2d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   CharacterBody2D (CharacterBody2D)
>     script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
>   > position = (227.0, -28.0)
>     DarkOverlay (ColorRect)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 8
>     > anchor_left = 0.5
>     > anchor_top = 0.5
>     > anchor_right = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = -1000.0
>     > offset_top = -1000.0
>     > offset_right = 1000.0
>     > offset_bottom = 1000.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > color = (0.0, 0.0, 0.0, 0.6157)
>     PlayerVisuals (Node2D)
>     > unique_name_in_owner = true
>       PlayerSprite (Sprite2D)
>       > unique_name_in_owner = true
>       > scale = (0.5, 0.5)
>       > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>       InteractionPrompt (Panel)
>       > unique_name_in_owner = true
>       > visible = false
>       > anchors_preset = 7
>       > anchor_left = 0.5
>       > anchor_top = 1.0
>       > anchor_right = 0.5
>       > anchor_bottom = 1.0
>       > offset_left = -16.0
>       > offset_top = -66.0
>       > offset_right = 16.0
>       > offset_bottom = -34.0
>       > grow_horizontal = 2
>       > grow_vertical = 0
>       > size_flags_vertical = 0
>         Label (Label)
>         > layout_mode = 1
>         > anchors_preset = 15
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>         > offset_top = -3.0
>         > offset_bottom = 5.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > text = "F"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>     PlayerArea2D (Area2D)
>     > unique_name_in_owner = true
>     > collision_layer = 2
>     > collision_mask = 2
>     > priority = 20
>       CollisionShape2D (CollisionShape2D)
>       > position = (0.0, -0.5)
>       > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>     ItemFocusPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (0.0, -122.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.0, 2.0)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     InventoryPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (-183.0, -5.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.5, 2.5)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_framed_example_scene.tscn ---
ExampleScene2D (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_framed_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -345.0
>   > offset_top = -143.0
>   > offset_right = 947.0
>   > offset_bottom = 578.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> TileMap (TileMap)
> > z_index = -1
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_framed_example_scene.tscn::TileSet_kf7eg
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Camera2D (Camera2D)
> > position = (282.0, -29.0)
> > zoom = (2.0, 2.0)
> > process_callback = 0
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Player (Node)
>   PlayerPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > top_level = true
>   > position = (282.0, -29.0)
>   > priority_override = false
>   > priority = 5
>   > follow_mode = 5
>   > follow_target = PlayerVisuals:<Node2D#6424314871378>
>   > follow_targets = []
>   > zoom = (2.0, 2.0)
>   > snap_to_pixel = false
>   > frame_preview = true
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_2d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.4
>   > dead_zone_height = 0.8
>   > show_viewfinder_in_play = true
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   Label (Label)
>   > offset_left = 167.0
>   > offset_top = -145.0
>   > offset_right = 332.0
>   > offset_bottom = -81.0
>   > text = "[WASD] to move\n[Space] to jump"
>   CharacterBody2D (CharacterBody2D)
>     script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
>   > position = (282.0, -29.0)
>     DarkOverlay (ColorRect)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 8
>     > anchor_left = 0.5
>     > anchor_top = 0.5
>     > anchor_right = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = -1000.0
>     > offset_top = -1000.0
>     > offset_right = 1000.0
>     > offset_bottom = 1000.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > color = (0.0, 0.0, 0.0, 0.6157)
>     PlayerVisuals (Node2D)
>     > unique_name_in_owner = true
>       PlayerSprite (Sprite2D)
>       > unique_name_in_owner = true
>       > scale = (0.5, 0.5)
>       > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>       InteractionPrompt (Panel)
>       > unique_name_in_owner = true
>       > visible = false
>       > anchors_preset = 7
>       > anchor_left = 0.5
>       > anchor_top = 1.0
>       > anchor_right = 0.5
>       > anchor_bottom = 1.0
>       > offset_left = -16.0
>       > offset_top = -66.0
>       > offset_right = 16.0
>       > offset_bottom = -34.0
>       > grow_horizontal = 2
>       > grow_vertical = 0
>       > size_flags_vertical = 0
>         Label (Label)
>         > layout_mode = 1
>         > anchors_preset = 15
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>         > offset_top = -3.0
>         > offset_bottom = 5.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > text = "F"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>     PlayerArea2D (Area2D)
>     > unique_name_in_owner = true
>     > collision_layer = 2
>     > collision_mask = 2
>     > priority = 20
>       CollisionShape2D (CollisionShape2D)
>       > position = (0.0, -0.5)
>       > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>     ItemFocusPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (0.0, -122.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.0, 2.0)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     InventoryPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (-183.0, -5.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.5, 2.5)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_group_example_scene.tscn ---
ExampleScene2D (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_group_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> TileMap (TileMap)
> > z_index = -1
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_group_example_scene.tscn::TileSet_kf7eg
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Camera2D (Camera2D)
> > position = (186.0, -172.5)
> > zoom = (1.5, 1.5)
> > position_smoothing_speed = 8.0
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Label (Label)
> > offset_left = 167.0
> > offset_top = -133.0
> > offset_right = 332.0
> > offset_bottom = -69.0
> > text = "[WASD] to move\n[Space] to jump"
> PhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > top_level = true
> > position = (186.0, -172.5)
> > priority_override = false
> > priority = 10
> > follow_mode = 3
> > follow_targets = ["GroupNPCSprite:<Sprite2D#6428760831584>","PlayerVisuals:<Node2D#6428827940372>"]
> > zoom = (1.5, 1.5)
> > snap_to_pixel = false
> > frame_preview = true
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_group_example_scene.tscn::Resource_spy00
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = true
> > auto_zoom_min = 0.5
> > auto_zoom_max = 1.5
> > auto_zoom_margin = (200.0, 0.0, 200.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = 
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> GroupNPCSprite (Sprite2D)
> > unique_name_in_owner = true
> > position = (107.0, -316.0)
> > texture = res://addons/phantom_camera/examples/textures/2D/phantom_camera_2d_sprite.png
> CharacterBody2D (CharacterBody2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
> > position = (265.0, -29.0)
>   DarkOverlay (ColorRect)
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -1000.0
>   > offset_top = -1000.0
>   > offset_right = 1000.0
>   > offset_bottom = 1000.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > color = (0.0, 0.0, 0.0, 0.6157)
>   PlayerVisuals (Node2D)
>   > unique_name_in_owner = true
>     PlayerSprite (Sprite2D)
>     > unique_name_in_owner = true
>     > scale = (0.5, 0.5)
>     > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>     InteractionPrompt (Panel)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 7
>     > anchor_left = 0.5
>     > anchor_top = 1.0
>     > anchor_right = 0.5
>     > anchor_bottom = 1.0
>     > offset_left = -16.0
>     > offset_top = -66.0
>     > offset_right = 16.0
>     > offset_bottom = -34.0
>     > grow_horizontal = 2
>     > grow_vertical = 0
>     > size_flags_vertical = 0
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_top = -3.0
>       > offset_bottom = 5.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "F"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -0.5)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>   PlayerArea2D (Area2D)
>   > unique_name_in_owner = true
>   > collision_layer = 2
>   > collision_mask = 2
>   > priority = 20
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>   ItemFocusPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (0.0, -122.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.0, 2.0)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   InventoryPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (-183.0, -5.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.5, 2.5)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_path_example_scene.tscn ---
ExampleScene2D (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_path_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> TileMap (TileMap)
> > z_index = -1
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_path_example_scene.tscn::TileSet_kf7eg
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Camera2D (Camera2D)
> > position = (374.0, -216.0)
> > zoom = (1.5, 1.5)
> > process_callback = 0
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Label (Label)
> > offset_left = 167.0
> > offset_top = -133.0
> > offset_right = 332.0
> > offset_bottom = -69.0
> > text = "[WASD] to move\n[Space] to jump"
> Player (Node)
>   Label (Label)
>   > visible = false
>   > offset_left = 167.0
>   > offset_top = -145.0
>   > offset_right = 332.0
>   > offset_bottom = -81.0
>   > text = "[WASD] to move\n[Space] to jump"
> PlayerPhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > unique_name_in_owner = true
> > top_level = true
> > position = (374.0, -216.0)
> > priority_override = false
> > priority = 10
> > follow_mode = 4
> > follow_target = PlayerVisuals:<Node2D#6433290681961>
> > follow_targets = []
> > follow_path = Path2D:<Path2D#6433223572607>
> > zoom = (1.5, 1.5)
> > snap_to_pixel = false
> > frame_preview = true
> > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_2d_tween.tres
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = 
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> Path2D (Path2D)
> > position = (152.0, -216.0)
> > curve = res://addons/phantom_camera/examples/example_scenes/2D/2d_follow_path_example_scene.tscn::Curve2D_usrhf
> CharacterBody2D (CharacterBody2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
> > position = (225.0, -28.0)
>   DarkOverlay (ColorRect)
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -1000.0
>   > offset_top = -1000.0
>   > offset_right = 1000.0
>   > offset_bottom = 1000.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > color = (0.0, 0.0, 0.0, 0.6157)
>   PlayerVisuals (Node2D)
>   > unique_name_in_owner = true
>     PlayerSprite (Sprite2D)
>     > unique_name_in_owner = true
>     > scale = (0.5, 0.5)
>     > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>     InteractionPrompt (Panel)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 7
>     > anchor_left = 0.5
>     > anchor_top = 1.0
>     > anchor_right = 0.5
>     > anchor_bottom = 1.0
>     > offset_left = -16.0
>     > offset_top = -66.0
>     > offset_right = 16.0
>     > offset_bottom = -34.0
>     > grow_horizontal = 2
>     > grow_vertical = 0
>     > size_flags_vertical = 0
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_top = -3.0
>       > offset_bottom = 5.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "F"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -0.5)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>   PlayerArea2D (Area2D)
>   > unique_name_in_owner = true
>   > collision_layer = 2
>   > collision_mask = 2
>   > priority = 20
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>   ItemFocusPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (0.0, -122.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.0, 2.0)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   InventoryPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (-183.0, -5.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.5, 2.5)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D/2d_limit_example_scene.tscn ---
ExampleScene2D (Node2D)
> script: res://addons/phantom_camera/examples/scripts/2D/2d_room_limit_tween.gd
> scene: res://addons/phantom_camera/examples/example_scenes/2D/2d_limit_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> TileMap (TileMap)
> > z_index = -1
> > position = (-97.0, 0.0)
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D/2d_limit_example_scene.tscn::TileSet_kf7eg
> TileMap2 (TileMap)
> > z_index = -1
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D/2d_limit_example_scene.tscn::TileSet_kf7eg
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> CharacterBody2D (CharacterBody2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
> > unique_name_in_owner = true
> > position = (66.0, -28.0)
>   DarkOverlay (ColorRect)
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -1000.0
>   > offset_top = -1000.0
>   > offset_right = 1000.0
>   > offset_bottom = 1000.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > color = (0.0, 0.0, 0.0, 0.6157)
>   PlayerVisuals (Node2D)
>   > unique_name_in_owner = true
>     PlayerSprite (Sprite2D)
>     > unique_name_in_owner = true
>     > scale = (0.5, 0.5)
>     > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>     InteractionPrompt (Panel)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 7
>     > anchor_left = 0.5
>     > anchor_top = 1.0
>     > anchor_right = 0.5
>     > anchor_bottom = 1.0
>     > offset_left = -16.0
>     > offset_top = -66.0
>     > offset_right = 16.0
>     > offset_bottom = -34.0
>     > grow_horizontal = 2
>     > grow_vertical = 0
>     > size_flags_vertical = 0
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_top = -3.0
>       > offset_bottom = 5.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "F"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -0.5)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>   PlayerArea2D (Area2D)
>   > unique_name_in_owner = true
>   > collision_layer = 2
>   > collision_mask = 2
>   > priority = 20
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>   ItemFocusPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (0.0, -122.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.0, 2.0)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   InventoryPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (-183.0, -5.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.5, 2.5)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
> RoomLeftPhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > unique_name_in_owner = true
> > top_level = true
> > position = (66.0, -91.205)
> > priority_override = false
> > priority = 5
> > follow_mode = 2
> > follow_target = PlayerVisuals:<Node2D#6437635980568>
> > follow_targets = []
> > zoom = (2.0, 2.0)
> > snap_to_pixel = false
> > frame_preview = true
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D/2d_limit_example_scene.tscn::Resource_ct1eh
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, -63.205)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = ../TileMap
> > limit_margin = (-50, 0, -50, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> RoomLeftArea2D (Area2D)
> > unique_name_in_owner = true
> > position = (117.0, -174.0)
>   CollisionShape2D (CollisionShape2D)
>   > position = (-79.0, 43.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/2d_limit_example_scene.tscn::RectangleShape2D_xmxri
>   > debug_color = (0.0, 0.6, 0.702, 0.0314)
> RoomCentrePhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > unique_name_in_owner = true
> > top_level = true
> > position = (1474.0, -149.0)
> > priority_override = false
> > priority = 0
> > follow_mode = 2
> > follow_targets = []
> > zoom = (1.5, 1.5)
> > snap_to_pixel = false
> > frame_preview = true
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D/2d_limit_example_scene.tscn::Resource_exr3j
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = ../RoomCentreArea2D/CollisionShape2D
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> RoomCentreArea2D (Area2D)
> > unique_name_in_owner = true
> > position = (755.0, -179.0)
>   CollisionShape2D (CollisionShape2D)
>   > position = (338.0, -28.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/2d_limit_example_scene.tscn::RectangleShape2D_wtfjw
>   > debug_color = (0.0, 0.6, 0.702, 0.0)
> RoomRightArea2D (Area2D)
> > unique_name_in_owner = true
> > position = (2065.0, -160.0)
>   CollisionShape2D (CollisionShape2D)
>   > position = (255.75, -3.25)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/2d_limit_example_scene.tscn::RectangleShape2D_daeuh
>   > debug_color = (0.0, 0.6, 0.702, 0.0)
> RoomRightPhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > unique_name_in_owner = true
> > top_level = true
> > position = (2347.0, -156.0)
> > scale = (1.0024, 1.0)
> > priority_override = false
> > priority = 0
> > follow_mode = 2
> > follow_targets = []
> > zoom = (2.0, 2.0)
> > snap_to_pixel = false
> > frame_preview = true
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D/2d_limit_example_scene.tscn::Resource_exr3j
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = 
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> Camera2D (Camera2D)
> > position = (66.0, -91.205)
> > zoom = (2.0, 2.0)
> > process_callback = 0
> > limit_left = -387
> > limit_top = -528
> > limit_right = 433
> > limit_bottom = 288
> > position_smoothing_speed = 10.0
> > editor_draw_limits = true
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D/2d_tweening_example_scene.tscn ---
ExampleScene2D (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D/2d_tweening_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> TileMap (TileMap)
> > z_index = -1
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D/2d_tweening_example_scene.tscn::TileSet_kf7eg
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Camera2D (Camera2D)
> > position = (227.0, -28.0)
> > process_callback = 0
> > position_smoothing_speed = 10.0
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Player (Node)
>   PlayerPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > top_level = true
>   > position = (227.0, -28.0)
>   > priority_override = false
>   > priority = 5
>   > follow_mode = 2
>   > follow_target = PlayerVisuals:<Node2D#6442568475758>
>   > follow_targets = []
>   > zoom = (1.0, 1.0)
>   > snap_to_pixel = false
>   > frame_preview = true
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_2d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   Label (Label)
>   > offset_left = 167.0
>   > offset_top = -132.0
>   > offset_right = 332.0
>   > offset_bottom = -68.0
>   > text = "[WASD] to move\n[Space] to jump"
>   CharacterBody2D (CharacterBody2D)
>     script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
>   > position = (227.0, -28.0)
>     DarkOverlay (ColorRect)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 8
>     > anchor_left = 0.5
>     > anchor_top = 0.5
>     > anchor_right = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = -1000.0
>     > offset_top = -1000.0
>     > offset_right = 1000.0
>     > offset_bottom = 1000.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > color = (0.0, 0.0, 0.0, 0.6157)
>     PlayerVisuals (Node2D)
>     > unique_name_in_owner = true
>       PlayerSprite (Sprite2D)
>       > unique_name_in_owner = true
>       > scale = (0.5, 0.5)
>       > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>       InteractionPrompt (Panel)
>       > unique_name_in_owner = true
>       > visible = false
>       > anchors_preset = 7
>       > anchor_left = 0.5
>       > anchor_top = 1.0
>       > anchor_right = 0.5
>       > anchor_bottom = 1.0
>       > offset_left = -16.0
>       > offset_top = -66.0
>       > offset_right = 16.0
>       > offset_bottom = -34.0
>       > grow_horizontal = 2
>       > grow_vertical = 0
>       > size_flags_vertical = 0
>         Label (Label)
>         > layout_mode = 1
>         > anchors_preset = 15
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>         > offset_top = -3.0
>         > offset_bottom = 5.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > text = "F"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>     PlayerArea2D (Area2D)
>     > unique_name_in_owner = true
>     > collision_layer = 2
>     > collision_mask = 2
>     > priority = 20
>       CollisionShape2D (CollisionShape2D)
>       > position = (0.0, -0.5)
>       > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>     ItemFocusPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (0.0, -122.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.0, 2.0)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     InventoryPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (-183.0, -5.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.5, 2.5)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
> WideArea (Area2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/2d_trigger_area.gd
> > position = (393.0, -40.0)
> > collision_layer = 2
> > collision_mask = 2
> > area_pcam = PhantomCamera2D:<Node2D#6442887248984>
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -40.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/2d_tweening_example_scene.tscn::RectangleShape2D_tgk1y
>   ColorRect (ColorRect)
>   > offset_left = -70.0
>   > offset_top = -120.0
>   > offset_right = 70.0
>   > offset_bottom = 40.0
>   > size_flags_horizontal = 0
>   > size_flags_vertical = 0
>   > color = (0.5569, 0.4471, 0.5451, 0.698)
>   Label (Label)
>   > offset_left = -77.0
>   > offset_top = -250.0
>   > offset_right = 76.0
>   > offset_bottom = -120.0
>   > text = "Transition Type:\nSine\n\nDuration:\n0.6s"
>   > horizontal_alignment = 1
>   PhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > position = (4.0, -100.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (0.8, 0.8)
>   > snap_to_pixel = false
>   > frame_preview = true
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D/2d_tweening_example_scene.tscn::Resource_mtp70
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
> UpperZoomArea (Area2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/2d_trigger_area.gd
> > position = (649.0, -135.0)
> > collision_layer = 2
> > collision_mask = 2
> > area_pcam = PhantomCamera2D:<Node2D#6443038244110>
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -40.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/2d_tweening_example_scene.tscn::RectangleShape2D_clm0y
>   CollisionShape2D2 (CollisionShape2D)
>   > position = (0.0, -40.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/2d_tweening_example_scene.tscn::RectangleShape2D_clm0y
>   ColorRect (ColorRect)
>   > offset_left = -52.0
>   > offset_top = -120.0
>   > offset_right = 52.0
>   > offset_bottom = 40.0
>   > size_flags_horizontal = 0
>   > size_flags_vertical = 0
>   > color = (0.5569, 0.4471, 0.5451, 0.698)
>   Label (Label)
>   > offset_left = -74.0
>   > offset_top = -251.0
>   > offset_right = 79.0
>   > offset_bottom = -121.0
>   > text = "Transition Type:\nCirc\n\nDuration:\n0.3s"
>   > horizontal_alignment = 1
>   PhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > position = (2.0, -83.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.0, 2.0)
>   > snap_to_pixel = false
>   > frame_preview = true
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D/2d_tweening_example_scene.tscn::Resource_8jg5c
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
> ForwardArea (Area2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/2d_trigger_area.gd
> > position = (1136.0, -38.0)
> > collision_layer = 2
> > collision_mask = 2
> > area_pcam = PhantomCamera2D:<Node2D#6443172461664>
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -42.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/2d_tweening_example_scene.tscn::RectangleShape2D_uka0w
>   ColorRect (ColorRect)
>   > offset_left = -280.0
>   > offset_top = -122.0
>   > offset_right = 280.0
>   > offset_bottom = 38.0
>   > size_flags_horizontal = 0
>   > size_flags_vertical = 0
>   > color = (0.5569, 0.4471, 0.5451, 0.698)
>   Label (Label)
>   > offset_left = -76.0
>   > offset_top = -252.0
>   > offset_right = 77.0
>   > offset_bottom = -122.0
>   > text = "Transition Type:\nBack\n\nDuration:\n1.2s"
>   > horizontal_alignment = 1
>   PhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > position = (344.0, -46.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (0.9, 0.9)
>   > snap_to_pixel = false
>   > frame_preview = true
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D/2d_tweening_example_scene.tscn::Resource_e4e41
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn ---
CharacterBody2D (CharacterBody2D)
> script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d.gd
> scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
> DarkOverlay (ColorRect)
> > unique_name_in_owner = true
> > visible = false
> > anchors_preset = 8
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -1000.0
> > offset_top = -1000.0
> > offset_right = 1000.0
> > offset_bottom = 1000.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > color = (0.0, 0.0, 0.0, 0.6157)
> PlayerVisuals (Node2D)
> > unique_name_in_owner = true
>   PlayerSprite (Sprite2D)
>   > unique_name_in_owner = true
>   > scale = (0.5, 0.5)
>   > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>   InteractionPrompt (Panel)
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 7
>   > anchor_left = 0.5
>   > anchor_top = 1.0
>   > anchor_right = 0.5
>   > anchor_bottom = 1.0
>   > offset_left = -16.0
>   > offset_top = -66.0
>   > offset_right = 16.0
>   > offset_bottom = -34.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>   > size_flags_vertical = 0
>     Label (Label)
>     > layout_mode = 1
>     > anchors_preset = 15
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > offset_top = -3.0
>     > offset_bottom = 5.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > text = "F"
>     > horizontal_alignment = 1
>     > vertical_alignment = 1
> CollisionShape2D (CollisionShape2D)
> > position = (0.0, -0.5)
> > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
> PlayerArea2D (Area2D)
> > unique_name_in_owner = true
> > collision_layer = 2
> > collision_mask = 2
> > priority = 20
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -0.5)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
> ItemFocusPhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > unique_name_in_owner = true
> > position = (0.0, -122.0)
> > priority_override = false
> > priority = 0
> > follow_mode = 0
> > follow_targets = []
> > zoom = (2.0, 2.0)
> > snap_to_pixel = false
> > frame_preview = false
> > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.0, 0.0)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = 
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> InventoryPhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > unique_name_in_owner = true
> > position = (-183.0, -5.0)
> > priority_override = false
> > priority = 0
> > follow_mode = 0
> > follow_targets = []
> > zoom = (2.5, 2.5)
> > snap_to_pixel = false
> > frame_preview = false
> > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.0, 0.0)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = 
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_example_scene.tscn ---
Root (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> Pillar (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_example_scene.tscn::TileSet_nawqc
> > collision_enabled = false
> > navigation_enabled = false
> Terrain (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_example_scene.tscn::TileSet_nawqc
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Controls (Label)
> > offset_left = 167.0
> > offset_top = -145.0
> > offset_right = 332.0
> > offset_bottom = -81.0
> > text = "[WASD] to move\n[Space] to jump"
> Camera2D (Camera2D)
> > physics_interpolation_mode = 1
> > position = (227.0, -28.0)
> > zoom = (1.5, 1.5)
> > process_callback = 0
> > editor_draw_limits = true
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Player (Node)
>   PlayerPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > process_priority = -1
>   > top_level = true
>   > position = (227.0, -28.0)
>   > priority_override = false
>   > priority = 10
>   > follow_mode = 2
>   > follow_target = CharacterBody2D:<CharacterBody2D#6449229037148>
>   > follow_targets = []
>   > zoom = (1.5, 1.5)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_2d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   CharacterBody2D (CharacterBody2D)
>     script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d_4.3.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
>   > position = (227.0, -28.0)
>     DarkOverlay (ColorRect)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 8
>     > anchor_left = 0.5
>     > anchor_top = 0.5
>     > anchor_right = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = -1000.0
>     > offset_top = -1000.0
>     > offset_right = 1000.0
>     > offset_bottom = 1000.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > color = (0.0, 0.0, 0.0, 0.6157)
>     PlayerVisuals (Node2D)
>     > unique_name_in_owner = true
>       PlayerSprite (Sprite2D)
>       > unique_name_in_owner = true
>       > scale = (0.5, 0.5)
>       > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>       InteractionPrompt (Panel)
>       > unique_name_in_owner = true
>       > visible = false
>       > anchors_preset = 7
>       > anchor_left = 0.5
>       > anchor_top = 1.0
>       > anchor_right = 0.5
>       > anchor_bottom = 1.0
>       > offset_left = -16.0
>       > offset_top = -66.0
>       > offset_right = 16.0
>       > offset_bottom = -34.0
>       > grow_horizontal = 2
>       > grow_vertical = 0
>       > size_flags_vertical = 0
>         Label (Label)
>         > layout_mode = 1
>         > anchors_preset = 15
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>         > offset_top = -3.0
>         > offset_bottom = 5.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > text = "F"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>     PlayerArea2D (Area2D)
>     > unique_name_in_owner = true
>     > collision_layer = 2
>     > collision_mask = 2
>     > priority = 20
>       CollisionShape2D (CollisionShape2D)
>       > position = (0.0, -0.5)
>       > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>     ItemFocusPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (0.0, -122.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.0, 2.0)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     InventoryPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (-183.0, -5.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.5, 2.5)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_framed_example_scene.tscn ---
Root (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_framed_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -345.0
>   > offset_top = -143.0
>   > offset_right = 947.0
>   > offset_bottom = 578.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> Pillar (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_framed_example_scene.tscn::TileSet_kxirl
> > collision_enabled = false
> > navigation_enabled = false
> Terrain (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_framed_example_scene.tscn::TileSet_kxirl
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Camera2D (Camera2D)
> > physics_interpolation_mode = 1
> > position = (215.0, -73.0)
> > zoom = (2.0, 2.0)
> > process_callback = 0
> > editor_draw_limits = true
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Player (Node)
>   PlayerPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > top_level = true
>   > position = (215.0, -73.0)
>   > priority_override = false
>   > priority = 5
>   > follow_mode = 5
>   > follow_target = CharacterBody2D:<CharacterBody2D#6453507225174>
>   > follow_targets = []
>   > zoom = (2.0, 2.0)
>   > snap_to_pixel = false
>   > frame_preview = true
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_2d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, -45.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.25
>   > dead_zone_height = 0.8
>   > show_viewfinder_in_play = true
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   Label (Label)
>   > offset_left = 167.0
>   > offset_top = -145.0
>   > offset_right = 332.0
>   > offset_bottom = -81.0
>   > text = "[WASD] to move\n[Space] to jump"
>   CharacterBody2D (CharacterBody2D)
>     script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d_4.3.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
>   > position = (215.0, -28.0)
>     DarkOverlay (ColorRect)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 8
>     > anchor_left = 0.5
>     > anchor_top = 0.5
>     > anchor_right = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = -1000.0
>     > offset_top = -1000.0
>     > offset_right = 1000.0
>     > offset_bottom = 1000.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > color = (0.0, 0.0, 0.0, 0.6157)
>     PlayerVisuals (Node2D)
>     > unique_name_in_owner = true
>       PlayerSprite (Sprite2D)
>       > unique_name_in_owner = true
>       > scale = (0.5, 0.5)
>       > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>       InteractionPrompt (Panel)
>       > unique_name_in_owner = true
>       > visible = false
>       > anchors_preset = 7
>       > anchor_left = 0.5
>       > anchor_top = 1.0
>       > anchor_right = 0.5
>       > anchor_bottom = 1.0
>       > offset_left = -16.0
>       > offset_top = -66.0
>       > offset_right = 16.0
>       > offset_bottom = -34.0
>       > grow_horizontal = 2
>       > grow_vertical = 0
>       > size_flags_vertical = 0
>         Label (Label)
>         > layout_mode = 1
>         > anchors_preset = 15
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>         > offset_top = -3.0
>         > offset_bottom = 5.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > text = "F"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>     PlayerArea2D (Area2D)
>     > unique_name_in_owner = true
>     > collision_layer = 2
>     > collision_mask = 2
>     > priority = 20
>       CollisionShape2D (CollisionShape2D)
>       > position = (0.0, -0.5)
>       > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>     ItemFocusPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (0.0, -122.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.0, 2.0)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     InventoryPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (-183.0, -5.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.5, 2.5)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_group_example_scene.tscn ---
Root (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_group_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> Pillar (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_group_example_scene.tscn::TileSet_14yng
> > collision_enabled = false
> > navigation_enabled = false
> Terrain (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_group_example_scene.tscn::TileSet_14yng
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Camera2D (Camera2D)
> > physics_interpolation_mode = 1
> > position = (186.0, -172.5)
> > zoom = (1.5, 1.5)
> > process_callback = 0
> > position_smoothing_speed = 8.0
> > editor_draw_limits = true
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Label (Label)
> > offset_left = 167.0
> > offset_top = -133.0
> > offset_right = 332.0
> > offset_bottom = -69.0
> > text = "[WASD] to move\n[Space] to jump"
> PhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > top_level = true
> > position = (186.0, -172.5)
> > priority_override = false
> > priority = 10
> > follow_mode = 3
> > follow_targets = ["CharacterBody2D:<CharacterBody2D#6458020298344>","GroupNPCSprite:<Sprite2D#6458003520637>"]
> > zoom = (1.5, 1.5)
> > snap_to_pixel = false
> > frame_preview = true
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_group_example_scene.tscn::Resource_spy00
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = true
> > auto_zoom_min = 0.5
> > auto_zoom_max = 1.5
> > auto_zoom_margin = (200.0, 0.0, 200.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = 
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> GroupNPCSprite (Sprite2D)
> > unique_name_in_owner = true
> > position = (107.0, -316.0)
> > texture = res://addons/phantom_camera/examples/textures/2D/phantom_camera_2d_sprite.png
> CharacterBody2D (CharacterBody2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d_4.3.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
> > position = (265.0, -29.0)
>   DarkOverlay (ColorRect)
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -1000.0
>   > offset_top = -1000.0
>   > offset_right = 1000.0
>   > offset_bottom = 1000.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > color = (0.0, 0.0, 0.0, 0.6157)
>   PlayerVisuals (Node2D)
>   > unique_name_in_owner = true
>     PlayerSprite (Sprite2D)
>     > unique_name_in_owner = true
>     > scale = (0.5, 0.5)
>     > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>     InteractionPrompt (Panel)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 7
>     > anchor_left = 0.5
>     > anchor_top = 1.0
>     > anchor_right = 0.5
>     > anchor_bottom = 1.0
>     > offset_left = -16.0
>     > offset_top = -66.0
>     > offset_right = 16.0
>     > offset_bottom = -34.0
>     > grow_horizontal = 2
>     > grow_vertical = 0
>     > size_flags_vertical = 0
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_top = -3.0
>       > offset_bottom = 5.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "F"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -0.5)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>   PlayerArea2D (Area2D)
>   > unique_name_in_owner = true
>   > collision_layer = 2
>   > collision_mask = 2
>   > priority = 20
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>   ItemFocusPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (0.0, -122.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.0, 2.0)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   InventoryPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (-183.0, -5.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.5, 2.5)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_path_example_scene.tscn ---
Root (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_path_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> Pillar (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_path_example_scene.tscn::TileSet_eyojy
> > collision_enabled = false
> > navigation_enabled = false
> Terrain (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_path_example_scene.tscn::TileSet_eyojy
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Camera2D (Camera2D)
> > physics_interpolation_mode = 1
> > position = (374.0, -190.0)
> > zoom = (1.5, 1.5)
> > process_callback = 0
> > editor_draw_limits = true
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Label (Label)
> > offset_left = 167.0
> > offset_top = -133.0
> > offset_right = 332.0
> > offset_bottom = -69.0
> > text = "[WASD] to move\n[Space] to jump"
> Player (Node)
>   Label (Label)
>   > visible = false
>   > offset_left = 167.0
>   > offset_top = -145.0
>   > offset_right = 332.0
>   > offset_bottom = -81.0
>   > text = "[WASD] to move\n[Space] to jump"
> PlayerPhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > unique_name_in_owner = true
> > top_level = true
> > position = (374.0, -190.0)
> > priority_override = false
> > priority = 10
> > follow_mode = 4
> > follow_target = CharacterBody2D:<CharacterBody2D#6462483037239>
> > follow_targets = []
> > follow_path = Path2D:<Path2D#6462466258532>
> > zoom = (1.5, 1.5)
> > snap_to_pixel = false
> > frame_preview = true
> > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_2d_tween.tres
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = 
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> Path2D (Path2D)
> > position = (152.0, -190.0)
> > curve = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_follow_path_example_scene.tscn::Curve2D_usrhf
> CharacterBody2D (CharacterBody2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d_4.3.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
> > position = (225.0, -28.0)
>   DarkOverlay (ColorRect)
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -1000.0
>   > offset_top = -1000.0
>   > offset_right = 1000.0
>   > offset_bottom = 1000.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > color = (0.0, 0.0, 0.0, 0.6157)
>   PlayerVisuals (Node2D)
>   > unique_name_in_owner = true
>     PlayerSprite (Sprite2D)
>     > unique_name_in_owner = true
>     > scale = (0.5, 0.5)
>     > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>     InteractionPrompt (Panel)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 7
>     > anchor_left = 0.5
>     > anchor_top = 1.0
>     > anchor_right = 0.5
>     > anchor_bottom = 1.0
>     > offset_left = -16.0
>     > offset_top = -66.0
>     > offset_right = 16.0
>     > offset_bottom = -34.0
>     > grow_horizontal = 2
>     > grow_vertical = 0
>     > size_flags_vertical = 0
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_top = -3.0
>       > offset_bottom = 5.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "F"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -0.5)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>   PlayerArea2D (Area2D)
>   > unique_name_in_owner = true
>   > collision_layer = 2
>   > collision_mask = 2
>   > priority = 20
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>   ItemFocusPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (0.0, -122.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.0, 2.0)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   InventoryPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (-183.0, -5.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.5, 2.5)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_limit_example_scene.tscn ---
ExampleScene2D (Node2D)
> script: res://addons/phantom_camera/examples/scripts/2D/2d_room_limit_tween_4.3.gd
> scene: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_limit_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> StartingTerrain (TileMapLayer)
> > z_index = 1
> > use_parent_material = true
> > position = (-97.0, 0.0)
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_limit_example_scene.tscn::TileSet_kf7eg
> OtherTerrain (TileMapLayer)
> > z_index = 1
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_limit_example_scene.tscn::TileSet_kf7eg
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> CharacterBody2D (CharacterBody2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d_4.3.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
> > unique_name_in_owner = true
> > z_index = 1
> > position = (66.0, -28.0)
>   DarkOverlay (ColorRect)
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -1000.0
>   > offset_top = -1000.0
>   > offset_right = 1000.0
>   > offset_bottom = 1000.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > color = (0.0, 0.0, 0.0, 0.6157)
>   PlayerVisuals (Node2D)
>   > unique_name_in_owner = true
>     PlayerSprite (Sprite2D)
>     > unique_name_in_owner = true
>     > scale = (0.5, 0.5)
>     > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>     InteractionPrompt (Panel)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 7
>     > anchor_left = 0.5
>     > anchor_top = 1.0
>     > anchor_right = 0.5
>     > anchor_bottom = 1.0
>     > offset_left = -16.0
>     > offset_top = -66.0
>     > offset_right = 16.0
>     > offset_bottom = -34.0
>     > grow_horizontal = 2
>     > grow_vertical = 0
>     > size_flags_vertical = 0
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_top = -3.0
>       > offset_bottom = 5.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "F"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -0.5)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>   PlayerArea2D (Area2D)
>   > unique_name_in_owner = true
>   > collision_layer = 2
>   > collision_mask = 2
>   > priority = 20
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>   ItemFocusPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (0.0, -122.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.0, 2.0)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   InventoryPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > position = (-183.0, -5.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.5, 2.5)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.0, 0.0)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
> RoomLeftPhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > unique_name_in_owner = true
> > top_level = true
> > position = (141.0, -91.205)
> > priority_override = false
> > priority = 5
> > follow_mode = 2
> > follow_target = CharacterBody2D:<CharacterBody2D#6466778005123>
> > follow_targets = []
> > zoom = (2.0, 2.0)
> > snap_to_pixel = false
> > frame_preview = true
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_limit_example_scene.tscn::Resource_ct1eh
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, -63.205)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = ../StartingTerrain
> > limit_margin = (-50, 0, -50, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> RoomLeftArea2D (Area2D)
> > unique_name_in_owner = true
> > position = (117.0, -174.0)
>   CollisionShape2D (CollisionShape2D)
>   > position = (-79.0, 43.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_limit_example_scene.tscn::RectangleShape2D_xmxri
>   > debug_color = (0.0, 0.6, 0.702, 0.0314)
> RoomCentrePhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > unique_name_in_owner = true
> > top_level = true
> > position = (1218.0, -217.0)
> > priority_override = false
> > priority = 0
> > follow_mode = 2
> > follow_targets = []
> > zoom = (1.5, 1.5)
> > snap_to_pixel = false
> > frame_preview = true
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_limit_example_scene.tscn::Resource_exr3j
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = ../RoomCentreArea2D/CollisionShape2D
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> RoomCentreArea2D (Area2D)
> > unique_name_in_owner = true
> > position = (755.0, -179.0)
>   CollisionShape2D (CollisionShape2D)
>   > position = (338.0, -28.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_limit_example_scene.tscn::RectangleShape2D_wtfjw
>   > debug_color = (0.0, 0.6, 0.702, 0.0)
> RoomRightArea2D (Area2D)
> > unique_name_in_owner = true
> > position = (2065.0, -160.0)
>   CollisionShape2D (CollisionShape2D)
>   > position = (255.75, -3.25)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_limit_example_scene.tscn::RectangleShape2D_daeuh
>   > debug_color = (0.0, 0.6, 0.702, 0.0)
> RoomRightPhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > unique_name_in_owner = true
> > top_level = true
> > position = (2347.0, -156.0)
> > scale = (1.0024, 1.0)
> > priority_override = false
> > priority = 0
> > follow_mode = 2
> > follow_targets = []
> > zoom = (2.0, 2.0)
> > snap_to_pixel = false
> > frame_preview = true
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_limit_example_scene.tscn::Resource_exr3j
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = 
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> Camera2D (Camera2D)
> > physics_interpolation_mode = 1
> > position = (141.0, -91.205)
> > zoom = (2.0, 2.0)
> > process_callback = 0
> > limit_left = -147
> > limit_top = -528
> > limit_right = 673
> > limit_bottom = 288
> > position_smoothing_speed = 10.0
> > editor_draw_limits = true
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_noise_example_scene.tscn ---
Root (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_noise_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> Pillar (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_noise_example_scene.tscn::TileSet_kf7eg
> > collision_enabled = false
> > navigation_enabled = false
> Terrain (TileMapLayer)
> > z_index = 1
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_noise_example_scene.tscn::TileSet_kf7eg
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Controls (Label)
> > offset_left = 167.0
> > offset_top = -145.0
> > offset_right = 332.0
> > offset_bottom = -81.0
> > text = "[WASD] to move\n[Space] to jump\n[Q] to trigger Noise Emitter"
> Camera2D (Camera2D)
> > physics_interpolation_mode = 1
> > position = (227.0, -28.0)
> > offset = (2.3068, -7.8485)
> > ignore_rotation = false
> > zoom = (1.5, 1.5)
> > process_callback = 0
> > editor_draw_limits = true
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Player (Node)
>   PlayerPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > process_priority = -1
>   > top_level = true
>   > position = (227.0, -28.0)
>   > priority_override = false
>   > priority = 10
>   > follow_mode = 2
>   > follow_target = CharacterBody2D:<CharacterBody2D#6471676950102>
>   > follow_targets = []
>   > zoom = (1.5, 1.5)
>   > snap_to_pixel = false
>   > frame_preview = false
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_2d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > noise = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_noise_example_scene.tscn::Resource_87ddr
>   > _preview_noise = true
>   > noise_emitter_layer = 1
>   PlayerPhantomCameraNoiseEmitter2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_noise_emitter_2d.gd
>   > unique_name_in_owner = true
>   > noise = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_noise_example_scene.tscn::Resource_rmnw1
>   > preview = false
>   > continuous = false
>   > growth_time = 0.0
>   > duration = 0.1
>   > decay_time = 0.1
>   > noise_emitter_layer = 1
>   CharacterBody2D (CharacterBody2D)
>     script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d_4.3.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
>   > z_index = 2
>   > position = (227.0, -28.0)
>     DarkOverlay (ColorRect)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 8
>     > anchor_left = 0.5
>     > anchor_top = 0.5
>     > anchor_right = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = -1000.0
>     > offset_top = -1000.0
>     > offset_right = 1000.0
>     > offset_bottom = 1000.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > color = (0.0, 0.0, 0.0, 0.6157)
>     PlayerVisuals (Node2D)
>     > unique_name_in_owner = true
>       PlayerSprite (Sprite2D)
>       > unique_name_in_owner = true
>       > scale = (0.5, 0.5)
>       > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>       InteractionPrompt (Panel)
>       > unique_name_in_owner = true
>       > visible = false
>       > anchors_preset = 7
>       > anchor_left = 0.5
>       > anchor_top = 1.0
>       > anchor_right = 0.5
>       > anchor_bottom = 1.0
>       > offset_left = -16.0
>       > offset_top = -66.0
>       > offset_right = 16.0
>       > offset_bottom = -34.0
>       > grow_horizontal = 2
>       > grow_vertical = 0
>       > size_flags_vertical = 0
>         Label (Label)
>         > layout_mode = 1
>         > anchors_preset = 15
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>         > offset_top = -3.0
>         > offset_bottom = 5.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > text = "F"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>     PlayerArea2D (Area2D)
>     > unique_name_in_owner = true
>     > collision_layer = 2
>     > collision_mask = 2
>     > priority = 20
>       CollisionShape2D (CollisionShape2D)
>       > position = (0.0, -0.5)
>       > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>     ItemFocusPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (0.0, -122.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.0, 2.0)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     InventoryPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (-183.0, -5.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.5, 2.5)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn ---
Root (Node2D)
> scene: res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn
> Background (CanvasLayer)
> > layer = -3
>   ColorRect (ColorRect)
>   > auto_translate_mode = 2
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = -311.0
>   > offset_top = -173.0
>   > offset_right = 981.0
>   > offset_bottom = 548.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > localize_numeral_system = false
>   > color = (0.1373, 0.149, 0.1961, 1.0)
> Pillar (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn::TileSet_na7gm
> > collision_enabled = false
> > navigation_enabled = false
> Terrain (TileMapLayer)
> > use_parent_material = true
> > scale = (3.0, 3.0)
> > tile_set = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn::TileSet_na7gm
> UI (CanvasLayer)
>   UIInventory (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 4
>     > anchor_top = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = 28.0
>     > offset_top = -255.0
>     > offset_right = 908.0
>     > offset_bottom = 183.0
>     > grow_vertical = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>       Label (Label)
>       > layout_mode = 0
>       > offset_left = 345.0
>       > offset_top = 12.0
>       > offset_right = 535.0
>       > offset_bottom = 60.0
>       > text = "Inventory"
>       > horizontal_alignment = 1
>       > uppercase = true
>   UISign (Control)
>     scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
>   > unique_name_in_owner = true
>   > visible = false
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_horizontal = 3
>   > size_flags_vertical = 3
>     TextureRect (TextureRect)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -273.567993164063
>     > offset_top = 47.0
>     > offset_right = 273.567993164063
>     > offset_bottom = 413.0
>     > grow_horizontal = 2
>     > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>       Label (Label)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_left = 25.0
>       > offset_top = 64.0
>       > offset_right = -25.0
>       > offset_bottom = -88.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > text = "Stay Awhile\nand read"
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > uppercase = true
>     Panel (Panel)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -240.0
>     > offset_right = 240.0
>     > offset_bottom = 200.0
>     > grow_horizontal = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 3
>       VBoxContainer (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > alignment = 1
>         Label2 (Label)
>         > layout_mode = 2
>         > text = "Example Textsdadassa\n"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
> Camera2D (Camera2D)
> > physics_interpolation_mode = 1
> > position = (227.0, -28.0)
> > process_callback = 0
> > position_smoothing_speed = 10.0
> > editor_draw_limits = true
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Player (Node)
>   PlayerPhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > unique_name_in_owner = true
>   > top_level = true
>   > position = (227.0, -28.0)
>   > priority_override = false
>   > priority = 5
>   > follow_mode = 2
>   > follow_target = CharacterBody2D:<CharacterBody2D#6476106135076>
>   > follow_targets = []
>   > zoom = (1.0, 1.0)
>   > snap_to_pixel = false
>   > frame_preview = true
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_2d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   Label (Label)
>   > offset_left = 167.0
>   > offset_top = -132.0
>   > offset_right = 332.0
>   > offset_bottom = -68.0
>   > text = "[WASD] to move\n[Space] to jump"
>   CharacterBody2D (CharacterBody2D)
>     script: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d_4.3.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn
>   > position = (227.0, -28.0)
>     DarkOverlay (ColorRect)
>     > unique_name_in_owner = true
>     > visible = false
>     > anchors_preset = 8
>     > anchor_left = 0.5
>     > anchor_top = 0.5
>     > anchor_right = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = -1000.0
>     > offset_top = -1000.0
>     > offset_right = 1000.0
>     > offset_bottom = 1000.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > color = (0.0, 0.0, 0.0, 0.6157)
>     PlayerVisuals (Node2D)
>     > unique_name_in_owner = true
>       PlayerSprite (Sprite2D)
>       > unique_name_in_owner = true
>       > scale = (0.5, 0.5)
>       > texture = res://addons/phantom_camera/examples/textures/2D/player_sprite.svg
>       InteractionPrompt (Panel)
>       > unique_name_in_owner = true
>       > visible = false
>       > anchors_preset = 7
>       > anchor_left = 0.5
>       > anchor_top = 1.0
>       > anchor_right = 0.5
>       > anchor_bottom = 1.0
>       > offset_left = -16.0
>       > offset_top = -66.0
>       > offset_right = 16.0
>       > offset_bottom = -34.0
>       > grow_horizontal = 2
>       > grow_vertical = 0
>       > size_flags_vertical = 0
>         Label (Label)
>         > layout_mode = 1
>         > anchors_preset = 15
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>         > offset_top = -3.0
>         > offset_bottom = 5.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > text = "F"
>         > horizontal_alignment = 1
>         > vertical_alignment = 1
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, -0.5)
>     > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_xj4ar
>     PlayerArea2D (Area2D)
>     > unique_name_in_owner = true
>     > collision_layer = 2
>     > collision_mask = 2
>     > priority = 20
>       CollisionShape2D (CollisionShape2D)
>       > position = (0.0, -0.5)
>       > shape = res://addons/phantom_camera/examples/example_scenes/2D/sub_scenes/playable_character_2d.tscn::RectangleShape2D_18i13
>     ItemFocusPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (0.0, -122.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.0, 2.0)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/item_focus_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     InventoryPhantomCamera2D (Node2D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>     > unique_name_in_owner = true
>     > position = (-183.0, -5.0)
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > zoom = (2.5, 2.5)
>     > snap_to_pixel = false
>     > frame_preview = false
>     > tween_resource = res://addons/phantom_camera/examples/resources/tween/inventory_phantom_camera_2d_tween.tres
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > follow_offset = (0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.0, 0.0)
>     > follow_axis_lock = 0
>     > rotate_with_target = false
>     > rotation_offset = 0.0
>     > rotation_damping = false
>     > rotation_damping_value = 0.1
>     > auto_zoom = false
>     > auto_zoom_min = 1.0
>     > auto_zoom_max = 5.0
>     > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > draw_limits = true
>     > limit_left = -10000000
>     > limit_top = -10000000
>     > limit_right = 10000000
>     > limit_bottom = 10000000
>     > limit_target = 
>     > limit_margin = (0, 0, 0, 0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
> WideArea (Area2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/2d_trigger_area.gd
> > position = (393.0, -40.0)
> > collision_layer = 2
> > collision_mask = 2
> > area_pcam = PhantomCamera2D:<Node2D#6476475235349>
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -40.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn::RectangleShape2D_tgk1y
>   ColorRect (ColorRect)
>   > offset_left = -70.0
>   > offset_top = -120.0
>   > offset_right = 70.0
>   > offset_bottom = 40.0
>   > size_flags_horizontal = 0
>   > size_flags_vertical = 0
>   > color = (0.5569, 0.4471, 0.5451, 0.698)
>   Label (Label)
>   > offset_left = -77.0
>   > offset_top = -250.0
>   > offset_right = 76.0
>   > offset_bottom = -120.0
>   > text = "Transition Type:\nSine\n\nDuration:\n0.6s"
>   > horizontal_alignment = 1
>   PhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > position = (4.0, -100.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (0.8, 0.8)
>   > snap_to_pixel = false
>   > frame_preview = true
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn::Resource_mtp70
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
> UpperZoomArea (Area2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/2d_trigger_area.gd
> > position = (649.0, -135.0)
> > collision_layer = 2
> > collision_mask = 2
> > area_pcam = PhantomCamera2D:<Node2D#6476626230437>
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -40.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn::RectangleShape2D_clm0y
>   CollisionShape2D2 (CollisionShape2D)
>   > position = (0.0, -40.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn::RectangleShape2D_clm0y
>   ColorRect (ColorRect)
>   > offset_left = -52.0
>   > offset_top = -120.0
>   > offset_right = 52.0
>   > offset_bottom = 40.0
>   > size_flags_horizontal = 0
>   > size_flags_vertical = 0
>   > color = (0.5569, 0.4471, 0.5451, 0.698)
>   Label (Label)
>   > offset_left = -74.0
>   > offset_top = -251.0
>   > offset_right = 79.0
>   > offset_bottom = -121.0
>   > text = "Transition Type:\nCirc\n\nDuration:\n0.3s"
>   > horizontal_alignment = 1
>   PhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > position = (2.0, -83.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (2.0, 2.0)
>   > snap_to_pixel = false
>   > frame_preview = true
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn::Resource_8jg5c
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
> ForwardArea (Area2D)
>   script: res://addons/phantom_camera/examples/scripts/2D/2d_trigger_area.gd
> > position = (1136.0, -38.0)
> > collision_layer = 2
> > collision_mask = 2
> > area_pcam = PhantomCamera2D:<Node2D#6476760448147>
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, -42.0)
>   > shape = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn::RectangleShape2D_uka0w
>   ColorRect (ColorRect)
>   > offset_left = -280.0
>   > offset_top = -122.0
>   > offset_right = 280.0
>   > offset_bottom = 38.0
>   > size_flags_horizontal = 0
>   > size_flags_vertical = 0
>   > color = (0.5569, 0.4471, 0.5451, 0.698)
>   Label (Label)
>   > offset_left = -76.0
>   > offset_top = -252.0
>   > offset_right = 77.0
>   > offset_bottom = -122.0
>   > text = "Transition Type:\nBack\n\nDuration:\n1.2s"
>   > horizontal_alignment = 1
>   PhantomCamera2D (Node2D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
>   > position = (344.0, -46.0)
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > zoom = (0.9, 0.9)
>   > snap_to_pixel = false
>   > frame_preview = true
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/2D-4.3/2d_tweening_example_scene.tscn::Resource_e4e41
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > follow_offset = (0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1)
>   > follow_axis_lock = 0
>   > rotate_with_target = false
>   > rotation_offset = 0.0
>   > rotation_damping = false
>   > rotation_damping_value = 0.1
>   > auto_zoom = false
>   > auto_zoom_min = 1.0
>   > auto_zoom_max = 5.0
>   > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > draw_limits = true
>   > limit_left = -10000000
>   > limit_top = -10000000
>   > limit_right = 10000000
>   > limit_bottom = 10000000
>   > limit_target = 
>   > limit_margin = (0, 0, 0, 0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.948876, -0.315649), Z: (0.0, 0.315649, 0.948876), O: (-2.53871, 2.0, 9.76232)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> PlayerGroup (Node)
>   PlayerCharacterBody3D (CharacterBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/player_controller.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.53871, 0.5, 7.26232)]
>   > SPEED = 5.0
>   > JUMP_VELOCITY = 4.5
>   > enable_gravity = true
>     PlayerArea3D (Area3D)
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerCollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerVisual (Node3D)
>     > unique_name_in_owner = true
>       PlayerModel (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>       > skeleton = ../..
>   MovementInstructionsLabel (Label3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.866025, -0.5), Z: (0.0, 0.5, 0.866025), O: (-2.47682, -0.070802, 7.93048)]
>   > modulate = (0.2941, 1.0, 0.6314, 1.0)
>   > text = "[WASD] to move"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   > font_size = 48
>   PlayerPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.999858, 0.0, 0.0), Y: (0.0, 0.94884, -0.315637), Z: (0.0, 0.315632, 0.948825), O: (-2.53871, 2.0, 9.76232)]
>   > top_level = true
>   > priority_override = false
>   > priority = 10
>   > follow_mode = 2
>   > follow_target = PlayerVisual:<Node3D#6479612568653>
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::Resource_jtk1d
>   > follow_offset = (0.0, 1.5, 2.5)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
> NPCGroup (Node)
>   NPCPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.616596, -0.0, -0.78728), Y: (-0.109786, 0.990229, -0.085984), Z: (0.779587, 0.13945, 0.610571), O: (-2.98802, 1.50739, 1.19719)]
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::Resource_o161n
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   NPCDescriptionLabel (Label3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.866026, -0.5), Z: (0.0, 0.5, 0.866025), O: (-3.04693, 0.367287, 0.953757)]
>   > text = "Input Example"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   NPCDialogueExampleLabel (Label3D)
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.939693, -0.34202), Z: (0.0, 0.34202, 0.939693), O: (-4.46738, 1.58641, -0.253679)]
>   > modulate = (1.0, 0.6039, 0.2549, 1.0)
>   > text = "Press [ F ] to change camera"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   NPCInteractionZoneMesh (MeshInstance3D)
>   > transform = [X: (0.819152, -0.0, 0.573576), Y: (0.0, 1.0, 0.0), Z: (-0.573576, -0.0, 0.819152), O: (-3.46138, -0.4, 0.875321)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_7tjw4
>   > skeleton = ../..
>     NPCInteractionArea3D (Area3D)
>     > unique_name_in_owner = true
>     > transform = [X: (1.0, 0.0, 0.0), Y: (-0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>     > monitorable = false
>       NPCInterationCollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxShape3D_65o6h
>   NPC (StaticBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/npc.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, -0.0, 1.0), O: (-4.56338, 0.5, -0.272679)]
>     PlayerCollisionShape3D2 (CollisionShape3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (-0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::CapsuleShape3D_tpc7d
>     NPCMesh (MeshInstance3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (-0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::CapsuleMesh_g0eml
>     > skeleton = ../../..
>   MoveToLocation (Node3D)
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-4.70084, 0.5, 0.962891)]
> FixedCameraTriggerZone (Node)
>   FixedCameraLabel (Label3D)
>   > unique_name_in_owner = true
>   > transform = [X: (0.939693, 0.0, 0.34202), Y: (0.280167, 0.573577, -0.769751), Z: (-0.196175, 0.819152, 0.538986), O: (-0.538716, -0.247626, 3.13456)]
>   > text = "Fixed Camera\nExample"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   NorthRoomPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > transform = [X: (0.38357, -0.105898, -0.917417), Y: (-0.555836, 0.766851, -0.320912), Z: (0.737507, 0.633027, 0.235279), O: (6.89638, 4.73986, 0.115512)]
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::Resource_tpvee
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::Resource_bxbnv
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   NorthRoomTrigger (Area3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (3.0, -0.45, -0.9)]
>   > priority = 5
>   > area_pcam = NorthRoomPhantomCamera3D:<Node3D#6479931342142>
>     CollisionShape3D (CollisionShape3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.6, 0.0, -0.4)]
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxShape3D_wcrbb
>   EntryRoomPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > transform = [X: (0.258818, 0.0, -0.965924), Y: (-0.482963, 0.866025, -0.129409), Z: (0.836515, 0.499999, 0.224143), O: (6.69741, 4.73364, 4.02374)]
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::Resource_7ih0k
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::Resource_4iyps
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   EntryRoomTrigger (Area3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (3.00003, -0.454982, 3.00572)]
>   > priority = 5
>   > area_pcam = EntryRoomPhantomCamera3D:<Node3D#6479998449181>
>     CollisionShape3D (CollisionShape3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.3, 0.0, 0.2)]
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxShape3D_ctyr8
>   SouthRoomPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > transform = [X: (-0.766043, 0.0, -0.642786), Y: (-0.492403, 0.642787, 0.586825), Z: (0.413175, 0.766043, -0.492403), O: (6.89741, 4.73364, 5.62374)]
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::Resource_x5y0u
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::Resource_pgiyx
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   SouthRoomTrigger (Area3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (3.0, -0.45, 6.7)]
>   > priority = 5
>   > area_pcam = SouthRoomPhantomCamera3D:<Node3D#6480065559651>
>     CollisionShape3D (CollisionShape3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.6, 0.0, 0.1)]
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxShape3D_ua072
>   CSGMesh3D (CSGMesh3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (7.14238, 1.82571, 2.88655)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_ugc3s
>   > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::StandardMaterial3D_68thd
>     CSGMesh3D2 (CSGMesh3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.001926, -0.012034, 0.004944)]
>     > operation = 2
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_wphly
>     > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::StandardMaterial3D_68thd
> Environment (Node)
>   DirectionalLight3D (DirectionalLight3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
>   Environment (Node3D)
>     Floor (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     West Wall (StaticBody3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-16.0, 0.5, 0.0)]
>       MeshInstance3D2 (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_gyp5s
>       > skeleton = 
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxShape3D_lfaqs
>     East Wall (StaticBody3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (16.999, 0.502, 0.0)]
>       MeshInstance3D2 (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_gyp5s
>       > skeleton = 
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxShape3D_lfaqs
>     North Wall (StaticBody3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.5, -6.90828)]
>       MeshInstance3D2 (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_n70lt
>       > skeleton = 
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxShape3D_jxmqm
>     South Wall (StaticBody3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.25, 0.5, 9.087)]
>       MeshInstance3D3 (MeshInstance3D)
>       > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (4.0, 0.0, 0.0)]
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_x0tgm
>       > skeleton = 
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxShape3D_t67ef
>     FixedCamOuterWall (CSGMesh3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 2.5, 2.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_rmslh
>       FixedCamOuterDoorway (CSGMesh3D)
>       > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, -1.5, 1.0)]
>       > operation = 2
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_242ij
>     FixedCamNorthWall (CSGMesh3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (4.0, 2.5, 1.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_niuda
>       FixedCamNorthDoorway (CSGMesh3D)
>       > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, -1.5, 0.0)]
>       > operation = 2
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_242ij
>     FixedCamSouthWall (CSGMesh3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (4.0, 2.5, 5.1)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_niuda
>       FixedCamSouthDoorway (CSGMesh3D)
>       > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, -1.50541, 0.0)]
>       > operation = 2
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_example_scene.tscn::BoxMesh_242ij

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_framed_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_framed_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.793353, -0.608762), Z: (0.0, 0.608762, 0.793353), O: (0.083587, 2.94168, 5.22787)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> Player (Node)
>   PlayerPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.99995, 0.0, 0.0), Y: (0.0, 0.79324, -0.608675), Z: (0.0, 0.608671, 0.793235), O: (0.0, 2.43468, 3.17294)]
>   > top_level = true
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 5
>   > follow_target = PlayerVisual:<Node3D#6482179489034>
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_framed_example_scene.tscn::Resource_wg1pr
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 4.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.161
>   > dead_zone_height = 0.386
>   > show_viewfinder_in_play = true
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 4.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   PlayerCharacterBody3D2 (CharacterBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/player_controller.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
>   > SPEED = 5.0
>   > JUMP_VELOCITY = 4.5
>   > enable_gravity = true
>     PlayerArea3D (Area3D)
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerCollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerVisual (Node3D)
>     > unique_name_in_owner = true
>       PlayerModel (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>       > skeleton = ../..
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   CSGCylinder3D (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.636134, 0.805455, -6.37532)]
>   > use_collision = true
>   > radius = 1.71970999240875
>   > height = 2.61090993881226
>   > sides = 32
>   CSGCylinder3D5 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-7.54597, -0.540694, -3.39517)]
>   > use_collision = true
>   > radius = 1.53269004821777
>   > height = 2.50359988212585
>   > sides = 32
>   CSGCylinder3D6 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.64877, -1.50101, 1.22863)]
>   > use_collision = true
>   > radius = 1.57419002056122
>   > height = 3.47475004196167
>   > sides = 32
>   CSGCylinder3D2 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (10.4732, 0.805455, -8.78984)]
>   > use_collision = true
>   > radius = 0.95628499984741
>   > height = 2.61090993881226
>   > sides = 32
>   CSGSphere3D (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.40027, -1.69814, 3.36997)]
>   > use_collision = true
>   > radius = 3.34732007980347
>   > rings = 32
>   CSGSphere3D2 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (5.13768, -0.599204, -1.04651)]
>   > use_collision = true
>   > radius = 2.65844011306763
>   > rings = 32
>   CSGSphere3D3 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-11.7976, -0.599204, -2.42244)]
>   > use_collision = true
>   > radius = 2.1460599899292
>   > rings = 32
>   CSGTorus3D2 (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (7.84078, -0.497663, 4.44352)]
>   > use_collision = true
>   > inner_radius = 0.97154301404953
>   > outer_radius = 2.15226006507874
>   > sides = 32
>   > ring_sides = 18
>   CSGBox3D (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.52545, 6.53866, -12.6331)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_framed_example_scene.tscn::StandardMaterial3D_auy8m
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-6.88916, 0.760708, -6.1376)]
>   > use_collision = true
>   > size = (2.64182, 2.52142, 2.30997)
>   CSGBox3D5 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-3.83837, -0.241718, 7.14677)]
>   > use_collision = true
>   > size = (3.80964, 1.67049, 0.932048)
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (7.34377, 0.138478, -4.36159)]
>   > use_collision = true
>   > size = (1.53893, 1.27695, 1.80814)
>   CSGBox3D6 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (10.9834, 0.138478, -1.89037)]
>   > use_collision = true
>   > size = (4.03502, 1.27695, 5.2198)
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (8.38147, 0.044043, 8.36617)]
>   > use_collision = true
>   > size = (4.57784, 1.08809, 3.11285)

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_glued_example_scene.tscn ---
Node3D (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_glued_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.638767, -0.7694), Z: (0.0, 0.7694, 0.638768), O: (0.0, 6.39, 7.0)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> Player (Node)
>   PlayerPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.999954, 0.0, 0.0), Y: (0.0, 0.638683, -0.769298), Z: (0.0, 0.769345, 0.638723), O: (0.0, 6.39, 7.0)]
>   > top_level = true
>   > priority_override = false
>   > priority = 5
>   > follow_mode = 1
>   > follow_target = PlayerVisual:<Node3D#6483555221109>
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_glued_example_scene.tscn::Resource_ucp3e
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_glued_example_scene.tscn::Resource_ab013
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.3, 0.3, 0.3)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   PlayerCharacterBody3D (CharacterBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/player_controller.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 6.39, 7.0)]
>   > SPEED = 5.0
>   > JUMP_VELOCITY = 4.5
>   > enable_gravity = false
>     PlayerArea3D (Area3D)
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerCollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerVisual (Node3D)
>     > unique_name_in_owner = true
>     > visible = false
>       PlayerModel (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>       > skeleton = ../..
> NPCs (Node)
>   PlayerMeshInstance3D (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.04486, 0.519002, -1.52506)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_glued_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
>   PlayerMeshInstance3D2 (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (2.51494, 0.519, 4.06618)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_glued_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   CSGCylinder3D (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-1.62737, 0.805455, -6.37532)]
>   > use_collision = true
>   > radius = 1.71970999240875
>   > height = 2.61090993881226
>   > sides = 32
>   CSGCylinder3D5 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (24.9378, 0.31181, -5.46661)]
>   > use_collision = true
>   > radius = 2.77590990066528
>   > height = 1.62362003326416
>   > sides = 32
>   CSGCylinder3D6 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.58617, 0.31181, 6.6322)]
>   > use_collision = true
>   > radius = 1.57419002056122
>   > height = 3.47475004196167
>   > sides = 32
>   CSGCylinder3D3 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (14.774, 0.201103, 2.71259)]
>   > use_collision = true
>   > radius = 1.41311001777649
>   > height = 1.40220999717712
>   > sides = 32
>   CSGCylinder3D4 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (7.40488, 0.201101, 11.6804)]
>   > use_collision = true
>   > radius = 2.21673011779785
>   > height = 7.88260984420776
>   > sides = 32
>   CSGCylinder3D2 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (8.20971, 0.805455, -8.78984)]
>   > use_collision = true
>   > radius = 0.95628499984741
>   > height = 2.61090993881226
>   > sides = 32
>   CSGSphere3D (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (14.9771, -1.69814, -6.51262)]
>   > use_collision = true
>   > radius = 3.34732007980347
>   > rings = 32
>   CSGSphere3D2 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.555532, -0.599204, 8.81048)]
>   > use_collision = true
>   > radius = 2.65844011306763
>   > rings = 32
>   CSGSphere3D3 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-14.0611, -0.599204, -2.42244)]
>   > use_collision = true
>   > radius = 2.1460599899292
>   > rings = 32
>   CSGTorus3D (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-5.21187, -0.000002, 0.346393)]
>   > use_collision = true
>   > inner_radius = 1.29999995231628
>   > outer_radius = 2.0
>   > sides = 32
>   > ring_sides = 18
>   CSGTorus3D2 (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (21.9283, -0.000002, 7.89765)]
>   > use_collision = true
>   > inner_radius = 0.97154301404953
>   > outer_radius = 2.15226006507874
>   > sides = 32
>   > ring_sides = 18
>   CSGBox3D (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (9.49828, 6.53866, -12.6331)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_glued_example_scene.tscn::StandardMaterial3D_auy8m
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.15267, 0.760708, -6.1376)]
>   > use_collision = true
>   > size = (2.64182, 2.52142, 2.30997)
>   CSGBox3D5 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (14.3427, 0.335247, 8.22829)]
>   > use_collision = true
>   > size = (3.80964, 1.67049, 0.932048)
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (5.08027, 0.138478, -4.36159)]
>   > use_collision = true
>   > size = (1.53893, 1.27695, 1.80814)
>   CSGBox3D6 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-14.7748, 0.138478, 5.20734)]
>   > use_collision = true
>   > size = (4.03502, 1.27695, 5.2198)
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (30.1473, 1.78638, -1.60318)]
>   > use_collision = true
>   > size = (4.57784, 4.57276, 3.11285)

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_group_example_scene.tscn ---
Node3D (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_group_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.906308, -0.422618), Z: (0.0, 0.422618, 0.906308), O: (-7.26116, 5.72974, 12.279)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> Player (Node)
>   PlayerCharacterBody3D2 (CharacterBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/player_controller.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
>   > SPEED = 5.0
>   > JUMP_VELOCITY = 4.5
>   > enable_gravity = true
>     PlayerArea3D (Area3D)
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerCollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerVisual (Node3D)
>     > unique_name_in_owner = true
>       PlayerModel (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>       > skeleton = ../..
>   PlayerPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.999954, 0.0, 0.0), Y: (0.0, 0.906188, -0.422562), Z: (0.0, 0.422588, 0.906243), O: (-7.30295, 5.45858, 11.2744)]
>   > top_level = true
>   > priority_override = false
>   > priority = 5
>   > follow_mode = 3
>   > follow_targets = ["PlayerCharacterBody3D2:<CharacterBody3D#6485132279089>","PlayerMeshInstance3D:<MeshInstance3D#6485283274370>","PlayerMeshInstance3D2:<MeshInstance3D#6485300051400>"]
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_group_example_scene.tscn::Resource_1iman
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 5.0
>   > auto_follow_distance = true
>   > auto_follow_distance_min = 5.0
>   > auto_follow_distance_max = 15.0
>   > auto_follow_distance_divisor = 20.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 5.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
> NPCs (Node)
>   PlayerMeshInstance3D (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-14.6059, 0.519002, 0.128472)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_group_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
>   PlayerMeshInstance3D2 (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-10.0461, 0.519, 0.249913)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_group_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.52545, 6.53866, -12.6331)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_group_example_scene.tscn::StandardMaterial3D_auy8m
>   CSGCylinder3D (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-13.6511, 0.805455, -6.37532)]
>   > use_collision = true
>   > radius = 1.71970999240875
>   > height = 2.61090993881226
>   > sides = 32
>   CSGCylinder3D5 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (12.9141, 0.31181, -5.46661)]
>   > use_collision = true
>   > radius = 2.77590990066528
>   > height = 1.62362003326416
>   > sides = 32
>   CSGCylinder3D6 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-21.6099, 0.31181, 6.6322)]
>   > use_collision = true
>   > radius = 1.57419002056122
>   > height = 3.47475004196167
>   > sides = 32
>   CSGCylinder3D2 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-3.81402, 0.805455, -8.78984)]
>   > use_collision = true
>   > radius = 0.95628499984741
>   > height = 2.61090993881226
>   > sides = 32
>   CSGSphere3D (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (2.95333, -1.69814, -6.51262)]
>   > use_collision = true
>   > radius = 3.34732007980347
>   > rings = 32
>   CSGSphere3D2 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-11.4682, -0.599204, 8.81048)]
>   > use_collision = true
>   > radius = 2.65844011306763
>   > rings = 32
>   CSGSphere3D3 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-26.0848, -0.599204, -2.42244)]
>   > use_collision = true
>   > radius = 2.1460599899292
>   > rings = 32
>   CSGTorus3D2 (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (9.90455, -0.000002, 7.89765)]
>   > use_collision = true
>   > inner_radius = 0.97154301404953
>   > outer_radius = 2.15226006507874
>   > sides = 32
>   > ring_sides = 18
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-21.1764, 0.760708, -6.1376)]
>   > use_collision = true
>   > size = (2.64182, 2.52142, 2.30997)
>   CSGBox3D5 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (2.31901, 0.335247, 8.22829)]
>   > use_collision = true
>   > size = (3.80964, 1.67049, 0.932048)
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-6.94346, 0.138478, -4.36159)]
>   > use_collision = true
>   > size = (1.53893, 1.27695, 1.80814)
>   CSGBox3D6 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-26.7985, 0.138478, 5.20734)]
>   > use_collision = true
>   > size = (4.03502, 1.27695, 5.2198)
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (18.1236, 1.78638, -1.60318)]
>   > use_collision = true
>   > size = (4.57784, 4.57276, 3.11285)

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > transform = [X: (0.999996, 0.0, -0.002843), Y: (-0.002163, 0.648938, -0.760838), Z: (0.001845, 0.760841, 0.648936), O: (0.0, 2.507, 1.5)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> PlayerPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999807, 0.0, -0.002842), Y: (-0.002162, 0.648836, -0.760718), Z: (0.001844, 0.760728, 0.648839), O: (0.0, 2.507, 1.5)]
> > top_level = true
> > priority_override = false
> > priority = 10
> > follow_mode = 2
> > follow_target = PlayerVisual:<Node3D#6486860332303>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::Resource_ofv2c
> > follow_offset = (0.0, 2.0, 1.5)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerCharacterBody3D2 (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.507, 0.0)]
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerVisual (Node3D)
>   > unique_name_in_owner = true
>     PlayerModel (MeshInstance3D)
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>     > skeleton = ../..
> Paths (Node)
>   PathPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > transform = [X: (-0.0, 0.0, -1.0), Y: (-1.0, -0.0, 0.0), Z: (-0.0, 1.0, 0.0), O: (-0.31028, 7.9199, -1.60976)]
>   > top_level = true
>   > priority_override = false
>   > priority = 2
>   > follow_mode = 4
>   > follow_target = PlayerVisual:<Node3D#6486860332303>
>   > follow_targets = []
>   > follow_path = FollowPath:<Path3D#6486944218369>
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::Resource_01tho
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::Resource_syh5m
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   FollowPath (Path3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.31028, 7.9199, -1.60976)]
>   > curve = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::Curve3D_b33df
>   StraightPathFollowTrigger (Area3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/path_follow.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.04204, -0.45, -6.73666)]
>   > priority = 5
>   > path_pcam = PathPhantomCamera3D:<Node3D#6486910664325>
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::BoxShape3D_aovgi
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::BoxMesh_0hdeh
>       > skeleton = ../../../..
>   PathPhantomCamera3D2 (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (0.0, 7.9199, -13.4572)]
>   > top_level = true
>   > visible = false
>   > priority_override = false
>   > priority = 2
>   > follow_mode = 4
>   > follow_target = PlayerVisual:<Node3D#6486860332303>
>   > follow_targets = []
>   > follow_path = FollowPath2:<Path3D#6487044881975>
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::Resource_01tho
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::Resource_xci4c
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.6, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   FollowPath2 (Path3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-4.97141, 7.9199, -13.4572)]
>   > curve = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::Curve3D_8uw2x
>   StraightPathFollowTrigger2 (Area3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/path_follow.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.04204, 0.0, -13.7367)]
>   > priority = 5
>   > path_pcam = PathPhantomCamera3D2:<Node3D#6487011327441>
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::BoxShape3D_ctnqu
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, -0.45, 0.0)]
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::BoxMesh_f6dp8
>       > skeleton = ../../../..
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Floor3 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (6.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.44204, 0.0, 1.76334)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor2 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.166667, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 14.0), O: (-0.516667, 1.0, -6.5)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor5 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.166667, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 14.0), O: (0.65, 1.0, -6.5)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor4 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (2.0, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.066667, 1.0, -18.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor6 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.333333, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.766667, 1.0, -13.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::BoxMesh_7l3dh
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor8 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.166667, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 6.0), O: (-1.01667, 1.0, -15.5)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::BoxMesh_as6ok
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor9 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.166667, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 6.0), O: (1.15, 1.0, -15.5)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::BoxMesh_as6ok
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor7 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.333333, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.9, 1.0, -13.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_path_example_scene.tscn::BoxMesh_7l3dh
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   NPCDescriptionLabel (Label3D)
>   > transform = [X: (0.0, -0.0, -0.999999), Y: (-1.0, 0.0, -0.0), Z: (-0.000001, 0.999999, -0.0), O: (-3.47306, 2.59595, -5.51755)]
>   > text = "Camera follows player while confined to a Path3D"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   > font_size = 64
>   MovementInstructionsLabel (Label3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (-0.02174, -0.455369, 0.570585)]
>   > modulate = (0.2941, 1.0, 0.6314, 1.0)
>   > text = "[WASD] to move"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   > font_size = 48

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_simple_example_scene.tscn ---
Node3D2 (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_simple_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.906308, -0.422618), Z: (0.0, 0.422618, 0.906308), O: (-13.2122, 2.5, 10.4016)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> Player (Node)
>   PlayerPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.999954, 0.0, 0.0), Y: (0.0, 0.906188, -0.422562), Z: (0.0, 0.422588, 0.906243), O: (-13.2122, 2.5, 10.4016)]
>   > top_level = true
>   > priority_override = false
>   > priority = 10
>   > follow_mode = 2
>   > follow_target = PlayerVisual:<Node3D#6488504493133>
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_simple_example_scene.tscn::Resource_28vpp
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_simple_example_scene.tscn::Resource_axopo
>   > follow_offset = (0.0, 2.0, 2.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   PlayerCharacterBody3D (CharacterBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/player_controller.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-13.2122, 0.5, 8.40162)]
>   > SPEED = 5.0
>   > JUMP_VELOCITY = 4.5
>   > enable_gravity = true
>     PlayerArea3D (Area3D)
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerCollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerVisual (Node3D)
>     > unique_name_in_owner = true
>       PlayerModel (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>       > skeleton = ../..
> NPCs (Node)
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   CSGCylinder3D (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-13.6511, 0.805455, -6.37532)]
>   > use_collision = true
>   > radius = 1.71970999240875
>   > height = 2.61090993881226
>   > sides = 32
>   CSGCylinder3D5 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-21.8332, -0.540694, -3.39517)]
>   > use_collision = true
>   > radius = 1.53269004821777
>   > height = 2.50359988212585
>   > sides = 32
>   CSGCylinder3D6 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-16.936, -1.50101, 1.22863)]
>   > use_collision = true
>   > radius = 1.57419002056122
>   > height = 3.47475004196167
>   > sides = 32
>   CSGCylinder3D2 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-3.81402, 0.805455, -8.78984)]
>   > use_collision = true
>   > radius = 0.95628499984741
>   > height = 2.61090993881226
>   > sides = 32
>   CSGSphere3D (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-23.6875, -1.69814, 3.36997)]
>   > use_collision = true
>   > radius = 3.34732007980347
>   > rings = 32
>   CSGSphere3D2 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.14955, -0.599204, -1.04651)]
>   > use_collision = true
>   > radius = 2.65844011306763
>   > rings = 32
>   CSGSphere3D3 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-26.0848, -0.599204, -2.42244)]
>   > use_collision = true
>   > radius = 2.1460599899292
>   > rings = 32
>   CSGTorus3D2 (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-6.44645, -0.497663, 4.44352)]
>   > use_collision = true
>   > inner_radius = 0.97154301404953
>   > outer_radius = 2.15226006507874
>   > sides = 32
>   > ring_sides = 18
>   CSGBox3D (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.52545, 6.53866, -12.6331)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_simple_example_scene.tscn::StandardMaterial3D_auy8m
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-21.1764, 0.760708, -6.1376)]
>   > use_collision = true
>   > size = (2.64182, 2.52142, 2.30997)
>   CSGBox3D5 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-18.1256, 0.335247, 7.14677)]
>   > use_collision = true
>   > size = (3.80964, 1.67049, 0.932048)
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-6.94346, 0.138478, -4.36159)]
>   > use_collision = true
>   > size = (1.53893, 1.27695, 1.80814)
>   CSGBox3D6 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-3.30382, 0.138478, -1.89037)]
>   > use_collision = true
>   > size = (4.03502, 1.27695, 5.2198)
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.04727, 0.044043, 8.36617)]
>   > use_collision = true
>   > size = (4.57784, 1.08809, 3.11285)

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn
> PlayerPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.019409, 0.506884, 9.13821)]
> > priority_override = false
> > priority = 10
> > follow_mode = 6
> > follow_target = PlayerVisual:<Node3D#6490366770624>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::Resource_8fhct
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::Resource_7m0fv
> > attributes = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::CameraAttributesPractical_i42vj
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 3.5
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 3.5
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerAimPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.019409, 1.47688, 6.73921)]
> > priority_override = false
> > priority = 0
> > follow_mode = 6
> > follow_target = PlayerVisual:<Node3D#6490366770624>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::Resource_e7t18
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::Resource_jogxh
> > attributes = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::CameraAttributesPractical_fvhx5
> > follow_offset = (0.0, 0.97, -0.399)
> > follow_damping = false
> > follow_damping_value = (0.0, 0.0, 0.0)
> > follow_axis_lock = 0
> > follow_distance = 1.5
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.5
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerCharacterBody3D (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller_third_person.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn
> > unique_name_in_owner = true
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.019409, 0.506884, 5.63821)]
> > collision_layer = 2
> > mouse_sensitivity = 0.05
> > min_pitch = -89.9
> > max_pitch = 50.0
> > min_yaw = 0.0
> > max_yaw = 360.0
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
>   PlayerVisual (Node3D)
>   > unique_name_in_owner = true
>     PlayerMeshInstance3D (MeshInstance3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleMesh_47f0o
>     > skeleton = ../..
>     PlayerDirection (MeshInstance3D)
>     > unique_name_in_owner = true
>     > transform = [X: (1.0, -0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.015623, 1.08631, 0.0)]
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::PrismMesh_wg1x3
>     > skeleton = ../..
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.019409, 0.506884, 9.13821)]
> > attributes = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::CameraAttributesPractical_pst8q
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.5, 4.5, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall2 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (9.5, 4.5, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall3 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (0.0, 4.5, 10.5)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall4 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (0.0, 4.5, -9.5)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   DirectionalLight3D (DirectionalLight3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> CeilingPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (-0.0, 0.0, -1.0), Y: (-1.0, 0.0, 0.0), Z: (0.0, 1.0, -0.0), O: (-0.200665, 13.366, -0.162648)]
> > priority_override = false
> > priority = 0
> > follow_mode = 0
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::Resource_afrr1
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::Resource_unpfd
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> MovementInstructionsLabel (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (0.05056, -0.484909, 1.44357)]
> > visible = false
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[WASD] to move"
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48
> MovementInstructionsLabel3 (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (0.05056, -0.484909, 0.817134)]
> > visible = false
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[Right Mouse Click] to \"aim\""
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48
> MovementInstructionsLabel2 (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (-0.044015, -0.490478, -6.30248)]
> > visible = false
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[Space] to toggle PCam"
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48
> MeshInstance3D (MeshInstance3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, 1.0), Z: (0.0, -1.0, -0.0), O: (0.260217, 1.60477, -9.07797)]
> > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::CylinderMesh_sm466
> MeshInstance3D3 (MeshInstance3D)
> > transform = [X: (-1.0, 0.0, 0.0), Y: (-0.0, -0.0, -1.0), Z: (0.0, -1.0, 0.0), O: (0.052586, 1.60477, 9.98156)]
> > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_attribtues_example_scene.tscn::CylinderMesh_sm466

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn
> PlayerCharacterBody3D (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller_third_person.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn
> > unique_name_in_owner = true
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.506884, 0.0)]
> > collision_layer = 2
> > mouse_sensitivity = 0.05
> > min_pitch = -89.9
> > max_pitch = 50.0
> > min_yaw = 0.0
> > max_yaw = 360.0
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
>   PlayerVisual (Node3D)
>   > unique_name_in_owner = true
>     PlayerMeshInstance3D (MeshInstance3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleMesh_47f0o
>     > skeleton = ../..
>     PlayerDirection (MeshInstance3D)
>     > unique_name_in_owner = true
>     > transform = [X: (1.0, -0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.015623, 1.08631, 0.0)]
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::PrismMesh_wg1x3
>     > skeleton = ../..
> PlayerPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.012092, 0.865941, -0.5), Z: (0.006981, 0.499951, 0.866025), O: (0.024434, 2.25671, 3.03109)]
> > priority_override = false
> > priority = 10
> > follow_mode = 6
> > follow_target = PlayerVisual:<Node3D#6491708947713>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::Resource_8fhct
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::Resource_7m0fv
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 3.5
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.523599
> > horizontal_rotation_offset = 0.0
> > spring_length = 3.5
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerAimPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 1.30688, 1.101)]
> > priority_override = false
> > priority = 0
> > follow_mode = 6
> > follow_target = PlayerVisual:<Node3D#6491708947713>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::Resource_e7t18
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::Resource_jogxh
> > follow_offset = (0.0, 0.8, -0.399)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.5
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.5
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.012092, 0.865941, -0.5), Z: (0.006981, 0.499951, 0.866025), O: (0.024434, 2.25671, 3.03109)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.5, 4.5, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall5 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-6.133, 3.0, -6.5)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::BoxMesh_bj3re
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall6 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (2.5, 3.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::BoxMesh_bj3re
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall7 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.5, 3.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::BoxMesh_bj3re
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall2 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (9.5, 4.5, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall3 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (0.0, 4.5, 10.5)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall4 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (0.0, 4.5, -9.5)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   DirectionalLight3D (DirectionalLight3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> CeilingPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (-0.0, 0.0, -1.0), Y: (-1.0, 0.0, 0.0), Z: (0.0, 1.0, -0.0), O: (-0.200665, 13.366, -0.162648)]
> > priority_override = false
> > priority = 0
> > follow_mode = 0
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::Resource_afrr1
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_follow_third_person_example_scene.tscn::Resource_ioijp
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> MovementInstructionsLabel (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (0.05056, -0.484909, 1.44357)]
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[WASD] to move"
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48
> MovementInstructionsLabel3 (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (0.05056, -0.484909, 0.817134)]
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[Right Mouse Click] to \"aim\""
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48
> MovementInstructionsLabel2 (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (-0.044015, -0.490478, -6.30248)]
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[Space] to toggle PCam"
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_look_at_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_look_at_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > transform = [X: (0.998682, 0.0, 0.051327), Y: (0.032472, 0.774433, -0.631822), Z: (-0.039749, 0.632656, 0.773412), O: (-0.137901, 4.03222, 6.36446)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> PhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > transform = [X: (0.999694, -0.000167, 0.024757), Y: (0.013649, 0.838005, -0.545492), Z: (-0.020655, 0.545663, 0.837751), O: (-0.137901, 4.03222, 6.36446)]
> > priority_override = false
> > priority = 10
> > follow_mode = 0
> > follow_targets = []
> > look_at_mode = 2
> > look_at_target = PlayerVisual:<Node3D#6493403446728>
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_look_at_example_scene.tscn::Resource_pwcgo
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_look_at_example_scene.tscn::Resource_ft2w3
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = true
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerCharacterBody3D2 (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerVisual (Node3D)
>   > unique_name_in_owner = true
>     PlayerModel (MeshInstance3D)
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>     > skeleton = ../..
> NPCs (Node)
>   PlayerMeshInstance3D (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-1.96028, 0.519002, -1.52506)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_look_at_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
>   PlayerMeshInstance3D2 (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (2.59952, 0.519, 4.06618)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_look_at_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   CSGCylinder3D (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-1.00548, 0.805455, -6.37532)]
>   > use_collision = true
>   > radius = 1.71970999240875
>   > height = 2.61090993881226
>   > sides = 32
>   CSGCylinder3D5 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (25.5597, 0.31181, -5.46661)]
>   > use_collision = true
>   > radius = 2.77590990066528
>   > height = 1.62362003326416
>   > sides = 32
>   CSGCylinder3D6 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-8.96428, 0.31181, 6.6322)]
>   > use_collision = true
>   > radius = 1.57419002056122
>   > height = 3.47475004196167
>   > sides = 32
>   CSGCylinder3D3 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (15.3959, 0.201103, 2.71259)]
>   > use_collision = true
>   > radius = 1.41311001777649
>   > height = 1.40220999717712
>   > sides = 32
>   CSGCylinder3D4 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (8.02677, 0.201101, 11.6804)]
>   > use_collision = true
>   > radius = 2.21673011779785
>   > height = 7.88260984420776
>   > sides = 32
>   CSGCylinder3D2 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (8.8316, 0.805455, -8.78984)]
>   > use_collision = true
>   > radius = 0.95628499984741
>   > height = 2.61090993881226
>   > sides = 32
>   CSGSphere3D (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (15.5989, -1.69814, -6.51262)]
>   > use_collision = true
>   > radius = 3.34732007980347
>   > rings = 32
>   CSGSphere3D2 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (1.17742, -0.599204, 8.81048)]
>   > use_collision = true
>   > radius = 2.65844011306763
>   > rings = 32
>   CSGSphere3D3 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-13.4392, -0.599204, -2.42244)]
>   > use_collision = true
>   > radius = 2.1460599899292
>   > rings = 32
>   CSGTorus3D (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-4.58998, -0.000002, 0.346393)]
>   > use_collision = true
>   > inner_radius = 1.29999995231628
>   > outer_radius = 2.0
>   > sides = 32
>   > ring_sides = 18
>   CSGTorus3D2 (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (22.5502, -0.000002, 7.89765)]
>   > use_collision = true
>   > inner_radius = 0.97154301404953
>   > outer_radius = 2.15226006507874
>   > sides = 32
>   > ring_sides = 18
>   CSGBox3D (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (10.1202, 6.53866, -12.6331)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_look_at_example_scene.tscn::StandardMaterial3D_auy8m
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-8.53078, 0.760708, -6.1376)]
>   > use_collision = true
>   > size = (2.64182, 2.52142, 2.30997)
>   CSGBox3D5 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (14.9646, 0.335247, 8.22829)]
>   > use_collision = true
>   > size = (3.80964, 1.67049, 0.932048)
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (5.70216, 0.138478, -4.36159)]
>   > use_collision = true
>   > size = (1.53893, 1.27695, 1.80814)
>   CSGBox3D6 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-14.1529, 0.138478, 5.20734)]
>   > use_collision = true
>   > size = (4.03502, 1.27695, 5.2198)
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (30.7692, 1.78638, -1.60318)]
>   > use_collision = true
>   > size = (4.57784, 4.57276, 3.11285)

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > transform = [X: (0.012978, 0.0, -0.999916), Y: (0.096242, 0.995357, 0.001249), Z: (0.995273, -0.09625, 0.012918), O: (-16.46, 0.503767, 4.249)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> PlayerCharacterBody3D (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller_first_person.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999897, -0.014364, 0.0), Y: (0.014364, 0.999897, 0.0), Z: (0.0, 0.0, 1.0), O: (-16.46, 0.503767, 4.249)]
> > mouse_sensitivity = 0.05
> > min_pitch = -89.9
> > max_pitch = 50.0
> > min_yaw = 0.0
> > max_yaw = 360.0
> > run_noise = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::Resource_t3bgw
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerVisual (MeshInstance3D)
>   > unique_name_in_owner = true
>   > visible = false
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::CapsuleMesh_yvgu3
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::CapsuleShape3D_lsrh7
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::CapsuleShape3D_lsrh7
> PlayerPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.004415, 0.0, -0.999923), Y: (0.0, 0.999995, 0.0), Z: (0.999915, 0.0, 0.004415), O: (-16.46, 0.503767, 4.249)]
> > top_level = true
> > priority_override = false
> > priority = 10
> > follow_mode = 2
> > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6495014059653>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::Resource_lhgur
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::Resource_ghjuj
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > noise = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::Resource_2l4w0
> > _preview_noise = true
> > noise_emitter_layer = 1
> PlayerPhantomCameraNoiseEmitter3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_noise_emitter_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (-0.0, 0.0, -0.999933), Y: (0.0, 0.999995, 0.0), Z: (0.999925, 0.0, -0.0), O: (-16.46, 0.503767, 4.249)]
> > noise = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::Resource_6tnhy
> > preview = false
> > continuous = false
> > growth_time = 0.0
> > duration = 0.1
> > decay_time = 0.1
> > noise_emitter_layer = 1
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   CSGBox3D (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.525, 6.539, 2.5)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::StandardMaterial3D_qi01t
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (8.83707, 6.53866, -1.80739)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::StandardMaterial3D_qi01t
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (-38.9392, 6.53866, -1.80739)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::StandardMaterial3D_qi01t
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.525, 6.539, 6.0)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D/3d_noise_example_scene.tscn::StandardMaterial3D_qi01t
>   DirectionalLight3D (DirectionalLight3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> EmitterTip (Panel)
> > unique_name_in_owner = true
> > visible = false
> > anchors_preset = -1
> > anchor_right = 0.30000001192093
> > anchor_bottom = 0.10000000149012
>   Guidance (RichTextLabel)
>   > layout_mode = 1
>   > anchors_preset = -1
>   > anchor_top = 0.5
>   > anchor_right = 1.0
>   > anchor_bottom = 0.5
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_vertical = 8
>   > bbcode_enabled = true
>   > text = "[center]Press [b]Q[/b] to trigger Noise Emitter"
>   > fit_content = true

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn
> Environment (Node)
>   DirectionalLight3D (DirectionalLight3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.000005, 2.00003, 2.00013)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> ------------------ (Node)
> PlayerPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999889, 0.0, 0.0), Y: (0.0, 0.707092, -0.707092), Z: (0.0, 0.707088, 0.707088), O: (0.0, 2.0, 2.0)]
> > top_level = true
> > priority_override = false
> > priority = 3
> > follow_mode = 2
> > follow_target = PlayerVisual:<Node3D#6496909878349>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::Resource_0dtvs
> > follow_offset = (0.0, 2.0, 2.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerCharacterBody3D2 (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerVisual (Node3D)
>   > unique_name_in_owner = true
>     PlayerModel (MeshInstance3D)
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>     > skeleton = ../..
> ------------------- (Node)
> Tweening Example (Node3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, -1.97)]
>   Linear (Node3D)
>     EntryRoomTrigger (Area3D)
>       script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>     > priority = 5
>     > area_pcam = PhantomCamera3D:<Node3D#6497044102789>
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::BoxShape3D_j6fha
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::BoxMesh_xg4en
>       > skeleton = ../../../../..
>     PhantomCamera3D (Node3D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.642788, -0.766044), Z: (0.0, 0.766044, 0.642788), O: (0.0, 4.8, 3.3)]
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > look_at_mode = 0
>     > look_at_targets = []
>     > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::Resource_v8ndi
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::Resource_kmep1
>     > follow_offset = (0.0, 0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.1, 0.1, 0.1)
>     > follow_axis_lock = 0
>     > follow_distance = 1.0
>     > auto_follow_distance = false
>     > auto_follow_distance_min = 1.0
>     > auto_follow_distance_max = 5.0
>     > auto_follow_distance_divisor = 10.0
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > vertical_rotation_offset = 0.0
>     > horizontal_rotation_offset = 0.0
>     > spring_length = 1.0
>     > collision_mask = 1
>     > margin = 0.01
>     > look_at_offset = (0.0, 0.0, 0.0)
>     > look_at_damping = false
>     > look_at_damping_value = 0.25
>     > up = (0.0, 1.0, 0.0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     TweenNameLabel (Label3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.695913, -0.718126), Z: (0.0, 0.718126, 0.695913), O: (-1.8, 0.5, 0.0)]
>     > text = "Transition Type:\nLinear\n\nDuration:\n0.6s"
>     > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>     > font_size = 48
>   Sine (Node3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, -7.4)]
>     EntryRoomTrigger (Area3D)
>       script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>     > priority = 5
>     > area_pcam = PhantomCamera3D:<Node3D#6497161542753>
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::BoxShape3D_j6fha
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::BoxMesh_xg4en
>       > skeleton = ../../../../..
>     PhantomCamera3D (Node3D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.642788, -0.766044), Z: (0.0, 0.766044, 0.642788), O: (0.0, 4.8, 3.3)]
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > look_at_mode = 0
>     > look_at_targets = []
>     > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::Resource_uxg44
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::Resource_eu3bc
>     > follow_offset = (0.0, 0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.1, 0.1, 0.1)
>     > follow_axis_lock = 0
>     > follow_distance = 1.0
>     > auto_follow_distance = false
>     > auto_follow_distance_min = 1.0
>     > auto_follow_distance_max = 5.0
>     > auto_follow_distance_divisor = 10.0
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > vertical_rotation_offset = 0.0
>     > horizontal_rotation_offset = 0.0
>     > spring_length = 1.0
>     > collision_mask = 1
>     > margin = 0.01
>     > look_at_offset = (0.0, 0.0, 0.0)
>     > look_at_damping = false
>     > look_at_damping_value = 0.25
>     > up = (0.0, 1.0, 0.0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     TweenNameLabel (Label3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.695913, -0.718126), Z: (0.0, 0.718126, 0.695913), O: (1.7, 0.5, 0.0)]
>     > text = "Transition Type:\nSine\n\nDuration:\n0.3s"
>     > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>     > font_size = 72
>   Circ (Node3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, -14.1)]
>     EntryRoomTrigger (Area3D)
>       script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>     > priority = 5
>     > area_pcam = PhantomCamera3D:<Node3D#6497278981660>
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::BoxShape3D_j6fha
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::BoxMesh_xg4en
>       > skeleton = ../../../../..
>     PhantomCamera3D (Node3D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.642788, -0.766044), Z: (0.0, 0.766044, 0.642788), O: (0.0, 4.8, 3.3)]
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > look_at_mode = 0
>     > look_at_targets = []
>     > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::Resource_0nci0
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::Resource_u0lff
>     > follow_offset = (0.0, 0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.1, 0.1, 0.1)
>     > follow_axis_lock = 0
>     > follow_distance = 1.0
>     > auto_follow_distance = false
>     > auto_follow_distance_min = 1.0
>     > auto_follow_distance_max = 5.0
>     > auto_follow_distance_divisor = 10.0
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > vertical_rotation_offset = 0.0
>     > horizontal_rotation_offset = 0.0
>     > spring_length = 1.0
>     > collision_mask = 1
>     > margin = 0.01
>     > look_at_offset = (0.0, 0.0, 0.0)
>     > look_at_damping = false
>     > look_at_damping_value = 0.25
>     > up = (0.0, 1.0, 0.0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     TweenNameLabel (Label3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.695913, -0.718126), Z: (0.0, 0.718126, 0.695913), O: (-1.8, 0.5, 0.0)]
>     > text = "Transition Type:\nCirc\n\nDuration:\n0.3s"
>     > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>     > font_size = 72
>   Back (Node3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, -21.0)]
>     EntryRoomTrigger (Area3D)
>       script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>     > priority = 5
>     > area_pcam = PhantomCamera3D:<Node3D#6497396422106>
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::BoxShape3D_j6fha
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::BoxMesh_xg4en
>       > skeleton = ../../../../..
>     PhantomCamera3D (Node3D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.642788, -0.766044), Z: (0.0, 0.766044, 0.642788), O: (-0.8, 4.8, 3.3)]
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > look_at_mode = 0
>     > look_at_targets = []
>     > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::Resource_50m5g
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D/3d_tweening_example_scene.tscn::Resource_rexf8
>     > follow_offset = (0.0, 0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.1, 0.1, 0.1)
>     > follow_axis_lock = 0
>     > follow_distance = 1.0
>     > auto_follow_distance = false
>     > auto_follow_distance_min = 1.0
>     > auto_follow_distance_max = 5.0
>     > auto_follow_distance_divisor = 10.0
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > vertical_rotation_offset = 0.0
>     > horizontal_rotation_offset = 0.0
>     > spring_length = 1.0
>     > collision_mask = 1
>     > margin = 0.01
>     > look_at_offset = (0.0, 0.0, 0.0)
>     > look_at_damping = false
>     > look_at_damping_value = 0.25
>     > up = (0.0, 1.0, 0.0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     TweenNameLabel (Label3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.695913, -0.718126), Z: (0.0, 0.718126, 0.695913), O: (1.7, 0.5, 0.0)]
>     > text = "Transition Type:\nBack\n\nDuration:\n1.2s"
>     > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>     > font_size = 48

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn ---
PlayerCharacterBody3D2 (CharacterBody3D)
> script: res://addons/phantom_camera/examples/scripts/3D/player_controller.gd
> scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
> SPEED = 5.0
> JUMP_VELOCITY = 4.5
> enable_gravity = true
> PlayerArea3D (Area3D)
>   CollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
> PlayerCollisionShape3D (CollisionShape3D)
> > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
> PlayerVisual (Node3D)
> > unique_name_in_owner = true
>   PlayerModel (MeshInstance3D)
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>   > skeleton = ../..

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn ---
PlayerCharacterBody3D (CharacterBody3D)
> script: res://addons/phantom_camera/examples/scripts/3D/player_controller_third_person.gd
> scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn
> transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
> collision_layer = 2
> mouse_sensitivity = 0.05
> min_pitch = -89.9
> max_pitch = 50.0
> min_yaw = 0.0
> max_yaw = 360.0
> SPEED = 5.0
> JUMP_VELOCITY = 4.5
> enable_gravity = true
> PlayerArea3D (Area3D)
>   CollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
> PlayerCollisionShape3D (CollisionShape3D)
> > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
> PlayerVisual (Node3D)
> > unique_name_in_owner = true
>   PlayerMeshInstance3D (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleMesh_47f0o
>   > skeleton = ../..
>   PlayerDirection (MeshInstance3D)
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, -0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.015623, 1.08631, 0.0)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::PrismMesh_wg1x3
>   > skeleton = ../..

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.948876, -0.315649), Z: (0.0, 0.315649, 0.948876), O: (-2.53871, 2.0, 9.76232)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> PlayerGroup (Node)
>   PlayerCharacterBody3D (CharacterBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/player_controller_4.4.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.53871, 0.5, 7.26232)]
>   > SPEED = 5.0
>   > JUMP_VELOCITY = 4.5
>   > enable_gravity = true
>     PlayerArea3D (Area3D)
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerCollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerVisual (Node3D)
>     > unique_name_in_owner = true
>       PlayerModel (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>       > skeleton = ../..
>   MovementInstructionsLabel (Label3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.866025, -0.5), Z: (0.0, 0.5, 0.866025), O: (-2.47682, -0.070802, 7.93048)]
>   > modulate = (0.2941, 1.0, 0.6314, 1.0)
>   > text = "[WASD] to move"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   > font_size = 48
>   PlayerPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.999858, 0.0, 0.0), Y: (0.0, 0.94884, -0.315637), Z: (0.0, 0.315632, 0.948825), O: (-2.53871, 2.0, 9.76232)]
>   > top_level = true
>   > priority_override = false
>   > priority = 10
>   > follow_mode = 2
>   > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6500516984345>
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::Resource_jtk1d
>   > follow_offset = (0.0, 1.5, 2.5)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
> NPCGroup (Node)
>   NPCPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.616596, -0.0, -0.78728), Y: (-0.109786, 0.990229, -0.085984), Z: (0.779587, 0.13945, 0.610571), O: (-2.98802, 1.50739, 1.19719)]
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::Resource_o161n
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   NPCDescriptionLabel (Label3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.866026, -0.5), Z: (0.0, 0.5, 0.866025), O: (-3.04693, 0.367287, 0.953757)]
>   > text = "Input Example"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   NPCDialogueExampleLabel (Label3D)
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.939693, -0.34202), Z: (0.0, 0.34202, 0.939693), O: (-4.46738, 1.58641, -0.253679)]
>   > modulate = (1.0, 0.6039, 0.2549, 1.0)
>   > text = "Press [ F ] to change camera"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   NPCInteractionZoneMesh (MeshInstance3D)
>   > transform = [X: (0.819152, -0.0, 0.573576), Y: (0.0, 1.0, 0.0), Z: (-0.573576, -0.0, 0.819152), O: (-3.46138, -0.4, 0.875321)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_7tjw4
>   > skeleton = ../..
>     NPCInteractionArea3D (Area3D)
>     > unique_name_in_owner = true
>     > transform = [X: (1.0, 0.0, 0.0), Y: (-0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>     > monitorable = false
>       NPCInterationCollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxShape3D_65o6h
>   NPC (StaticBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/npc.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, -0.0, 1.0), O: (-4.56338, 0.5, -0.272679)]
>     PlayerCollisionShape3D2 (CollisionShape3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (-0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::CapsuleShape3D_tpc7d
>     NPCMesh (MeshInstance3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (-0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::CapsuleMesh_g0eml
>     > skeleton = ../../..
>   MoveToLocation (Node3D)
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-4.70084, 0.5, 0.962891)]
> FixedCameraTriggerZone (Node)
>   FixedCameraLabel (Label3D)
>   > unique_name_in_owner = true
>   > transform = [X: (0.939693, 0.0, 0.34202), Y: (0.280167, 0.573577, -0.769751), Z: (-0.196175, 0.819152, 0.538986), O: (-0.538716, -0.247626, 3.13456)]
>   > text = "Fixed Camera\nExample"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   NorthRoomPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > transform = [X: (0.38357, -0.105898, -0.917417), Y: (-0.555836, 0.766851, -0.320912), Z: (0.737507, 0.633027, 0.235279), O: (6.89638, 4.73986, 0.115512)]
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::Resource_tpvee
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::Resource_bxbnv
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   NorthRoomTrigger (Area3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (3.0, -0.45, -0.9)]
>   > priority = 5
>   > area_pcam = NorthRoomPhantomCamera3D:<Node3D#6500902862142>
>     CollisionShape3D (CollisionShape3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.6, 0.0, -0.4)]
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxShape3D_wcrbb
>   EntryRoomPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > transform = [X: (0.258818, 0.0, -0.965924), Y: (-0.482963, 0.866025, -0.129409), Z: (0.836515, 0.499999, 0.224143), O: (6.69741, 4.73364, 4.02374)]
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::Resource_7ih0k
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::Resource_4iyps
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   EntryRoomTrigger (Area3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (3.00003, -0.454982, 3.00572)]
>   > priority = 5
>   > area_pcam = EntryRoomPhantomCamera3D:<Node3D#6500969969181>
>     CollisionShape3D (CollisionShape3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.3, 0.0, 0.2)]
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxShape3D_ctyr8
>   SouthRoomPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > transform = [X: (-0.766043, 0.0, -0.642786), Y: (-0.492403, 0.642787, 0.586825), Z: (0.413175, 0.766043, -0.492403), O: (6.89741, 4.73364, 5.62374)]
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 0
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::Resource_x5y0u
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::Resource_pgiyx
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = false
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   SouthRoomTrigger (Area3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (3.0, -0.45, 6.7)]
>   > priority = 5
>   > area_pcam = SouthRoomPhantomCamera3D:<Node3D#6501037079651>
>     CollisionShape3D (CollisionShape3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.6, 0.0, 0.1)]
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxShape3D_ua072
>   CSGMesh3D (CSGMesh3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (7.14238, 1.82571, 2.88655)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_ugc3s
>   > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::StandardMaterial3D_68thd
>     CSGMesh3D2 (CSGMesh3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.001926, -0.012034, 0.004944)]
>     > operation = 2
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_wphly
>     > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::StandardMaterial3D_68thd
> Environment (Node)
>   DirectionalLight3D (DirectionalLight3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
>   Environment (Node3D)
>     Floor (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     West Wall (StaticBody3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-16.0, 0.5, 0.0)]
>       MeshInstance3D2 (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_gyp5s
>       > skeleton = 
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxShape3D_lfaqs
>     East Wall (StaticBody3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (16.999, 0.502, 0.0)]
>       MeshInstance3D2 (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_gyp5s
>       > skeleton = 
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxShape3D_lfaqs
>     North Wall (StaticBody3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.5, -6.90828)]
>       MeshInstance3D2 (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_n70lt
>       > skeleton = 
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxShape3D_jxmqm
>     South Wall (StaticBody3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.25, 0.5, 9.087)]
>       MeshInstance3D3 (MeshInstance3D)
>       > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (4.0, 0.0, 0.0)]
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_x0tgm
>       > skeleton = 
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxShape3D_t67ef
>     FixedCamOuterWall (CSGMesh3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 2.5, 2.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_rmslh
>       FixedCamOuterDoorway (CSGMesh3D)
>       > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, -1.5, 1.0)]
>       > operation = 2
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_242ij
>     FixedCamNorthWall (CSGMesh3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (4.0, 2.5, 1.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_niuda
>       FixedCamNorthDoorway (CSGMesh3D)
>       > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, -1.5, 0.0)]
>       > operation = 2
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_242ij
>     FixedCamSouthWall (CSGMesh3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (4.0, 2.5, 5.1)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_niuda
>       FixedCamSouthDoorway (CSGMesh3D)
>       > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, -1.50541, 0.0)]
>       > operation = 2
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_example_scene.tscn::BoxMesh_242ij

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_framed_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_framed_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.793353, -0.608762), Z: (0.0, 0.608762, 0.793353), O: (0.0, 2.93468, 3.17294)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> Player (Node)
>   PlayerPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.99995, 0.0, 0.0), Y: (0.0, 0.79324, -0.608675), Z: (0.0, 0.608671, 0.793235), O: (0.0, 2.93468, 3.17294)]
>   > top_level = true
>   > priority_override = false
>   > priority = 0
>   > follow_mode = 5
>   > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6503100677668>
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_framed_example_scene.tscn::Resource_wg1pr
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 4.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.139
>   > dead_zone_height = 0.14
>   > show_viewfinder_in_play = true
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 4.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   PlayerCharacterBody3D (CharacterBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/player_controller_4.4.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.5, 0.0)]
>   > SPEED = 5.0
>   > JUMP_VELOCITY = 4.5
>   > enable_gravity = true
>     PlayerArea3D (Area3D)
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerCollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerVisual (Node3D)
>     > unique_name_in_owner = true
>       PlayerModel (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>       > skeleton = ../..
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   CSGCylinder3D (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.636134, 0.805455, -6.37532)]
>   > use_collision = true
>   > radius = 1.71970999240875
>   > height = 2.61090993881226
>   > sides = 32
>   CSGCylinder3D5 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-7.54597, -0.540694, -3.39517)]
>   > use_collision = true
>   > radius = 1.53269004821777
>   > height = 2.50359988212585
>   > sides = 32
>   CSGCylinder3D6 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.64877, -1.50101, 1.22863)]
>   > use_collision = true
>   > radius = 1.57419002056122
>   > height = 3.47475004196167
>   > sides = 32
>   CSGCylinder3D2 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (10.4732, 0.805455, -8.78984)]
>   > use_collision = true
>   > radius = 0.95628499984741
>   > height = 2.61090993881226
>   > sides = 32
>   CSGSphere3D (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.40027, -1.69814, 3.36997)]
>   > use_collision = true
>   > radius = 3.34732007980347
>   > rings = 32
>   CSGSphere3D2 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (5.13768, -0.599204, -1.04651)]
>   > use_collision = true
>   > radius = 2.65844011306763
>   > rings = 32
>   CSGSphere3D3 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-11.7976, -0.599204, -2.42244)]
>   > use_collision = true
>   > radius = 2.1460599899292
>   > rings = 32
>   CSGTorus3D2 (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (7.84078, -0.497663, 4.44352)]
>   > use_collision = true
>   > inner_radius = 0.97154301404953
>   > outer_radius = 2.15226006507874
>   > sides = 32
>   > ring_sides = 18
>   CSGBox3D (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.52545, 6.53866, -12.6331)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_framed_example_scene.tscn::StandardMaterial3D_auy8m
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-6.88916, 0.760708, -6.1376)]
>   > use_collision = true
>   > size = (2.64182, 2.52142, 2.30997)
>   CSGBox3D5 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-3.83837, -0.241718, 7.14677)]
>   > use_collision = true
>   > size = (3.80964, 1.67049, 0.932048)
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (7.34377, 0.138478, -4.36159)]
>   > use_collision = true
>   > size = (1.53893, 1.27695, 1.80814)
>   CSGBox3D6 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (10.9834, 0.138478, -1.89037)]
>   > use_collision = true
>   > size = (4.03502, 1.27695, 5.2198)
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (8.38147, 0.044043, 8.36617)]
>   > use_collision = true
>   > size = (4.57784, 1.08809, 3.11285)

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_glued_example_scene.tscn ---
Node3D (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_glued_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.638767, -0.7694), Z: (0.0, 0.7694, 0.638768), O: (0.0, 6.39, 7.0)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> Player (Node)
>   PlayerPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.999954, 0.0, 0.0), Y: (0.0, 0.638683, -0.769298), Z: (0.0, 0.769345, 0.638723), O: (0.0, 6.39, 7.0)]
>   > top_level = true
>   > priority_override = false
>   > priority = 5
>   > follow_mode = 1
>   > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6504493186609>
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_glued_example_scene.tscn::Resource_ucp3e
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_glued_example_scene.tscn::Resource_ab013
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.3, 0.3, 0.3)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   PlayerCharacterBody3D (CharacterBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/player_controller_4.4.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 6.39, 7.0)]
>   > SPEED = 5.0
>   > JUMP_VELOCITY = 4.5
>   > enable_gravity = false
>     PlayerArea3D (Area3D)
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerCollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerVisual (Node3D)
>     > unique_name_in_owner = true
>     > visible = false
>       PlayerModel (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>       > skeleton = ../..
> NPCs (Node)
>   PlayerMeshInstance3D (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.04486, 0.519002, -1.52506)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_glued_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
>   PlayerMeshInstance3D2 (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (2.51494, 0.519, 4.06618)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_glued_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   CSGCylinder3D (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-1.62737, 0.805455, -6.37532)]
>   > use_collision = true
>   > radius = 1.71970999240875
>   > height = 2.61090993881226
>   > sides = 32
>   CSGCylinder3D5 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (24.9378, 0.31181, -5.46661)]
>   > use_collision = true
>   > radius = 2.77590990066528
>   > height = 1.62362003326416
>   > sides = 32
>   CSGCylinder3D6 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.58617, 0.31181, 6.6322)]
>   > use_collision = true
>   > radius = 1.57419002056122
>   > height = 3.47475004196167
>   > sides = 32
>   CSGCylinder3D3 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (14.774, 0.201103, 2.71259)]
>   > use_collision = true
>   > radius = 1.41311001777649
>   > height = 1.40220999717712
>   > sides = 32
>   CSGCylinder3D4 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (7.40488, 0.201101, 11.6804)]
>   > use_collision = true
>   > radius = 2.21673011779785
>   > height = 7.88260984420776
>   > sides = 32
>   CSGCylinder3D2 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (8.20971, 0.805455, -8.78984)]
>   > use_collision = true
>   > radius = 0.95628499984741
>   > height = 2.61090993881226
>   > sides = 32
>   CSGSphere3D (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (14.9771, -1.69814, -6.51262)]
>   > use_collision = true
>   > radius = 3.34732007980347
>   > rings = 32
>   CSGSphere3D2 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.555532, -0.599204, 8.81048)]
>   > use_collision = true
>   > radius = 2.65844011306763
>   > rings = 32
>   CSGSphere3D3 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-14.0611, -0.599204, -2.42244)]
>   > use_collision = true
>   > radius = 2.1460599899292
>   > rings = 32
>   CSGTorus3D (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-5.21187, -0.000002, 0.346393)]
>   > use_collision = true
>   > inner_radius = 1.29999995231628
>   > outer_radius = 2.0
>   > sides = 32
>   > ring_sides = 18
>   CSGTorus3D2 (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (21.9283, -0.000002, 7.89765)]
>   > use_collision = true
>   > inner_radius = 0.97154301404953
>   > outer_radius = 2.15226006507874
>   > sides = 32
>   > ring_sides = 18
>   CSGBox3D (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (9.49828, 6.53866, -12.6331)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_glued_example_scene.tscn::StandardMaterial3D_auy8m
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.15267, 0.760708, -6.1376)]
>   > use_collision = true
>   > size = (2.64182, 2.52142, 2.30997)
>   CSGBox3D5 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (14.3427, 0.335247, 8.22829)]
>   > use_collision = true
>   > size = (3.80964, 1.67049, 0.932048)
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (5.08027, 0.138478, -4.36159)]
>   > use_collision = true
>   > size = (1.53893, 1.27695, 1.80814)
>   CSGBox3D6 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-14.7748, 0.138478, 5.20734)]
>   > use_collision = true
>   > size = (4.03502, 1.27695, 5.2198)
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (30.1473, 1.78638, -1.60318)]
>   > use_collision = true
>   > size = (4.57784, 4.57276, 3.11285)

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_group_example_scene.tscn ---
Node3D (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_group_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.621367, -0.78352), Z: (0.0, 0.78352, 0.621367), O: (-7.26116, 10.1812, 8.76176)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> Player (Node)
>   PlayerCharacterBody3D (CharacterBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/player_controller_4.4.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_3d.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.083587, 0.5, 2.05493)]
>   > SPEED = 5.0
>   > JUMP_VELOCITY = 4.5
>   > enable_gravity = true
>     PlayerArea3D (Area3D)
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerCollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerVisual (Node3D)
>     > unique_name_in_owner = true
>       PlayerModel (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>       > skeleton = ../..
>   PlayerPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.999954, 0.0, 0.0), Y: (0.0, 0.621285, -0.783416), Z: (0.0, 0.783464, 0.621322), O: (-7.26116, 10.1812, 8.76176)]
>   > top_level = true
>   > priority_override = false
>   > priority = 5
>   > follow_mode = 3
>   > follow_targets = ["PlayerCharacterBody3D:<CharacterBody3D#6506321903051>","PlayerMeshInstance3D:<MeshInstance3D#6506472897835>","PlayerMeshInstance3D2:<MeshInstance3D#6506489675199>"]
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_group_example_scene.tscn::Resource_1iman
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 5.0
>   > auto_follow_distance = true
>   > auto_follow_distance_min = 5.0
>   > auto_follow_distance_max = 15.0
>   > auto_follow_distance_divisor = 20.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 5.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
> NPCs (Node)
>   PlayerMeshInstance3D (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-14.6059, 0.519002, 0.128472)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_group_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
>   PlayerMeshInstance3D2 (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-10.0461, 0.519, 0.249913)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_group_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.52545, 6.53866, -12.6331)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_group_example_scene.tscn::StandardMaterial3D_auy8m
>   CSGCylinder3D (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-13.6511, 0.805455, -6.37532)]
>   > use_collision = true
>   > radius = 1.71970999240875
>   > height = 2.61090993881226
>   > sides = 32
>   CSGCylinder3D5 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (12.9141, 0.31181, -5.46661)]
>   > use_collision = true
>   > radius = 2.77590990066528
>   > height = 1.62362003326416
>   > sides = 32
>   CSGCylinder3D6 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-21.6099, 0.31181, 6.6322)]
>   > use_collision = true
>   > radius = 1.57419002056122
>   > height = 3.47475004196167
>   > sides = 32
>   CSGCylinder3D2 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-3.81402, 0.805455, -8.78984)]
>   > use_collision = true
>   > radius = 0.95628499984741
>   > height = 2.61090993881226
>   > sides = 32
>   CSGSphere3D (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (2.95333, -1.69814, -6.51262)]
>   > use_collision = true
>   > radius = 3.34732007980347
>   > rings = 32
>   CSGSphere3D2 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-11.4682, -0.599204, 8.81048)]
>   > use_collision = true
>   > radius = 2.65844011306763
>   > rings = 32
>   CSGSphere3D3 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-26.0848, -0.599204, -2.42244)]
>   > use_collision = true
>   > radius = 2.1460599899292
>   > rings = 32
>   CSGTorus3D2 (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (9.90455, -0.000002, 7.89765)]
>   > use_collision = true
>   > inner_radius = 0.97154301404953
>   > outer_radius = 2.15226006507874
>   > sides = 32
>   > ring_sides = 18
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-21.1764, 0.760708, -6.1376)]
>   > use_collision = true
>   > size = (2.64182, 2.52142, 2.30997)
>   CSGBox3D5 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (2.31901, 0.335247, 8.22829)]
>   > use_collision = true
>   > size = (3.80964, 1.67049, 0.932048)
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-6.94346, 0.138478, -4.36159)]
>   > use_collision = true
>   > size = (1.53893, 1.27695, 1.80814)
>   CSGBox3D6 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-26.7985, 0.138478, 5.20734)]
>   > use_collision = true
>   > size = (4.03502, 1.27695, 5.2198)
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (18.1236, 1.78638, -1.60318)]
>   > use_collision = true
>   > size = (4.57784, 4.57276, 3.11285)

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (0.999996, 0.0, -0.002843), Y: (-0.002163, 0.648938, -0.760838), Z: (0.001845, 0.760841, 0.648936), O: (0.0, 2.5, 1.5)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> PlayerPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999807, 0.0, -0.002842), Y: (-0.002162, 0.648836, -0.760718), Z: (0.001844, 0.760728, 0.648839), O: (0.0, 2.5, 1.5)]
> > top_level = true
> > priority_override = false
> > priority = 10
> > follow_mode = 2
> > follow_target = PlayerCharacterBody3D2:<CharacterBody3D#6508184173821>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::Resource_ofv2c
> > follow_offset = (0.0, 2.0, 1.5)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerCharacterBody3D2 (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller_4.4.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.5, 0.0)]
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerVisual (Node3D)
>   > unique_name_in_owner = true
>     PlayerModel (MeshInstance3D)
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>     > skeleton = ../..
> Paths (Node)
>   PathPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > transform = [X: (-0.0, 0.0, -1.0), Y: (-1.0, -0.0, 0.0), Z: (-0.0, 1.0, 0.0), O: (-0.31028, 7.9199, -1.60976)]
>   > top_level = true
>   > priority_override = false
>   > priority = 2
>   > follow_mode = 4
>   > follow_target = PlayerCharacterBody3D2:<CharacterBody3D#6508184173821>
>   > follow_targets = []
>   > follow_path = FollowPath:<Path3D#6508335169157>
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::Resource_01tho
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::Resource_syh5m
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   FollowPath (Path3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.31028, 7.9199, -1.60976)]
>   > curve = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::Curve3D_b33df
>   StraightPathFollowTrigger (Area3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/path_follow.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.04204, -0.45, -6.73666)]
>   > priority = 5
>   > path_pcam = PathPhantomCamera3D:<Node3D#6508301614337>
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::BoxShape3D_aovgi
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::BoxMesh_0hdeh
>       > skeleton = ../../../..
>   PathPhantomCamera3D2 (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (0.0, 7.9199, -13.4572)]
>   > top_level = true
>   > visible = false
>   > priority_override = false
>   > priority = 2
>   > follow_mode = 4
>   > follow_target = PlayerCharacterBody3D2:<CharacterBody3D#6508184173821>
>   > follow_targets = []
>   > follow_path = FollowPath2:<Path3D#6508435831835>
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::Resource_01tho
>   > tween_on_load = true
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::Resource_xci4c
>   > follow_offset = (0.0, 0.0, 0.0)
>   > follow_damping = true
>   > follow_damping_value = (0.6, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   FollowPath2 (Path3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-4.97141, 7.9199, -13.4572)]
>   > curve = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::Curve3D_8uw2x
>   StraightPathFollowTrigger2 (Area3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/path_follow.gd
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.04204, 0.0, -13.7367)]
>   > priority = 5
>   > path_pcam = PathPhantomCamera3D2:<Node3D#6508402277505>
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::BoxShape3D_ctnqu
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, -0.45, 0.0)]
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::BoxMesh_f6dp8
>       > skeleton = ../../../..
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Floor3 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (6.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.44204, 0.0, 1.76334)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor2 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.166667, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 14.0), O: (-0.516667, 1.0, -6.5)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor5 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.166667, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 14.0), O: (0.65, 1.0, -6.5)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor4 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (2.0, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.066667, 1.0, -18.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor6 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.333333, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.766667, 1.0, -13.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::BoxMesh_7l3dh
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor8 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.166667, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 6.0), O: (-1.01667, 1.0, -15.5)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::BoxMesh_as6ok
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor9 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.166667, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 6.0), O: (1.15, 1.0, -15.5)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::BoxMesh_as6ok
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>     Floor7 (CSGMesh3D)
>       scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>     > transform = [X: (0.333333, 0.0, 0.0), Y: (0.0, 3.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.9, 1.0, -13.0)]
>     > use_collision = true
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_path_example_scene.tscn::BoxMesh_7l3dh
>     > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   NPCDescriptionLabel (Label3D)
>   > transform = [X: (0.0, -0.0, -0.999999), Y: (-1.0, 0.0, -0.0), Z: (-0.000001, 0.999999, -0.0), O: (-3.47306, 2.59595, -5.51755)]
>   > text = "Camera follows player while confined to a Path3D"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   > font_size = 64
>   MovementInstructionsLabel (Label3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (-0.02174, -0.455369, 0.570585)]
>   > modulate = (0.2941, 1.0, 0.6314, 1.0)
>   > text = "[WASD] to move"
>   > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>   > font_size = 48

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_simple_example_scene.tscn ---
Node3D2 (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_simple_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.906308, -0.422618), Z: (0.0, 0.422618, 0.906308), O: (-13.2122, 2.5, 10.4016)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> Player (Node)
>   PlayerPhantomCamera3D (Node3D)
>     script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>   > unique_name_in_owner = true
>   > transform = [X: (0.999954, 0.0, 0.0), Y: (0.0, 0.906188, -0.422562), Z: (0.0, 0.422588, 0.906243), O: (-13.2122, 2.5, 10.4016)]
>   > top_level = true
>   > priority_override = false
>   > priority = 10
>   > follow_mode = 2
>   > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6509845118077>
>   > follow_targets = []
>   > look_at_mode = 0
>   > look_at_targets = []
>   > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_simple_example_scene.tscn::Resource_28vpp
>   > tween_on_load = false
>   > inactive_update_mode = 0
>   > host_layers = 1
>   > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_simple_example_scene.tscn::Resource_axopo
>   > follow_offset = (0.0, 2.0, 2.0)
>   > follow_damping = true
>   > follow_damping_value = (0.1, 0.1, 0.1)
>   > follow_axis_lock = 0
>   > follow_distance = 1.0
>   > auto_follow_distance = false
>   > auto_follow_distance_min = 1.0
>   > auto_follow_distance_max = 5.0
>   > auto_follow_distance_divisor = 10.0
>   > dead_zone_width = 0.0
>   > dead_zone_height = 0.0
>   > show_viewfinder_in_play = false
>   > vertical_rotation_offset = 0.0
>   > horizontal_rotation_offset = 0.0
>   > spring_length = 1.0
>   > collision_mask = 1
>   > margin = 0.01
>   > look_at_offset = (0.0, 0.0, 0.0)
>   > look_at_damping = false
>   > look_at_damping_value = 0.25
>   > up = (0.0, 1.0, 0.0)
>   > _preview_noise = true
>   > noise_emitter_layer = 0
>   PlayerCharacterBody3D (CharacterBody3D)
>     script: res://addons/phantom_camera/examples/scripts/3D/player_controller_4.4.gd
>     scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-13.2122, 0.5, 8.40162)]
>   > SPEED = 5.0
>   > JUMP_VELOCITY = 4.5
>   > enable_gravity = true
>     PlayerArea3D (Area3D)
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerCollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>     PlayerVisual (Node3D)
>     > unique_name_in_owner = true
>       PlayerModel (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>       > skeleton = ../..
> NPCs (Node)
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   CSGCylinder3D (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-13.6511, 0.805455, -6.37532)]
>   > use_collision = true
>   > radius = 1.71970999240875
>   > height = 2.61090993881226
>   > sides = 32
>   CSGCylinder3D5 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-21.8332, -0.540694, -3.39517)]
>   > use_collision = true
>   > radius = 1.53269004821777
>   > height = 2.50359988212585
>   > sides = 32
>   CSGCylinder3D6 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-16.936, -1.50101, 1.22863)]
>   > use_collision = true
>   > radius = 1.57419002056122
>   > height = 3.47475004196167
>   > sides = 32
>   CSGCylinder3D2 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-3.81402, 0.805455, -8.78984)]
>   > use_collision = true
>   > radius = 0.95628499984741
>   > height = 2.61090993881226
>   > sides = 32
>   CSGSphere3D (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-23.6875, -1.69814, 3.36997)]
>   > use_collision = true
>   > radius = 3.34732007980347
>   > rings = 32
>   CSGSphere3D2 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.14955, -0.599204, -1.04651)]
>   > use_collision = true
>   > radius = 2.65844011306763
>   > rings = 32
>   CSGSphere3D3 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-26.0848, -0.599204, -2.42244)]
>   > use_collision = true
>   > radius = 2.1460599899292
>   > rings = 32
>   CSGTorus3D2 (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-6.44645, -0.497663, 4.44352)]
>   > use_collision = true
>   > inner_radius = 0.97154301404953
>   > outer_radius = 2.15226006507874
>   > sides = 32
>   > ring_sides = 18
>   CSGBox3D (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.52545, 6.53866, -12.6331)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_simple_example_scene.tscn::StandardMaterial3D_auy8m
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-21.1764, 0.760708, -6.1376)]
>   > use_collision = true
>   > size = (2.64182, 2.52142, 2.30997)
>   CSGBox3D5 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-18.1256, 0.335247, 7.14677)]
>   > use_collision = true
>   > size = (3.80964, 1.67049, 0.932048)
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-6.94346, 0.138478, -4.36159)]
>   > use_collision = true
>   > size = (1.53893, 1.27695, 1.80814)
>   CSGBox3D6 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-3.30382, 0.138478, -1.89037)]
>   > use_collision = true
>   > size = (4.03502, 1.27695, 5.2198)
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.04727, 0.044043, 8.36617)]
>   > use_collision = true
>   > size = (4.57784, 1.08809, 3.11285)

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn
> PlayerPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.019409, 0.506884, 8.76853)]
> > priority_override = false
> > priority = 10
> > follow_mode = 6
> > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6511724166165>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::Resource_8fhct
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::Resource_7m0fv
> > attributes = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::CameraAttributesPractical_i42vj
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 3.5
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 3.5
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerAimPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.019409, 1.47688, 6.36953)]
> > priority_override = false
> > priority = 0
> > follow_mode = 6
> > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6511724166165>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::Resource_e7t18
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::Resource_jogxh
> > attributes = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::CameraAttributesPractical_fvhx5
> > follow_offset = (0.0, 0.97, -0.399)
> > follow_damping = false
> > follow_damping_value = (0.0, 0.0, 0.0)
> > follow_axis_lock = 0
> > follow_distance = 1.5
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.5
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerCharacterBody3D (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller_third_person_4.4.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn
> > unique_name_in_owner = true
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.019409, 0.506884, 5.26853)]
> > collision_layer = 2
> > mouse_sensitivity = 0.05
> > min_pitch = -89.9
> > max_pitch = 50.0
> > min_yaw = 0.0
> > max_yaw = 360.0
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
>   PlayerVisual (Node3D)
>   > unique_name_in_owner = true
>     PlayerMeshInstance3D (MeshInstance3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleMesh_47f0o
>     > skeleton = ../..
>     PlayerDirection (MeshInstance3D)
>     > unique_name_in_owner = true
>     > transform = [X: (1.0, -0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.015623, 1.08631, 0.0)]
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::PrismMesh_wg1x3
>     > skeleton = ../..
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.019409, 0.506884, 8.76853)]
> > attributes = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::CameraAttributesPractical_fnb35
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.5, 4.5, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall2 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (9.5, 4.5, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall3 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (0.0, 4.5, 10.5)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall4 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (0.0, 4.5, -9.5)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   DirectionalLight3D (DirectionalLight3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> CeilingPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (-0.0, 0.0, -1.0), Y: (-1.0, 0.0, 0.0), Z: (0.0, 1.0, -0.0), O: (-0.200665, 13.366, -0.162648)]
> > priority_override = false
> > priority = 0
> > follow_mode = 0
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::Resource_afrr1
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::Resource_unpfd
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> MovementInstructionsLabel (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (0.05056, -0.484909, 1.44357)]
> > visible = false
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[WASD] to move"
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48
> MovementInstructionsLabel3 (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (0.05056, -0.484909, 0.817134)]
> > visible = false
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[Right Mouse Click] to \"aim\""
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48
> MovementInstructionsLabel2 (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (-0.044015, -0.490478, -6.30248)]
> > visible = false
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[Space] to toggle PCam"
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48
> MeshInstance3D (MeshInstance3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, 1.0), Z: (0.0, -1.0, -0.0), O: (0.260217, 1.60477, -9.07797)]
> > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::CylinderMesh_sm466
> MeshInstance3D3 (MeshInstance3D)
> > transform = [X: (-1.0, 0.0, 0.0), Y: (-0.0, -0.0, -1.0), Z: (0.0, -1.0, 0.0), O: (0.052586, 1.60477, 9.98156)]
> > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_attribtues_example_scene.tscn::CylinderMesh_sm466

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn ---
Root2 (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn
> PlayerCharacterBody3D (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller_third_person_4.4.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn
> > unique_name_in_owner = true
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.5, 0.0)]
> > collision_layer = 2
> > mouse_sensitivity = 0.05
> > min_pitch = -89.9
> > max_pitch = 50.0
> > min_yaw = 0.0
> > max_yaw = 360.0
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
>   PlayerVisual (Node3D)
>   > unique_name_in_owner = true
>     PlayerMeshInstance3D (MeshInstance3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::CapsuleMesh_47f0o
>     > skeleton = ../..
>     PlayerDirection (MeshInstance3D)
>     > unique_name_in_owner = true
>     > transform = [X: (1.0, -0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.015623, 1.08631, 0.0)]
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_third_person_3d.tscn::PrismMesh_wg1x3
>     > skeleton = ../..
> PlayerPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.866025, -0.5), Z: (0.0, 0.5, 0.866025), O: (0.0, 2.25, 3.03109)]
> > priority_override = false
> > priority = 10
> > follow_mode = 6
> > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6513083120667>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::Resource_8fhct
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::Resource_7m0fv
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 3.5
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.523599
> > horizontal_rotation_offset = 0.0
> > spring_length = 3.5
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerAimPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.584, 1.3, 1.101)]
> > priority_override = false
> > priority = 0
> > follow_mode = 6
> > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6513083120667>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::Resource_e7t18
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::Resource_jogxh
> > follow_offset = (0.584, 0.8, -0.399)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.5
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.5
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.866025, -0.5), Z: (0.0, 0.5, 0.866025), O: (0.0, 2.25, 3.03109)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-9.5, 4.5, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall5 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-6.133, 3.0, -6.5)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::BoxMesh_bj3re
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall6 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (2.5, 3.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::BoxMesh_bj3re
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall7 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.5, 3.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::BoxMesh_bj3re
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall2 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (9.5, 4.5, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall3 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (0.0, 4.5, 10.5)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   Wall4 (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (0.0, 4.5, -9.5)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::BoxMesh_wsigl
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   DirectionalLight3D (DirectionalLight3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> CeilingPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (-0.0, 0.0, -1.0), Y: (-1.0, 0.0, 0.0), Z: (0.0, 1.0, -0.0), O: (-0.200665, 13.366, -0.162648)]
> > priority_override = false
> > priority = 0
> > follow_mode = 0
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::Resource_afrr1
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_follow_third_person_example_scene.tscn::Resource_ioijp
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> MovementInstructionsLabel (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (0.05056, -0.484909, 1.44357)]
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[WASD] to move"
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48
> MovementInstructionsLabel3 (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (0.05056, -0.484909, 0.817134)]
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[Right Mouse Click] to \"aim\""
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48
> MovementInstructionsLabel2 (Label3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, -0.0, -1.0), Z: (0.0, 1.0, -0.0), O: (-0.044015, -0.490478, -6.30248)]
> > modulate = (0.2941, 1.0, 0.6314, 1.0)
> > text = "[Space] to toggle PCam"
> > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
> > font_size = 48

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_look_at_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_look_at_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (0.999765, 0.0, 0.021662), Y: (0.010421, 0.876683, -0.480956), Z: (-0.018991, 0.481069, 0.876477), O: (-0.137901, 4.03222, 6.36446)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> DirectionalLight3D (DirectionalLight3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> PhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > transform = [X: (0.999765, 0.0, 0.021662), Y: (0.010421, 0.876683, -0.480956), Z: (-0.018991, 0.481069, 0.876478), O: (-0.137901, 4.03222, 6.36446)]
> > priority_override = false
> > priority = 10
> > follow_mode = 0
> > follow_targets = []
> > look_at_mode = 2
> > look_at_target = PlayerCharacterBody3D2:<CharacterBody3D#6514794396797>
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_look_at_example_scene.tscn::Resource_pwcgo
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_look_at_example_scene.tscn::Resource_ft2w3
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = true
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerCharacterBody3D2 (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller_4.4.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.5, 0.0)]
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerVisual (Node3D)
>   > unique_name_in_owner = true
>     PlayerModel (MeshInstance3D)
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>     > skeleton = ../..
> NPCs (Node)
>   PlayerMeshInstance3D (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-1.96028, 0.519002, -1.52506)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_look_at_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
>   PlayerMeshInstance3D2 (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (2.59952, 0.519, 4.06618)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_look_at_example_scene.tscn::CapsuleMesh_2h36r
>   > skeleton = 
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   CSGCylinder3D (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-1.00548, 0.805455, -6.37532)]
>   > use_collision = true
>   > radius = 1.71970999240875
>   > height = 2.61090993881226
>   > sides = 32
>   CSGCylinder3D5 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (25.5597, 0.31181, -5.46661)]
>   > use_collision = true
>   > radius = 2.77590990066528
>   > height = 1.62362003326416
>   > sides = 32
>   CSGCylinder3D6 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-8.96428, 0.31181, 6.6322)]
>   > use_collision = true
>   > radius = 1.57419002056122
>   > height = 3.47475004196167
>   > sides = 32
>   CSGCylinder3D3 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (15.3959, 0.201103, 2.71259)]
>   > use_collision = true
>   > radius = 1.41311001777649
>   > height = 1.40220999717712
>   > sides = 32
>   CSGCylinder3D4 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (8.02677, 0.201101, 11.6804)]
>   > use_collision = true
>   > radius = 2.21673011779785
>   > height = 7.88260984420776
>   > sides = 32
>   CSGCylinder3D2 (CSGCylinder3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (8.8316, 0.805455, -8.78984)]
>   > use_collision = true
>   > radius = 0.95628499984741
>   > height = 2.61090993881226
>   > sides = 32
>   CSGSphere3D (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (15.5989, -1.69814, -6.51262)]
>   > use_collision = true
>   > radius = 3.34732007980347
>   > rings = 32
>   CSGSphere3D2 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (1.17742, -0.599204, 8.81048)]
>   > use_collision = true
>   > radius = 2.65844011306763
>   > rings = 32
>   CSGSphere3D3 (CSGSphere3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-13.4392, -0.599204, -2.42244)]
>   > use_collision = true
>   > radius = 2.1460599899292
>   > rings = 32
>   CSGTorus3D (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-4.58998, -0.000002, 0.346393)]
>   > use_collision = true
>   > inner_radius = 1.29999995231628
>   > outer_radius = 2.0
>   > sides = 32
>   > ring_sides = 18
>   CSGTorus3D2 (CSGTorus3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (22.5502, -0.000002, 7.89765)]
>   > use_collision = true
>   > inner_radius = 0.97154301404953
>   > outer_radius = 2.15226006507874
>   > sides = 32
>   > ring_sides = 18
>   CSGBox3D (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (10.1202, 6.53866, -12.6331)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_look_at_example_scene.tscn::StandardMaterial3D_auy8m
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-8.53078, 0.760708, -6.1376)]
>   > use_collision = true
>   > size = (2.64182, 2.52142, 2.30997)
>   CSGBox3D5 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (14.9646, 0.335247, 8.22829)]
>   > use_collision = true
>   > size = (3.80964, 1.67049, 0.932048)
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (5.70216, 0.138478, -4.36159)]
>   > use_collision = true
>   > size = (1.53893, 1.27695, 1.80814)
>   CSGBox3D6 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-14.1529, 0.138478, 5.20734)]
>   > use_collision = true
>   > size = (4.03502, 1.27695, 5.2198)
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (30.7692, 1.78638, -1.60318)]
>   > use_collision = true
>   > size = (4.57784, 4.57276, 3.11285)

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn ---
Root2 (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (-0.037211, -0.0, -0.999307), Y: (0.035164, 0.999381, -0.001309), Z: (0.998689, -0.035189, -0.037188), O: (-16.46, 0.503767, 4.249)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> PlayerCharacterBody3D (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller_first_person_4.4.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999897, -0.014364, 0.0), Y: (0.014364, 0.999897, 0.0), Z: (0.0, 0.0, 1.0), O: (-16.46, 0.503767, 4.249)]
> > mouse_sensitivity = 0.05
> > min_pitch = -89.9
> > max_pitch = 50.0
> > min_yaw = 0.0
> > max_yaw = 360.0
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerVisual (MeshInstance3D)
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.000048, 0.003311, 0.0)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::CapsuleMesh_yvgu3
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::CapsuleShape3D_lsrh7
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::CapsuleShape3D_lsrh7
> PlayerPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.004415, 0.0, -0.999923), Y: (0.0, 0.999995, 0.0), Z: (0.999915, 0.0, 0.004415), O: (-16.46, 0.503767, 4.249)]
> > top_level = true
> > priority_override = false
> > priority = 10
> > follow_mode = 2
> > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6516438564429>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::Resource_lhgur
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::Resource_ghjuj
> > follow_offset = (0.0, 0.0, 0.0)
> > follow_damping = false
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > noise = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::Resource_2l4w0
> > _preview_noise = true
> > noise_emitter_layer = 1
> PlayerPhantomCameraNoiseEmitter3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_noise_emitter_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (-0.0, 0.0, -0.999933), Y: (0.0, 0.999995, 0.0), Z: (0.999925, 0.0, -0.0), O: (-16.46, 0.503767, 4.249)]
> > noise = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::Resource_6tnhy
> > preview = false
> > continuous = false
> > growth_time = 0.0
> > duration = 0.1
> > decay_time = 0.1
> > noise_emitter_layer = 1
> Environment (Node)
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
>   CSGBox3D (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.525, 6.539, 2.5)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::StandardMaterial3D_qi01t
>   CSGBox3D3 (CSGBox3D)
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (8.83707, 6.53866, -1.80739)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::StandardMaterial3D_qi01t
>   CSGBox3D4 (CSGBox3D)
>   > transform = [X: (-0.0, 0.0, 1.0), Y: (0.0, 1.0, 0.0), Z: (-1.0, 0.0, -0.0), O: (-38.9392, 6.53866, -1.80739)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::StandardMaterial3D_qi01t
>   CSGBox3D2 (CSGBox3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-2.525, 6.539, 6.0)]
>   > use_collision = true
>   > size = (178.429, 14.0773, 1.0)
>   > material = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_noise_example_scene.tscn::StandardMaterial3D_qi01t
>   DirectionalLight3D (DirectionalLight3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
> EmitterTip (Panel)
> > unique_name_in_owner = true
> > visible = false
> > anchors_preset = -1
> > anchor_right = 0.30000001192093
> > anchor_bottom = 0.10000000149012
>   Guidance (RichTextLabel)
>   > layout_mode = 1
>   > anchors_preset = -1
>   > anchor_top = 0.5
>   > anchor_right = 1.0
>   > anchor_bottom = 0.5
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > size_flags_vertical = 8
>   > bbcode_enabled = true
>   > text = "[center]Press [b]Q[/b] to trigger Noise Emitter"
>   > fit_content = true

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn ---
Root (Node3D)
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn
> Environment (Node)
>   DirectionalLight3D (DirectionalLight3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 8.0, 0.0)]
>   Floor (CSGMesh3D)
>     scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
>   > transform = [X: (1000.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1000.0), O: (0.0, -1.0, 0.0)]
>   > use_collision = true
>   > mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
>   > material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v
> MainCamera3D (Camera3D)
> > unique_name_in_owner = true
> > physics_interpolation_mode = 1
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.707107, -0.707107), Z: (0.0, 0.707107, 0.707107), O: (0.0, 2.5, 2.0)]
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> ------------------ (Node)
> PlayerPhantomCamera3D (Node3D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
> > unique_name_in_owner = true
> > transform = [X: (0.999889, 0.0, 0.0), Y: (0.0, 0.707092, -0.707092), Z: (0.0, 0.707088, 0.707088), O: (0.0, 2.5, 2.0)]
> > top_level = true
> > priority_override = false
> > priority = 3
> > follow_mode = 2
> > follow_target = PlayerCharacterBody3D:<CharacterBody3D#6518284057729>
> > follow_targets = []
> > look_at_mode = 0
> > look_at_targets = []
> > tween_resource = res://addons/phantom_camera/examples/resources/tween/player_phantom_camera_3d_tween.tres
> > tween_on_load = false
> > inactive_update_mode = 0
> > host_layers = 1
> > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::Resource_0dtvs
> > follow_offset = (0.0, 2.0, 2.0)
> > follow_damping = true
> > follow_damping_value = (0.1, 0.1, 0.1)
> > follow_axis_lock = 0
> > follow_distance = 1.0
> > auto_follow_distance = false
> > auto_follow_distance_min = 1.0
> > auto_follow_distance_max = 5.0
> > auto_follow_distance_divisor = 10.0
> > dead_zone_width = 0.0
> > dead_zone_height = 0.0
> > show_viewfinder_in_play = false
> > vertical_rotation_offset = 0.0
> > horizontal_rotation_offset = 0.0
> > spring_length = 1.0
> > collision_mask = 1
> > margin = 0.01
> > look_at_offset = (0.0, 0.0, 0.0)
> > look_at_damping = false
> > look_at_damping_value = 0.25
> > up = (0.0, 1.0, 0.0)
> > _preview_noise = true
> > noise_emitter_layer = 0
> PlayerCharacterBody3D (CharacterBody3D)
>   script: res://addons/phantom_camera/examples/scripts/3D/player_controller_4.4.gd
>   scene: res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.5, 0.0)]
> > SPEED = 5.0
> > JUMP_VELOCITY = 4.5
> > enable_gravity = true
>   PlayerArea3D (Area3D)
>     CollisionShape3D (CollisionShape3D)
>     > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerCollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
>   PlayerVisual (Node3D)
>   > unique_name_in_owner = true
>     PlayerModel (MeshInstance3D)
>     > mesh = res://addons/phantom_camera/examples/example_scenes/3D/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>     > skeleton = ../..
> ------------------- (Node)
> Tweening Example (Node3D)
> > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, -1.97)]
>   Linear (Node3D)
>     EntryRoomTrigger (Area3D)
>       script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>     > priority = 5
>     > area_pcam = PhantomCamera3D:<Node3D#6518485384538>
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::BoxShape3D_j6fha
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::BoxMesh_xg4en
>       > skeleton = ../../../../..
>     PhantomCamera3D (Node3D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.642788, -0.766044), Z: (0.0, 0.766044, 0.642788), O: (0.0, 4.8, 3.3)]
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > look_at_mode = 0
>     > look_at_targets = []
>     > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::Resource_v8ndi
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::Resource_kmep1
>     > follow_offset = (0.0, 0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.1, 0.1, 0.1)
>     > follow_axis_lock = 0
>     > follow_distance = 1.0
>     > auto_follow_distance = false
>     > auto_follow_distance_min = 1.0
>     > auto_follow_distance_max = 5.0
>     > auto_follow_distance_divisor = 10.0
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > vertical_rotation_offset = 0.0
>     > horizontal_rotation_offset = 0.0
>     > spring_length = 1.0
>     > collision_mask = 1
>     > margin = 0.01
>     > look_at_offset = (0.0, 0.0, 0.0)
>     > look_at_damping = false
>     > look_at_damping_value = 0.25
>     > up = (0.0, 1.0, 0.0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     TweenNameLabel (Label3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.695913, -0.718126), Z: (0.0, 0.718126, 0.695913), O: (-1.8, 0.5, 0.0)]
>     > text = "Transition Type:\nLinear\n\nDuration:\n0.6s"
>     > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>     > font_size = 48
>   Sine (Node3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, -7.4)]
>     EntryRoomTrigger (Area3D)
>       script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>     > priority = 5
>     > area_pcam = PhantomCamera3D:<Node3D#6518602823193>
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::BoxShape3D_j6fha
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::BoxMesh_xg4en
>       > skeleton = ../../../../..
>     PhantomCamera3D (Node3D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.642788, -0.766044), Z: (0.0, 0.766044, 0.642788), O: (0.0, 4.8, 3.3)]
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > look_at_mode = 0
>     > look_at_targets = []
>     > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::Resource_uxg44
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::Resource_eu3bc
>     > follow_offset = (0.0, 0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.1, 0.1, 0.1)
>     > follow_axis_lock = 0
>     > follow_distance = 1.0
>     > auto_follow_distance = false
>     > auto_follow_distance_min = 1.0
>     > auto_follow_distance_max = 5.0
>     > auto_follow_distance_divisor = 10.0
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > vertical_rotation_offset = 0.0
>     > horizontal_rotation_offset = 0.0
>     > spring_length = 1.0
>     > collision_mask = 1
>     > margin = 0.01
>     > look_at_offset = (0.0, 0.0, 0.0)
>     > look_at_damping = false
>     > look_at_damping_value = 0.25
>     > up = (0.0, 1.0, 0.0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     TweenNameLabel (Label3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.695913, -0.718126), Z: (0.0, 0.718126, 0.695913), O: (1.7, 0.5, 0.0)]
>     > text = "Transition Type:\nSine\n\nDuration:\n0.3s"
>     > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>     > font_size = 72
>   Circ (Node3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, -14.1)]
>     EntryRoomTrigger (Area3D)
>       script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>     > priority = 5
>     > area_pcam = PhantomCamera3D:<Node3D#6518720265480>
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::BoxShape3D_j6fha
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::BoxMesh_xg4en
>       > skeleton = ../../../../..
>     PhantomCamera3D (Node3D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.642788, -0.766044), Z: (0.0, 0.766044, 0.642788), O: (0.0, 4.8, 3.3)]
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > look_at_mode = 0
>     > look_at_targets = []
>     > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::Resource_0nci0
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::Resource_u0lff
>     > follow_offset = (0.0, 0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.1, 0.1, 0.1)
>     > follow_axis_lock = 0
>     > follow_distance = 1.0
>     > auto_follow_distance = false
>     > auto_follow_distance_min = 1.0
>     > auto_follow_distance_max = 5.0
>     > auto_follow_distance_divisor = 10.0
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > vertical_rotation_offset = 0.0
>     > horizontal_rotation_offset = 0.0
>     > spring_length = 1.0
>     > collision_mask = 1
>     > margin = 0.01
>     > look_at_offset = (0.0, 0.0, 0.0)
>     > look_at_damping = false
>     > look_at_damping_value = 0.25
>     > up = (0.0, 1.0, 0.0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     TweenNameLabel (Label3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.695913, -0.718126), Z: (0.0, 0.718126, 0.695913), O: (-1.8, 0.5, 0.0)]
>     > text = "Transition Type:\nCirc\n\nDuration:\n0.3s"
>     > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>     > font_size = 72
>   Back (Node3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, -21.0)]
>     EntryRoomTrigger (Area3D)
>       script: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd
>     > priority = 5
>     > area_pcam = PhantomCamera3D:<Node3D#6518837704154>
>       CollisionShape3D (CollisionShape3D)
>       > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::BoxShape3D_j6fha
>       NPCInteractionZoneMesh (MeshInstance3D)
>       > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::BoxMesh_xg4en
>       > skeleton = ../../../../..
>     PhantomCamera3D (Node3D)
>       script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.642788, -0.766044), Z: (0.0, 0.766044, 0.642788), O: (-0.8, 4.8, 3.3)]
>     > priority_override = false
>     > priority = 0
>     > follow_mode = 0
>     > follow_targets = []
>     > look_at_mode = 0
>     > look_at_targets = []
>     > tween_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::Resource_50m5g
>     > tween_on_load = true
>     > inactive_update_mode = 0
>     > host_layers = 1
>     > camera_3d_resource = res://addons/phantom_camera/examples/example_scenes/3D-4.4/3d_tweening_example_scene.tscn::Resource_rexf8
>     > follow_offset = (0.0, 0.0, 0.0)
>     > follow_damping = false
>     > follow_damping_value = (0.1, 0.1, 0.1)
>     > follow_axis_lock = 0
>     > follow_distance = 1.0
>     > auto_follow_distance = false
>     > auto_follow_distance_min = 1.0
>     > auto_follow_distance_max = 5.0
>     > auto_follow_distance_divisor = 10.0
>     > dead_zone_width = 0.0
>     > dead_zone_height = 0.0
>     > show_viewfinder_in_play = false
>     > vertical_rotation_offset = 0.0
>     > horizontal_rotation_offset = 0.0
>     > spring_length = 1.0
>     > collision_mask = 1
>     > margin = 0.01
>     > look_at_offset = (0.0, 0.0, 0.0)
>     > look_at_damping = false
>     > look_at_damping_value = 0.25
>     > up = (0.0, 1.0, 0.0)
>     > _preview_noise = true
>     > noise_emitter_layer = 0
>     TweenNameLabel (Label3D)
>     > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 0.695913, -0.718126), Z: (0.0, 0.718126, 0.695913), O: (1.7, 0.5, 0.0)]
>     > text = "Transition Type:\nBack\n\nDuration:\n1.2s"
>     > font = res://addons/phantom_camera/fonts/Nunito-Black.ttf
>     > font_size = 48

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_3d.tscn ---
PlayerCharacterBody3D2 (CharacterBody3D)
> script: res://addons/phantom_camera/examples/scripts/3D/player_controller_4.4.gd
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_3d.tscn
> transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.083587, 0.507, 2.05493)]
> SPEED = 5.0
> JUMP_VELOCITY = 4.5
> enable_gravity = true
> PlayerArea3D (Area3D)
>   CollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
> PlayerCollisionShape3D (CollisionShape3D)
> > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_3d.tscn::CapsuleShape3D_8efyg
> PlayerVisual (Node3D)
> > unique_name_in_owner = true
>   PlayerModel (MeshInstance3D)
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_3d.tscn::CapsuleMesh_2cfaw
>   > skeleton = ../..

--- SCENE: res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_third_person_3d.tscn ---
PlayerCharacterBody3D (CharacterBody3D)
> script: res://addons/phantom_camera/examples/scripts/3D/player_controller_third_person_4.4.gd
> scene: res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_third_person_3d.tscn
> transform = [X: (0.999903, -0.013962, 0.0), Y: (0.013962, 0.999903, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.019409, 0.506884, -0.016325)]
> collision_layer = 2
> mouse_sensitivity = 0.05
> min_pitch = -89.9
> max_pitch = 50.0
> min_yaw = 0.0
> max_yaw = 360.0
> SPEED = 5.0
> JUMP_VELOCITY = 4.5
> enable_gravity = true
> PlayerArea3D (Area3D)
>   CollisionShape3D (CollisionShape3D)
>   > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
> PlayerCollisionShape3D (CollisionShape3D)
> > shape = res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_third_person_3d.tscn::CapsuleShape3D_s61dn
> PlayerVisual (Node3D)
> > unique_name_in_owner = true
>   PlayerMeshInstance3D (MeshInstance3D)
>   > transform = [X: (1.0, 0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (0.0, 0.0, 0.0)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_third_person_3d.tscn::CapsuleMesh_47f0o
>   > skeleton = ../..
>   PlayerDirection (MeshInstance3D)
>   > unique_name_in_owner = true
>   > transform = [X: (1.0, -0.0, 0.0), Y: (0.0, 1.0, 0.0), Z: (0.0, 0.0, 1.0), O: (-0.015623, 1.08631, 0.0)]
>   > mesh = res://addons/phantom_camera/examples/example_scenes/3D-4.4/sub_scenes/playable_character_third_person_3d.tscn::PrismMesh_wg1x3
>   > skeleton = ../..

--- SCENE: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn ---
3DPrototypeCube (CSGMesh3D)
> scene: res://addons/phantom_camera/examples/models/3d_cube_dark.tscn
> use_collision = true
> mesh = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::BoxMesh_d24c3
> material = res://addons/phantom_camera/examples/models/3d_cube_dark.tscn::StandardMaterial3D_aox6v

--- SCENE: res://addons/phantom_camera/examples/ui/ui_inventory.tscn ---
Control (Control)
> scene: res://addons/phantom_camera/examples/ui/ui_inventory.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> TextureRect (TextureRect)
> > layout_mode = 1
> > anchors_preset = 4
> > anchor_top = 0.5
> > anchor_bottom = 0.5
> > offset_left = 28.0
> > offset_top = -255.0
> > offset_right = 908.0
> > offset_bottom = 183.0
> > grow_vertical = 2
> > texture = res://addons/phantom_camera/examples/textures/2D/inventory_container.png
>   Label (Label)
>   > layout_mode = 0
>   > offset_left = 345.0
>   > offset_top = 12.0
>   > offset_right = 535.0
>   > offset_bottom = 60.0
>   > text = "Inventory"
>   > horizontal_alignment = 1
>   > uppercase = true

--- SCENE: res://addons/phantom_camera/examples/ui/ui_sign.tscn ---
Control (Control)
> scene: res://addons/phantom_camera/examples/ui/ui_sign.tscn
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> size_flags_horizontal = 3
> size_flags_vertical = 3
> TextureRect (TextureRect)
> > layout_mode = 1
> > anchors_preset = 5
> > anchor_left = 0.5
> > anchor_right = 0.5
> > offset_left = -273.567993164063
> > offset_top = 47.0
> > offset_right = 273.567993164063
> > offset_bottom = 413.0
> > grow_horizontal = 2
> > texture = res://addons/phantom_camera/examples/textures/2D/sign_prompt.png
>   Label (Label)
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = 25.0
>   > offset_top = 64.0
>   > offset_right = -25.0
>   > offset_bottom = -88.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > text = "Stay Awhile\nand read"
>   > horizontal_alignment = 1
>   > vertical_alignment = 1
>   > uppercase = true
> Panel (Panel)
> > visible = false
> > layout_mode = 1
> > anchors_preset = 5
> > anchor_left = 0.5
> > anchor_right = 0.5
> > offset_left = -240.0
> > offset_right = 240.0
> > offset_bottom = 200.0
> > grow_horizontal = 2
> > size_flags_horizontal = 3
> > size_flags_vertical = 3
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > alignment = 1
>     Label2 (Label)
>     > layout_mode = 2
>     > text = "Example Textsdadassa\n"
>     > horizontal_alignment = 1
>     > vertical_alignment = 1

--- SCENE: res://addons/phantom_camera/panel/editor.tscn ---
EditorPanel (VBoxContainer)
> script: res://addons/phantom_camera/scripts/panel/editor.gd
> scene: res://addons/phantom_camera/panel/editor.tscn
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> UpdateButton (Button)
>   script: res://addons/phantom_camera/scripts/panel/updater/update_button.gd
>   scene: res://addons/phantom_camera/panel/updater/update_button.tscn
> > unique_name_in_owner = true
> > visible = false
> > layout_mode = 2
> > size_flags_horizontal = 8
> > text = "Update available"
> > icon = res://addons/phantom_camera/icons/phantom_camera_updater_panel_icon.svg
>   HTTPRequest (HTTPRequest)
>   > unique_name_in_owner = true
>     @Timer@34381 (Timer)
>     > one_shot = true
>   DownloadDialog (AcceptDialog)
>   > unique_name_in_owner = true
>   > transparent_bg = true
>   > title = "New Update"
>   > initial_position = 2
>   > size = (450, 480)
>   > transient = false
>   > unresizable = true
>   > borderless = true
>   > keep_title_visible = false
>   > content_scale_mode = 1
>   > ok_button_text = "Close"
>     DownloadUpdatePanel (Control)
>       script: res://addons/phantom_camera/scripts/panel/updater/download_update_panel.gd
>       scene: res://addons/phantom_camera/panel/updater/download_update_panel.tscn
>     > unique_name_in_owner = true
>     > custom_minimum_size = (300.0, 350.0)
>     > anchors_preset = 15
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > offset_left = 2.0
>     > offset_top = 2.0
>     > offset_right = -2.0
>     > offset_bottom = -80.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>       DownloadHTTPRequest (HTTPRequest)
>       > unique_name_in_owner = true
>         @Timer@34388 (Timer)
>         > one_shot = true
>         Timer (Timer)
>         > one_shot = true
>       VBox (VBoxContainer)
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>         VBoxContainer2 (VBoxContainer)
>         > layout_mode = 2
>           MarginContainer (MarginContainer)
>           > layout_mode = 2
>             Logo (TextureRect)
>             > unique_name_in_owner = true
>             > clip_contents = true
>             > custom_minimum_size = (300.0, 160.0)
>             > layout_mode = 2
>             > texture = res://addons/phantom_camera/icons/phantom_camera_logo.png
>             > expand_mode = 3
>             > stretch_mode = 5
>           VBoxContainer (VBoxContainer)
>           > layout_mode = 2
>             NameLabel (Label)
>             > layout_mode = 2
>             > text = "Phantom Camera"
>             > horizontal_alignment = 1
>             DownloadVersionLabel (Label)
>             > unique_name_in_owner = true
>             > layout_mode = 2
>             > text = "v1.2.3 is available for download."
>             > horizontal_alignment = 1
>         CurrentVersionLabel (Label)
>         > unique_name_in_owner = true
>         > visible = false
>         > layout_mode = 2
>         > text = "Current version: 0.0.0"
>         > horizontal_alignment = 1
>         Center2 (CenterContainer)
>         > layout_mode = 2
>           NotesButton (LinkButton)
>           > layout_mode = 2
>           > text = "Release Notes"
>         Center (CenterContainer)
>         > layout_mode = 2
>           VBoxContainer (VBoxContainer)
>           > layout_mode = 2
>             BreakingLabel (Label)
>             > unique_name_in_owner = true
>             > visible = false
>             > layout_mode = 2
>             > text = "Potential Breaking Changes\nin new release"
>             > horizontal_alignment = 1
>             > uppercase = true
>             BreakingMarginContainer (MarginContainer)
>             > unique_name_in_owner = true
>             > visible = false
>             > layout_mode = 2
>               VBoxContainer (VBoxContainer)
>               > layout_mode = 2
>                 RichTextLabel2 (RichTextLabel)
>                 > layout_mode = 2
>                 > bbcode_enabled = true
>                 > text = "[center][b]I am prepared for any breaking\nchanges that may occur from this update[/b][/center]"
>                 > fit_content = true
>                 BreakingOptionButton (OptionButton)
>                 > unique_name_in_owner = true
>                 > visible = false
>                 > layout_mode = 2
>                 > mouse_default_cursor_shape = 2
>                 > alignment = 1
>                 > selected = 0
>                 > item_count = 2
>             DownloadButton (Button)
>             > unique_name_in_owner = true
>             > custom_minimum_size = (240.0, 90.0)
>             > layout_mode = 2
>             > mouse_default_cursor_shape = 2
>               DownloadButtonBG (NinePatchRect)
>               > unique_name_in_owner = true
>               > layout_mode = 1
>               > anchors_preset = 15
>               > anchor_right = 1.0
>               > anchor_bottom = 1.0
>               > grow_horizontal = 2
>               > grow_vertical = 2
>               > texture = res://addons/phantom_camera/assets/PhantomCameraBtnPrimaryDefault.png
>               > patch_margin_left = 38
>               > patch_margin_top = 37
>               > patch_margin_right = 38
>               > patch_margin_bottom = 39
>               UpdateLabel (Label)
>               > unique_name_in_owner = true
>               > layout_mode = 1
>               > anchors_preset = 14
>               > anchor_top = 0.5
>               > anchor_right = 1.0
>               > anchor_bottom = 0.5
>               > offset_top = -14.5
>               > offset_bottom = 14.5
>               > grow_horizontal = 2
>               > grow_vertical = 2
>               > text = "Update"
>               > horizontal_alignment = 1
>               > uppercase = true
>         MarginContainer (MarginContainer)
>         > layout_mode = 2
>           RichTextLabel (RichTextLabel)
>           > layout_mode = 2
>           > bbcode_enabled = true
>           > text = "[center]The updater can be disabled within:\n[code]Project Settings / Phantom Camera / Updater / Enable Updater[/code][/center]"
>           > fit_content = true
>   NeedsReloadDialog (ConfirmationDialog)
>   > unique_name_in_owner = true
>   UpdateFailedDialog (AcceptDialog)
>   > unique_name_in_owner = true
> ViewfinderPanel (Control)
>   script: res://addons/phantom_camera/scripts/panel/viewfinder/viewfinder.gd
>   scene: res://addons/phantom_camera/panel/viewfinder/viewfinder_panel.tscn
> > unique_name_in_owner = true
> > clip_contents = true
> > custom_minimum_size = (0.0, 300.0)
> > layout_mode = 2
> > size_flags_horizontal = 3
> > size_flags_vertical = 3
> > mouse_filter = 2
>   Viewfinder (Control)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > mouse_filter = 2
>     SubViewportContainer (SubViewportContainer)
>     > unique_name_in_owner = true
>     > layout_mode = 1
>     > anchors_preset = 15
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > mouse_filter = 2
>     > stretch = true
>       SubViewport (SubViewport)
>       > unique_name_in_owner = true
>       > handle_input_locally = false
>       > canvas_item_default_texture_filter = 0
>       > gui_disable_input = true
>       > size = (1152, 648)
>       > size_2d_override_stretch = true
>       > render_target_update_mode = 4
>         Camera2D (Camera2D)
>         > unique_name_in_owner = true
>         > editor_draw_screen = false
>     DeadZoneHBoxContainer (HBoxContainer)
>     > unique_name_in_owner = true
>     > clip_contents = true
>     > layout_mode = 1
>     > anchors_preset = 15
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > mouse_filter = 2
>       DeadZoneLeftHBoxContainer (VBoxContainer)
>       > clip_contents = true
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       > mouse_filter = 2
>         DeadZoneLeftTopPanel (Panel)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>         > mouse_filter = 2
>         DeadZoneLeftCenterPanel (Panel)
>         > unique_name_in_owner = true
>         > layout_mode = 2
>         > mouse_filter = 2
>         DeadZoneLeftBottomPanel (Panel)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>         > mouse_filter = 2
>       DeadZoneCenterHBoxContainer (VBoxContainer)
>       > unique_name_in_owner = true
>       > clip_contents = true
>       > layout_mode = 2
>       > size_flags_horizontal = 4
>       > mouse_filter = 2
>         DeadZoneCenterTopPanel (Panel)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>         > mouse_filter = 2
>         DeadZoneCenterCenterPanel (Panel)
>         > unique_name_in_owner = true
>         > layout_mode = 2
>         > size_flags_vertical = 4
>         > mouse_filter = 2
>         DeadZoneCenterBottomPanel (Panel)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>         > mouse_filter = 2
>       DeadZoneRightHBoxContainer (VBoxContainer)
>       > clip_contents = true
>       > layout_mode = 2
>       > size_flags_horizontal = 3
>       > mouse_filter = 2
>         DeadZoneRightTopPanel (Panel)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>         > mouse_filter = 2
>         DeadZoneRightCenterPanel (Panel)
>         > unique_name_in_owner = true
>         > layout_mode = 2
>         > mouse_filter = 2
>         DeadZoneRightBottomPanel (Panel)
>         > layout_mode = 2
>         > size_flags_vertical = 3
>         > mouse_filter = 2
>     AspectRatioContainer (AspectRatioContainer)
>     > unique_name_in_owner = true
>     > clip_contents = true
>     > layout_mode = 1
>     > anchors_preset = 15
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > mouse_filter = 2
>     > ratio = 1.77778005599976
>       CameraViewportPanel (Panel)
>       > layout_mode = 2
>       > mouse_filter = 2
>         TargetPoint (Panel)
>         > unique_name_in_owner = true
>         > layout_mode = 1
>         > anchors_preset = 8
>         > anchor_left = 0.5
>         > anchor_top = 0.5
>         > anchor_right = 0.5
>         > anchor_bottom = 0.5
>         > offset_left = -3.0
>         > offset_top = -3.0
>         > offset_right = 3.0
>         > offset_bottom = 3.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > mouse_filter = 2
>   NoSupportMsg (Label)
>   > unique_name_in_owner = true
>   > visible = false
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_top = -8.0
>   > offset_bottom = -8.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > text = "Control scenes are not supported"
>   > horizontal_alignment = 1
>   > vertical_alignment = 1
>   EmptyStateControl (Control)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     BGColorRect (ColorRect)
>     > visible = false
>     > layout_mode = 1
>     > anchors_preset = 15
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > color = (0.0, 0.0, 0.0, 1.0)
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 1
>     > anchors_preset = 8
>     > anchor_left = 0.5
>     > anchor_top = 0.5
>     > anchor_right = 0.5
>     > anchor_bottom = 0.5
>     > offset_left = -200.0
>     > offset_top = -112.0
>     > offset_right = 200.0
>     > offset_bottom = 112.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>     > alignment = 1
>       EmptyStateIcon (TextureRect)
>       > unique_name_in_owner = true
>       > custom_minimum_size = (0.0, 64.0)
>       > layout_mode = 2
>       > texture = res://addons/phantom_camera/icons/phantom_camera_host.svg
>       > expand_mode = 1
>       > stretch_mode = 5
>       EmptyStateText (RichTextLabel)
>       > unique_name_in_owner = true
>       > layout_mode = 2
>       > bbcode_enabled = true
>       > text = "[center][b]NodeType[/b] Description [/center]"
>       > fit_content = true
>       AddNodeButton (Button)
>       > unique_name_in_owner = true
>       > custom_minimum_size = (400.0, 54.0)
>       > layout_mode = 2
>       > size_flags_horizontal = 4
>       > focus_mode = 0
>         AddNodeTypeText (RichTextLabel)
>         > unique_name_in_owner = true
>         > layout_mode = 1
>         > anchors_preset = 15
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>         > offset_top = 9.0
>         > offset_bottom = -11.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > mouse_filter = 2
>         > bbcode_enabled = true
>         > text = "[center]Add [img=32]res://addons/phantom_camera/icons/viewfinder/Camera3DIcon.svg[/img] [b]{NodeType}[/b][/center]"
>         > scroll_active = false
>   PriorityOverrideButton (Button)
>   > unique_name_in_owner = true
>   > visible = false
>   > layout_mode = 1
>   > offset_left = 5.0
>   > offset_top = 5.0
>   > offset_right = 165.0
>   > offset_bottom = 57.0
>   > mouse_default_cursor_shape = 2
>     PriorityOverrideIcon (TextureRect)
>     > layout_mode = 1
>     > offset_left = 8.0
>     > offset_top = 4.0
>     > offset_right = 32.0
>     > offset_bottom = 28.0
>     > texture = res://addons/phantom_camera/icons/misc/PriorityOverride.svg
>     > expand_mode = 1
>     PriorityOverrideByLabel (Label)
>     > layout_mode = 0
>     > offset_left = 30.0
>     > offset_top = 1.0
>     > offset_right = 140.0
>     > offset_bottom = 24.0
>     > text = "OVERRIDDEN BY"
>     > vertical_alignment = 1
>     PriorityOverrideNameLabel (Label)
>     > unique_name_in_owner = true
>     > layout_mode = 0
>     > offset_left = 6.0
>     > offset_top = 21.0
>     > offset_right = 153.0
>     > offset_bottom = 44.0
>     > text = "PCam_Name\n"
>     > vertical_alignment = 1
>     > text_overrun_behavior = 3
>   SizeLabel (Label)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = 4
>   > anchor_top = 0.5
>   > anchor_bottom = 0.5
>   > offset_top = -11.5
>   > offset_right = 40.0
>   > offset_bottom = 11.5
>   > grow_vertical = 2
>   PCamHostList (VBoxContainer)
>     script: res://addons/phantom_camera/scripts/panel/viewfinder/host_list.gd
>   > unique_name_in_owner = true
>   > visible = false
>   > layout_mode = 1
>   > anchors_preset = -1
>   > anchor_bottom = 1.0
>   > offset_top = 588.0
>   > grow_vertical = 2
>   > size_flags_horizontal = 0
>   > size_flags_vertical = 0
>   > alignment = 2
>     HostListButton (Button)
>     > unique_name_in_owner = true
>     > custom_minimum_size = (40.0, 40.0)
>     > layout_mode = 2
>     > size_flags_horizontal = 0
>     > icon = res://addons/phantom_camera/icons/phantom_camera_host.svg
>     > expand_icon = true
>     PanelContainer (PanelContainer)
>     > layout_mode = 2
>     > size_flags_vertical = 3
>     > theme = res://addons/phantom_camera/themes/theme.tres
>       ScrollContainer (ScrollContainer)
>       > unique_name_in_owner = true
>       > layout_mode = 2
>       > size_flags_vertical = 3
>       > theme = res://addons/phantom_camera/themes/theme.tres
>       > horizontal_scroll_mode = 0
>         HostListContainer (VBoxContainer)
>         > unique_name_in_owner = true
>         > layout_mode = 2
>         > theme = res://addons/phantom_camera/themes/theme.tres

--- SCENE: res://addons/phantom_camera/panel/updater/download_update_panel.tscn ---
DownloadUpdatePanel (Control)
> script: res://addons/phantom_camera/scripts/panel/updater/download_update_panel.gd
> scene: res://addons/phantom_camera/panel/updater/download_update_panel.tscn
> custom_minimum_size = (300.0, 350.0)
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> offset_bottom = -61.0
> grow_horizontal = 2
> grow_vertical = 2
> DownloadHTTPRequest (HTTPRequest)
> > unique_name_in_owner = true
>   @Timer@34445 (Timer)
>   > one_shot = true
>   Timer (Timer)
>   > one_shot = true
> VBox (VBoxContainer)
> > layout_mode = 1
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   VBoxContainer2 (VBoxContainer)
>   > layout_mode = 2
>     MarginContainer (MarginContainer)
>     > layout_mode = 2
>       Logo (TextureRect)
>       > unique_name_in_owner = true
>       > clip_contents = true
>       > custom_minimum_size = (300.0, 160.0)
>       > layout_mode = 2
>       > texture = res://addons/phantom_camera/icons/phantom_camera_logo.png
>       > expand_mode = 3
>       > stretch_mode = 5
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       NameLabel (Label)
>       > layout_mode = 2
>       > text = "Phantom Camera"
>       > horizontal_alignment = 1
>       DownloadVersionLabel (Label)
>       > unique_name_in_owner = true
>       > layout_mode = 2
>       > text = "v1.2.3 is available for download."
>       > horizontal_alignment = 1
>   CurrentVersionLabel (Label)
>   > unique_name_in_owner = true
>   > visible = false
>   > layout_mode = 2
>   > text = "Current version: 0.0.0"
>   > horizontal_alignment = 1
>   Center2 (CenterContainer)
>   > layout_mode = 2
>     NotesButton (LinkButton)
>     > layout_mode = 2
>     > text = "Release Notes"
>   Center (CenterContainer)
>   > layout_mode = 2
>     VBoxContainer (VBoxContainer)
>     > layout_mode = 2
>       BreakingLabel (Label)
>       > unique_name_in_owner = true
>       > visible = false
>       > layout_mode = 2
>       > text = "Potential Breaking Changes\nin new release"
>       > horizontal_alignment = 1
>       > uppercase = true
>       BreakingMarginContainer (MarginContainer)
>       > unique_name_in_owner = true
>       > visible = false
>       > layout_mode = 2
>         VBoxContainer (VBoxContainer)
>         > layout_mode = 2
>           RichTextLabel2 (RichTextLabel)
>           > layout_mode = 2
>           > bbcode_enabled = true
>           > text = "[center][b]I am prepared for any breaking\nchanges that may occur from this update[/b][/center]"
>           > fit_content = true
>           BreakingOptionButton (OptionButton)
>           > unique_name_in_owner = true
>           > visible = false
>           > layout_mode = 2
>           > mouse_default_cursor_shape = 2
>           > alignment = 1
>           > selected = 0
>           > item_count = 2
>       DownloadButton (Button)
>       > unique_name_in_owner = true
>       > custom_minimum_size = (240.0, 90.0)
>       > layout_mode = 2
>       > mouse_default_cursor_shape = 2
>         DownloadButtonBG (NinePatchRect)
>         > unique_name_in_owner = true
>         > layout_mode = 1
>         > anchors_preset = 15
>         > anchor_right = 1.0
>         > anchor_bottom = 1.0
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > texture = res://addons/phantom_camera/assets/PhantomCameraBtnPrimaryDefault.png
>         > patch_margin_left = 38
>         > patch_margin_top = 37
>         > patch_margin_right = 38
>         > patch_margin_bottom = 39
>         UpdateLabel (Label)
>         > unique_name_in_owner = true
>         > layout_mode = 1
>         > anchors_preset = 14
>         > anchor_top = 0.5
>         > anchor_right = 1.0
>         > anchor_bottom = 0.5
>         > offset_top = -14.5
>         > offset_bottom = 14.5
>         > grow_horizontal = 2
>         > grow_vertical = 2
>         > text = "Update"
>         > horizontal_alignment = 1
>         > uppercase = true
>   MarginContainer (MarginContainer)
>   > layout_mode = 2
>     RichTextLabel (RichTextLabel)
>     > layout_mode = 2
>     > bbcode_enabled = true
>     > text = "[center]The updater can be disabled within:\n[code]Project Settings / Phantom Camera / Updater / Enable Updater[/code][/center]"
>     > fit_content = true

--- SCENE: res://addons/phantom_camera/panel/updater/update_button.tscn ---
UpdateButton (Button)
> script: res://addons/phantom_camera/scripts/panel/updater/update_button.gd
> scene: res://addons/phantom_camera/panel/updater/update_button.tscn
> visible = false
> offset_left = 1.0
> offset_right = 149.0
> offset_bottom = 28.0
> size_flags_vertical = 3
> text = "Update available"
> icon = res://addons/phantom_camera/icons/phantom_camera_updater_panel_icon.svg
> HTTPRequest (HTTPRequest)
> > unique_name_in_owner = true
>   @Timer@34463 (Timer)
>   > one_shot = true
> DownloadDialog (AcceptDialog)
> > unique_name_in_owner = true
> > transparent_bg = true
> > title = "New Update"
> > initial_position = 2
> > size = (450, 480)
> > transient = false
> > unresizable = true
> > borderless = true
> > keep_title_visible = false
> > content_scale_mode = 1
> > ok_button_text = "Close"
>   DownloadUpdatePanel (Control)
>     script: res://addons/phantom_camera/scripts/panel/updater/download_update_panel.gd
>     scene: res://addons/phantom_camera/panel/updater/download_update_panel.tscn
>   > unique_name_in_owner = true
>   > custom_minimum_size = (300.0, 350.0)
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_left = 2.0
>   > offset_top = 2.0
>   > offset_right = -2.0
>   > offset_bottom = -80.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>     DownloadHTTPRequest (HTTPRequest)
>     > unique_name_in_owner = true
>       @Timer@34470 (Timer)
>       > one_shot = true
>       Timer (Timer)
>       > one_shot = true
>     VBox (VBoxContainer)
>     > layout_mode = 1
>     > anchors_preset = 15
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > grow_horizontal = 2
>     > grow_vertical = 2
>       VBoxContainer2 (VBoxContainer)
>       > layout_mode = 2
>         MarginContainer (MarginContainer)
>         > layout_mode = 2
>           Logo (TextureRect)
>           > unique_name_in_owner = true
>           > clip_contents = true
>           > custom_minimum_size = (300.0, 160.0)
>           > layout_mode = 2
>           > texture = res://addons/phantom_camera/icons/phantom_camera_logo.png
>           > expand_mode = 3
>           > stretch_mode = 5
>         VBoxContainer (VBoxContainer)
>         > layout_mode = 2
>           NameLabel (Label)
>           > layout_mode = 2
>           > text = "Phantom Camera"
>           > horizontal_alignment = 1
>           DownloadVersionLabel (Label)
>           > unique_name_in_owner = true
>           > layout_mode = 2
>           > text = "v1.2.3 is available for download."
>           > horizontal_alignment = 1
>       CurrentVersionLabel (Label)
>       > unique_name_in_owner = true
>       > visible = false
>       > layout_mode = 2
>       > text = "Current version: 0.0.0"
>       > horizontal_alignment = 1
>       Center2 (CenterContainer)
>       > layout_mode = 2
>         NotesButton (LinkButton)
>         > layout_mode = 2
>         > text = "Release Notes"
>       Center (CenterContainer)
>       > layout_mode = 2
>         VBoxContainer (VBoxContainer)
>         > layout_mode = 2
>           BreakingLabel (Label)
>           > unique_name_in_owner = true
>           > visible = false
>           > layout_mode = 2
>           > text = "Potential Breaking Changes\nin new release"
>           > horizontal_alignment = 1
>           > uppercase = true
>           BreakingMarginContainer (MarginContainer)
>           > unique_name_in_owner = true
>           > visible = false
>           > layout_mode = 2
>             VBoxContainer (VBoxContainer)
>             > layout_mode = 2
>               RichTextLabel2 (RichTextLabel)
>               > layout_mode = 2
>               > bbcode_enabled = true
>               > text = "[center][b]I am prepared for any breaking\nchanges that may occur from this update[/b][/center]"
>               > fit_content = true
>               BreakingOptionButton (OptionButton)
>               > unique_name_in_owner = true
>               > visible = false
>               > layout_mode = 2
>               > mouse_default_cursor_shape = 2
>               > alignment = 1
>               > selected = 0
>               > item_count = 2
>           DownloadButton (Button)
>           > unique_name_in_owner = true
>           > custom_minimum_size = (240.0, 90.0)
>           > layout_mode = 2
>           > mouse_default_cursor_shape = 2
>             DownloadButtonBG (NinePatchRect)
>             > unique_name_in_owner = true
>             > layout_mode = 1
>             > anchors_preset = 15
>             > anchor_right = 1.0
>             > anchor_bottom = 1.0
>             > grow_horizontal = 2
>             > grow_vertical = 2
>             > texture = res://addons/phantom_camera/assets/PhantomCameraBtnPrimaryDefault.png
>             > patch_margin_left = 38
>             > patch_margin_top = 37
>             > patch_margin_right = 38
>             > patch_margin_bottom = 39
>             UpdateLabel (Label)
>             > unique_name_in_owner = true
>             > layout_mode = 1
>             > anchors_preset = 14
>             > anchor_top = 0.5
>             > anchor_right = 1.0
>             > anchor_bottom = 0.5
>             > offset_top = -14.5
>             > offset_bottom = 14.5
>             > grow_horizontal = 2
>             > grow_vertical = 2
>             > text = "Update"
>             > horizontal_alignment = 1
>             > uppercase = true
>       MarginContainer (MarginContainer)
>       > layout_mode = 2
>         RichTextLabel (RichTextLabel)
>         > layout_mode = 2
>         > bbcode_enabled = true
>         > text = "[center]The updater can be disabled within:\n[code]Project Settings / Phantom Camera / Updater / Enable Updater[/code][/center]"
>         > fit_content = true
> NeedsReloadDialog (ConfirmationDialog)
> > unique_name_in_owner = true
> UpdateFailedDialog (AcceptDialog)
> > unique_name_in_owner = true

--- SCENE: res://addons/phantom_camera/panel/viewfinder/host_list/host_list.tscn ---
PCamHostList (VBoxContainer)
> script: res://addons/phantom_camera/scripts/panel/viewfinder/host_list.gd
> scene: res://addons/phantom_camera/panel/viewfinder/host_list/host_list.tscn
> anchor_bottom = 1.0
> size_flags_horizontal = 0
> size_flags_vertical = 0
> alignment = 2
> HostListButton (Button)
> > unique_name_in_owner = true
> > custom_minimum_size = (40.0, 40.0)
> > layout_mode = 2
> > size_flags_horizontal = 0
> > icon = res://addons/phantom_camera/icons/phantom_camera_host.svg
> > expand_icon = true
> ScrollContainer (ScrollContainer)
> > unique_name_in_owner = true
> > layout_mode = 2
> > size_flags_vertical = 3
> > horizontal_scroll_mode = 0
>   HostListContainer (VBoxContainer)
>   > unique_name_in_owner = true
>   > layout_mode = 2

--- SCENE: res://addons/phantom_camera/panel/viewfinder/host_list/host_list_item.tscn ---
HostListItem (PanelContainer)
> script: res://addons/phantom_camera/scripts/panel/viewfinder/host_list_item.gd
> scene: res://addons/phantom_camera/panel/viewfinder/host_list/host_list_item.tscn
> offset_right = 229.0
> offset_bottom = 34.0
> HBoxContainer (HBoxContainer)
> > layout_mode = 2
>   SelectPCamHost (Button)
>   > unique_name_in_owner = true
>   > layout_mode = 2
>   > size_flags_vertical = 4
>   > tooltip_text = "Select the Phantom Camera Host node from the scene hierarchy"
>   > focus_mode = 0
>   > theme = res://addons/phantom_camera/panel/viewfinder/host_list/host_list_item.tscn::Theme_7h15c
>   > icon = res://addons/phantom_camera/icons/viewfinder/Select.svg
>   > flat = true
>   HBoxContainer (HBoxContainer)
>   > layout_mode = 2
>     ErrorPCamHost (TextureRect)
>     > unique_name_in_owner = true
>     > custom_minimum_size = (18.0, 18.0)
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     > size_flags_vertical = 4
>     > tooltip_text = "This Phantom Camera Host node will not affect a Camera node.\nSee the warning in the Scene Tree for more information."
>     > texture = res://addons/phantom_camera/icons/warning.svg
>     > expand_mode = 1
>     SwitchPCamHost (Button)
>     > unique_name_in_owner = true
>     > custom_minimum_size = (40.0, 0.0)
>     > layout_mode = 2
>     > tooltip_text = "Change the viewfinder\'s camera to the camera of this Phantom Camera Host"
>     > theme = res://addons/phantom_camera/themes/theme.tres
>     > toggle_mode = true
>     > button_group = 
>     > text = "{ PCamHostName }"

--- SCENE: res://addons/phantom_camera/panel/viewfinder/viewfinder_panel.tscn ---
ViewfinderPanel (Control)
> script: res://addons/phantom_camera/scripts/panel/viewfinder/viewfinder.gd
> scene: res://addons/phantom_camera/panel/viewfinder/viewfinder_panel.tscn
> clip_contents = true
> custom_minimum_size = (0.0, 300.0)
> anchors_preset = 15
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> size_flags_horizontal = 3
> size_flags_vertical = 3
> mouse_filter = 2
> Viewfinder (Control)
> > unique_name_in_owner = true
> > layout_mode = 1
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > mouse_filter = 2
>   SubViewportContainer (SubViewportContainer)
>   > unique_name_in_owner = true
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > mouse_filter = 2
>   > stretch = true
>     SubViewport (SubViewport)
>     > unique_name_in_owner = true
>     > handle_input_locally = false
>     > canvas_item_default_texture_filter = 0
>     > gui_disable_input = true
>     > size = (1152, 648)
>     > size_2d_override_stretch = true
>     > render_target_update_mode = 4
>       Camera2D (Camera2D)
>       > unique_name_in_owner = true
>       > editor_draw_screen = false
>   DeadZoneHBoxContainer (HBoxContainer)
>   > unique_name_in_owner = true
>   > clip_contents = true
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > mouse_filter = 2
>     DeadZoneLeftHBoxContainer (VBoxContainer)
>     > clip_contents = true
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     > mouse_filter = 2
>       DeadZoneLeftTopPanel (Panel)
>       > layout_mode = 2
>       > size_flags_vertical = 3
>       > mouse_filter = 2
>       DeadZoneLeftCenterPanel (Panel)
>       > unique_name_in_owner = true
>       > layout_mode = 2
>       > mouse_filter = 2
>       DeadZoneLeftBottomPanel (Panel)
>       > layout_mode = 2
>       > size_flags_vertical = 3
>       > mouse_filter = 2
>     DeadZoneCenterHBoxContainer (VBoxContainer)
>     > unique_name_in_owner = true
>     > clip_contents = true
>     > layout_mode = 2
>     > size_flags_horizontal = 4
>     > mouse_filter = 2
>       DeadZoneCenterTopPanel (Panel)
>       > layout_mode = 2
>       > size_flags_vertical = 3
>       > mouse_filter = 2
>       DeadZoneCenterCenterPanel (Panel)
>       > unique_name_in_owner = true
>       > layout_mode = 2
>       > size_flags_vertical = 4
>       > mouse_filter = 2
>       DeadZoneCenterBottomPanel (Panel)
>       > layout_mode = 2
>       > size_flags_vertical = 3
>       > mouse_filter = 2
>     DeadZoneRightHBoxContainer (VBoxContainer)
>     > clip_contents = true
>     > layout_mode = 2
>     > size_flags_horizontal = 3
>     > mouse_filter = 2
>       DeadZoneRightTopPanel (Panel)
>       > layout_mode = 2
>       > size_flags_vertical = 3
>       > mouse_filter = 2
>       DeadZoneRightCenterPanel (Panel)
>       > unique_name_in_owner = true
>       > layout_mode = 2
>       > mouse_filter = 2
>       DeadZoneRightBottomPanel (Panel)
>       > layout_mode = 2
>       > size_flags_vertical = 3
>       > mouse_filter = 2
>   AspectRatioContainer (AspectRatioContainer)
>   > unique_name_in_owner = true
>   > clip_contents = true
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > mouse_filter = 2
>   > ratio = 1.77778005599976
>     CameraViewportPanel (Panel)
>     > layout_mode = 2
>     > mouse_filter = 2
>       TargetPoint (Panel)
>       > unique_name_in_owner = true
>       > layout_mode = 1
>       > anchors_preset = 8
>       > anchor_left = 0.5
>       > anchor_top = 0.5
>       > anchor_right = 0.5
>       > anchor_bottom = 0.5
>       > offset_left = -3.0
>       > offset_top = -3.0
>       > offset_right = 3.0
>       > offset_bottom = 3.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > mouse_filter = 2
> NoSupportMsg (Label)
> > unique_name_in_owner = true
> > visible = false
> > layout_mode = 1
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > offset_top = -8.0
> > offset_bottom = -8.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > text = "Control scenes are not supported"
> > horizontal_alignment = 1
> > vertical_alignment = 1
> EmptyStateControl (Control)
> > unique_name_in_owner = true
> > layout_mode = 1
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   BGColorRect (ColorRect)
>   > visible = false
>   > layout_mode = 1
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > color = (0.0, 0.0, 0.0, 1.0)
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 1
>   > anchors_preset = 8
>   > anchor_left = 0.5
>   > anchor_top = 0.5
>   > anchor_right = 0.5
>   > anchor_bottom = 0.5
>   > offset_left = -200.0
>   > offset_top = -112.0
>   > offset_right = 200.0
>   > offset_bottom = 112.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > alignment = 1
>     EmptyStateIcon (TextureRect)
>     > unique_name_in_owner = true
>     > custom_minimum_size = (0.0, 64.0)
>     > layout_mode = 2
>     > texture = res://addons/phantom_camera/icons/phantom_camera_host.svg
>     > expand_mode = 1
>     > stretch_mode = 5
>     EmptyStateText (RichTextLabel)
>     > unique_name_in_owner = true
>     > layout_mode = 2
>     > bbcode_enabled = true
>     > text = "[center][b]NodeType[/b] Description [/center]"
>     > fit_content = true
>     AddNodeButton (Button)
>     > unique_name_in_owner = true
>     > custom_minimum_size = (400.0, 54.0)
>     > layout_mode = 2
>     > size_flags_horizontal = 4
>     > focus_mode = 0
>       AddNodeTypeText (RichTextLabel)
>       > unique_name_in_owner = true
>       > layout_mode = 1
>       > anchors_preset = 15
>       > anchor_right = 1.0
>       > anchor_bottom = 1.0
>       > offset_top = 9.0
>       > offset_bottom = -11.0
>       > grow_horizontal = 2
>       > grow_vertical = 2
>       > mouse_filter = 2
>       > bbcode_enabled = true
>       > text = "[center]Add [img=32]res://addons/phantom_camera/icons/viewfinder/Camera3DIcon.svg[/img] [b]{NodeType}[/b][/center]"
>       > scroll_active = false
> PriorityOverrideButton (Button)
> > unique_name_in_owner = true
> > visible = false
> > layout_mode = 1
> > offset_left = 5.0
> > offset_top = 5.0
> > offset_right = 165.0
> > offset_bottom = 57.0
> > mouse_default_cursor_shape = 2
>   PriorityOverrideIcon (TextureRect)
>   > layout_mode = 1
>   > offset_left = 8.0
>   > offset_top = 4.0
>   > offset_right = 32.0
>   > offset_bottom = 28.0
>   > texture = res://addons/phantom_camera/icons/misc/PriorityOverride.svg
>   > expand_mode = 1
>   PriorityOverrideByLabel (Label)
>   > layout_mode = 0
>   > offset_left = 30.0
>   > offset_top = 1.0
>   > offset_right = 140.0
>   > offset_bottom = 24.0
>   > text = "OVERRIDDEN BY"
>   > vertical_alignment = 1
>   PriorityOverrideNameLabel (Label)
>   > unique_name_in_owner = true
>   > layout_mode = 0
>   > offset_left = 6.0
>   > offset_top = 21.0
>   > offset_right = 153.0
>   > offset_bottom = 44.0
>   > text = "PCam_Name\n"
>   > vertical_alignment = 1
>   > text_overrun_behavior = 3
> SizeLabel (Label)
> > unique_name_in_owner = true
> > layout_mode = 1
> > anchors_preset = 4
> > anchor_top = 0.5
> > anchor_bottom = 0.5
> > offset_top = -11.5
> > offset_right = 40.0
> > offset_bottom = 11.5
> > grow_vertical = 2
> PCamHostList (VBoxContainer)
>   script: res://addons/phantom_camera/scripts/panel/viewfinder/host_list.gd
> > unique_name_in_owner = true
> > visible = false
> > layout_mode = 1
> > anchors_preset = -1
> > anchor_bottom = 1.0
> > offset_top = 588.0
> > grow_vertical = 2
> > size_flags_horizontal = 0
> > size_flags_vertical = 0
> > alignment = 2
>   HostListButton (Button)
>   > unique_name_in_owner = true
>   > custom_minimum_size = (40.0, 40.0)
>   > layout_mode = 2
>   > size_flags_horizontal = 0
>   > icon = res://addons/phantom_camera/icons/phantom_camera_host.svg
>   > expand_icon = true
>   PanelContainer (PanelContainer)
>   > layout_mode = 2
>   > size_flags_vertical = 3
>   > theme = res://addons/phantom_camera/themes/theme.tres
>     ScrollContainer (ScrollContainer)
>     > unique_name_in_owner = true
>     > layout_mode = 2
>     > size_flags_vertical = 3
>     > theme = res://addons/phantom_camera/themes/theme.tres
>     > horizontal_scroll_mode = 0
>       HostListContainer (VBoxContainer)
>       > unique_name_in_owner = true
>       > layout_mode = 2
>       > theme = res://addons/phantom_camera/themes/theme.tres

--- SCENE: res://Enemies/CustomVisionCone.tscn ---
VisionConeArea (Area2D)
> script: res://Enemies/CustomVisionCone.tscn::GDScript_txeai
> scene: res://Enemies/CustomVisionCone.tscn
> scale = (0.5, 0.5)
> radius = 200.0
> angle_degrees = 60.0
> ray_count = 30
> collision_mask_override = 1
> CollisionPolygon2D (CollisionPolygon2D)
> > polygon = [(201.3, -22.6), (201.3, 64.0), (1.3, 2.6)]
> VisionConePolygon (Polygon2D)
> > color = (0.3922, 0.3922, 0.0, 0.6196)
> > polygon = [(201.3, -22.6), (201.3, 64.0), (1.3, 2.6)]

--- SCENE: res://Enemies/Guard/Guard.tscn ---
Guard (CharacterBody2D)
> script: res://Enemies/Guard/Guard.gd
> scene: res://Enemies/Guard/Guard.tscn
> scale = (0.6, 0.6)
> collision_mask = 2
> speed = 50.0
> vision_cone_neutral_color = (1.0, 1.0, 1.0, 0.2)
> vision_cone_suspicious_color = (1.0, 1.0, 0.0, 0.25)
> vision_cone_alert_color = (1.0, 0.0, 0.0, 0.3)
> CollisionShape2D (CollisionShape2D)
> > position = (-4.16667, 30.3333)
> > shape = res://Enemies/Guard/Guard.tscn::RectangleShape2D_gyn35
> AnimatedSprite2D (AnimatedSprite2D)
> > sprite_frames = res://Enemies/Guard/Guard.tscn::SpriteFrames_a34ki
> > animation = walk
> > frame_progress = 0.02958899922669
> TurnCooldownTimer (Timer)
> > one_shot = true
> LedgeCheckRay (RayCast2D)
> > position = (11.6667, 55.0)
> > collision_mask = 2
> GroundCheckRay (RayCast2D)
> > position = (-3.33333, 21.6667)
> > collision_mask = 2
> WallCheckRay (RayCast2D)
> > position = (0.0, 21.33)
> > target_position = (50.0, 0.337)
> > collision_mask = 2
> StateMachine (Node)
>   script: res://Enemies/Guard/States/guard_state_machine.gd
> > initial_state = PatrolState:<Node#6543600876823>
>   PatrolState (Node)
>     script: res://Enemies/Guard/States/patrol_state.gd
>   CaughtState (Node)
>     script: res://Enemies/Guard/States/caught_state.gd
> VisionCone2D (Node2D)
>   script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d.gd
>   scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d_template.tscn
> > angle_deg = 60
> > ray_count = 30
> > max_distance = 150.0
> > collision_layer_mask = 2
> > write_collision_polygon = VisionConeCollider:<CollisionPolygon2D#6543684763191>
> > write_polygon2d = VisionConeRenderer:<Polygon2D#6543651208647>
> > debug_lines = false
> > debug_shape = false
> > minimum_recalculate_time_msec = 100
> > recalculate_if_static = true
> > static_threshold = 2.0
> > min_distance_sqr = 16.0
>   VisionConeRenderer (Polygon2D)
>   > color = (0.4314, 0.9294, 0.2784, 0.2863)
>   VisionConeArea (Area2D)
>   > collision_layer = 0
>   > monitorable = false
>     VisionConeCollider (CollisionPolygon2D)
>   DebugDraw (Node2D)
>     script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/cone_editor_helper.gd
>   > is_visible = true
>   > color = (1.0, 0.0, 0.0, 1.0)

--- SCENE: res://Interactables/ArcherPlaceholder.tscn ---
ArcherPlaceHolder (Node2D)
> scene: res://Interactables/ArcherPlaceholder.tscn
> AnimatedSprite2D (AnimatedSprite2D)
> > scale = (1.20313, 1.21094)
> > sprite_frames = res://Interactables/ArcherPlaceholder.tscn::SpriteFrames_enote
> > animation = idle
> > autoplay = "idle"
> > frame_progress = 0.55470299720764

--- SCENE: res://Interactables/Campfire.tscn ---
Campfire (StaticBody2D)
> script: res://Interactables/Campfire.gd
> scene: res://Interactables/Campfire.tscn
> CollisionShape2D (CollisionShape2D)
> > shape = res://Interactables/Campfire.tscn::CircleShape2D_4rtkt
> AnimatedSprite2D (AnimatedSprite2D)
> > scale = (1.5, 1.5)
> > sprite_frames = res://Interactables/Campfire.tscn::SpriteFrames_o5grn
> > autoplay = "default"
> > frame_progress = 0.27172300219536
> Interactable (Area2D)
>   script: res://Interactables/Interactable.gd
>   scene: res://Interactables/Interactable.tscn
> > prompt_message = "Interact"
> > prompt_vertical_offset = -40.0
> > interaction_duration = 1.0
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://Interactables/Interactable.tscn::CircleShape2D_nuwr0

--- SCENE: res://Interactables/Interactable.tscn ---
Interactable (Area2D)
> script: res://Interactables/Interactable.gd
> scene: res://Interactables/Interactable.tscn
> prompt_message = "Interact"
> prompt_vertical_offset = -40.0
> interaction_duration = 1.0
> CollisionShape2D (CollisionShape2D)
> > shape = res://Interactables/Interactable.tscn::CircleShape2D_nuwr0

--- SCENE: res://Interactables/MissionBoard.tscn ---
MissionBoard (StaticBody2D)
> script: res://Interactables/MissionBoard.gd
> scene: res://Interactables/MissionBoard.tscn
> Sprite2D (Sprite2D)
> > texture = res://assets/signpost32px.png
> CollisionShape2D (CollisionShape2D)
> > shape = res://Interactables/MissionBoard.tscn::RectangleShape2D_0ghu3
> Interactable (Area2D)
>   script: res://Interactables/Interactable.gd
>   scene: res://Interactables/Interactable.tscn
> > prompt_message = "Start Mission"
> > prompt_vertical_offset = -50.0
> > interaction_duration = 1.0
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://Interactables/Interactable.tscn::CircleShape2D_nuwr0

--- SCENE: res://Interactables/Prisoner/Prisoner.tscn ---
Prisoner (StaticBody2D)
> script: res://Interactables/Prisoner/Prisoner.gd
> scene: res://Interactables/Prisoner/Prisoner.tscn
> CollisionShape2D (CollisionShape2D)
> > position = (1.0, 15.0)
> > shape = res://Interactables/Prisoner/Prisoner.tscn::RectangleShape2D_cw31s
> AnimatedSprite2D (AnimatedSprite2D)
> > sprite_frames = res://Interactables/Prisoner/Prisoner.tscn::SpriteFrames_1j4pt
> > animation = idle
> Interactable (Area2D)
>   script: res://Interactables/Interactable.gd
>   scene: res://Interactables/Interactable.tscn
> > prompt_message = "Rescue"
> > prompt_vertical_offset = -40.0
> > interaction_duration = 1.5
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, 16.0)
>   > shape = res://Interactables/Interactable.tscn::CircleShape2D_nuwr0
> PersistenceComponent (Node)
>   script: res://Interactables/PersistenceComponent.gd
> > object_id = ""
> > generate_new_id = false
> AnimationPlayer (AnimationPlayer)
> > libraries = {"":"<AnimationLibrary#-9223369823252037334>"}

--- SCENE: res://Interactables/RescuedVillager/RescuedVillager.tscn ---
RescuedVillager (StaticBody2D)
> script: res://Interactables/RescuedVillager/RescuedVillager.gd
> scene: res://Interactables/RescuedVillager/RescuedVillager.tscn
> dialogue_message = "Thank you!"
> CollisionShape2D (CollisionShape2D)
> > position = (0.0, 14.5)
> > shape = res://Interactables/RescuedVillager/RescuedVillager.tscn::RectangleShape2D_mdajx
> InteractionArea (Area2D)
>   script: res://Interactables/Interactable.gd
> > prompt_message = "Interact"
> > prompt_vertical_offset = -40.0
> > interaction_duration = 0.2
>   CollisionShape2D (CollisionShape2D)
>   > position = (-1.0, 15.5)
>   > shape = res://Interactables/RescuedVillager/RescuedVillager.tscn::CircleShape2D_3pwis
> AnimatedSprite2D (AnimatedSprite2D)
> > sprite_frames = res://Interactables/RescuedVillager/RescuedVillager.tscn::SpriteFrames_b8v8i
> > frame_progress = 0.38301599025726

--- SCENE: res://Interactables/Spike.tscn ---
Spike (StaticBody2D)
> scene: res://Interactables/Spike.tscn
> CollisionPolygon2D (CollisionPolygon2D)
>   groups = [&"hazards"]
> > position = (0.427778, 0.044617)
> > scale = (0.986111, 0.999282)
> > polygon = [(2.0, -51.0), (20.0, 35.0), (-16.0, 36.0)]
> SteelspikeUp (Sprite2D)
> > position = (2.0, -7.0)
> > texture = res://assets/spikey stuff/spikeystuff/SteelspikeUp.png

--- SCENE: res://Levels/CameraBoundary.tscn ---
CameraBoundary (Area2D)
> scene: res://Levels/CameraBoundary.tscn
> groups = [&"camera_boundary"]
> CollisionShape2D (CollisionShape2D)
> > shape = res://Levels/CameraBoundary.tscn::RectangleShape2D_r8dwf

--- SCENE: res://Levels/Hideout/Hideout.tscn ---
Hideout (Node2D)
> script: res://Levels/Hideout.gd
> scene: res://Levels/Hideout/Hideout.tscn
> position = (56.0, -17.0)
> ParallaxBackground (ParallaxBackground)
> > scale = (1.2, 1.2)
> > transform = [X: (1.2, 0.0), Y: (0.0, 1.2), O: (0.0, 0.0)]
>   CloudsBack (ParallaxLayer)
>   > motion_scale = (0.01, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/CloudsBack.png
>     > expand_mode = 1
>     > stretch_mode = 6
>   CoudsFront (ParallaxLayer)
>   > motion_scale = (0.05, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/CloudsFront.png
>     > expand_mode = 1
>     > stretch_mode = 6
>   BGBack (ParallaxLayer)
>   > motion_scale = (0.075, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/BGBack.png
>     > expand_mode = 1
>     > stretch_mode = 6
>   BGFront (ParallaxLayer)
>   > motion_scale = (0.1, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/BGFront.png
>     > expand_mode = 1
>     > stretch_mode = 6
> CanvasLayer (CanvasLayer)
>   GUI (Control)
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > theme = res://Levels/Hideout/hideout_theme.tres
>     ResourceDisplay (MarginContainer)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -20.0
>     > offset_right = 20.0
>     > offset_bottom = 62.0
>     > grow_horizontal = 2
>       PanelContainer (PanelContainer)
>       > layout_mode = 2
>         HBoxContainer (HBoxContainer)
>         > layout_mode = 2
>           VillagerLabel (Label)
>           > layout_mode = 2
>           GoldLabel (Label)
>           > layout_mode = 2
>           ArcherLabel (Label)
>           > layout_mode = 2
>     TrainArcherButton (Button)
>     > layout_mode = 1
>     > anchors_preset = 3
>     > anchor_left = 1.0
>     > anchor_top = 1.0
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > offset_left = -110.0
>     > offset_top = -36.0
>     > offset_right = -6.0
>     > offset_bottom = -5.0
>     > grow_horizontal = 0
>     > grow_vertical = 0
>     > text = "Train Archer"
> TileMapLayer (TileMapLayer)
> > position = (-26.0, 129.0)
> > tile_set = res://Levels/Hideout/Hideout.tscn::TileSet_0vrxt
> RescuedVillager (StaticBody2D)
>   script: res://Interactables/RescuedVillager/RescuedVillager.gd
>   scene: res://Interactables/RescuedVillager/RescuedVillager.tscn
> > position = (494.0, 720.0)
> > dialogue_message = "Thank you!"
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, 14.5)
>   > shape = res://Interactables/RescuedVillager/RescuedVillager.tscn::RectangleShape2D_mdajx
>   InteractionArea (Area2D)
>     script: res://Interactables/Interactable.gd
>   > prompt_message = "Interact"
>   > prompt_vertical_offset = -40.0
>   > interaction_duration = 0.2
>     CollisionShape2D (CollisionShape2D)
>     > position = (-1.0, 15.5)
>     > shape = res://Interactables/RescuedVillager/RescuedVillager.tscn::CircleShape2D_3pwis
>   AnimatedSprite2D (AnimatedSprite2D)
>   > sprite_frames = res://Interactables/RescuedVillager/RescuedVillager.tscn::SpriteFrames_b8v8i
>   > frame_progress = 0.38301599025726
> PlayerSpawnPoint (Marker2D)
> > position = (66.0, 663.0)
> DialogueBox (CanvasLayer)
>   script: res://UserInterface/DialogueBox.gd
>   scene: res://UserInterface/DialogueBox.tscn
>   groups = [&"DialogueBox"]
> > process_mode = 3
> > visible = false
>   MarginContainer (MarginContainer)
>   > custom_minimum_size = (100.0, 100.0)
>   > anchors_preset = 12
>   > anchor_top = 1.0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_top = -75.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>     Panel (Panel)
>     > custom_minimum_size = (150.0, 75.0)
>     > layout_mode = 2
>       Label (Label)
>       > layout_mode = 1
>       > offset_right = 130.0
>       > offset_bottom = 61.0
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > autowrap_mode = 3
> ArcheryRange (Node2D)
> > position = (722.0, 742.0)
> CameraBoundary (Area2D)
>   scene: res://Levels/CameraBoundary.tscn
>   groups = [&"camera_boundary"]
> > visible = false
>   CollisionShape2D (CollisionShape2D)
>   > position = (523.5, 519.5)
>   > shape = res://Levels/Hideout/Hideout.tscn::RectangleShape2D_df04x
> MissionBoard (StaticBody2D)
>   script: res://Interactables/MissionBoard.gd
>   scene: res://Interactables/MissionBoard.tscn
> > position = (1002.0, 742.0)
>   Sprite2D (Sprite2D)
>   > texture = res://assets/signpost32px.png
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://Interactables/MissionBoard.tscn::RectangleShape2D_0ghu3
>   Interactable (Area2D)
>     script: res://Interactables/Interactable.gd
>     scene: res://Interactables/Interactable.tscn
>   > prompt_message = "Start Mission"
>   > prompt_vertical_offset = -50.0
>   > interaction_duration = 1.0
>     CollisionShape2D (CollisionShape2D)
>     > shape = res://Interactables/Interactable.tscn::CircleShape2D_nuwr0

--- SCENE: res://Levels/Hideout/Hideout_Level_1.tscn ---
Hideout (Node2D)
> script: res://Levels/Hideout.gd
> scene: res://Levels/Hideout/Hideout_Level_1.tscn
> position = (56.0, -17.0)
> archer_placeholder_scene = res://Interactables/ArcherPlaceholder.tscn
> ParallaxBackground (ParallaxBackground)
> > scale = (1.2, 1.2)
> > transform = [X: (1.2, 0.0), Y: (0.0, 1.2), O: (0.0, 0.0)]
>   CloudsBack (ParallaxLayer)
>   > motion_scale = (0.01, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/CloudsBack.png
>     > expand_mode = 1
>     > stretch_mode = 6
>   CoudsFront (ParallaxLayer)
>   > motion_scale = (0.05, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/CloudsFront.png
>     > expand_mode = 1
>     > stretch_mode = 6
>   BGBack (ParallaxLayer)
>   > motion_scale = (0.075, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/BGBack.png
>     > expand_mode = 1
>     > stretch_mode = 6
>   BGFront (ParallaxLayer)
>   > motion_scale = (0.1, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/BGFront.png
>     > expand_mode = 1
>     > stretch_mode = 6
> CanvasLayer (CanvasLayer)
>   GUI (Control)
>     script: res://Levels/Hideout/Hideout_Level_1.tscn::GDScript_nptum
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > theme = res://Levels/Hideout/hideout_theme.tres
>   > archer_placeholder_scene = res://Interactables/ArcherPlaceholder.tscn
>     ResourceDisplay (MarginContainer)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -20.0
>     > offset_right = 20.0
>     > offset_bottom = 62.0
>     > grow_horizontal = 2
>       PanelContainer (PanelContainer)
>       > layout_mode = 2
>         HBoxContainer (HBoxContainer)
>         > layout_mode = 2
>           VillagerLabel (Label)
>           > layout_mode = 2
>           GoldLabel (Label)
>           > layout_mode = 2
>           ArcherLabel (Label)
>           > layout_mode = 2
>     TrainArcherButton (Button)
>     > layout_mode = 1
>     > anchors_preset = 3
>     > anchor_left = 1.0
>     > anchor_top = 1.0
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > offset_left = -110.0
>     > offset_top = -36.0
>     > offset_right = -6.0
>     > offset_bottom = -5.0
>     > grow_horizontal = 0
>     > grow_vertical = 0
>     > text = "Train Archer"
> TileMapLayer (TileMapLayer)
> > position = (-26.0, 129.0)
> > tile_set = res://Levels/Hideout/Hideout_Level_1.tscn::TileSet_0vrxt
> RescuedVillager (StaticBody2D)
>   script: res://Interactables/RescuedVillager/RescuedVillager.gd
>   scene: res://Interactables/RescuedVillager/RescuedVillager.tscn
> > position = (886.0, 718.0)
> > dialogue_message = "Thank you!"
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, 14.5)
>   > shape = res://Interactables/RescuedVillager/RescuedVillager.tscn::RectangleShape2D_mdajx
>   InteractionArea (Area2D)
>     script: res://Interactables/Interactable.gd
>   > prompt_message = "Interact"
>   > prompt_vertical_offset = -40.0
>   > interaction_duration = 0.2
>     CollisionShape2D (CollisionShape2D)
>     > position = (-1.0, 15.5)
>     > shape = res://Interactables/RescuedVillager/RescuedVillager.tscn::CircleShape2D_3pwis
>   AnimatedSprite2D (AnimatedSprite2D)
>   > sprite_frames = res://Interactables/RescuedVillager/RescuedVillager.tscn::SpriteFrames_b8v8i
>   > frame_progress = 0.38301599025726
> PlayerSpawnPoint (Marker2D)
> > position = (66.0, 663.0)
> DialogueBox (CanvasLayer)
>   script: res://UserInterface/DialogueBox.gd
>   scene: res://UserInterface/DialogueBox.tscn
>   groups = [&"DialogueBox"]
> > process_mode = 3
> > visible = false
>   MarginContainer (MarginContainer)
>   > custom_minimum_size = (100.0, 100.0)
>   > anchors_preset = 12
>   > anchor_top = 1.0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_top = -75.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>     Panel (Panel)
>     > custom_minimum_size = (150.0, 75.0)
>     > layout_mode = 2
>       Label (Label)
>       > layout_mode = 1
>       > offset_right = 130.0
>       > offset_bottom = 61.0
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > autowrap_mode = 3
> ArcheryRange (Node2D)
> > position = (722.0, 742.0)
> CameraBoundary (Area2D)
>   scene: res://Levels/CameraBoundary.tscn
>   groups = [&"camera_boundary"]
> > visible = false
>   CollisionShape2D (CollisionShape2D)
>   > position = (523.5, 519.5)
>   > shape = res://Levels/Hideout/Hideout_Level_1.tscn::RectangleShape2D_df04x
> MissionBoard (StaticBody2D)
>   script: res://Interactables/MissionBoard.gd
>   scene: res://Interactables/MissionBoard.tscn
> > position = (1002.0, 742.0)
>   Sprite2D (Sprite2D)
>   > texture = res://assets/signpost32px.png
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://Interactables/MissionBoard.tscn::RectangleShape2D_0ghu3
>   Interactable (Area2D)
>     script: res://Interactables/Interactable.gd
>     scene: res://Interactables/Interactable.tscn
>   > prompt_message = "Start Mission"
>   > prompt_vertical_offset = -50.0
>   > interaction_duration = 1.0
>     CollisionShape2D (CollisionShape2D)
>     > shape = res://Interactables/Interactable.tscn::CircleShape2D_nuwr0
> Campfire (StaticBody2D)
>   script: res://Interactables/Campfire.gd
>   scene: res://Interactables/Campfire.tscn
> > position = (469.0, 717.0)
>   CollisionShape2D (CollisionShape2D)
>   > position = (1.5, 2.0)
>   > shape = res://Levels/Hideout/Hideout_Level_1.tscn::RectangleShape2D_nptum
>   AnimatedSprite2D (AnimatedSprite2D)
>   > scale = (1.5, 1.5)
>   > sprite_frames = res://Interactables/Campfire.tscn::SpriteFrames_o5grn
>   > autoplay = "default"
>   > frame_progress = 0.27172300219536
>   Interactable (Area2D)
>     script: res://Interactables/Interactable.gd
>     scene: res://Interactables/Interactable.tscn
>   > prompt_message = "Upgrade Hideout (10 Gold)"
>   > prompt_vertical_offset = -40.0
>   > interaction_duration = 1.0
>     CollisionShape2D (CollisionShape2D)
>     > shape = res://Interactables/Interactable.tscn::CircleShape2D_nuwr0

--- SCENE: res://Levels/Hideout/Hideout_Level_2.tscn ---
Hideout (Node2D)
> script: res://Levels/Hideout.gd
> scene: res://Levels/Hideout/Hideout_Level_2.tscn
> position = (56.0, -17.0)
> ParallaxBackground (ParallaxBackground)
> > scale = (1.2, 1.2)
> > transform = [X: (1.2, 0.0), Y: (0.0, 1.2), O: (0.0, 0.0)]
>   CloudsBack (ParallaxLayer)
>   > motion_scale = (0.01, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/CloudsBack.png
>     > expand_mode = 1
>     > stretch_mode = 6
>   CoudsFront (ParallaxLayer)
>   > motion_scale = (0.05, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/CloudsFront.png
>     > expand_mode = 1
>     > stretch_mode = 6
>   BGBack (ParallaxLayer)
>   > motion_scale = (0.075, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/BGBack.png
>     > expand_mode = 1
>     > stretch_mode = 6
>   BGFront (ParallaxLayer)
>   > motion_scale = (0.1, 1.0)
>   > motion_mirroring = (640.0, 360.0)
>     TextureRect (TextureRect)
>     > offset_right = 640.0
>     > offset_bottom = 360.0
>     > texture = res://assets/Backgrounds/Background/BGFront.png
>     > expand_mode = 1
>     > stretch_mode = 6
> CanvasLayer (CanvasLayer)
>   GUI (Control)
>     script: res://Levels/Hideout.gd
>   > anchors_preset = 15
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > grow_horizontal = 2
>   > grow_vertical = 2
>   > theme = res://Levels/Hideout/hideout_theme.tres
>   > archer_placeholder_scene = res://Interactables/ArcherPlaceholder.tscn
>     ResourceDisplay (MarginContainer)
>     > layout_mode = 1
>     > anchors_preset = 5
>     > anchor_left = 0.5
>     > anchor_right = 0.5
>     > offset_left = -20.0
>     > offset_right = 20.0
>     > offset_bottom = 62.0
>     > grow_horizontal = 2
>       PanelContainer (PanelContainer)
>       > layout_mode = 2
>         HBoxContainer (HBoxContainer)
>         > layout_mode = 2
>           VillagerLabel (Label)
>           > layout_mode = 2
>           GoldLabel (Label)
>           > layout_mode = 2
>           ArcherLabel (Label)
>           > layout_mode = 2
>     TrainArcherButton (Button)
>     > layout_mode = 1
>     > anchors_preset = 3
>     > anchor_left = 1.0
>     > anchor_top = 1.0
>     > anchor_right = 1.0
>     > anchor_bottom = 1.0
>     > offset_left = -110.0
>     > offset_top = -36.0
>     > offset_right = -6.0
>     > offset_bottom = -5.0
>     > grow_horizontal = 0
>     > grow_vertical = 0
>     > text = "Train Archer"
> TileMapLayer (TileMapLayer)
> > position = (-26.0, 129.0)
> > tile_set = res://Levels/Hideout/Hideout_Level_2.tscn::TileSet_0vrxt
> RescuedVillager (StaticBody2D)
>   script: res://Interactables/RescuedVillager/RescuedVillager.gd
>   scene: res://Interactables/RescuedVillager/RescuedVillager.tscn
> > position = (494.0, 720.0)
> > dialogue_message = "Thank you!"
>   CollisionShape2D (CollisionShape2D)
>   > position = (0.0, 14.5)
>   > shape = res://Interactables/RescuedVillager/RescuedVillager.tscn::RectangleShape2D_mdajx
>   InteractionArea (Area2D)
>     script: res://Interactables/Interactable.gd
>   > prompt_message = "Interact"
>   > prompt_vertical_offset = -40.0
>   > interaction_duration = 0.2
>     CollisionShape2D (CollisionShape2D)
>     > position = (-1.0, 15.5)
>     > shape = res://Interactables/RescuedVillager/RescuedVillager.tscn::CircleShape2D_3pwis
>   AnimatedSprite2D (AnimatedSprite2D)
>   > sprite_frames = res://Interactables/RescuedVillager/RescuedVillager.tscn::SpriteFrames_b8v8i
>   > frame_progress = 0.38301599025726
> PlayerSpawnPoint (Marker2D)
> > position = (66.0, 663.0)
> DialogueBox (CanvasLayer)
>   script: res://UserInterface/DialogueBox.gd
>   scene: res://UserInterface/DialogueBox.tscn
>   groups = [&"DialogueBox"]
> > process_mode = 3
> > visible = false
>   MarginContainer (MarginContainer)
>   > custom_minimum_size = (100.0, 100.0)
>   > anchors_preset = 12
>   > anchor_top = 1.0
>   > anchor_right = 1.0
>   > anchor_bottom = 1.0
>   > offset_top = -75.0
>   > grow_horizontal = 2
>   > grow_vertical = 0
>     Panel (Panel)
>     > custom_minimum_size = (150.0, 75.0)
>     > layout_mode = 2
>       Label (Label)
>       > layout_mode = 1
>       > offset_right = 130.0
>       > offset_bottom = 61.0
>       > horizontal_alignment = 1
>       > vertical_alignment = 1
>       > autowrap_mode = 3
> ArcheryRange (Node2D)
> > position = (722.0, 742.0)
> CameraBoundary (Area2D)
>   scene: res://Levels/CameraBoundary.tscn
>   groups = [&"camera_boundary"]
> > visible = false
>   CollisionShape2D (CollisionShape2D)
>   > position = (523.5, 519.5)
>   > shape = res://Levels/Hideout/Hideout_Level_2.tscn::RectangleShape2D_df04x
> MissionBoard (StaticBody2D)
>   script: res://Interactables/MissionBoard.gd
>   scene: res://Interactables/MissionBoard.tscn
> > position = (1002.0, 742.0)
>   Sprite2D (Sprite2D)
>   > texture = res://assets/signpost32px.png
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://Interactables/MissionBoard.tscn::RectangleShape2D_0ghu3
>   Interactable (Area2D)
>     script: res://Interactables/Interactable.gd
>     scene: res://Interactables/Interactable.tscn
>   > prompt_message = "Start Mission"
>   > prompt_vertical_offset = -50.0
>   > interaction_duration = 1.0
>     CollisionShape2D (CollisionShape2D)
>     > shape = res://Interactables/Interactable.tscn::CircleShape2D_nuwr0

--- SCENE: res://Levels/level_1.tscn ---
Level 1 (TileMapLayer)
> scene: res://Levels/level_1.tscn
> position = (84.0, -74.0)
> tile_set = res://Levels/level_1.tscn::TileSet_congi

--- SCENE: res://Levels/Level_Template.tscn ---
Test Box (Node2D)
> scene: res://Levels/Level_Template.tscn
> TileMapLayer (TileMapLayer)
>   scene: res://Levels/TestBox.tscn
> > tile_set = res://Levels/TestBox.tscn::TileSet_congi
> Level 1 (TileMapLayer)
>   scene: res://Levels/level_1.tscn
> > position = (17.0, 653.0)
> > tile_set = res://Levels/Level_Template.tscn::TileSet_3mhv4
> > collision_visibility_mode = 1

--- SCENE: res://Levels/TestBox.tscn ---
TileMapLayer (TileMapLayer)
> scene: res://Levels/TestBox.tscn
> tile_set = res://Levels/TestBox.tscn::TileSet_congi

--- SCENE: res://Levels/VillageOutskirts.tscn ---
VillageOutskirts (Node2D)
> scene: res://Levels/VillageOutskirts.tscn
> VillageOutskirtsTilelayer (TileMapLayer)
>   scene: res://Levels/VillageOutskirtsTilelayer.tscn
> > position = (17.0, 126.0)
> > tile_set = res://Levels/VillageOutskirtsTilelayer.tscn::TileSet_yp6sa
> PlayerSpawnPoint (Marker2D)
> > position = (75.0, 519.0)
> ExitZone (Area2D)
>   script: res://World/ExitZone.gd
>   scene: res://World/ExitZone.tscn
> > position = (22.0, 231.0)
>   CollisionShape2D (CollisionShape2D)
>   > position = (-6.0, 171.0)
>   > shape = res://World/ExitZone.tscn::RectangleShape2D_febds
> Chest (StaticBody2D)
>   script: res://Interactables/Chest/Chest.gd
>   scene: res://tests/Chest.tscn
> > position = (2102.0, 435.0)
> > gold_amount = 10
> > floating_text_scene = res://UserInterface/FloatingText.tscn
> > text_spawn_offset = (0.0, -20.0)
>   AnimatedSprite2D (AnimatedSprite2D)
>   > sprite_frames = res://tests/Chest.tscn::SpriteFrames_jv5ma
>   > animation = open
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://tests/Chest.tscn::RectangleShape2D_pmguq
>   InteractionArea (Area2D)
>     script: res://Interactables/Interactable.gd
>   > prompt_message = "Press E to Interact"
>   > prompt_vertical_offset = -40.0
>   > interaction_duration = 1.0
>     CollisionShape2D (CollisionShape2D)
>     > shape = res://Levels/VillageOutskirts.tscn::CircleShape2D_qso13
>   PersistenceComponent (Node)
>     script: res://Interactables/PersistenceComponent.gd
>   > object_id = "obj_15301981044325328242"
>   > generate_new_id = false
> Chest2 (StaticBody2D)
>   script: res://Interactables/Chest/Chest.gd
>   scene: res://tests/Chest.tscn
> > position = (2223.0, -44.0)
> > gold_amount = 10
> > floating_text_scene = res://UserInterface/FloatingText.tscn
> > text_spawn_offset = (0.0, -20.0)
>   AnimatedSprite2D (AnimatedSprite2D)
>   > sprite_frames = res://tests/Chest.tscn::SpriteFrames_jv5ma
>   > animation = open
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://Levels/VillageOutskirts.tscn::RectangleShape2D_nlkw8
>   InteractionArea (Area2D)
>     script: res://Interactables/Interactable.gd
>   > prompt_message = "Press E to Interact"
>   > prompt_vertical_offset = -40.0
>   > interaction_duration = 1.0
>     CollisionShape2D (CollisionShape2D)
>     > shape = res://Levels/VillageOutskirts.tscn::CircleShape2D_4ehxf
>   PersistenceComponent (Node)
>     script: res://Interactables/PersistenceComponent.gd
>   > object_id = "obj_35586616104310362197"
>   > generate_new_id = false
> Chest3 (StaticBody2D)
>   script: res://Interactables/Chest/Chest.gd
>   scene: res://tests/Chest.tscn
> > position = (1266.0, -175.0)
> > gold_amount = 10
> > floating_text_scene = res://UserInterface/FloatingText.tscn
> > text_spawn_offset = (0.0, -20.0)
>   AnimatedSprite2D (AnimatedSprite2D)
>   > sprite_frames = res://tests/Chest.tscn::SpriteFrames_jv5ma
>   > animation = open
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://tests/Chest.tscn::RectangleShape2D_pmguq
>   InteractionArea (Area2D)
>     script: res://Interactables/Interactable.gd
>   > prompt_message = "Press E to Interact"
>   > prompt_vertical_offset = -40.0
>   > interaction_duration = 1.0
>     CollisionShape2D (CollisionShape2D)
>     > shape = res://tests/Chest.tscn::CircleShape2D_i7tb8
>   PersistenceComponent (Node)
>     script: res://Interactables/PersistenceComponent.gd
>   > object_id = "obj_11875882354348981082"
>   > generate_new_id = false
> Guard (CharacterBody2D)
>   script: res://Enemies/Guard/Guard.gd
>   scene: res://Enemies/Guard/Guard.tscn
> > position = (1348.0, 406.0)
> > scale = (0.6, 0.6)
> > collision_mask = 2
> > speed = 50.0
> > vision_cone_neutral_color = (1.0, 1.0, 1.0, 0.2)
> > vision_cone_suspicious_color = (1.0, 1.0, 0.0, 0.25)
> > vision_cone_alert_color = (1.0, 0.0, 0.0, 0.3)
>   CollisionShape2D (CollisionShape2D)
>   > position = (-4.16667, 30.3333)
>   > shape = res://Enemies/Guard/Guard.tscn::RectangleShape2D_gyn35
>   AnimatedSprite2D (AnimatedSprite2D)
>   > sprite_frames = res://Enemies/Guard/Guard.tscn::SpriteFrames_a34ki
>   > animation = walk
>   > frame_progress = 0.02958899922669
>   TurnCooldownTimer (Timer)
>   > one_shot = true
>   LedgeCheckRay (RayCast2D)
>   > position = (11.6667, 55.0)
>   > collision_mask = 2
>   GroundCheckRay (RayCast2D)
>   > position = (-3.33333, 21.6667)
>   > collision_mask = 2
>   WallCheckRay (RayCast2D)
>   > position = (0.0, 21.33)
>   > target_position = (50.0, 0.337)
>   > collision_mask = 2
>   StateMachine (Node)
>     script: res://Enemies/Guard/States/guard_state_machine.gd
>   > initial_state = PatrolState:<Node#6567558741012>
>     PatrolState (Node)
>       script: res://Enemies/Guard/States/patrol_state.gd
>     CaughtState (Node)
>       script: res://Enemies/Guard/States/caught_state.gd
>   VisionCone2D (Node2D)
>     script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d.gd
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d_template.tscn
>   > angle_deg = 60
>   > ray_count = 30
>   > max_distance = 150.0
>   > collision_layer_mask = 2
>   > write_collision_polygon = VisionConeCollider:<CollisionPolygon2D#6567642627330>
>   > write_polygon2d = VisionConeRenderer:<Polygon2D#6567609066556>
>   > debug_lines = false
>   > debug_shape = false
>   > minimum_recalculate_time_msec = 100
>   > recalculate_if_static = true
>   > static_threshold = 2.0
>   > min_distance_sqr = 16.0
>     VisionConeRenderer (Polygon2D)
>     > color = (0.4314, 0.9294, 0.2784, 0.2863)
>     VisionConeArea (Area2D)
>     > collision_layer = 0
>     > monitorable = false
>       VisionConeCollider (CollisionPolygon2D)
>     DebugDraw (Node2D)
>       script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/cone_editor_helper.gd
>     > is_visible = true
>     > color = (1.0, 0.0, 0.0, 1.0)
> Guard3 (CharacterBody2D)
>   script: res://Enemies/Guard/Guard.gd
>   scene: res://Enemies/Guard/Guard.tscn
> > position = (1994.0, 406.0)
> > scale = (0.6, 0.6)
> > collision_mask = 2
> > speed = 50.0
> > vision_cone_neutral_color = (1.0, 1.0, 1.0, 0.2)
> > vision_cone_suspicious_color = (1.0, 1.0, 0.0, 0.25)
> > vision_cone_alert_color = (1.0, 0.0, 0.0, 0.3)
>   CollisionShape2D (CollisionShape2D)
>   > position = (-4.16667, 30.3333)
>   > shape = res://Enemies/Guard/Guard.tscn::RectangleShape2D_gyn35
>   AnimatedSprite2D (AnimatedSprite2D)
>   > sprite_frames = res://Enemies/Guard/Guard.tscn::SpriteFrames_a34ki
>   > animation = walk
>   > frame_progress = 0.02958899922669
>   TurnCooldownTimer (Timer)
>   > one_shot = true
>   LedgeCheckRay (RayCast2D)
>   > position = (11.6667, 55.0)
>   > collision_mask = 2
>   GroundCheckRay (RayCast2D)
>   > position = (-3.33333, 21.6667)
>   > collision_mask = 2
>   WallCheckRay (RayCast2D)
>   > position = (0.0, 21.33)
>   > target_position = (50.0, 0.337)
>   > collision_mask = 2
>   StateMachine (Node)
>     script: res://Enemies/Guard/States/guard_state_machine.gd
>   > initial_state = PatrolState:<Node#6567810399396>
>     PatrolState (Node)
>       script: res://Enemies/Guard/States/patrol_state.gd
>     CaughtState (Node)
>       script: res://Enemies/Guard/States/caught_state.gd
>   VisionCone2D (Node2D)
>     script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d.gd
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d_template.tscn
>   > angle_deg = 60
>   > ray_count = 30
>   > max_distance = 150.0
>   > collision_layer_mask = 2
>   > write_collision_polygon = VisionConeCollider:<CollisionPolygon2D#6567894285459>
>   > write_polygon2d = VisionConeRenderer:<Polygon2D#6567860731041>
>   > debug_lines = false
>   > debug_shape = false
>   > minimum_recalculate_time_msec = 100
>   > recalculate_if_static = true
>   > static_threshold = 2.0
>   > min_distance_sqr = 16.0
>     VisionConeRenderer (Polygon2D)
>     > color = (0.4314, 0.9294, 0.2784, 0.2863)
>     VisionConeArea (Area2D)
>     > collision_layer = 0
>     > monitorable = false
>       VisionConeCollider (CollisionPolygon2D)
>     DebugDraw (Node2D)
>       script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/cone_editor_helper.gd
>     > is_visible = true
>     > color = (1.0, 0.0, 0.0, 1.0)
> Guard2 (CharacterBody2D)
>   script: res://Enemies/Guard/Guard.gd
>   scene: res://Enemies/Guard/Guard.tscn
> > position = (1965.0, 101.0)
> > scale = (0.6, 0.6)
> > collision_mask = 2
> > speed = 50.0
> > vision_cone_neutral_color = (1.0, 1.0, 1.0, 0.2)
> > vision_cone_suspicious_color = (1.0, 1.0, 0.0, 0.25)
> > vision_cone_alert_color = (1.0, 0.0, 0.0, 0.3)
>   CollisionShape2D (CollisionShape2D)
>   > position = (-4.16667, 30.3333)
>   > shape = res://Enemies/Guard/Guard.tscn::RectangleShape2D_gyn35
>   AnimatedSprite2D (AnimatedSprite2D)
>   > sprite_frames = res://Enemies/Guard/Guard.tscn::SpriteFrames_a34ki
>   > animation = walk
>   > frame_progress = 0.02958899922669
>   TurnCooldownTimer (Timer)
>   > one_shot = true
>   LedgeCheckRay (RayCast2D)
>   > position = (11.6667, 55.0)
>   > collision_mask = 2
>   GroundCheckRay (RayCast2D)
>   > position = (-3.33333, 21.6667)
>   > collision_mask = 2
>   WallCheckRay (RayCast2D)
>   > position = (0.0, 21.33)
>   > target_position = (50.0, 0.337)
>   > collision_mask = 2
>   StateMachine (Node)
>     script: res://Enemies/Guard/States/guard_state_machine.gd
>   > initial_state = PatrolState:<Node#6568062057902>
>     PatrolState (Node)
>       script: res://Enemies/Guard/States/patrol_state.gd
>     CaughtState (Node)
>       script: res://Enemies/Guard/States/caught_state.gd
>   VisionCone2D (Node2D)
>     script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d.gd
>     scene: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d_template.tscn
>   > angle_deg = 60
>   > ray_count = 30
>   > max_distance = 150.0
>   > collision_layer_mask = 2
>   > write_collision_polygon = VisionConeCollider:<CollisionPolygon2D#6568145943648>
>   > write_polygon2d = VisionConeRenderer:<Polygon2D#6568112389751>
>   > debug_lines = false
>   > debug_shape = false
>   > minimum_recalculate_time_msec = 100
>   > recalculate_if_static = true
>   > static_threshold = 2.0
>   > min_distance_sqr = 16.0
>     VisionConeRenderer (Polygon2D)
>     > color = (0.4314, 0.9294, 0.2784, 0.2863)
>     VisionConeArea (Area2D)
>     > collision_layer = 0
>     > monitorable = false
>       VisionConeCollider (CollisionPolygon2D)
>     DebugDraw (Node2D)
>       script: res://addons/godot-vision-cone-main/addons/vision_cone_2d/cone_editor_helper.gd
>     > is_visible = true
>     > color = (1.0, 0.0, 0.0, 1.0)
> CameraBoundary (Area2D)
>   scene: res://Levels/CameraBoundary.tscn
>   groups = [&"camera_boundary"]
> > visible = false
> > position = (-91.0, 0.0)
>   CollisionShape2D (CollisionShape2D)
>   > position = (1548.0, 175.0)
>   > shape = res://Levels/VillageOutskirts.tscn::RectangleShape2D_k88k2
> KillZone (Area2D)
>   script: res://World/KillZone.gd
>   scene: res://World/KillZone.tscn
> > position = (-18.0, 624.0)
> > collision_layer = 2
>   CollisionShape2D (CollisionShape2D)
>   > position = (1376.5, 37.875)
>   > shape = res://Levels/VillageOutskirts.tscn::RectangleShape2D_qapib
> Checkpoint (Area2D)
>   script: res://World/Checkpoint.gd
>   scene: res://World/Checkpoint.tscn
> > position = (2075.0, 221.0)
> > respawn_point = RespawnPoint
>   CollisionShape2D (CollisionShape2D)
>   > position = (28.0, -7.0)
>   > shape = res://Levels/VillageOutskirts.tscn::RectangleShape2D_tljy5
>   RespawnPoint (Marker2D)
>   > position = (-3.0, -15.0)
> Prisoner (StaticBody2D)
>   script: res://Interactables/Prisoner/Prisoner.gd
>   scene: res://Interactables/Prisoner/Prisoner.tscn
> > position = (2151.0, 204.0)
>   CollisionShape2D (CollisionShape2D)
>   > position = (1.0, 15.0)
>   > shape = res://Interactables/Prisoner/Prisoner.tscn::RectangleShape2D_cw31s
>   AnimatedSprite2D (AnimatedSprite2D)
>   > sprite_frames = res://Interactables/Prisoner/Prisoner.tscn::SpriteFrames_1j4pt
>   > animation = idle
>   Interactable (Area2D)
>     script: res://Interactables/Interactable.gd
>     scene: res://Interactables/Interactable.tscn
>   > prompt_message = "Rescue"
>   > prompt_vertical_offset = -40.0
>   > interaction_duration = 1.5
>     CollisionShape2D (CollisionShape2D)
>     > position = (0.0, 16.0)
>     > shape = res://Interactables/Interactable.tscn::CircleShape2D_nuwr0
>   PersistenceComponent (Node)
>     script: res://Interactables/PersistenceComponent.gd
>   > object_id = ""
>   > generate_new_id = false
>   AnimationPlayer (AnimationPlayer)
>   > libraries = {"":"<AnimationLibrary#-9223369823252037334>"}

--- SCENE: res://Levels/VillageOutskirtsTilelayer.tscn ---
VillageOutskirtsTilelayer (TileMapLayer)
> scene: res://Levels/VillageOutskirtsTilelayer.tscn
> position = (0.0, -448.0)
> tile_set = res://Levels/VillageOutskirtsTilelayer.tscn::TileSet_yp6sa

--- SCENE: res://Player/PlayerCamera.tscn ---
PlayerCamera (Camera2D)
> script: res://Player/PlayerCamera.gd
> scene: res://Player/PlayerCamera.tscn

--- SCENE: res://Player/PlayerScene.tscn ---
Player (CharacterBody2D)
> script: res://Player/PlayerScript.gd
> scene: res://Player/PlayerScene.tscn
> groups = [&"player"]
> rotation = -0.00456182984635
> collision_mask = 2
> stats = res://Player/Data/player_stats.tres
> dash_start_vfx = res://VFX/VFXData/dash_start.tres
> AnimatedSprite2D (AnimatedSprite2D)
> > position = (5.0, 3.0)
> > sprite_frames = res://Player/PlayerScene.tscn::SpriteFrames_pwdtq
> > animation = wall slide
> > autoplay = "idle"
> > offset = (0.0, -40.0)
> AnimationPlayer (AnimationPlayer)
> > libraries = {"":"<AnimationLibrary#-9223369854608655093>"}
> StandingCollision (CollisionShape2D)
> > position = (1.886, -15.0)
> > shape = res://Player/PlayerScene.tscn::CapsuleShape2D_vbs5d
> CrouchingCollision (CollisionShape2D)
> > visible = false
> > position = (1.0, -10.0)
> > scale = (1.06667, 1.08811)
> > shape = res://Player/PlayerScene.tscn::RectangleShape2D_qvcxh
> WallSlideCollision (CollisionShape2D)
> > visible = false
> > position = (3.504, -15.0)
> > shape = res://Player/PlayerScene.tscn::RectangleShape2D_epaal
> > disabled = true
> HeadClearanceRaycast (RayCast2D)
> > position = (1.886, -15.0)
> > target_position = (0.109488, -23.9998)
> > collision_mask = 2
> Timers (Node)
>   groups = [&"timers"]
>   SlowMoTimer (Timer)
>     groups = [&"timers"]
>   > wait_time = 0.5
>   > one_shot = true
>   InvisibilityTimer (Timer)
>     groups = [&"timers"]
>   > wait_time = 0.5
>   > one_shot = true
>   InvisibilityCooldownTimer (Timer)
>     groups = [&"timers"]
>   > wait_time = 0.5
>   > one_shot = true
>   WallDetachTimer (Timer)
>     groups = [&"timers"]
>   > wait_time = 0.5
>   > one_shot = true
>   CameraZoomResetTimer (Timer)
>     groups = [&"timers"]
>   > wait_time = 0.5
>   > one_shot = true
>   SlideTimer (Timer)
>     groups = [&"timers"]
>   > wait_time = 0.5
>   > one_shot = true
>   WallCoyoteTimer (Timer)
>     groups = [&"timers"]
>   > wait_time = 0.5
>   > one_shot = true
>   SkidTimer (Timer)
>     groups = [&"timers"]
>   > wait_time = 0.5
>   > one_shot = true
>   WallSlipTimer (Timer)
>     groups = [&"timers"]
>   > wait_time = 0.1
>   > one_shot = true
>   WallStickTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   FallZoomTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   AfterImageTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   DashTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   DashFreezeTimer (Timer)
>     groups = [&"timers"]
>   > process_callback = 0
>   > one_shot = true
>   JumpBufferTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   CoyoteTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   DashCooldownTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   CrouchTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   LandTimer (Timer)
>     groups = [&"timers"]
>   > wait_time = 0.1
>   > one_shot = true
>   ComboTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   ComboResetTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   StandingSlideCooldownTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
>   WallKickTimer (Timer)
>     groups = [&"timers"]
>   > one_shot = true
> DashParticles (GPUParticles2D)
> > material = res://Player/PlayerScene.tscn::ShaderMaterial_4tc8y
> > position = (-2.0, -40.0)
> > emitting = false
> > amount = 6
> > texture = res://assets/CharacterSprites/Knight_Colour1/NoOutline/120x80_PNGSheets/_Dash.png
> > lifetime = 0.25
> > process_material = res://Player/PlayerScene.tscn::ParticleProcessMaterial_fpl1g
> VFX (Node2D)
>   script: res://VFX/VFXManager.gd
> AnimationController (Node2D)
>   script: res://Player/PlayerModularControl/AnimationController.gd
> TrajectoryLine (Line2D)
> > position = (-3.0, 20.0)
> > width = 3.0
> > default_color = (0.9735, 0.9735, 0.9735, 1.0)
> TargetPoint (Marker2D)
> > position = (1.05929, -12.9953)
> StateMachine (Node)
>   script: res://Player/States/StateMachine.gd
> > initial_state = IdleState
>   IdleState (Node)
>     script: res://Player/States/Idle.gd
>   RunningState (Node)
>     script: res://Player/States/RunningState.gd
>   JumpingState (Node)
>     script: res://Player/States/JumpingState.gd
>   > jump_vfx = res://VFX/VFXData/jump_puff_vfx.tres
>   FallingState (Node)
>     script: res://Player/States/FallingState.gd
>   > wall_jump_vfx = res://VFX/VFXData/wall_jump.tres
>   WallDetachState (Node)
>     script: res://Player/States/WallDetachState.gd
>   OnWallState (Node)
>     script: res://Player/States/OnWallState.gd
>   > wall_slide_vfx = res://VFX/VFXData/wall_slide_vfx.tres
>   > wall_jump_vfx = res://VFX/VFXData/wall_jump.tres
>     VFXTimer (Timer)
>     > wait_time = 0.1
>   WallStickingState (Node)
>     script: res://Player/States/WallStickingState.gd
>   DashingState (Node)
>     script: res://Player/States/DashingState.gd
>   GlidingState (Node)
>     script: res://Player/States/GlidingState.gd
>   WallSlipState (Node)
>     script: res://Player/States/WallSlipState.gd
>   LandingState (Node)
>     script: res://Player/States/LandingState.gd
>   > land_vfx = res://VFX/VFXData/land_puff_vfx.tres
>   SlidingState (Node)
>     script: res://Player/States/SlidingState.gd
>   > slide_vfx = res://VFX/VFXData/slide_puff.tres
>   SkiddingState (Node)
>     script: res://Player/States/SkiddingState.gd
>   > skid_vfx = res://VFX/VFXData/skid_puff.tres
>   DashPrepareState (Node)
>     script: res://Player/States/DashPrepareState.gd
>   > dash_prepare_vfx = res://VFX/VFXData/dash_prepare.tres
>   UnstickingState (Node)
>     script: res://Player/States/UnstickingState.gd
>   CrouchingState (Node)
>     script: res://Player/States/CrouchingState.gd
>   WallKickState (Node)
>     script: res://Player/States/WallKickState.gd
>   > wall_kick_vfx = res://VFX/VFXData/wall_kick_vfx.tres
> PlayerInteraction (Area2D)
>   script: res://Player/PlayerInteraction.gd
> > visible = false
> > position = (1.85311, 26.0089)
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://Player/PlayerScene.tscn::CircleShape2D_5x2q4
> PlayerCamera (Camera2D)
>   script: res://Player/PlayerCamera.gd
> > physics_interpolation_mode = 1
> > position = (19.99979, 0.091236)
> > rotation = 0.00456182984635
> > stats = res://Player/Data/default_camera_stats.tres
>   CameraZoomResetTimer (Timer)
>   PhantomCameraHost (Node)
>     script: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd
>   > process_priority = 300
>   > process_physics_priority = 300
>   > host_layers = 1
>   > interpolation_mode = 0
> WallCheckRayRight (RayCast2D)
> > position = (3.832, -15.0)
> > target_position = (20.0, 0.0)
> WallCheckRayLeft (RayCast2D)
> > position = (2.847, -15.0)
> > target_position = (-20.0, 0.0)
> GroundRay (RayCast2D)
> > position = (2.955, -40.0)
> > target_position = (-0.17847, 48.9995)
> > collision_mask = 2
> LedgeRay (RayCast2D)
> > position = (23.0, -40.0)
> > target_position = (-0.219206, 48.1044)
> > collision_mask = 2
> FootSpawner (Marker2D)
> > position = (0.792, 0.0)
> WallSlideSpawner (Marker2D)
> > position = (-8.0, -13.0)
> PhantomCamera2D (Node2D)
>   script: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd
> > top_level = true
> > position = (20.0, 0.0)
> > priority_override = false
> > priority = 10
> > follow_mode = 5
> > follow_target = Player:<CharacterBody2D#6570058544698>
> > follow_targets = []
> > zoom = (1.0, 1.0)
> > snap_to_pixel = true
> > frame_preview = true
> > tween_resource = res://Player/PlayerScene.tscn::Resource_kh4fv
> > tween_on_load = true
> > inactive_update_mode = 0
> > host_layers = 1
> > follow_offset = (20.0, 0.0)
> > follow_damping = true
> > follow_damping_value = (0.5, 0.5)
> > follow_axis_lock = 0
> > rotate_with_target = false
> > rotation_offset = 0.0
> > rotation_damping = false
> > rotation_damping_value = 0.1
> > auto_zoom = false
> > auto_zoom_min = 1.0
> > auto_zoom_max = 5.0
> > auto_zoom_margin = (0.0, 0.0, 0.0, 0.0)
> > dead_zone_width = 0.5
> > dead_zone_height = 0.6
> > show_viewfinder_in_play = true
> > draw_limits = true
> > limit_left = -10000000
> > limit_top = -10000000
> > limit_right = 10000000
> > limit_bottom = 10000000
> > limit_target = 
> > limit_margin = (0, 0, 0, 0)
> > _preview_noise = true
> > noise_emitter_layer = 0

--- SCENE: res://Singletons/game_manager.tscn ---
GameManager (Node)
> script: res://Singletons/GameManager.gd
> scene: res://Singletons/game_manager.tscn
> hideout_progression_data = res://Data/hideout_upgrades.tres

--- SCENE: res://Singletons/SceneManager.tscn ---
SceneManager (CanvasLayer)
> script: res://Singletons/SceneManager.gd
> scene: res://Singletons/SceneManager.tscn
> process_mode = 3
> scene_entries = ["<Resource#-9223365464145430957>","<Resource#-9223365464128651669>","<Resource#-9223365464111874783>"]
> player_scene = res://Player/PlayerScene.tscn
> ColorRect (ColorRect)
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > color = (0.0, 0.0, 0.0, 0.0)
> AnimationPlayer (AnimationPlayer)
> > libraries = {"":"<AnimationLibrary#-9223365464044765882>"}

--- SCENE: res://tests/Chest.tscn ---
Chest (StaticBody2D)
> script: res://Interactables/Chest/Chest.gd
> scene: res://tests/Chest.tscn
> gold_amount = 10
> floating_text_scene = res://UserInterface/FloatingText.tscn
> text_spawn_offset = (0.0, -20.0)
> AnimatedSprite2D (AnimatedSprite2D)
> > sprite_frames = res://tests/Chest.tscn::SpriteFrames_jv5ma
> > animation = open
> CollisionShape2D (CollisionShape2D)
> > shape = res://tests/Chest.tscn::RectangleShape2D_pmguq
> InteractionArea (Area2D)
>   script: res://Interactables/Interactable.gd
> > prompt_message = "Press E to Interact"
> > prompt_vertical_offset = -40.0
> > interaction_duration = 1.0
>   CollisionShape2D (CollisionShape2D)
>   > shape = res://tests/Chest.tscn::CircleShape2D_i7tb8
> PersistenceComponent (Node)
>   script: res://Interactables/PersistenceComponent.gd
> > object_id = ""
> > generate_new_id = false

--- SCENE: res://UserInterface/DialogueBox.tscn ---
DialogueBox (CanvasLayer)
> script: res://UserInterface/DialogueBox.gd
> scene: res://UserInterface/DialogueBox.tscn
> groups = [&"DialogueBox"]
> process_mode = 3
> visible = false
> MarginContainer (MarginContainer)
> > custom_minimum_size = (100.0, 100.0)
> > anchors_preset = 12
> > anchor_top = 1.0
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > offset_top = -75.0
> > grow_horizontal = 2
> > grow_vertical = 0
>   Panel (Panel)
>   > custom_minimum_size = (150.0, 75.0)
>   > layout_mode = 2
>     Label (Label)
>     > layout_mode = 1
>     > offset_right = 130.0
>     > offset_bottom = 61.0
>     > horizontal_alignment = 1
>     > vertical_alignment = 1
>     > autowrap_mode = 3

--- SCENE: res://UserInterface/FloatingText.tscn ---
FloatingText (Label)
> script: res://UserInterface/FloatingText.gd
> scene: res://UserInterface/FloatingText.tscn
> offset_right = 40.0
> offset_bottom = 23.0
> theme = res://pixel_theme.tres
> float_height = 50.0

--- SCENE: res://UserInterface/InteractionUI.tscn ---
InteractionUI (Control)
> script: res://UserInterface/InteractionUI.gd
> scene: res://UserInterface/InteractionUI.tscn
> default_panel_color = (0.1765, 0.1765, 0.1765, 1.0)
> fill_panel_color = (1.0, 1.0, 1.0, 1.0)
> Panel (PanelContainer)
> > layout_mode = 0
> > offset_right = 85.0
> > offset_bottom = 28.0
>   Label (Label)
>   > layout_mode = 2
>   > theme = res://pixel_theme.tres
>   > text = "Filler Text"
>   > horizontal_alignment = 1
>   HoldProgressBar (ProgressBar)
>   > layout_mode = 2
>   > show_percentage = false

--- SCENE: res://UserInterface/MissionFailedScreen.tscn ---
MissionFailedScreen (CanvasLayer)
> script: res://UserInterface/MissionFailedScreen.gd
> scene: res://UserInterface/MissionFailedScreen.tscn
> process_mode = 2
> ColorRect (ColorRect)
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > color = (0.1836, 0.1836, 0.1836, 1.0)
> MarginContainer (MarginContainer)
> > anchors_preset = 8
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -74.5
> > offset_top = -29.0
> > offset_right = 74.5
> > offset_bottom = 29.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > theme = res://pixel_theme.tres
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>   > size_flags_vertical = 4
>   > focus_mode = 2
>     Label (Label)
>     > layout_mode = 2
>     > text = "You were detected!"
>     > horizontal_alignment = 1
>     > vertical_alignment = 1
>     ReturnButton (Button)
>     > process_mode = 3
>     > layout_mode = 2
>     > size_flags_horizontal = 4
>     > size_flags_vertical = 4
>     > text = "Return to Hideout"

--- SCENE: res://UserInterface/MissionSuccessScreen.tscn ---
MissionSuccessScreen (CanvasLayer)
> script: res://UserInterface/MissionSuccessScreen.gd
> scene: res://UserInterface/MissionSuccessScreen.tscn
> process_mode = 2
> ColorRect (ColorRect)
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > color = (0.1836, 0.1836, 0.1836, 1.0)
> MarginContainer (MarginContainer)
> > anchors_preset = 8
> > anchor_left = 0.5
> > anchor_top = 0.5
> > anchor_right = 0.5
> > anchor_bottom = 0.5
> > offset_left = -74.0
> > offset_top = -56.0
> > offset_right = 74.0
> > offset_bottom = 56.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > theme = res://pixel_theme.tres
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>   > size_flags_horizontal = 4
>   > size_flags_vertical = 4
>     Label (Label)
>     > layout_mode = 2
>     > text = "Mission Complete!"
>     GoldLabel (Label)
>     > layout_mode = 2
>     VillagersLabel (Label)
>     > layout_mode = 2
>     ReturnButton (Button)
>     > process_mode = 3
>     > layout_mode = 2
>     > text = "Return to Hideout"

--- SCENE: res://UserInterface/PauseMenu.tscn ---
PauseMenu (CanvasLayer)
> script: res://UserInterface/PauseMenu.gd
> scene: res://UserInterface/PauseMenu.tscn
> process_mode = 3
> Background (ColorRect)
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > color = (0.0, 0.0, 0.0, 0.3882)
> MarginContainer (MarginContainer)
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
> > size_flags_horizontal = 3
> > size_flags_vertical = 3
> > theme = res://pixel_theme.tres
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>   > size_flags_horizontal = 4
>   > size_flags_vertical = 4
>     Label (Label)
>     > layout_mode = 2
>     > text = "Game Paused"
>     > horizontal_alignment = 1
>     ResumeButton (Button)
>     > layout_mode = 2
>     > text = "Resume\n"
>     QuitButton (Button)
>     > layout_mode = 2
>     > text = "Quit to Hideout"

--- SCENE: res://UserInterface/TitleScreen.tscn ---
Title Screen (ColorRect)
> script: res://UserInterface/TitleScreen.gd
> scene: res://UserInterface/TitleScreen.tscn
> anchor_right = 1.0
> anchor_bottom = 1.0
> grow_horizontal = 2
> grow_vertical = 2
> size_flags_vertical = 4
> theme = res://pixel_theme.tres
> color = (0.0, 0.0, 0.0, 1.0)
> CenterContainer (CenterContainer)
> > layout_mode = 1
> > anchors_preset = 15
> > anchor_right = 1.0
> > anchor_bottom = 1.0
> > grow_horizontal = 2
> > grow_vertical = 2
>   VBoxContainer (VBoxContainer)
>   > layout_mode = 2
>   > size_flags_horizontal = 3
>   > mouse_filter = 2
>     Label (Label)
>     > layout_mode = 2
>     > size_flags_vertical = 1
>     > text = "Project: Robin Hood"
>     > horizontal_alignment = 1
>     > vertical_alignment = 1
>     ContinueButton (Button)
>     > layout_mode = 2
>     > size_flags_vertical = 3
>     > text = "Continue\n"
>     NewGameButton (Button)
>     > layout_mode = 2
>     > size_flags_vertical = 3
>     > text = "New Game\n"

--- SCENE: res://UserInterface/UIManager.tscn ---
UIManager (CanvasLayer)
> script: res://UserInterface/UIManager.gd
> scene: res://UserInterface/UIManager.tscn

--- SCENE: res://VFX/AnimatedEffect.tscn ---
AnimatedEffect (AnimatedSprite2D)
> script: res://VFX/AnimatedEffect.gd
> scene: res://VFX/AnimatedEffect.tscn
> sprite_frames = res://VFX/AnimatedEffect.tscn::SpriteFrames_dfwn2
> animation = dash_puff

--- SCENE: res://VFX/DustPuff.tscn ---
DustPuff (GPUParticles2D)
> script: res://VFX/DustPuff.gd
> scene: res://VFX/DustPuff.tscn
> emitting = false
> amount = 16
> texture = res://assets/dustparticles/dust1.png
> lifetime = 0.3
> one_shot = true
> explosiveness = 0.89999997615814
> process_material = res://VFX/DustPuff.tscn::ParticleProcessMaterial_fydcl

--- SCENE: res://World/Checkpoint.tscn ---
Checkpoint (Area2D)
> script: res://World/Checkpoint.gd
> scene: res://World/Checkpoint.tscn
> respawn_point = RespawnPoint
> CollisionShape2D (CollisionShape2D)
> RespawnPoint (Marker2D)

--- SCENE: res://World/ExitZone.tscn ---
ExitZone (Area2D)
> script: res://World/ExitZone.gd
> scene: res://World/ExitZone.tscn
> CollisionShape2D (CollisionShape2D)
> > position = (-6.0, 171.0)
> > shape = res://World/ExitZone.tscn::RectangleShape2D_febds

--- SCENE: res://World/KillZone.tscn ---
KillZone (Area2D)
> script: res://World/KillZone.gd
> scene: res://World/KillZone.tscn
> CollisionShape2D (CollisionShape2D)
> > shape = res://World/KillZone.tscn::RectangleShape2D_c8hpk
--- END OF SCENE STRUCTURES ---

#### **2.4. Codebase**

--- START OF CODEBASE ---
--- SCRIPT: res://addons/godot-vision-cone-main/addons/vision_cone_2d/cone_editor_helper.gd ---
@tool
extends Node2D

@export var is_visible = true
@export var color = Color.RED

@onready var vision_cone: VisionCone2D = get_parent()

## Draws a preview of the vision cone inside the editor. The actual vision cone cannot be displayed as a lot of stuff
## is missing before the game is actually started
func _draw():
	if not is_visible or not Engine.is_editor_hint():
		return
	var rot_diff = global_rotation - vision_cone.global_rotation
	var half_angle = deg_to_rad(vision_cone.angle_deg)/2.
	var right = Vector2(0, vision_cone.max_distance).rotated(rot_diff + half_angle)
	var left = Vector2(0, vision_cone.max_distance).rotated(rot_diff - half_angle)
	draw_line(Vector2.ZERO, right, color)
	draw_line(Vector2.ZERO, left, color)
	draw_line(right, left, color)

--- SCRIPT: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/enemy.gd ---
extends CharacterBody2D

@export var vision_renderer: Polygon2D
@export var alert_color: Color

@export_group("Rotation")
@export var is_rotating = false
@export var rotation_speed = 0.1
@export var rotation_angle = 90

@export_group("Movement")
@export var move_on_path: PathFollow2D
@export var movement_speed = 0.1
@onready var pos_start = position.x

@onready var original_color = vision_renderer.color if vision_renderer else Color.WHITE
@onready var rot_start = rotation

func _on_vision_cone_area_body_entered(body: Node2D) -> void:
	# print("%s is seeing %s" % [self, body])
	vision_renderer.color = alert_color

func _on_vision_cone_area_body_exited(body: Node2D) -> void:
	# print("%s stopped seeing %s" % [self, body])
	vision_renderer.color = original_color

func _physics_process(delta: float) -> void:
	if is_rotating:
		rotation = rot_start + sin(Time.get_ticks_msec()/1000. * rotation_speed) * deg_to_rad(rotation_angle/2.)
	if move_on_path:
		move_on_path.progress += movement_speed
		global_position = move_on_path.position
		rotation = move_on_path.rotation

--- SCRIPT: res://addons/godot-vision-cone-main/addons/vision_cone_2d/examples/player_movement.gd ---
extends CharacterBody2D

@export var speed = 1.
@export var distance = 300.

@onready var pos_start = position.x

func _physics_process(delta: float) -> void:
	var target_pos = pos_start + sin(Time.get_ticks_msec()/1000. * speed) * distance
	velocity = Vector2(target_pos - position.x, 0)
	move_and_slide()

--- SCRIPT: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_2d.gd ---
extends Node2D

## A configurable vision cone for 2D entities. It can be used for example to simulate the vision of enemies in a stealth game.
class_name VisionCone2D

@export_group("Raycast parameters")
## How wide the vision cone is in degrees
@export_range(0, 360) var angle_deg: int = 360
## Total number of rays that will be shot to cover the angle. Will be distributed at equal distances.
## This has the biggest impact on performance in the script.
## Have this high enough that it is precise, but low enough that it doesn't affect performance
@export var ray_count: int = 100
## The maximum length of the rays. Basically how far the character can see
@export var max_distance: float = 500.

@export_group("Collisions")
## What collision layers will block the vision. Have it set to the same layer as your walls, while avoiding things like items or characters
@export_flags_2d_physics var collision_layer_mask: int = 0
## Optional collision shape that the cone will be copied to.
## Use this if you want to have logic on things entering the cone (you probably do, unless you're just visualizing the cone without acting on it)
@export var write_collision_polygon: CollisionPolygon2D

@export_group("Visualization")
## Optional shape used to render the cone. This can then be textured and colored to customize the visual aspect
## or it can be null if you don't need to visualize the cone, but maybe just use it for AI
@export var write_polygon2d: Polygon2D
## Will draw lines for each ray. Only used for debugging, you should probably disable it in the actual project
@export var debug_lines: bool = false
## Will draw the shape outline of the cone. Only used for debugging, you should probably disable it in the actual project
@export var debug_shape: bool = false

@export_group("Optimizations")
## Introduce a minimum time (in msec) before recalculating. Useful to improve performance for slow moving objects,
## or objects where precise updates on every physics update are not necessary
@export var minimum_recalculate_time_msec: int = 0
## Should the vision cone be recalculated when the object hasn't moved?
## Set this to false to optimize by not recalculating the area if the object hasn't moved.
## May incorrectly avoid an update if the object rotates in place or the scene layout changes at runtime
@export var recalculate_if_static: bool = true
## How far the character has to move before the vision cone is recalculated. Only used if recalculate_if_static is false
@export var static_threshold: float = 2
## How far two adjacent ray points have to be from each other before adding a new point to the shape.
## Use this to reduce the number of vertices in the cone mesh when there are a lot of them close together.
## Increasing this can help with performance or when getting Godot errors like [Convex decomposing failed], at the cost of detail
## A <= 0 value will disable this behavior altogether. The value has to be squared, aka distance^2 (for performance reasons the sqrt is avoided)
@export var min_distance_sqr: float = 16

var _vision_points: Array[Vector2]
var _last_position = null  ## Optional[Vector2]
var _last_redraw_time: int = 0

# constants for optimization
@onready var _angle: float = deg_to_rad(angle_deg)
@onready var _angle_half: float = _angle/2.
@onready var _angular_delta: float = _angle / ray_count

func _process(_delta: float) -> void:
	if debug_lines or debug_shape:
		queue_redraw()

func _physics_process(delta: float) -> void:
	if Time.get_ticks_msec() - _last_redraw_time > minimum_recalculate_time_msec:
		_last_redraw_time = Time.get_ticks_msec()
		recalculate_vision()

func recalculate_vision(override_static_flag = false):
	var should_recalculate = override_static_flag or recalculate_if_static
	if not should_recalculate:
		var has_position_changed = _last_position == null or (global_position - _last_position).length() > static_threshold
		if not has_position_changed:
			return
	
	_last_position = global_position
	_vision_points.clear()
	_vision_points = calculate_vision_shape(override_static_flag)
	_update_collision_polygon()
	_update_render_polygon()

func calculate_vision_shape(override_static_flag = false) -> Array[Vector2]:
	var new_vision_points: Array[Vector2] = []
	var last_point = null # Optional[Vector2]

	if _angle < 2*PI:
		new_vision_points.append(Vector2.ZERO)
		last_point = Vector2.ZERO

	for i in range(ray_count + 1): 
		# TODO following transform should be customizable
		var new_point = _ray_to(Vector2(0, max_distance).rotated(_angular_delta * i + global_rotation - _angle_half))
		if min_distance_sqr > 0 and last_point:
			# check against min_distance_sqr
			var dist = (new_point - last_point).length_squared()
			if dist < min_distance_sqr:
				continue
		new_vision_points.append(new_point)
		last_point = new_point

	if _angle < 2*PI:
		new_vision_points.append(Vector2.ZERO)
	return new_vision_points

func _draw():
	if len(_vision_points) == 0:
		return 
	var from = _vision_points[0]
	var to: Vector2
	for i in range(1, len(_vision_points)):
		to = _vision_points[i]
		if debug_shape:
			draw_line(from, to, Color.GREEN)
		if debug_lines:
			draw_line(Vector2.ZERO, to, Color(0, 0, 1, 0.5))
		from = to
	
func _update_collision_polygon():
	if write_collision_polygon == null:
		return
	write_collision_polygon.polygon = _vision_points

func _update_render_polygon():
	if write_polygon2d == null:
		return
	write_polygon2d.polygon = _vision_points

func _ray_to(direction: Vector2) -> Vector2:
	# TODO add offset to origin
	var destination = global_position + direction
	var query = PhysicsRayQueryParameters2D.create(global_position, destination, collision_layer_mask)
	var collision = get_world_2d().direct_space_state.intersect_ray(query)

	var ray_position = collision.get("position", destination)
	return to_local(ray_position)

--- SCRIPT: res://addons/godot-vision-cone-main/addons/vision_cone_2d/vision_cone_entry.gd ---
@tool
extends EditorPlugin


func _enter_tree() -> void:
	# Initialization of the plugin goes here.
	pass


func _exit_tree() -> void:
	# Clean-up of the plugin goes here.
	pass

--- SCRIPT: res://addons/gut/autofree.gd ---
# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# Class used to keep track of objects to be freed and utilities to free them.
# ##############################################################################
var _to_free = []
var _to_queue_free = []

func add_free(thing):
	if(typeof(thing) == TYPE_OBJECT):
		if(!thing is RefCounted):
			_to_free.append(thing)

func add_queue_free(thing):
	_to_queue_free.append(thing)

func get_queue_free_count():
	return _to_queue_free.size()

func get_free_count():
	return _to_free.size()

func free_all():
	for i in range(_to_free.size()):
		if(is_instance_valid(_to_free[i])):
			_to_free[i].free()
	_to_free.clear()

	for i in range(_to_queue_free.size()):
		if(is_instance_valid(_to_queue_free[i])):
			_to_queue_free[i].queue_free()
	_to_queue_free.clear()

--- SCRIPT: res://addons/gut/awaiter.gd ---
extends Node

signal timeout
signal wait_started

var _wait_time := 0.0
var _wait_process_frames := 0
var _wait_physics_frames := 0
var _signal_to_wait_on = null

var _predicate_method = null
var _waiting_for_predicate_to_be = null

var _predicate_time_between := 0.0
var _predicate_time_between_elpased := 0.0

var _did_last_wait_timeout = false
var did_last_wait_timeout = false :
	get: return _did_last_wait_timeout
	set(val): push_error("Cannot set did_last_wait_timeout")

var _elapsed_time := 0.0
var _elapsed_frames := 0

func _ready() -> void:
	get_tree().process_frame.connect(_on_tree_process_frame)
	get_tree().physics_frame.connect(_on_tree_physics_frame)


func _on_tree_process_frame():
	# Count frames here instead of in _process so that tree order never
	# makes a difference and the count/signaling happens outside of
	# _process being called.
	if(_wait_process_frames > 0):
		_elapsed_frames += 1
		if(_elapsed_frames > _wait_process_frames):
			_end_wait()


func _on_tree_physics_frame():
	# Count frames here instead of in _physics_process so that tree order never
	# makes a difference and the count/signaling happens outside of
	# _physics_process being called.
	if(_wait_physics_frames != 0):
		_elapsed_frames += 1
		if(_elapsed_frames > _wait_physics_frames):
			_end_wait()


func _physics_process(delta):
	if(_wait_time != 0.0):
		_elapsed_time += delta
		if(_elapsed_time >= _wait_time):
			_end_wait()

	if(_predicate_method != null):
		_predicate_time_between_elpased += delta
		if(_predicate_time_between_elpased >= _predicate_time_between):
			_predicate_time_between_elpased = 0.0
			var result = _predicate_method.call()
			if(_waiting_for_predicate_to_be == false):
				if(typeof(result) != TYPE_BOOL or result != true):
					_end_wait()
			else:
				if(typeof(result) == TYPE_BOOL and result == _waiting_for_predicate_to_be):
					_end_wait()


func _end_wait():
	# Check for time before checking for frames so that the extra frames added
	# when waiting on a signal do not cause a false negative for timing out.
	if(_wait_time > 0):
		_did_last_wait_timeout = _elapsed_time >= _wait_time
	elif(_wait_physics_frames > 0):
		_did_last_wait_timeout = _elapsed_frames >= _wait_physics_frames
	elif(_wait_process_frames > 0):
		_did_last_wait_timeout = _elapsed_frames >= _wait_process_frames

	if(_signal_to_wait_on != null and _signal_to_wait_on.is_connected(_signal_callback)):
		_signal_to_wait_on.disconnect(_signal_callback)

	_wait_process_frames = 0
	_wait_time = 0.0
	_wait_physics_frames = 0
	_signal_to_wait_on = null
	_predicate_method = null
	_elapsed_time = 0.0
	_elapsed_frames = 0
	timeout.emit()


const ARG_NOT_SET = '_*_argument_*_is_*_not_set_*_'
func _signal_callback(
		_arg1=ARG_NOT_SET, _arg2=ARG_NOT_SET, _arg3=ARG_NOT_SET,
		_arg4=ARG_NOT_SET, _arg5=ARG_NOT_SET, _arg6=ARG_NOT_SET,
		_arg7=ARG_NOT_SET, _arg8=ARG_NOT_SET, _arg9=ARG_NOT_SET):

	_signal_to_wait_on.disconnect(_signal_callback)
	# DO NOT _end_wait here.  For other parts of the test to get the signal that
	# was waited on, we have to wait for another frames.  For example, the
	# signal_watcher doesn't get the signal in time if we don't do this.
	_wait_process_frames = 1


func wait_seconds(x):
	_did_last_wait_timeout = false
	_wait_time = x
	wait_started.emit()


func wait_process_frames(x):
	_did_last_wait_timeout = false
	_wait_process_frames = x
	wait_started.emit()


func wait_physics_frames(x):
	_did_last_wait_timeout = false
	_wait_physics_frames = x
	wait_started.emit()


func wait_for_signal(the_signal, max_time):
	_did_last_wait_timeout = false
	the_signal.connect(_signal_callback)
	_signal_to_wait_on = the_signal
	_wait_time = max_time
	wait_started.emit()


func wait_until(predicate_function: Callable, max_time, time_between_calls:=0.0):
	_predicate_time_between = time_between_calls
	_predicate_method = predicate_function
	_wait_time = max_time

	_waiting_for_predicate_to_be = true
	_predicate_time_between_elpased = 0.0
	_did_last_wait_timeout = false

	wait_started.emit()


func wait_while(predicate_function: Callable, max_time, time_between_calls:=0.0):
	_predicate_time_between = time_between_calls
	_predicate_method = predicate_function
	_wait_time = max_time

	_waiting_for_predicate_to_be = false
	_predicate_time_between_elpased = 0.0
	_did_last_wait_timeout = false

	wait_started.emit()

func is_waiting():
	return _wait_time != 0.0 || _wait_physics_frames != 0

--- SCRIPT: res://addons/gut/cli/change_project_warnings.gd ---
extends SceneTree

var Optparse = load('res://addons/gut/cli/optparse.gd')
var WarningsManager = load("res://addons/gut/warnings_manager.gd")
const WARN_VALUE_PRINT_POSITION = 36

var godot_default_warnings = {
  "assert_always_false": 1,             "assert_always_true": 1,  			"confusable_identifier": 1,
  "confusable_local_declaration": 1,    "confusable_local_usage": 1,  		"constant_used_as_function": 1,
  "deprecated_keyword": 1,              "empty_file": 1,  					"enable": true,
  "exclude_addons": true, 				"function_used_as_property": 1,  	"get_node_default_without_onready": 2,
  "incompatible_ternary": 1,  			"inference_on_variant": 2,  		"inferred_declaration": 0,
  "int_as_enum_without_cast": 1,  		"int_as_enum_without_match": 1,  	"integer_division": 1,
  "narrowing_conversion": 1,  			"native_method_override": 2,  		"onready_with_export": 2,
  "property_used_as_function": 1,  		"redundant_await": 1,  				"redundant_static_unload": 1,
  "renamed_in_godot_4_hint": 1,  		"return_value_discarded": 0,  		"shadowed_global_identifier": 1,
  "shadowed_variable": 1,  				"shadowed_variable_base_class": 1,  "standalone_expression": 1,
  "standalone_ternary": 1,  			"static_called_on_instance": 1,  	"unassigned_variable": 1,
  "unassigned_variable_op_assign": 1,  	"unreachable_code": 1,  			"unreachable_pattern": 1,
  "unsafe_call_argument": 0,  			"unsafe_cast": 0,  					"unsafe_method_access": 0,
  "unsafe_property_access": 0,  		"unsafe_void_return": 1,  			"untyped_declaration": 0,
  "unused_local_constant": 1,  			"unused_parameter": 1,  			"unused_private_class_variable": 1,
  "unused_signal": 1,  					"unused_variable": 1
}

var gut_default_changes = {
  "exclude_addons": false, 				"redundant_await": 0,
}

var warning_settings = {}

func _setup_warning_settings():
	warning_settings["godot_default"] = godot_default_warnings
	warning_settings["current"] = WarningsManager.create_warnings_dictionary_from_project_settings()
	warning_settings["all_warn"] = WarningsManager.create_warn_all_warnings_dictionary()

	var gut_default = godot_default_warnings.duplicate()
	gut_default.merge(gut_default_changes, true)
	warning_settings["gut_default"] = gut_default


func _warn_value_to_s(value):
	var readable = str(value).capitalize()
	if(typeof(value) == TYPE_INT):
		readable = WarningsManager.WARNING_LOOKUP.get(value, str(readable, ' ???'))
		readable = readable.capitalize()
	return readable


func _human_readable(warnings):
	var to_return = ""
	for key in warnings:
		var readable = _warn_value_to_s(warnings[key])
		to_return += str(key.capitalize().rpad(35, ' '), readable, "\n")
	return to_return


func _dump_settings(which):
	if(warning_settings.has(which)):
		GutUtils.pretty_print(warning_settings[which])
	else:
		print("UNKNOWN print option ", which)


func _print_settings(which):
	if(warning_settings.has(which)):
		print(_human_readable(warning_settings[which]))
	else:
		print("UNKNOWN print option ", which)


func _apply_settings(which):
	if(!warning_settings.has(which)):
		print("UNKNOWN set option ", which)
		return

	var pre_settings = warning_settings["current"]
	var new_settings = warning_settings[which]

	if(new_settings == pre_settings):
		print("-- Settings are the same, no changes were made --")
		return

	WarningsManager.apply_warnings_dictionary(new_settings)
	ProjectSettings.save()
	print("-- Project Warning Settings have been updated --")
	print(_diff_changes_text(pre_settings))


func _diff_text(w1, w2, diff_col_pad=10):
	var to_return = ""
	for key in w1:
		var v1_text = _warn_value_to_s(w1[key])
		var v2_text = _warn_value_to_s(w2[key])
		var diff_text = v1_text
		var prefix = "  "

		if(v1_text != v2_text):
			var diff_prefix = " "
			if(w1[key] > w2[key]):
				diff_prefix = "-"
			else:
				diff_prefix = "+"
			prefix = "* "
			diff_text = str(v1_text.rpad(diff_col_pad, ' '), diff_prefix, v2_text)

		to_return += str(str(prefix, key.capitalize()).rpad(WARN_VALUE_PRINT_POSITION, ' '), diff_text, "\n")

	return to_return.rstrip("\n")


func _diff_changes_text(pre_settings):
	var orig_diff_text = _diff_text(
		pre_settings,
		WarningsManager.create_warnings_dictionary_from_project_settings(),
		0)
	# these next two lines are fragile and brute force...enjoy
	var diff_text = orig_diff_text.replace("-", " -> ")
	diff_text = diff_text.replace("+", " -> ")

	if(orig_diff_text == diff_text):
		diff_text += "\n-- No changes were made --"
	else:
		diff_text += "\nChanges will not be visible in Godot until it is restarted.\n"
		diff_text += "Even if it asks you to reload...Maybe.  Probably."

	return diff_text



func _diff(name_1, name_2):
	if(warning_settings.has(name_1) and warning_settings.has(name_2)):
		var c2_pad = name_1.length() + 2
		var heading = str(" ".repeat(WARN_VALUE_PRINT_POSITION), name_1.rpad(c2_pad, ' '), name_2, "\n")
		heading += str(
			" ".repeat(WARN_VALUE_PRINT_POSITION),
			"-".repeat(name_1.length()).rpad(c2_pad, " "),
			"-".repeat(name_2.length()),
			"\n")

		var text = _diff_text(warning_settings[name_1], warning_settings[name_2], c2_pad)

		print(heading)
		print(text)

		var diff_count = 0
		for line in text.split("\n"):
			if(!line.begins_with("  ")):
				diff_count += 1

		if(diff_count == 0):
			print('-- [', name_1, "] and [", name_2, "] are the same --")
		else:
			print('-- There are ', diff_count, ' differences between [', name_1, "] and [", name_2, "] --")
	else:
		print("One or more unknown Warning Level Names:, [", name_1, "] [", name_2, "]")


func _set_settings(nvps):
	var pre_settings = warning_settings["current"]
	for i in range(nvps.size()/2):
		var s_name = nvps[i * 2]
		var s_value = nvps[i * 2 + 1]
		if(godot_default_warnings.has(s_name)):
			var t = typeof(godot_default_warnings[s_name])
			if(t == TYPE_INT):
				s_value = s_value.to_int()
			elif(t == TYPE_BOOL):
				s_value = s_value.to_lower() == 'true'

			WarningsManager.set_project_setting_warning(s_name, s_value)
			ProjectSettings.save()
	print(_diff_changes_text(pre_settings))



func _setup_options():
	var opts = Optparse.new()
	opts.banner = """
	This script prints info about or sets the warning settings for the project.
	Each action requires one or more Warning Level Names.

	Warning Level Names:
	    * current        The current settings for the project.
	    * godot_default  The default settings for Godot.
	    * gut_default    The warning settings that is used when developing GUT.
	    * all_warn       Everything set to warn.
	""".dedent()

	opts.add('-h', false, 'Print this help')
	opts.add('-set', [], "Sets a single setting in the project settings and saves.\n" +
						 "Use -dump to see a list of setting names and values.\n" +
						 "Example: -set enabled,true -set unsafe_cast,2 -set unreachable_code,0")
	opts.add_heading(" Actions (require Warning Level Name)")
	opts.add('-diff', [], "Shows the difference between two Warning Level Names.\n" +
						  "Example:  -diff current,all_warn")
	opts.add('-dump', 'none', "Prints a dictionary of the warning values.")
	opts.add('-print', 'none', "Print human readable warning values.")
	opts.add('-apply', 'none', "Applys one of the Warning Level Names to the project settings.  You should restart after using this")

	return opts

func _print_help(opts):
	opts.print_help()



func _init():
	# Testing might set this flag but it should never be disabled for this tool
	# or it cannot save project settings, but says it did.  Sneakily use the
	# private property to get around this property being read-only.  Don't
	# try this at home.
	WarningsManager._disabled = false

	_setup_warning_settings()

	var opts = _setup_options()
	opts.parse()

	if(opts.unused.size() != 0):
		opts.print_help()
		print("Unknown arguments ", opts.unused)
	if(opts.values.h):
		opts.print_help()
	elif(opts.values.print != 'none'):
		_print_settings(opts.values.print)
	elif(opts.values.dump != 'none'):
		_dump_settings(opts.values.dump)
	elif(opts.values.apply != 'none'):
		_apply_settings(opts.values.apply )
	elif(opts.values.diff.size() == 2):
		_diff(opts.values.diff[0], opts.values.diff[1])
	elif(opts.values.set.size() % 2 == 0):
		_set_settings(opts.values.set)
	else:
		opts.print_help()
		print("You didn't specify any options or too many or not the right size or something invalid.  I don't know what you want to do.")

	quit()

--- SCRIPT: res://addons/gut/cli/gut_cli.gd ---
extends Node

var Optparse = load('res://addons/gut/cli/optparse.gd')
var Gut = load('res://addons/gut/gut.gd')
var GutRunner = load('res://addons/gut/gui/GutRunner.tscn')

# ------------------------------------------------------------------------------
# Helper class to resolve the various different places where an option can
# be set.  Using the get_value method will enforce the order of precedence of:
# 	1.  command line value
#	2.  config file value
#	3.  default value
#
# The idea is that you set the base_opts.  That will get you a copies of the
# hash with null values for the other types of values.  Lower precedented hashes
# will punch through null values of higher precedented hashes.
# ------------------------------------------------------------------------------
class OptionResolver:
	var base_opts = {}
	var cmd_opts = {}
	var config_opts = {}


	func get_value(key):
		return _nvl(cmd_opts[key], _nvl(config_opts[key], base_opts[key]))

	func set_base_opts(opts):
		base_opts = opts
		cmd_opts = _null_copy(opts)
		config_opts = _null_copy(opts)

	# creates a copy of a hash with all values null.
	func _null_copy(h):
		var new_hash = {}
		for key in h:
			new_hash[key] = null
		return new_hash

	func _nvl(a, b):
		if(a == null):
			return b
		else:
			return a

	func _string_it(h):
		var to_return = ''
		for key in h:
			to_return += str('(',key, ':', _nvl(h[key], 'NULL'), ')')
		return to_return

	func to_s():
		return str("base:\n", _string_it(base_opts), "\n", \
				"config:\n", _string_it(config_opts), "\n", \
				"cmd:\n", _string_it(cmd_opts), "\n", \
				"resolved:\n", _string_it(get_resolved_values()))

	func get_resolved_values():
		var to_return = {}
		for key in base_opts:
			to_return[key] = get_value(key)
		return to_return

	func to_s_verbose():
		var to_return = ''
		var resolved = get_resolved_values()
		for key in base_opts:
			to_return += str(key, "\n")
			to_return += str('  default: ', _nvl(base_opts[key], 'NULL'), "\n")
			to_return += str('  config:  ', _nvl(config_opts[key], ' --'), "\n")
			to_return += str('  cmd:     ', _nvl(cmd_opts[key], ' --'), "\n")
			to_return += str('  final:   ', _nvl(resolved[key], 'NULL'), "\n")

		return to_return

# ------------------------------------------------------------------------------
# Here starts the actual script that uses the Options class to kick off Gut
# and run your tests.
# ------------------------------------------------------------------------------
var _gut_config = load('res://addons/gut/gut_config.gd').new()

# array of command line options specified
var _final_opts = []


func setup_options(options, font_names):
	var opts = Optparse.new()
	opts.banner =\
"""
The GUT CLI
-----------
The default behavior for GUT is to load options from a res://.gutconfig.json if
it exists.  Any options specified on the command line will take precedence over
options specified in the gutconfig file.  You can specify a different gutconfig
file with the -gconfig option.

To generate a .gutconfig.json file you can use -gprint_gutconfig_sample
To see the effective values of a CLI command and a gutconfig use -gpo

Values for options can be supplied using:
    option=value    # no space around "="
    option value    # a space between option and value w/o =

Options whose values are lists/arrays can be specified multiple times:
	-gdir=a,b
	-gdir c,d
	-gdir e
	# results in -gdir equaling [a, b, c, d, e]
"""
	opts.add_heading("Test Config:")
	opts.add('-gdir', options.dirs, 'List of directories to search for test scripts in.')
	opts.add('-ginclude_subdirs', false, 'Flag to include all subdirectories specified with -gdir.')
	opts.add('-gtest', [], 'List of full paths to test scripts to run.')
	opts.add('-gprefix', options.prefix, 'Prefix used to find tests when specifying -gdir.  Default "[default]".')
	opts.add('-gsuffix', options.suffix, 'Test script suffix, including .gd extension.  Default "[default]".')
	opts.add('-gconfig', 'res://.gutconfig.json', 'The config file to load options from.  The default is [default].  Use "-gconfig=" to not use a config file.')
	opts.add('-gpre_run_script', '', 'pre-run hook script path')
	opts.add('-gpost_run_script', '', 'post-run hook script path')
	opts.add('-gerrors_do_not_cause_failure', false, 'When an internal GUT error occurs tests will fail.  With this option set, that does not happen.')
	opts.add('-gdouble_strategy', 'SCRIPT_ONLY', 'Default strategy to use when doubling.  Valid values are [INCLUDE_NATIVE, SCRIPT_ONLY].  Default "[default]"')

	opts.add_heading("Run Options:")
	opts.add('-gselect', '', 'All scripts that contain the specified string in their filename will be ran')
	opts.add('-ginner_class', '', 'Only run inner classes that contain the specified string in their name.')
	opts.add('-gunit_test_name', '', 'Any test that contains the specified text will be run, all others will be skipped.')
	opts.add('-gexit', false, 'Exit after running tests.  If not specified you have to manually close the window.')
	opts.add('-gexit_on_success', false, 'Only exit if zero tests fail.')
	opts.add('-gignore_pause', false, 'Ignores any calls to pause_before_teardown.')

	opts.add_heading("Display Settings:")
	opts.add('-glog', options.log_level, 'Log level [0-3].  Default [default]')
	opts.add('-ghide_orphans', false, 'Display orphan counts for tests and scripts.  Default [default].')
	opts.add('-gmaximize', false, 'Maximizes test runner window to fit the viewport.')
	opts.add('-gcompact_mode', false, 'The runner will be in compact mode.  This overrides -gmaximize.')
	opts.add('-gopacity', options.opacity, 'Set opacity of test runner window. Use range 0 - 100. 0 = transparent, 100 = opaque.')
	opts.add('-gdisable_colors', false, 'Disable command line colors.')
	opts.add('-gfont_name', options.font_name, str('Valid values are:  ', font_names, '.  Default "[default]"'))
	opts.add('-gfont_size', options.font_size, 'Font size, default "[default]"')
	opts.add('-gbackground_color', options.background_color, 'Background color as an html color, default "[default]"')
	opts.add('-gfont_color',options.font_color, 'Font color as an html color, default "[default]"')
	opts.add('-gpaint_after', options.paint_after, 'Delay before GUT will add a 1 frame pause to paint the screen/GUI.  default [default]')

	opts.add_heading("Result Export:")
	opts.add('-gjunit_xml_file', options.junit_xml_file, 'Export results of run to this file in the Junit XML format.')
	opts.add('-gjunit_xml_timestamp', options.junit_xml_timestamp, 'Include a timestamp in the -gjunit_xml_file, default [default]')

	opts.add_heading("Help:")
	opts.add('-gh', false, 'Print this help.  You did this to see this, so you probably understand.')
	opts.add('-gpo', false, 'Print option values from all sources and the value used.')
	opts.add('-gprint_gutconfig_sample', false, 'Print out json that can be used to make a gutconfig file.')

	return opts


# Parses options, applying them to the _tester or setting values
# in the options struct.
func extract_command_line_options(from, to):
	to.config_file = from.get_value_or_null('-gconfig')
	to.dirs = from.get_value_or_null('-gdir')
	to.disable_colors =  from.get_value_or_null('-gdisable_colors')
	to.double_strategy = from.get_value_or_null('-gdouble_strategy')
	to.ignore_pause = from.get_value_or_null('-gignore_pause')
	to.include_subdirs = from.get_value_or_null('-ginclude_subdirs')
	to.inner_class = from.get_value_or_null('-ginner_class')
	to.log_level = from.get_value_or_null('-glog')
	to.opacity = from.get_value_or_null('-gopacity')
	to.post_run_script = from.get_value_or_null('-gpost_run_script')
	to.pre_run_script = from.get_value_or_null('-gpre_run_script')
	to.prefix = from.get_value_or_null('-gprefix')
	to.selected = from.get_value_or_null('-gselect')
	to.should_exit = from.get_value_or_null('-gexit')
	to.should_exit_on_success = from.get_value_or_null('-gexit_on_success')
	to.should_maximize = from.get_value_or_null('-gmaximize')
	to.compact_mode = from.get_value_or_null('-gcompact_mode')
	to.hide_orphans = from.get_value_or_null('-ghide_orphans')
	to.suffix = from.get_value_or_null('-gsuffix')
	to.errors_do_not_cause_failure = from.get_value_or_null('-gerrors_do_not_cause_failure')
	to.tests = from.get_value_or_null('-gtest')
	to.unit_test_name = from.get_value_or_null('-gunit_test_name')

	to.font_size = from.get_value_or_null('-gfont_size')
	to.font_name = from.get_value_or_null('-gfont_name')
	to.background_color = from.get_value_or_null('-gbackground_color')
	to.font_color = from.get_value_or_null('-gfont_color')
	to.paint_after = from.get_value_or_null('-gpaint_after')

	to.junit_xml_file = from.get_value_or_null('-gjunit_xml_file')
	to.junit_xml_timestamp = from.get_value_or_null('-gjunit_xml_timestamp')



func _print_gutconfigs(values):
	var header = """Here is a sample of a full .gutconfig.json file.
You do not need to specify all values in your own file.  The values supplied in
this sample are what would be used if you ran gut w/o the -gprint_gutconfig_sample
option.   Option priority is:  command-line, .gutconfig, default)."""
	print("\n", header.replace("\n", ' '), "\n")
	var resolved = values

	# remove_at some options that don't make sense to be in config
	resolved.erase("config_file")
	resolved.erase("show_help")

	print(JSON.stringify(resolved, '  '))

	for key in resolved:
		resolved[key] = null

	print("\n\nAnd here's an empty config for you fill in what you want.")
	print(JSON.stringify(resolved, ' '))


func _run_tests(opt_resolver):
	_final_opts = opt_resolver.get_resolved_values();
	_gut_config.options = _final_opts

	var runner = GutRunner.instantiate()
	runner.set_gut_config(_gut_config)
	get_tree().root.add_child(runner)

	runner.run_tests()


# parse options and run Gut
func main():
	var opt_resolver = OptionResolver.new()
	opt_resolver.set_base_opts(_gut_config.default_options)

	var cli_opts = setup_options(_gut_config.default_options, _gut_config.valid_fonts)

	cli_opts.parse()
	var all_options_valid = cli_opts.unused.size() == 0
	extract_command_line_options(cli_opts, opt_resolver.cmd_opts)

	var config_path = opt_resolver.get_value('config_file')
	var load_result = 1
	# Checking for an empty config path allows us to not use a config file via
	# the -gconfig_file option since using "-gconfig_file=" or -gconfig_file=''"
	# will result in an empty string.
	if(config_path != ''):
		load_result = _gut_config.load_options_no_defaults(config_path)

	# SHORTCIRCUIT
	if(!all_options_valid):
		print('Unknown arguments:  ', cli_opts.unused)
		get_tree().quit(1)
	elif(load_result == -1):
		print('Invalid gutconfig ', load_result)
		get_tree().quit(1)
	else:
		opt_resolver.config_opts = _gut_config.options

		if(cli_opts.get_value('-gh')):
			print(GutUtils.version_numbers.get_version_text())
			cli_opts.print_help()
			get_tree().quit(0)
		elif(cli_opts.get_value('-gpo')):
			print('All config options and where they are specified.  ' +
				'The "final" value shows which value will actually be used ' +
				'based on order of precedence (default < .gutconfig < cmd line).' + "\n")
			print(opt_resolver.to_s_verbose())
			get_tree().quit(0)
		elif(cli_opts.get_value('-gprint_gutconfig_sample')):
			_print_gutconfigs(opt_resolver.get_resolved_values())
			get_tree().quit(0)
		else:
			_run_tests(opt_resolver)



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/cli/optparse.gd ---
## Parses command line arguments, as one might expect.
##
## Parses command line arguments with a bunch of options including generating
## text that displays all the arguments your script accepts.  This
## is included in the GUT ClassRef since it might be usable by others and is
## portable (everything it needs is in this one file).
## [br]
## This does alot, if you want to see it in action have a look at
##	[url=https://github.com/bitwes/Gut/blob/main/scratch/optparse_example.gd]scratch/optparse_example.gd[/url]
## [codeblock lang=text]
##
## Godot Argument Lists
## -------------------------
## There are two sets of command line arguments that Godot populates:
##	OS.get_cmdline_args
##	OS.get_cmdline_user_args.
##
## OS.get_cmdline_args contains any arguments that are not used by the engine
## itself.  This means options like --help and -d will never appear in this list
## since these are used by the engine.  The one exception is the -s option which
## is always included as the first entry and the script path as the second.
## Optparse ignores these values for argument processing but can be accessed
## with my_optparse.options.script_option.  This list does not contain any
## arguments that appear in OS.get_cmdline_user_args.
##
## OS.get_cmdline_user_args contains any arguments that appear on the command
## line AFTER " -- " or " ++ ".  This list CAN contain options that the engine
## would otherwise use, and are ignored completely by the engine.
##
## The parse method, by default, includes arguments from OS.get_cmdline_args and
## OS.get_cmdline_user_args.  You can optionally pass one of these to the parse
## method to limit which arguments are parsed.  You can also conjure up your own
## array of arguments and pass that to parse.
##
## See Godot's documentation for get_cmdline_args and get_cmdline_user_args for
## more information.
##
##
## Adding Options
## --------------
## Use the following to add options to be parsed.  These methods return the
## created Option instance.  See that class above for more info.  You can use
## the returned instance to get values, or use get_value/get_value_or_null.
##   add("--name", "default", "Description goes here")
##   add(["--name", "--aliases"], "default", "Description goes here")
##   add_required(["--name", "--aliases"], "default", "Description goes here")
##   add_positional("--name", "default", "Description goes here")
##   add_positional_required("--name", "default", "Description goes here")
##
## get_value will return the value of the option or the default if it was not
## set.  get_value_or_null will return the value of the option or null if it was
## not set.
##
## The Datatype for an option is determined from the default value supplied to
## the various add methods.  Supported types are
##   String
##   Int
##   Float
##   Array of strings
##   Boolean
##
##
## Value Parsing
## -------------
## optparse uses option_name_prefix to differentiate between option names and
## values.  Any argument that starts with this value will be treated as an
## argument name.  The default is "-".  Set this before calling parse if you want
## to change it.
##
## Values for options can be supplied on the command line with or without an "=":
##	option=value    # no space around "="
##	option value    # a space between option and value w/o =
## There is no way to escape "=" at this time.
##
## Array options can be specified multiple times and/or set from a comma delimited
## list.
##   -gdir=a,b
##   -gdir c,d
##   -gdir e
## Results in -gdir equaling [a, b, c, d, e].  There is no way to escape commas
## at this time.
##
## To specify an empty list via the command line follow the option with an equal
## sign
##   -gdir=
##
## Boolean options will have thier value set to !default when they are supplied
## on the command line.  Boolean options cannot have a value on the command line.
## They are either supplied or not.
##
## If a value is not an array and is specified multiple times on the command line
## then the last entry will be used as the value.
##
## Positional argument values are parsed after all named arguments are parsed.
## This means that other options can appear before, between, and after positional
## arguments.
##   --foo=bar positional_0_value --disabled --bar foo positional_1_value --a_flag
##
## Anything that is not used by named or positional arguments will appear in the
## unused property.  You can use this to detect unrecognized arguments or treat
## everything else provided as a list of things, or whatever you want.  You can
## use is_option on the elements of unused (or whatever you want really) to see
## if optparse would treat it as an option name.
##
## Use get_missing_required_options to get an array of Option with all required
## options that were not found when parsing.
##
## The parsed_args property holds the list of arguments that were parsed.
##
##
## Help Generation
## ---------------
## You can call get_help to generate help text, or you can just call print_help
## and this will print it for you.
##
## Set the banner property to any text you want to appear before the usage and
## options sections.
##
## Options are printed in the order they are added.  You can add a heading for
## different options sections with add_heading.
##   add("--asdf", 1, "This will have no heading")
##   add_heading("foo")
##   add("--foo", false, "This will have the foo heading")
##   add("--another_foo", 1.5, "This too.")
##   add_heading("This is after foo")
##   add("--bar", true, "You probably get it by now.")
##
## If you include "[default]" in the description of a option, then the help will
## substitue it with the default value.
## [/codeblock]


#-------------------------------------------------------------------------------
# Holds all the properties of a command line option
#
# value will return the default when it has not been set.
#-------------------------------------------------------------------------------
class Option:
	var _has_been_set = false
	var _value = null
	# REMEMBER that when this option is an array, you have to set the value
	# before you alter the contents of the array (append etc) or has_been_set
	# will return false and it might not be used right.  For example
	# get_value_or_null will return null when you've actually changed the value.
	var value = _value:
		get:
			return _value

		set(val):
			_has_been_set = true
			_value = val

	var option_name = ''
	var default = null
	var description = ''
	var required = false
	var aliases: Array[String] = []


	func _init(name,default_value,desc=''):
		option_name = name
		default = default_value
		description = desc
		_value = default


	func to_s(min_space=0):
		var line_indent = str("\n", " ".repeat(min_space + 1))
		var subbed_desc = description
		if not aliases.is_empty():
			subbed_desc += "\naliases: " + ", ".join(aliases)
		subbed_desc = subbed_desc.replace('[default]', str(default))
		subbed_desc = subbed_desc.replace("\n", line_indent)
		return str(option_name.rpad(min_space), ' ', subbed_desc)


	func has_been_set():
		return _has_been_set




#-------------------------------------------------------------------------------
# A struct for organizing options by a heading
#-------------------------------------------------------------------------------
class OptionHeading:
	var options = []
	var display = 'default'




#-------------------------------------------------------------------------------
# Organizes options by order, heading, position.  Also responsible for all
# help related text generation.
#-------------------------------------------------------------------------------
class Options:
	var options = []
	var positional = []
	var default_heading = OptionHeading.new()
	var script_option = Option.new('-s', '?', 'script option provided by Godot')

	var _options_by_name = {"--script": script_option, "-s": script_option}
	var _options_by_heading = [default_heading]
	var _cur_heading = default_heading


	func add_heading(display):
		var heading = OptionHeading.new()
		heading.display = display
		_cur_heading = heading
		_options_by_heading.append(heading)


	func add(option, aliases=null):
		options.append(option)
		_options_by_name[option.option_name] = option
		_cur_heading.options.append(option)

		if aliases != null:
			for a in aliases:
				_options_by_name[a] = option
			option.aliases.assign(aliases)


	func add_positional(option):
		positional.append(option)
		_options_by_name[option.option_name] = option


	func get_by_name(option_name):
		var found_param = null
		if(_options_by_name.has(option_name)):
			found_param = _options_by_name[option_name]

		return found_param


	func get_help_text():
		var longest = 0
		var text = ""
		for i in range(options.size()):
			if(options[i].option_name.length() > longest):
				longest = options[i].option_name.length()

		for heading in _options_by_heading:
			if(heading != default_heading):
				text += str("\n", heading.display, "\n")
			for option in heading.options:
				text += str('  ', option.to_s(longest + 2).replace("\n", "\n  "), "\n")

		return text


	func get_option_value_text():
		var text = ""
		var i = 0
		for option in positional:
			text += str(i, '.  ', option.option_name, ' = ', option.value)

			if(!option.has_been_set()):
				text += " (default)"
			text += "\n"
			i += 1

		for option in options:
			text += str(option.option_name, ' = ', option.value)

			if(!option.has_been_set()):
				text += " (default)"
			text += "\n"
		return text


	func print_option_values():
		print(get_option_value_text())


	func get_missing_required_options():
		var to_return = []
		for opt in options:
			if(opt.required and !opt.has_been_set()):
				to_return.append(opt)

		for opt in positional:
			if(opt.required and !opt.has_been_set()):
				to_return.append(opt)

		return to_return


	func get_usage_text():
		var pos_text = ""
		for opt in positional:
			pos_text += str("[", opt.description, "] ")

		if(pos_text != ""):
			pos_text += " [opts] "

		return "<path to godot> -s " + script_option.value + " [opts] " + pos_text




#-------------------------------------------------------------------------------
#
# optarse
#
#-------------------------------------------------------------------------------
## @ignore
var options := Options.new()
## Set the banner property to any text you want to appear before the usage and
## options sections when printing the options help.
var banner := ''
## optparse uses option_name_prefix to differentiate between option names and
## values.  Any argument that starts with this value will be treated as an
## argument name.  The default is "-".  Set this before calling parse if you want
## to change it.
var option_name_prefix := '-'
## @ignore
var unused = []
## @ignore
var parsed_args = []
## @ignore
var values: Dictionary = {}


func _populate_values_dictionary():
	for entry in options.options:
		var value_key = entry.option_name.lstrip('-')
		values[value_key] = entry.value

	for entry in options.positional:
		var value_key = entry.option_name.lstrip('-')
		values[value_key] = entry.value


func _convert_value_to_array(raw_value):
	var split = raw_value.split(',')
	# This is what an empty set looks like from the command line.  If we do
	# not do this then we will always get back [''] which is not what it
	# shoudl be.
	if(split.size() == 1 and split[0] == ''):
		split = []
	return split

# REMEMBER raw_value not used for bools.
func _set_option_value(option, raw_value):
	var t = typeof(option.default)
	# only set values that were specified at the command line so that
	# we can punch through default and config values correctly later.
	# Without this check, you can't tell the difference between the
	# defaults and what was specified, so you can't punch through
	# higher level options.
	if(t == TYPE_INT):
		option.value = int(raw_value)
	elif(t == TYPE_STRING):
		option.value = str(raw_value)
	elif(t == TYPE_ARRAY):
		var values = _convert_value_to_array(raw_value)
		if(!option.has_been_set()):
			option.value = []
		option.value.append_array(values)
	elif(t == TYPE_BOOL):
		option.value = !option.default
	elif(t == TYPE_FLOAT):
		option.value = float(raw_value)
	elif(t == TYPE_NIL):
		print(option.option_name + ' cannot be processed, it has a nil datatype')
	else:
		print(option.option_name + ' cannot be processed, it has unknown datatype:' + str(t))


func _parse_command_line_arguments(args):
	var parsed_opts = args.duplicate()
	var i = 0
	var positional_index = 0

	while i < parsed_opts.size():
		var opt  = ''
		var value = ''
		var entry = parsed_opts[i]

		if(is_option(entry)):
			if(entry.find('=') != -1):
				var parts = entry.split('=')
				opt = parts[0]
				value = parts[1]
				var the_option = options.get_by_name(opt)
				if(the_option != null):
					parsed_opts.remove_at(i)
					_set_option_value(the_option, value)
				else:
					i += 1
			else:
				var the_option = options.get_by_name(entry)
				if(the_option != null):
					parsed_opts.remove_at(i)
					if(typeof(the_option.default) == TYPE_BOOL):
						_set_option_value(the_option, null)
					elif(i < parsed_opts.size() and !is_option(parsed_opts[i])):
						value = parsed_opts[i]
						parsed_opts.remove_at(i)
						_set_option_value(the_option, value)
				else:
					i += 1
		else:
			if(positional_index < options.positional.size()):
				_set_option_value(options.positional[positional_index], entry)
				parsed_opts.remove_at(i)
				positional_index += 1
			else:
				i += 1

	# this is the leftovers that were not extracted.
	return parsed_opts


## Test if something is an existing argument. If [code]str(arg)[/code] begins
## with the [member option_name_prefix], it will considered true,
## otherwise it will be considered false.
func is_option(arg) -> bool:
	return str(arg).begins_with(option_name_prefix)


## Adds a command line option.
## If [param op_names] is a String, this is set as the argument's name.
## If [param op_names] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add(op_names, default, desc: String) -> Option:
	var op_name: String
	var aliases: Array[String] = []
	var new_op: Option = null

	if(typeof(op_names) == TYPE_STRING):
		op_name = op_names
	else:
		op_name = op_names[0]
		aliases.assign(op_names.slice(1))

	var bad_alias: int = aliases.map(
		func (a: String) -> bool: return options.get_by_name(a) != null
	).find(true)

	if(options.get_by_name(op_name) != null):
		push_error(str('Option [', op_name, '] already exists.'))
	elif bad_alias != -1:
		push_error(str('Option [', aliases[bad_alias], '] already exists.'))
	else:
		new_op = Option.new(op_name, default, desc)
		options.add(new_op, aliases)

	return new_op


## Adds a required command line option.
## Required options that have not been set may be collected after parsing
## by calling [method get_missing_required_options].
## If [param op_names] is a String, this is set as the argument's name.
## If [param op_names] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add_required(op_names, default, desc: String) -> Option:
	var op := add(op_names, default, desc)
	if(op != null):
		op.required = true
	return op


## Adds a positional command line option.
## Positional options are parsed by their position in the list of arguments
## are are not assigned by name by the user.
## If [param op_name] is a String, this is set as the argument's name.
## If [param op_name] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add_positional(op_name, default, desc: String) -> Option:
	var new_op = null
	if(options.get_by_name(op_name) != null):
		push_error(str('Positional option [', op_name, '] already exists.'))
	else:
		new_op = Option.new(op_name, default, desc)
		options.add_positional(new_op)
	return new_op


## Adds a required positional command line option.
## If [param op_name] is a String, this is set as the argument's name.
## Required options that have not been set may be collected after parsing
## by calling [method get_missing_required_options].
## Positional options are parsed by their position in the list of arguments
## are are not assigned by name by the user.
## If [param op_name] is an Array of Strings, all elements of the array
## will be aliases for the same argument and will be treated as such during
## parsing.
## [param default] is the default value the option will be set to if it is not
## explicitly set during parsing.
## [param desc] is a human readable text description of the option.
## If the option is successfully added, the Option object will be returned.
## If the option is not successfully added (e.g. a name collision with another
## option occurs), an error message will be printed and [code]null[/code]
## will be returned.
func add_positional_required(op_name, default, desc: String) -> Option:
	var op = add_positional(op_name, default, desc)
	if(op != null):
		op.required = true
	return op


## Headings are used to separate logical groups of command line options
## when printing out options from the help menu.
## Headings are printed out between option descriptions in the order
## that [method add_heading] was called.
func add_heading(display_text: String) -> void:
	options.add_heading(display_text)


## Gets the value assigned to an option after parsing.
## [param name] can be the name of the option or an alias of it.
## [param name] specifies the option whose value you wish to query.
## If the option exists, the value assigned to it during parsing is returned.
## Otherwise, an error message is printed and [code]null[/code] is returned.
func get_value(name: String):
	var found_param: Option = options.get_by_name(name)

	if(found_param != null):
		return found_param.value
	else:
		push_error("COULD NOT FIND OPTION " + name)
		return null


## Gets the value assigned to an option after parsing,
## returning null if the option was not assigned instead of its default value.
## [param name] specifies the option whose value you wish to query.
## This can be useful when providing an order of precedence to your values.
## For example if
## [codeblock]
##     default value < config file < command line
## [/codeblock]
## then you do not want to get the default value for a command line option or
## it will overwrite the value in a config file.
func get_value_or_null(name: String):
	var found_param: Option = options.get_by_name(name)

	if(found_param != null and found_param.has_been_set()):
		return found_param.value
	else:
		return null


## Returns the help text for all defined options.
func get_help() -> String:
	var sep := '---------------------------------------------------------'

	var text := str(sep, "\n", banner, "\n\n")
	text += "Usage\n-----------\n"
	text += "  " + options.get_usage_text() + "\n\n"
	text += "\nOptions\n-----------\n"
	text += options.get_help_text()
	text += str(sep, "\n")
	return text


## Prints out the help text for all defined options.
func print_help() -> void:
	print(get_help())


## Parses a string for all options that have been set in this optparse.
## if [param cli_args] is passed as a String, then it is parsed.
## Otherwise if [param cli_args] is null,
## aruments passed to the Godot engine at startup are parsed.
## See the explanation at the top of addons/gut/cli/optparse.gd to understand
## which arguments this will have access to.
func parse(cli_args=null) -> void:
	parsed_args = cli_args

	if(parsed_args == null):
		parsed_args = OS.get_cmdline_args()
		parsed_args.append_array(OS.get_cmdline_user_args())

	unused = _parse_command_line_arguments(parsed_args)
	_populate_values_dictionary()


## Get all options that were required and were not set during parsing.
## The return value is an Array of Options.
func get_missing_required_options() -> Array:
	return options.get_missing_required_options()


# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/collected_script.gd ---
# ------------------------------------------------------------------------------
# This holds all the meta information for a test script.  It contains the
# name of the inner class and an array of CollectedTests.  This does not parse
# anything, it just holds the data about parsed scripts and tests.  The
# TestCollector is responsible for populating this object.
#
# This class also facilitates all the exporting and importing of tests.
# ------------------------------------------------------------------------------
var CollectedTest = GutUtils.CollectedTest

var _lgr = null

# One entry per test found in the script.  Added externally by TestCollector
var tests = []
# One entry for before_all and after_all (maybe add before_each and after_each).
# These are added by Gut when running before_all and after_all for the script.
var setup_teardown_tests = []
var inner_class_name:StringName
var path:String


# Set externally by test_collector after it can verify that the script was
# actually loaded.  This could probably be changed to just hold the GutTest
# script that was loaded, cutting down on complexity elsewhere.
var is_loaded = false

# Set by Gut when it decides that a script should be skipped.
# Right now this is whenever the script has the variable skip_script declared.
# the value of skip_script is put into skip_reason.
var was_skipped = false
var skip_reason = ''
var was_run = false


var name = '' :
	get: return path
	set(val):pass


func _init(logger=null):
	_lgr = logger


func get_new():
	return load_script().new()


func load_script():
	var to_return = load(path)

	if(inner_class_name != null and inner_class_name != ''):
		# If we wanted to do inner classes in inner classses
		# then this would have to become some kind of loop or recursive
		# call to go all the way down the chain or this class would
		# have to change to hold onto the loaded class instead of
		# just path information.
		to_return = to_return.get(inner_class_name)

	return to_return

# script.gd.InnerClass
func get_filename_and_inner():
	var to_return = get_filename()
	if(inner_class_name != ''):
		to_return += '.' + String(inner_class_name)
	return to_return


# res://foo/bar.gd.FooBar
func get_full_name():
	var to_return = path
	if(inner_class_name != ''):
		to_return += '.' + String(inner_class_name)
	return to_return


func get_filename():
	return path.get_file()


func has_inner_class():
	return inner_class_name != ''


# Note:  although this no longer needs to export the inner_class names since
#        they are pulled from metadata now, it is easier to leave that in
#        so we don't have to cut the export down to unique script names.
func export_to(config_file, section):
	config_file.set_value(section, 'path', path)
	config_file.set_value(section, 'inner_class', inner_class_name)
	var names = []
	for i in range(tests.size()):
		names.append(tests[i].name)
	config_file.set_value(section, 'tests', names)


func _remap_path(source_path):
	var to_return = source_path
	if(!FileAccess.file_exists(source_path)):
		_lgr.debug('Checking for remap for:  ' + source_path)
		var remap_path = source_path.get_basename() + '.gd.remap'
		if(FileAccess.file_exists(remap_path)):
			var cf = ConfigFile.new()
			cf.load(remap_path)
			to_return = cf.get_value('remap', 'path')
		else:
			_lgr.warn('Could not find remap file ' + remap_path)
	return to_return


func import_from(config_file, section):
	path = config_file.get_value(section, 'path')
	path = _remap_path(path)
	# Null is an acceptable value, but you can't pass null as a default to
	# get_value since it thinks you didn't send a default...then it spits
	# out red text.  This works around that.
	var inner_name = config_file.get_value(section, 'inner_class', 'Placeholder')
	if(inner_name != 'Placeholder'):
		inner_class_name = inner_name
	else: # just being explicit
		inner_class_name = StringName("")


func get_test_named(test_name):
	return GutUtils.search_array(tests, 'name', test_name)


func get_ran_test_count():
	var count = 0
	for t in tests:
		if(t.was_run):
			count += 1
	return count


func get_assert_count():
	var count = 0
	for t in tests:
		count += t.pass_texts.size()
		count += t.fail_texts.size()
	for t in setup_teardown_tests:
		count += t.pass_texts.size()
		count += t.fail_texts.size()
	return count


func get_pass_count():
	var count = 0
	for t in tests:
		count += t.pass_texts.size()
	for t in setup_teardown_tests:
		count += t.pass_texts.size()
	return count


func get_fail_count():
	var count = 0
	for t in tests:
		count += t.fail_texts.size()
	for t in setup_teardown_tests:
		count += t.fail_texts.size()
	return count


func get_pending_count():
	var count = 0
	for t in tests:
		count += t.pending_texts.size()
	return count


func get_passing_test_count():
	var count = 0
	for t in tests:
		if(t.is_passing()):
			count += 1
	return count


func get_failing_test_count():
	var count = 0
	for t in tests:
		if(t.is_failing()):
			count += 1
	return count


func get_risky_count():
	var count = 0
	if(was_skipped):
		count = 1
	else:
		for t in tests:
			if(t.is_risky()):
				count += 1
	return count


func to_s():
	var to_return = path
	if(inner_class_name != null):
		to_return += str('.', inner_class_name)
	to_return += "\n"
	for i in range(tests.size()):
		to_return += str('  ', tests[i].to_s())
	return to_return

--- SCRIPT: res://addons/gut/collected_test.gd ---
# ------------------------------------------------------------------------------
# Used to keep track of info about each test ran.
# ------------------------------------------------------------------------------
# the name of the function
var name = ""

# flag to know if the name has been printed yet.  Used by the logger.
var has_printed_name = false

# the number of arguments the method has
var arg_count = 0

# the time it took to execute the test in seconds
var time_taken : float = 0

# The number of asserts in the test.  Converted to a property for backwards
# compatibility.  This now reflects the text sizes instead of being a value
# that can be altered externally.
var assert_count = 0 :
	get: return pass_texts.size() + fail_texts.size()
	set(val): pass

# Converted to propety for backwards compatibility.  This now cannot be set
# externally
var pending = false :
	get: return is_pending()
	set(val): pass

# the line number when the test fails
var line_number = -1

# Set internally by Gut using whatever reason Gut wants to use to set this.
# Gut will skip these marked true and the test will be listed as risky.
var should_skip = false  # -- Currently not used by GUT don't believe ^

var pass_texts = []
var fail_texts = []
var pending_texts = []
var orphans = 0

var was_run = false


func did_pass():
	return is_passing()


func add_fail(fail_text):
	fail_texts.append(fail_text)


func add_pending(pending_text):
	pending_texts.append(pending_text)


func add_pass(passing_text):
	pass_texts.append(passing_text)


# must have passed an assert and not have any other status to be passing
func is_passing():
	return pass_texts.size() > 0 and fail_texts.size() == 0 and pending_texts.size() == 0


# failing takes precedence over everything else, so any failures makes the
# test a failure.
func is_failing():
	return fail_texts.size() > 0


# test is only pending if pending was called and the test is not failing.
func is_pending():
	return pending_texts.size() > 0 and fail_texts.size() == 0


func is_risky():
	return should_skip or (was_run and !did_something())


func did_something():
	return is_passing() or is_failing() or is_pending()


func get_status_text():
	var to_return = GutUtils.TEST_STATUSES.NO_ASSERTS

	if(should_skip):
		to_return = GutUtils.TEST_STATUSES.SKIPPED
	elif(!was_run):
		to_return = GutUtils.TEST_STATUSES.NOT_RUN
	elif(pending_texts.size() > 0):
		to_return = GutUtils.TEST_STATUSES.PENDING
	elif(fail_texts.size() > 0):
		to_return = GutUtils.TEST_STATUSES.FAILED
	elif(pass_texts.size() > 0):
		to_return = GutUtils.TEST_STATUSES.PASSED

	return to_return


# Deprecated
func get_status():
	return get_status_text()


func to_s():
	var pad = '     '
	var to_return = str(name, "[", get_status_text(), "]\n")

	for i in range(fail_texts.size()):
		to_return += str(pad, 'Fail:  ', fail_texts[i])
	for i in range(pending_texts.size()):
		to_return += str(pad, 'Pending:  ', pending_texts[i], "\n")
	for i in range(pass_texts.size()):
		to_return += str(pad, 'Pass:  ', pass_texts[i], "\n")
	return to_return

--- SCRIPT: res://addons/gut/comparator.gd ---
var _strutils = GutUtils.Strutils.new()
var _max_length = 100
var _should_compare_int_to_float = true

const MISSING = '|__missing__gut__compare__value__|'


func _cannot_compare_text(v1, v2):
	return str('Cannot compare ', _strutils.types[typeof(v1)], ' with ',
		_strutils.types[typeof(v2)], '.')


func _make_missing_string(text):
	return '<missing ' + text + '>'


func _create_missing_result(v1, v2, text):
	var to_return = null
	var v1_str = format_value(v1)
	var v2_str = format_value(v2)

	if(typeof(v1) == TYPE_STRING and v1 == MISSING):
		v1_str = _make_missing_string(text)
		to_return = GutUtils.CompareResult.new()
	elif(typeof(v2) == TYPE_STRING and v2 == MISSING):
		v2_str = _make_missing_string(text)
		to_return = GutUtils.CompareResult.new()

	if(to_return != null):
		to_return.summary = str(v1_str, ' != ', v2_str)
		to_return.are_equal = false

	return to_return


func simple(v1, v2, missing_string=''):
	var missing_result = _create_missing_result(v1, v2, missing_string)
	if(missing_result != null):
		return missing_result

	var result = GutUtils.CompareResult.new()
	var cmp_str = null
	var extra = ''

	var tv1 = typeof(v1)
	var tv2 = typeof(v2)

	# print(tv1, '::', tv2, '   ', _strutils.types[tv1], '::', _strutils.types[tv2])
	if(_should_compare_int_to_float and [TYPE_INT, TYPE_FLOAT].has(tv1) and [TYPE_INT, TYPE_FLOAT].has(tv2)):
		result.are_equal = v1 == v2
	elif([TYPE_STRING, TYPE_STRING_NAME].has(tv1) and [TYPE_STRING, TYPE_STRING_NAME].has(tv2)):
		result.are_equal = v1 == v2
	elif(GutUtils.are_datatypes_same(v1, v2)):
		result.are_equal = v1 == v2

		if(typeof(v1) == TYPE_DICTIONARY or typeof(v1) == TYPE_ARRAY):
			var sub_result = GutUtils.DiffTool.new(v1, v2, GutUtils.DIFF.DEEP)
			result.summary = sub_result.get_short_summary()
			if(!sub_result.are_equal):
				extra = ".\n" + sub_result.get_short_summary()
	else:
		cmp_str = '!='
		result.are_equal = false
		extra = str('.  ', _cannot_compare_text(v1, v2))

	cmp_str = get_compare_symbol(result.are_equal)
	result.summary = str(format_value(v1), ' ', cmp_str, ' ', format_value(v2), extra)

	return result


func shallow(v1, v2):
	var result =  null
	if(GutUtils.are_datatypes_same(v1, v2)):
		if(typeof(v1) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			result = GutUtils.DiffTool.new(v1, v2, GutUtils.DIFF.DEEP)
		else:
			result = simple(v1, v2)
	else:
		result = simple(v1, v2)

	return result


func deep(v1, v2):
	var result =  null

	if(GutUtils.are_datatypes_same(v1, v2)):
		if(typeof(v1) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			result = GutUtils.DiffTool.new(v1, v2, GutUtils.DIFF.DEEP)
		else:
			result = simple(v1, v2)
	else:
		result = simple(v1, v2)

	return result


func format_value(val, max_val_length=_max_length):
	return _strutils.truncate_string(_strutils.type2str(val), max_val_length)


func compare(v1, v2, diff_type=GutUtils.DIFF.SIMPLE):
	var result = null
	if(diff_type == GutUtils.DIFF.SIMPLE):
		result = simple(v1, v2)
	elif(diff_type ==  GutUtils.DIFF.DEEP):
		result = deep(v1, v2)

	return result


func get_should_compare_int_to_float():
	return _should_compare_int_to_float


func set_should_compare_int_to_float(should_compare_int_float):
	_should_compare_int_to_float = should_compare_int_float


func get_compare_symbol(is_equal):
	if(is_equal):
		return '=='
	else:
		return '!='

--- SCRIPT: res://addons/gut/compare_result.gd ---
var _are_equal = false
var are_equal = false :
	get:
		return get_are_equal()
	set(val):
		set_are_equal(val)

var _summary = null
var summary = null :
	get:
		return get_summary()
	set(val):
		set_summary(val)

var _max_differences = 30
var max_differences = 30 :
	get:
		return get_max_differences()
	set(val):
		set_max_differences(val)

var _differences = {}
var differences :
	get:
		return get_differences()
	set(val):
		set_differences(val)

func _block_set(which, val):
	push_error(str('cannot set ', which, ', value [', val, '] ignored.'))

func _to_string():
	return str(get_summary()) # could be null, gotta str it.

func get_are_equal():
	return _are_equal

func set_are_equal(r_eq):
	_are_equal = r_eq

func get_summary():
	return _summary

func set_summary(smry):
	_summary = smry

func get_total_count():
	pass

func get_different_count():
	pass

func get_short_summary():
	return summary

func get_max_differences():
	return _max_differences

func set_max_differences(max_diff):
	_max_differences = max_diff

func get_differences():
	return _differences

func set_differences(diffs):
	_block_set('differences', diffs)

func get_brackets():
	return null

--- SCRIPT: res://addons/gut/diff_formatter.gd ---
var _strutils = GutUtils.Strutils.new()
const INDENT = '    '
var _max_to_display = 30
const ABSOLUTE_MAX_DISPLAYED = 10000
const UNLIMITED = -1


func _single_diff(diff, depth=0):
	var to_return = ""
	var brackets = diff.get_brackets()

	if(brackets != null and !diff.are_equal):
		to_return = ''
		to_return += str(brackets.open, "\n",
			_strutils.indent_text(differences_to_s(diff.differences, depth), depth+1, INDENT), "\n",
			brackets.close)
	else:
		to_return = str(diff)

	return to_return


func make_it(diff):
	var to_return = ''
	if(diff.are_equal):
		to_return = diff.summary
	else:
		if(_max_to_display ==  ABSOLUTE_MAX_DISPLAYED):
			to_return = str(diff.get_value_1(), ' != ', diff.get_value_2())
		else:
			to_return = diff.get_short_summary()
		to_return +=  str("\n", _strutils.indent_text(_single_diff(diff, 0), 1, '  '))
	return to_return


func differences_to_s(differences, depth=0):
	var to_return = ''
	var keys = differences.keys()
	keys.sort()
	var limit = min(_max_to_display, differences.size())

	for i in range(limit):
		var key = keys[i]
		to_return += str(key, ":  ", _single_diff(differences[key], depth))

		if(i != limit -1):
			to_return += "\n"

	if(differences.size() > _max_to_display):
		to_return += str("\n\n... ", differences.size() - _max_to_display, " more.")

	return to_return


func get_max_to_display():
	return _max_to_display


func set_max_to_display(max_to_display):
	_max_to_display = max_to_display
	if(_max_to_display == UNLIMITED):
		_max_to_display = ABSOLUTE_MAX_DISPLAYED

--- SCRIPT: res://addons/gut/diff_tool.gd ---
extends 'res://addons/gut/compare_result.gd'
const INDENT = '    '
enum {
	DEEP,
	SIMPLE
}

var _strutils = GutUtils.Strutils.new()
var _compare = GutUtils.Comparator.new()
var DiffTool = load('res://addons/gut/diff_tool.gd')

var _value_1 = null
var _value_2 = null
var _total_count = 0
var _diff_type = null
var _brackets = null
var _valid = true
var _desc_things = 'somethings'

# -------- comapre_result.gd "interface" ---------------------
func set_are_equal(val):
	_block_set('are_equal', val)

func get_are_equal():
	if(!_valid):
		return null
	else:
		return differences.size() == 0


func set_summary(val):
	_block_set('summary', val)

func get_summary():
	return summarize()

func get_different_count():
	return differences.size()

func  get_total_count():
	return _total_count

func get_short_summary():
	var text = str(_strutils.truncate_string(str(_value_1), 50),
		' ', _compare.get_compare_symbol(are_equal), ' ',
		_strutils.truncate_string(str(_value_2), 50))
	if(!are_equal):
		text += str('  ', get_different_count(), ' of ', get_total_count(),
			' ', _desc_things, ' do not match.')
	return text

func get_brackets():
	return _brackets
# -------- comapre_result.gd "interface" ---------------------


func _invalidate():
	_valid = false
	differences = null


func _init(v1,v2,diff_type=DEEP):
	_value_1 = v1
	_value_2 = v2
	_diff_type = diff_type
	_compare.set_should_compare_int_to_float(false)
	_find_differences(_value_1, _value_2)


func _find_differences(v1, v2):
	if(GutUtils.are_datatypes_same(v1, v2)):
		if(typeof(v1) == TYPE_ARRAY):
			_brackets = {'open':'[', 'close':']'}
			_desc_things = 'indexes'
			_diff_array(v1, v2)
		elif(typeof(v2) == TYPE_DICTIONARY):
			_brackets = {'open':'{', 'close':'}'}
			_desc_things = 'keys'
			_diff_dictionary(v1, v2)
		else:
			_invalidate()
			GutUtils.get_logger().error('Only Arrays and Dictionaries are supported.')
	else:
		_invalidate()
		GutUtils.get_logger().error('Only Arrays and Dictionaries are supported.')


func _diff_array(a1, a2):
	_total_count = max(a1.size(), a2.size())
	for i in range(a1.size()):
		var result = null
		if(i < a2.size()):
			if(_diff_type == DEEP):
				result = _compare.deep(a1[i], a2[i])
			else:
				result = _compare.simple(a1[i], a2[i])
		else:
			result = _compare.simple(a1[i], _compare.MISSING, 'index')

		if(!result.are_equal):
			differences[i] = result

	if(a1.size() < a2.size()):
		for i in range(a1.size(), a2.size()):
			differences[i] = _compare.simple(_compare.MISSING, a2[i], 'index')


func _diff_dictionary(d1, d2):
	var d1_keys = d1.keys()
	var d2_keys = d2.keys()

	# Process all the keys in d1
	_total_count += d1_keys.size()
	for key in d1_keys:
		if(!d2.has(key)):
			differences[key] = _compare.simple(d1[key], _compare.MISSING, 'key')
		else:
			d2_keys.remove_at(d2_keys.find(key))

			var result = null
			if(_diff_type == DEEP):
				result = _compare.deep(d1[key], d2[key])
			else:
				result = _compare.simple(d1[key], d2[key])

			if(!result.are_equal):
				differences[key] = result

	# Process all the keys in d2 that didn't exist in d1
	_total_count += d2_keys.size()
	for i in range(d2_keys.size()):
		differences[d2_keys[i]] = _compare.simple(_compare.MISSING, d2[d2_keys[i]], 'key')


func summarize():
	var summary = ''

	if(are_equal):
		summary = get_short_summary()
	else:
		var formatter = load('res://addons/gut/diff_formatter.gd').new()
		formatter.set_max_to_display(max_differences)
		summary = formatter.make_it(self)

	return summary


func get_diff_type():
	return _diff_type


func get_value_1():
	return _value_1


func get_value_2():
	return _value_2

--- SCRIPT: res://addons/gut/doubler.gd ---
extends RefCounted


var _base_script_text = GutUtils.get_file_as_text('res://addons/gut/double_templates/script_template.txt')
var _script_collector = GutUtils.ScriptCollector.new()
# used by tests for debugging purposes.
var print_source = false
var inner_class_registry = GutUtils.InnerClassRegistry.new()

# ###############
# Properties
# ###############
var _stubber = GutUtils.Stubber.new()
func get_stubber():
	return _stubber
func set_stubber(stubber):
	_stubber = stubber

var _lgr = GutUtils.get_logger()
func get_logger():
	return _lgr
func set_logger(logger):
	_lgr = logger
	_method_maker.set_logger(logger)

var _spy = null
func get_spy():
	return _spy
func set_spy(spy):
	_spy = spy

var _gut = null
func get_gut():
	return _gut
func set_gut(gut):
	_gut = gut

var _strategy = null
func get_strategy():
	return _strategy
func set_strategy(strategy):
	if(GutUtils.DOUBLE_STRATEGY.values().has(strategy)):
		_strategy = strategy
	else:
		_lgr.error(str('doubler.gd:  invalid double strategy ', strategy))


var _method_maker = GutUtils.MethodMaker.new()
func get_method_maker():
	return _method_maker

var _ignored_methods = GutUtils.OneToMany.new()
func get_ignored_methods():
	return _ignored_methods

# ###############
# Private
# ###############
func _init(strategy=GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY):
	set_logger(GutUtils.get_logger())
	_strategy = strategy


func _get_indented_line(indents, text):
	var to_return = ''
	for _i in range(indents):
		to_return += "\t"
	return str(to_return, text, "\n")


func _stub_to_call_super(parsed, method_name):
	if(!parsed.get_method(method_name).is_eligible_for_doubling()):
		return

	var params = GutUtils.StubParams.new(parsed.script_path, method_name, parsed.subpath)
	params.to_call_super()
	_stubber.add_stub(params)


func _get_base_script_text(parsed, override_path, partial, included_methods):
	var path = parsed.script_path
	if(override_path != null):
		path = override_path

	var stubber_id = -1
	if(_stubber != null):
		stubber_id = _stubber.get_instance_id()

	var spy_id = -1
	if(_spy != null):
		spy_id = _spy.get_instance_id()

	var gut_id = -1
	if(_gut != null):
		gut_id = _gut.get_instance_id()

	var extends_text  = parsed.get_extends_text()

	var values = {
		# Top  sections
		"extends":extends_text,
		"constants":'',#obj_info.get_constants_text(),
		"properties":'',#obj_info.get_properties_text(),

		# metadata values
		"path":path,
		"subpath":GutUtils.nvl(parsed.subpath, ''),
		"stubber_id":stubber_id,
		"spy_id":spy_id,
		"gut_id":gut_id,
		"singleton_name":'',#GutUtils.nvl(obj_info.get_singleton_name(), ''),
		"is_partial":partial,
		"doubled_methods":included_methods,
	}

	return _base_script_text.format(values)


func _is_method_eligible_for_doubling(parsed_script, parsed_method):
	return !parsed_method.is_accessor() and \
		parsed_method.is_eligible_for_doubling() and \
		!_ignored_methods.has(parsed_script.resource, parsed_method.meta.name)


# Disable the native_method_override setting so that doubles do not generate
# errors or warnings when doubling with INCLUDE_NATIVE or when a method has
# been added because of param_count stub.
func _create_script_no_warnings(src):
	var prev_native_override_value = null
	var native_method_override = 'debug/gdscript/warnings/native_method_override'
	prev_native_override_value = ProjectSettings.get_setting(native_method_override)
	ProjectSettings.set_setting(native_method_override, 0)

	var DblClass = GutUtils.create_script_from_source(src)

	ProjectSettings.set_setting(native_method_override, prev_native_override_value)
	return DblClass


func _create_double(parsed, strategy, override_path, partial):
	var path = ""

	path = parsed.script_path
	var dbl_src = ""
	var included_methods = []

	for method in parsed.get_local_methods():
		if(_is_method_eligible_for_doubling(parsed, method)):
			included_methods.append(method.meta.name)
			var mthd = parsed.get_local_method(method.meta.name)
			if(parsed.is_native):
				dbl_src += _get_func_text(method.meta, parsed.resource)
			else:
				dbl_src += _get_func_text(method.meta, path)

	if(strategy == GutUtils.DOUBLE_STRATEGY.INCLUDE_NATIVE):
		for method in parsed.get_super_methods():
			if(_is_method_eligible_for_doubling(parsed, method)):
				included_methods.append(method.meta.name)
				_stub_to_call_super(parsed, method.meta.name)
				if(parsed.is_native):
					dbl_src += _get_func_text(method.meta, parsed.resource)
				else:
					dbl_src += _get_func_text(method.meta, path)

	var base_script = _get_base_script_text(parsed, override_path, partial, included_methods)
	dbl_src = base_script + "\n\n" + dbl_src


	if(print_source):
		print(GutUtils.add_line_numbers(dbl_src))

	var DblClass = _create_script_no_warnings(dbl_src)
	if(_stubber != null):
		_stub_method_default_values(DblClass, parsed, strategy)

	return DblClass


func _stub_method_default_values(which, parsed, strategy):
	for method in parsed.get_local_methods():
		if(method.is_eligible_for_doubling() and !_ignored_methods.has(parsed.resource, method.meta.name)):
			_stubber.stub_defaults_from_meta(parsed.script_path, method.meta)


func _double_scene_and_script(scene, strategy, partial):
	var dbl_bundle = scene._bundled.duplicate(true)
	var script_obj = GutUtils.get_scene_script_object(scene)
	# I'm not sure if the script object for the root node of a packed scene is
	# always the first entry in "variants" so this tries to find it.
	var script_index = dbl_bundle["variants"].find(script_obj)
	var script_dbl = null

	if(script_obj != null):
		if(partial):
			script_dbl = _partial_double(script_obj, strategy, scene.get_path())
		else:
			script_dbl = _double(script_obj, strategy, scene.get_path())

	if(script_index != -1):
		dbl_bundle["variants"][script_index] = script_dbl

	var doubled_scene = PackedScene.new()
	doubled_scene._set_bundled_scene(dbl_bundle)

	return doubled_scene


func _get_inst_id_ref_str(inst):
	var ref_str = 'null'
	if(inst):
		ref_str = str('instance_from_id(', inst.get_instance_id(),')')
	return ref_str


func _get_func_text(method_hash, path):
	var override_count = null;
	if(_stubber != null):
		override_count = _stubber.get_parameter_count(path, method_hash.name)

	var text = _method_maker.get_function_text(method_hash, override_count) + "\n"

	return text


func _parse_script(obj):
	var parsed = null

	if(GutUtils.is_inner_class(obj)):
		if(inner_class_registry.has(obj)):
			parsed = _script_collector.parse(inner_class_registry.get_base_resource(obj), obj)
		else:
			_lgr.error('Doubling Inner Classes requires you register them first.  Call register_inner_classes passing the script that contains the inner class.')
	else:
		parsed = _script_collector.parse(obj)

	return parsed


# Override path is used with scenes.
func _double(obj, strategy, override_path=null):
	var parsed = _parse_script(obj)
	if(parsed != null):
		return _create_double(parsed, strategy, override_path, false)


func _partial_double(obj, strategy, override_path=null):
	var parsed = _parse_script(obj)
	if(parsed != null):
		return _create_double(parsed, strategy, override_path, true)


# -------------------------
# Public
# -------------------------

# double a script/object
func double(obj, strategy=_strategy):
	return _double(obj, strategy)

func partial_double(obj, strategy=_strategy):
	return _partial_double(obj, strategy)


# double a scene
func double_scene(scene, strategy=_strategy):
	return _double_scene_and_script(scene, strategy, false)


func partial_double_scene(scene, strategy=_strategy):
	return _double_scene_and_script(scene, strategy, true)


func double_gdnative(which):
	return _double(which, GutUtils.DOUBLE_STRATEGY.INCLUDE_NATIVE)


func partial_double_gdnative(which):
	return _partial_double(which, GutUtils.DOUBLE_STRATEGY.INCLUDE_NATIVE)


func double_inner(parent, inner, strategy=_strategy):
	var parsed = _script_collector.parse(parent, inner)
	return _create_double(parsed, strategy, null, false)


func partial_double_inner(parent, inner, strategy=_strategy):
	var parsed = _script_collector.parse(parent, inner)
	return _create_double(parsed, strategy, null, true)


func add_ignored_method(obj, method_name):
	_ignored_methods.add(obj, method_name)



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/double_tools.gd ---
var thepath = ''
var subpath = ''
var stubber = null
var spy = null
var gut = null
var from_singleton = null
var is_partial = null
var double = null

const NO_DEFAULT_VALUE = '!__gut__no__default__value__!'
func _init(values=null):
	if(values != null):
		double = values.double
		thepath = values.thepath
		subpath = values.subpath
		stubber = from_id(values.stubber)
		spy = from_id(values.spy)
		gut = from_id(values.gut)
		from_singleton = values.from_singleton
		is_partial = values.is_partial

	if(gut != null):
		gut.get_autofree().add_free(double)


func _get_stubbed_method_to_call(method_name, called_with):
	var method = stubber.get_call_this(double, method_name, called_with)
	if(method != null):
		method = method.bindv(called_with)
		return method
	return method


func from_id(inst_id):
	if(inst_id ==  -1):
		return null
	else:
		return instance_from_id(inst_id)


func is_stubbed_to_call_super(method_name, called_with):
	if(stubber != null):
		return stubber.should_call_super(double, method_name, called_with)
	else:
		return false


func handle_other_stubs(method_name, called_with):
	if(stubber == null):
		return

	var method = _get_stubbed_method_to_call(method_name, called_with)
	if(method != null):
		return await method.call()
	else:
		return stubber.get_return(double, method_name, called_with)


func spy_on(method_name, called_with):
	if(spy != null):
		spy.add_call(double, method_name, called_with)


func default_val(method_name, p_index, default_val=NO_DEFAULT_VALUE):
	if(stubber != null):
		return stubber.get_default_value(double, method_name, p_index)
	else:
		return null


func vararg_warning():
	if(gut != null):
		gut.get_logger().warn(
			"This method contains a vararg argument and the paramter count was not stubbed.  " + \
			"GUT adds extra parameters to this method which should fill most needs.  " + \
			"It is recommended that you stub param_count for this object's class to ensure " + \
			"that there are not any parameter count mismatch errors.")

--- SCRIPT: res://addons/gut/dynamic_gdscript.gd ---
@tool
var default_script_name_no_extension = 'gut_dynamic_script'
var default_script_resource_path = 'res://addons/gut/not_a_real_file/'
var default_script_extension = "gd"

var _created_script_count = 0


# Creates a loaded script from the passed in source.  This loaded script is
# returned unless there is an error.  When an error occcurs the error number
# is returned instead.
func create_script_from_source(source, override_path=null):
	_created_script_count += 1
	var r_path = str(default_script_resource_path,
		default_script_name_no_extension, '_', _created_script_count, ".",
		default_script_extension)

	if(override_path != null):
		r_path = override_path

	var DynamicScript = GDScript.new()
	DynamicScript.source_code = source.dedent()
	# The resource_path must be unique or Godot thinks it is trying
	# to load something it has already loaded and generates an error like
	# ERROR: Another resource is loaded from path 'workaround for godot
	# issue #65263' (possible cyclic resource inclusion).
	DynamicScript.resource_path = r_path
	var result = DynamicScript.reload()
	if(result != OK):
		DynamicScript = result

	return DynamicScript

--- SCRIPT: res://addons/gut/gui/BottomPanelShortcuts.gd ---
@tool
extends Window

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
var default_path = GutEditorGlobals.editor_shortcuts_path

@onready var _ctrls = {
	run_all = $Layout/CRunAll/ShortcutButton,
	run_current_script = $Layout/CRunCurrentScript/ShortcutButton,
	run_current_inner = $Layout/CRunCurrentInner/ShortcutButton,
	run_current_test = $Layout/CRunCurrentTest/ShortcutButton,
	panel_button = $Layout/CPanelButton/ShortcutButton,
}

var _user_prefs = GutEditorGlobals.user_prefs

func _ready():
	for key in _ctrls:
		var sc_button = _ctrls[key]
		sc_button.connect('start_edit', _on_edit_start.bind(sc_button))
		sc_button.connect('end_edit', _on_edit_end)

	# show dialog when running scene from editor.
	if(get_parent() == get_tree().root):
		popup_centered()


func _cancel_all():
	_ctrls.run_all.cancel()
	_ctrls.run_current_script.cancel()
	_ctrls.run_current_inner.cancel()
	_ctrls.run_current_test.cancel()
	_ctrls.panel_button.cancel()

# ------------
# Events
# ------------
func _on_Hide_pressed():
	hide()


func _on_edit_start(which):
	for key in _ctrls:
		var sc_button = _ctrls[key]
		if(sc_button != which):
			sc_button.disable_set(true)
			sc_button.disable_clear(true)


func _on_edit_end():
	for key in _ctrls:
		var sc_button = _ctrls[key]
		sc_button.disable_set(false)
		sc_button.disable_clear(false)


func _on_popup_hide():
	_cancel_all()

# ------------
# Public
# ------------
func get_run_all():
	return _ctrls.run_all.get_shortcut()

func get_run_current_script():
	return _ctrls.run_current_script.get_shortcut()

func get_run_current_inner():
	return _ctrls.run_current_inner.get_shortcut()

func get_run_current_test():
	return _ctrls.run_current_test.get_shortcut()

func get_panel_button():
	return _ctrls.panel_button.get_shortcut()

func _set_pref_value(pref, button):
	pref.value = {shortcut = button.get_shortcut().events}


func save_shortcuts():
	save_shortcuts_to_file(default_path)


func save_shortcuts_to_editor_settings():
	_set_pref_value(_user_prefs.shortcut_run_all, _ctrls.run_all)
	_set_pref_value(_user_prefs.shortcut_run_current_script, _ctrls.run_current_script)
	_set_pref_value(_user_prefs.shortcut_run_current_inner, _ctrls.run_current_inner)
	_set_pref_value(_user_prefs.shortcut_run_current_test, _ctrls.run_current_test)
	_set_pref_value(_user_prefs.shortcut_panel_button, _ctrls.panel_button)

	_user_prefs.save_it()


func save_shortcuts_to_file(path):
	var f = ConfigFile.new()
	f.set_value('main', 'run_all', _ctrls.run_all.get_shortcut())
	f.set_value('main', 'run_current_script', _ctrls.run_current_script.get_shortcut())
	f.set_value('main', 'run_current_inner', _ctrls.run_current_inner.get_shortcut())
	f.set_value('main', 'run_current_test', _ctrls.run_current_test.get_shortcut())
	f.set_value('main', 'panel_button', _ctrls.panel_button.get_shortcut())
	f.save(path)


func _load_shortcut_from_pref(user_pref):
	var to_return = Shortcut.new()
	# value with be _user_prefs.EMPTY which is a string when the value
	# has not been set.
	if(typeof(user_pref.value) == TYPE_DICTIONARY):
		to_return.events.append(user_pref.value.shortcut[0])
		# to_return = user_pref.value
	return to_return


func load_shortcuts():
	load_shortcuts_from_file(default_path)


func load_shortcuts_from_editor_settings():
	var empty = Shortcut.new()

	_ctrls.run_all.set_shortcut(_load_shortcut_from_pref(_user_prefs.shortcut_run_all))
	_ctrls.run_current_script.set_shortcut(_load_shortcut_from_pref(_user_prefs.shortcut_run_current_script))
	_ctrls.run_current_inner.set_shortcut(_load_shortcut_from_pref(_user_prefs.shortcut_run_current_inner))
	_ctrls.run_current_test.set_shortcut(_load_shortcut_from_pref(_user_prefs.shortcut_run_current_test))
	_ctrls.panel_button.set_shortcut(_load_shortcut_from_pref(_user_prefs.shortcut_panel_button))


func load_shortcuts_from_file(path):
	var f = ConfigFile.new()
	var empty = Shortcut.new()

	f.load(path)
	_ctrls.run_all.set_shortcut(f.get_value('main', 'run_all', empty))
	_ctrls.run_current_script.set_shortcut(f.get_value('main', 'run_current_script', empty))
	_ctrls.run_current_inner.set_shortcut(f.get_value('main', 'run_current_inner', empty))
	_ctrls.run_current_test.set_shortcut(f.get_value('main', 'run_current_test', empty))
	_ctrls.panel_button.set_shortcut(f.get_value('main', 'panel_button', empty))

--- SCRIPT: res://addons/gut/gui/editor_globals.gd ---
@tool

static var GutUserPreferences = load("res://addons/gut/gui/gut_user_preferences.gd")
static var temp_directory = 'user://gut_temp_directory'

static var editor_run_gut_config_path = 'gut_editor_config.json':
	# This avoids having to use path_join wherever we want to reference this
	# path.  The value is not supposed to change.  Could it be a constant
	# instead?  Probably, but I didn't like repeating the directory part.
	# Do I like that this is a bit witty.  Absolutely.
	get: return temp_directory.path_join(editor_run_gut_config_path)
	# Should this print a message or something instead?  Probably, but then I'd
	# be repeating even more code than if this was just a constant.  So I didn't,
	# even though I wanted to make the message a easter eggish fun message.
	# I didn't, so this dumb comment will have to serve as the easter eggish fun.
	set(v):
		print("Be sure to document your code.  Never trust comments.")


static var editor_run_bbcode_results_path = 'gut_editor.bbcode':
	get: return temp_directory.path_join(editor_run_bbcode_results_path)
	set(v): pass


static var editor_run_json_results_path = 'gut_editor.json':
	get: return temp_directory.path_join(editor_run_json_results_path)
	set(v): pass


static var editor_shortcuts_path = 'gut_editor_shortcuts.cfg' :
	get: return temp_directory.path_join(editor_shortcuts_path)
	set(v): pass


static var _user_prefs = null
static var user_prefs = _user_prefs :
	# workaround not being able to reference EditorInterface when not in
	# the editor.  This shouldn't be referenced by anything not in the
	# editor.
	get:
		if(_user_prefs == null and Engine.is_editor_hint()):
			_user_prefs = GutUserPreferences.new(EditorInterface.get_editor_settings())
		return _user_prefs


static func create_temp_directory():
	DirAccess.make_dir_recursive_absolute(temp_directory)

--- SCRIPT: res://addons/gut/gui/GutBottomPanel.gd ---
@tool
extends Control

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
var TestScript = load('res://addons/gut/test.gd')
var GutConfigGui = load('res://addons/gut/gui/gut_config_gui.gd')
var ScriptTextEditors = load('res://addons/gut/gui/script_text_editor_controls.gd')


var _interface = null;
var _is_running = false;
var _gut_config = load('res://addons/gut/gut_config.gd').new()
var _gut_config_gui = null
var _gut_plugin = null
var _light_color = Color(0, 0, 0, .5)
var _panel_button = null
var _last_selected_path = null
var _user_prefs = null


@onready var _ctrls = {
	output = $layout/RSplit/CResults/TabBar/OutputText.get_rich_text_edit(),
	output_ctrl = $layout/RSplit/CResults/TabBar/OutputText,
	run_button = $layout/ControlBar/RunAll,
	shortcuts_button = $layout/ControlBar/Shortcuts,

	settings_button = $layout/ControlBar/Settings,
	run_results_button = $layout/ControlBar/RunResultsBtn,
	output_button = $layout/ControlBar/OutputBtn,

	settings = $layout/RSplit/sc/Settings,
	shortcut_dialog = $BottomPanelShortcuts,
	light = $layout/RSplit/CResults/ControlBar/Light3D,
	results = {
		bar = $layout/RSplit/CResults/ControlBar,
		passing = $layout/RSplit/CResults/ControlBar/Passing/value,
		failing = $layout/RSplit/CResults/ControlBar/Failing/value,
		pending = $layout/RSplit/CResults/ControlBar/Pending/value,
		errors = $layout/RSplit/CResults/ControlBar/Errors/value,
		warnings = $layout/RSplit/CResults/ControlBar/Warnings/value,
		orphans = $layout/RSplit/CResults/ControlBar/Orphans/value
	},
	run_at_cursor = $layout/ControlBar/RunAtCursor,
	run_results = $layout/RSplit/CResults/TabBar/RunResults
}

func _init():
	pass


func _ready():
	GutEditorGlobals.create_temp_directory()

	_user_prefs = GutEditorGlobals.user_prefs
	_gut_config_gui = GutConfigGui.new(_ctrls.settings)

	_ctrls.results.bar.connect('draw', _on_results_bar_draw.bind(_ctrls.results.bar))
	hide_settings(!_ctrls.settings_button.button_pressed)

	_gut_config.load_options(GutEditorGlobals.editor_run_gut_config_path)
	_gut_config_gui.set_options(_gut_config.options)
	_apply_options_to_controls()

	_ctrls.shortcuts_button.icon = get_theme_icon('Shortcut', 'EditorIcons')
	_ctrls.settings_button.icon = get_theme_icon('Tools', 'EditorIcons')
	_ctrls.run_results_button.icon = get_theme_icon('AnimationTrackGroup', 'EditorIcons') # Tree
	_ctrls.output_button.icon = get_theme_icon('Font', 'EditorIcons')

	_ctrls.run_results.set_output_control(_ctrls.output_ctrl)

	var check_import = load('res://addons/gut/images/red.png')
	if(check_import == null):
		_ctrls.run_results.add_centered_text("GUT got some new images that are not imported yet.  Please restart Godot.")
		print('GUT got some new images that are not imported yet.  Please restart Godot.')
	else:
		_ctrls.run_results.add_centered_text("Let's run some tests!")


func _apply_options_to_controls():
	hide_settings(_user_prefs.hide_settings.value)
	hide_result_tree(_user_prefs.hide_result_tree.value)
	hide_output_text(_user_prefs.hide_output_text.value)
	_ctrls.run_results.set_show_orphans(!_gut_config.options.hide_orphans)


func _process(delta):
	if(_is_running):
		if(!_interface.is_playing_scene()):
			_is_running = false
			_ctrls.output_ctrl.add_text("\ndone")
			load_result_output()
			_gut_plugin.make_bottom_panel_item_visible(self)

# ---------------
# Private
# ---------------

func load_shortcuts():
	_ctrls.shortcut_dialog.load_shortcuts()
	_apply_shortcuts()


func _is_test_script(script):
	var from = script.get_base_script()
	while(from and from.resource_path != 'res://addons/gut/test.gd'):
		from = from.get_base_script()

	return from != null


func _show_errors(errs):
	_ctrls.output_ctrl.clear()
	var text = "Cannot run tests, you have a configuration error:\n"
	for e in errs:
		text += str('*  ', e, "\n")
	text += "Check your settings ----->"
	_ctrls.output_ctrl.add_text(text)
	hide_output_text(false)
	hide_settings(false)


func _save_config():
	_user_prefs.hide_settings.value = !_ctrls.settings_button.button_pressed
	_user_prefs.hide_result_tree.value = !_ctrls.run_results_button.button_pressed
	_user_prefs.hide_output_text.value = !_ctrls.output_button.button_pressed
	_user_prefs.save_it()

	_gut_config.options = _gut_config_gui.get_options(_gut_config.options)
	var w_result = _gut_config.write_options(GutEditorGlobals.editor_run_gut_config_path)
	if(w_result != OK):
		push_error(str('Could not write options to ', GutEditorGlobals.editor_run_gut_config_path, ': ', w_result))
	else:
		_gut_config_gui.mark_saved()


func _run_tests():
	GutEditorGlobals.create_temp_directory()

	var issues = _gut_config_gui.get_config_issues()
	if(issues.size() > 0):
		_show_errors(issues)
		return

	write_file(GutEditorGlobals.editor_run_bbcode_results_path, 'Run in progress')
	_save_config()
	_apply_options_to_controls()

	_ctrls.output_ctrl.clear()
	_ctrls.run_results.clear()
	_ctrls.run_results.add_centered_text('Running...')

	_interface.play_custom_scene('res://addons/gut/gui/run_from_editor.tscn')
	_is_running = true
	_ctrls.output_ctrl.add_text('Running...')


func _apply_shortcuts():
	_ctrls.run_button.shortcut = _ctrls.shortcut_dialog.get_run_all()

	_ctrls.run_at_cursor.get_script_button().shortcut = \
		_ctrls.shortcut_dialog.get_run_current_script()
	_ctrls.run_at_cursor.get_inner_button().shortcut = \
		_ctrls.shortcut_dialog.get_run_current_inner()
	_ctrls.run_at_cursor.get_test_button().shortcut = \
		_ctrls.shortcut_dialog.get_run_current_test()

	_panel_button.shortcut = _ctrls.shortcut_dialog.get_panel_button()


func _run_all():
	_gut_config.options.selected = null
	_gut_config.options.inner_class = null
	_gut_config.options.unit_test_name = null

	_run_tests()


# ---------------
# Events
# ---------------
func _on_results_bar_draw(bar):
	bar.draw_rect(Rect2(Vector2(0, 0), bar.size), Color(0, 0, 0, .2))


func _on_Light_draw():
	var l = _ctrls.light
	l.draw_circle(Vector2(l.size.x / 2, l.size.y / 2), l.size.x / 2, _light_color)


func _on_editor_script_changed(script):
	if(script):
		set_current_script(script)


func _on_RunAll_pressed():
	_run_all()


func _on_Shortcuts_pressed():
	_ctrls.shortcut_dialog.popup_centered()

func _on_bottom_panel_shortcuts_visibility_changed():
	_apply_shortcuts()
	_ctrls.shortcut_dialog.save_shortcuts()

func _on_RunAtCursor_run_tests(what):
	_gut_config.options.selected = what.script
	_gut_config.options.inner_class = what.inner_class
	_gut_config.options.unit_test_name = what.test_method

	_run_tests()


func _on_Settings_pressed():
	hide_settings(!_ctrls.settings_button.button_pressed)
	_save_config()


func _on_OutputBtn_pressed():
	hide_output_text(!_ctrls.output_button.button_pressed)
	_save_config()


func _on_RunResultsBtn_pressed():
	hide_result_tree(! _ctrls.run_results_button.button_pressed)
	_save_config()


# Currently not used, but will be when I figure out how to put
# colors into the text results
func _on_UseColors_pressed():
	pass

# ---------------
# Public
# ---------------
func hide_result_tree(should):
	_ctrls.run_results.visible = !should
	_ctrls.run_results_button.button_pressed = !should


func hide_settings(should):
	var s_scroll = _ctrls.settings.get_parent()
	s_scroll.visible = !should

	# collapse only collapses the first control, so we move
	# settings around to be the collapsed one
	if(should):
		s_scroll.get_parent().move_child(s_scroll, 0)
	else:
		s_scroll.get_parent().move_child(s_scroll, 1)

	$layout/RSplit.collapsed = should
	_ctrls.settings_button.button_pressed = !should


func hide_output_text(should):
	$layout/RSplit/CResults/TabBar/OutputText.visible = !should
	_ctrls.output_button.button_pressed = !should


func load_result_output():
	_ctrls.output_ctrl.load_file(GutEditorGlobals.editor_run_bbcode_results_path)

	var summary = get_file_as_text(GutEditorGlobals.editor_run_json_results_path)
	var test_json_conv = JSON.new()
	if (test_json_conv.parse(summary) != OK):
		return
	var results = test_json_conv.get_data()

	_ctrls.run_results.load_json_results(results)

	var summary_json = results['test_scripts']['props']
	_ctrls.results.passing.text = str(summary_json.passing)
	_ctrls.results.passing.get_parent().visible = true

	_ctrls.results.failing.text = str(summary_json.failures)
	_ctrls.results.failing.get_parent().visible = true

	_ctrls.results.pending.text = str(summary_json.pending)
	_ctrls.results.pending.get_parent().visible = _ctrls.results.pending.text != '0'

	_ctrls.results.errors.text = str(summary_json.errors)
	_ctrls.results.errors.get_parent().visible = _ctrls.results.errors.text != '0'

	_ctrls.results.warnings.text = str(summary_json.warnings)
	_ctrls.results.warnings.get_parent().visible = _ctrls.results.warnings.text != '0'

	_ctrls.results.orphans.text = str(summary_json.orphans)
	_ctrls.results.orphans.get_parent().visible = _ctrls.results.orphans.text != '0' and !_gut_config.options.hide_orphans

	if(summary_json.tests == 0):
		_light_color = Color(1, 0, 0, .75)
	elif(summary_json.failures != 0):
		_light_color = Color(1, 0, 0, .75)
	elif(summary_json.pending != 0):
		_light_color = Color(1, 1, 0, .75)
	else:
		_light_color = Color(0, 1, 0, .75)
	_ctrls.light.visible = true
	_ctrls.light.queue_redraw()


func set_current_script(script):
	if(script):
		if(_is_test_script(script)):
			var file = script.resource_path.get_file()
			_last_selected_path = script.resource_path.get_file()
			_ctrls.run_at_cursor.activate_for_script(script.resource_path)


func set_interface(value):
	_interface = value
	_interface.get_script_editor().connect("editor_script_changed",Callable(self,'_on_editor_script_changed'))

	var ste = ScriptTextEditors.new(_interface.get_script_editor())
	_ctrls.run_results.set_interface(_interface)
	_ctrls.run_results.set_script_text_editors(ste)
	_ctrls.run_at_cursor.set_script_text_editors(ste)
	set_current_script(_interface.get_script_editor().get_current_script())


func set_plugin(value):
	_gut_plugin = value


func set_panel_button(value):
	_panel_button = value

# ------------------------------------------------------------------------------
# Write a file.
# ------------------------------------------------------------------------------
func write_file(path, content):
	var f = FileAccess.open(path, FileAccess.WRITE)
	if(f != null):
		f.store_string(content)
	f = null;

	return FileAccess.get_open_error()


# ------------------------------------------------------------------------------
# Returns the text of a file or an empty string if the file could not be opened.
# ------------------------------------------------------------------------------
func get_file_as_text(path):
	var to_return = ''
	var f = FileAccess.open(path, FileAccess.READ)
	if(f != null):
		to_return = f.get_as_text()
	f = null
	return to_return


# ------------------------------------------------------------------------------
# return if_null if value is null otherwise return value
# ------------------------------------------------------------------------------
func nvl(value, if_null):
	if(value == null):
		return if_null
	else:
		return value

--- SCRIPT: res://addons/gut/gui/GutControl.gd ---
@tool
extends Control

const RUNNER_JSON_PATH = 'res://.gut_editor_config.json'

var GutConfig = load('res://addons/gut/gut_config.gd')
var GutRunnerScene = load('res://addons/gut/gui/GutRunner.tscn')
var GutConfigGui = load('res://addons/gut/gui/gut_config_gui.gd')

var _config = GutConfig.new()
var _config_gui = null
var _gut_runner = GutRunnerScene.instantiate()
var _has_connected = false
var _tree_root : TreeItem = null

var _script_icon = load('res://addons/gut/images/Script.svg')
var _folder_icon = load('res://addons/gut/images/Folder.svg')

var _tree_scripts = {}
var _tree_directories = {}

const TREE_SCRIPT = 'Script'
const TREE_DIR = 'Directory'

@onready var _ctrls = {
	run_tests_button = $VBox/Buttons/RunTests,
	run_selected = $VBox/Buttons/RunSelected,
	test_tree = $VBox/Tabs/Tests,
	settings_vbox = $VBox/Tabs/SettingsScroll/Settings,
	tabs = $VBox/Tabs,
	bg = $Bg
}

@export var bg_color : Color = Color(.36, .36, .36) :
	get: return bg_color
	set(val):
		bg_color = val
		if(is_inside_tree()):
			$Bg.color = bg_color


func _ready():
	if Engine.is_editor_hint():
		return

	$Bg.color = bg_color
	_ctrls.tabs.set_tab_title(0, 'Tests')
	_ctrls.tabs.set_tab_title(1, 'Settings')

	_config_gui = GutConfigGui.new(_ctrls.settings_vbox)

	_ctrls.test_tree.hide_root = true
	add_child(_gut_runner)

	# TODO This might not need to be called deferred after changing GutUtils to
	# an all static class.
	call_deferred('_post_ready')


func _draw():
	if Engine.is_editor_hint():
		return

	var gut = _gut_runner.get_gut()
	if(!gut.is_running()):
		var r = Rect2(Vector2(0, 0), get_rect().size)
		draw_rect(r, Color.BLACK, false, 2)


func _post_ready():
	var gut = _gut_runner.get_gut()
	gut.start_run.connect(_on_gut_run_started)
	gut.end_run.connect(_on_gut_run_ended)
	_refresh_tree_and_settings()


func _set_meta_for_script_tree_item(item, script, test=null):
	var meta = {
		type = TREE_SCRIPT,
		script = script.path,
		inner_class = script.inner_class_name,
		test = ''
	}

	if(test != null):
		meta.test = test.name

	item.set_metadata(0, meta)


func _set_meta_for_directory_tree_item(item, path, temp_item):
	var meta = {
		type = TREE_DIR,
		path = path,
		temp_item = temp_item
	}
	item.set_metadata(0, meta)


func _get_script_tree_item(script, parent_item):
	if(!_tree_scripts.has(script.path)):
		var item = _ctrls.test_tree.create_item(parent_item)
		item.set_text(0, script.path.get_file())
		item.set_icon(0, _script_icon)
		_tree_scripts[script.path] = item
		_set_meta_for_script_tree_item(item, script)

	return _tree_scripts[script.path]


func _get_directory_tree_item(path):
	var parent = _tree_root
	if(!_tree_directories.has(path)):

		var item : TreeItem = null
		if(parent != _tree_root):
			item = parent.create_child(0)
		else:
			item = parent.create_child()

		_tree_directories[path] = item
		item.collapsed = false
		item.set_text(0, path)
		item.set_icon(0, _folder_icon)
		item.set_icon_modulate(0, Color.ROYAL_BLUE)
		# temp_item is used in calls with move_before since you must use
		# move_before or move_after to reparent tree items. This ensures that
		# there is an item on all directories.  These are deleted later.
		var temp_item = item.create_child()
		temp_item.set_text(0, '<temp>')

		_set_meta_for_directory_tree_item(item, path, temp_item)

	return _tree_directories[path]


func _find_dir_item_to_move_before(path):
	var max_matching_len = 0
	var best_parent = null

	# Go through all the directory items finding the one that has the longest
	# path that contains our path.
	for key in _tree_directories.keys():
		if(path != key and path.begins_with(key) and key.length() > max_matching_len):
				max_matching_len = key.length()
				best_parent = _tree_directories[key]

	var to_return = null
	if(best_parent != null):
		to_return = best_parent.get_metadata(0).temp_item
	return to_return


func _reorder_dir_items():
	var the_keys = _tree_directories.keys()
	the_keys.sort()
	for key in _tree_directories.keys():
		var to_move = _tree_directories[key]
		to_move.collapsed = false
		var move_before = _find_dir_item_to_move_before(key)
		if(move_before != null):
			to_move.move_before(move_before)
			var new_text = key.substr(move_before.get_parent().get_metadata(0).path.length())
			to_move.set_text(0, new_text)


func _remove_dir_temp_items():
	for key in _tree_directories.keys():
		var item = _tree_directories[key].get_metadata(0).temp_item
		_tree_directories[key].remove_child(item)


func _add_dir_and_script_tree_items():
	var tree : Tree = _ctrls.test_tree
	tree.clear()
	_tree_root = _ctrls.test_tree.create_item()

	var scripts = _gut_runner.get_gut().get_test_collector().scripts
	for script in scripts:
		var dir_item = _get_directory_tree_item(script.path.get_base_dir())
		var item = _get_script_tree_item(script, dir_item)

		if(script.inner_class_name != ''):
			var inner_item = tree.create_item(item)
			inner_item.set_text(0, script.inner_class_name)
			_set_meta_for_script_tree_item(inner_item, script)
			item = inner_item

		for test in script.tests:
			var test_item = tree.create_item(item)
			test_item.set_text(0, test.name)
			_set_meta_for_script_tree_item(test_item, script, test)


func _populate_tree():
	_add_dir_and_script_tree_items()
	_tree_root.set_collapsed_recursive(true)
	_tree_root.set_collapsed(false)
	_reorder_dir_items()
	_remove_dir_temp_items()


func _refresh_tree_and_settings():
	_config.apply_options(_gut_runner.get_gut())
	_gut_runner.set_gut_config(_config)
	_populate_tree()

# ---------------------------
# Events
# ---------------------------
func _on_gut_run_started():
	_ctrls.run_tests_button.disabled = true
	_ctrls.run_selected.visible = false
	_ctrls.tabs.visible = false
	_ctrls.bg.visible = false
	_ctrls.run_tests_button.text = 'Running'
	queue_redraw()


func _on_gut_run_ended():
	_ctrls.run_tests_button.disabled = false
	_ctrls.run_selected.visible = true
	_ctrls.tabs.visible = true
	_ctrls.bg.visible = true
	_ctrls.run_tests_button.text = 'Run All'
	queue_redraw()


func _on_run_tests_pressed():
	run_all()


func _on_run_selected_pressed():
	run_selected()


func _on_tests_item_activated():
	run_selected()

# ---------------------------
# Public
# ---------------------------
func get_gut():
	return _gut_runner.get_gut()


func get_config():
	return _config


func run_all():
	_config.options.selected = ''
	_config.options.inner_class_name = ''
	_config.options.unit_test_name = ''
	run_tests()


func run_tests(options = null):
	if(options == null):
		_config.options = _config_gui.get_options(_config.options)
	else:
		_config.options = options

	_gut_runner.get_gut().get_test_collector().clear()
	_gut_runner.set_gut_config(_config)
	_gut_runner.run_tests()


func run_selected():
	var sel_item = _ctrls.test_tree.get_selected()
	if(sel_item == null):
		return

	var options = _config_gui.get_options(_config.options)
	var meta = sel_item.get_metadata(0)
	if(meta.type == TREE_SCRIPT):
		options.selected = meta.script.get_file()
		options.inner_class_name = meta.inner_class
		options.unit_test_name = meta.test
	elif(meta.type == TREE_DIR):
		options.dirs = [meta.path]
		options.include_subdirectories = true
		options.selected = ''
		options.inner_class_name = ''
		options.unit_test_name = ''

	run_tests(options)


func load_config_file(path):
	_config.load_options(path)
	_config.options.selected = ''
	_config.options.inner_class_name = ''
	_config.options.unit_test_name = ''
	_config_gui.load_file(path)


# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/gui/GutRunner.gd ---
# ##############################################################################
# This class joins together GUT, GUT Gui, GutConfig and is THE way to kick off a
# run of a test suite.
#
# This creates its own instance of gut.gd that it manages.  You can set the
# gut.gd instance if you need to for testing.
#
# Set gut_config to an instance of a configured gut_config.gd instance prior to
# running tests.
#
# This will create a GUI and wire it up and apply gut_config.gd options.
#
# Running tests:  Call run_tests
# ##############################################################################
extends Node2D

const EXIT_OK = 0
const EXIT_ERROR = 1

var Gut = load('res://addons/gut/gut.gd')
var ResultExporter = load('res://addons/gut/result_exporter.gd')
var GutConfig = load('res://addons/gut/gut_config.gd')

var runner_json_path = null
var result_bbcode_path = null
var result_json_path = null

var lgr = GutUtils.get_logger()
var gut_config = null

var _hid_gut = null;
# Lazy loaded gut instance.  Settable for testing purposes.
var gut = _hid_gut :
	get:
		if(_hid_gut == null):
			_hid_gut = Gut.new()
		return _hid_gut
	set(val):
		_hid_gut = val

var _wrote_results = false
var _ran_from_editor = false

@onready var _gut_layer = $GutLayer
@onready var _gui = $GutLayer/GutScene


func _ready():
	GutUtils.WarningsManager.apply_warnings_dictionary(
		GutUtils.warnings_at_start)


func _exit_tree():
	if(!_wrote_results and _ran_from_editor):
		_write_results_for_gut_panel()


func _setup_gui(show_gui):
	if(show_gui):
		_gui.gut = gut
		var printer = gut.logger.get_printer('gui')
		printer.set_textbox(_gui.get_textbox())
	else:
		gut.logger.disable_printer('gui', true)
		_gui.visible = false

	var opts = gut_config.options
	_gui.set_font_size(opts.font_size)
	_gui.set_font(opts.font_name)
	if(opts.font_color != null and opts.font_color.is_valid_html_color()):
		_gui.set_default_font_color(Color(opts.font_color))
	if(opts.background_color != null and opts.background_color.is_valid_html_color()):
		_gui.set_background_color(Color(opts.background_color))

	_gui.set_opacity(min(1.0, float(opts.opacity) / 100))
	_gui.use_compact_mode(opts.compact_mode)


func _write_results_for_gut_panel():
	var content = _gui.get_textbox().get_parsed_text() #_gut.logger.get_gui_bbcode()
	var f = FileAccess.open(result_bbcode_path, FileAccess.WRITE)
	if(f != null):
		f.store_string(content)
		f = null # closes file
	else:
		push_error('Could not save bbcode, result = ', FileAccess.get_open_error())

	var exporter = ResultExporter.new()
	# TODO this should be checked and _wrote_results should maybe not be set, or
	# maybe we do not care.  Whichever, it should be clear.
	var _f_result = exporter.write_json_file(gut, result_json_path)
	_wrote_results = true


func _handle_quit(should_exit, should_exit_on_success, override_exit_code=EXIT_OK):
	var quitting_time = should_exit or \
		(should_exit_on_success and gut.get_fail_count() == 0)

	if(!quitting_time):
		if(should_exit_on_success):
			lgr.log("There are failing tests, exit manually.")
		_gui.use_compact_mode(false)
		return

	# For some reason, tests fail asserting that quit was called with 0 if we
	# do not do this, but everything is defaulted so I don't know why it gets
	# null.
	var exit_code = GutUtils.nvl(override_exit_code, EXIT_OK)

	if(gut.get_fail_count() > 0):
		exit_code = EXIT_ERROR

	# Overwrite the exit code with the post_script's exit code if it is set
	var post_hook_inst = gut.get_post_run_script_instance()
	if(post_hook_inst != null and post_hook_inst.get_exit_code() != null):
		exit_code = post_hook_inst.get_exit_code()

	quit(exit_code)


func _end_run(override_exit_code=EXIT_OK):
	if(_ran_from_editor):
		_write_results_for_gut_panel()

	_handle_quit(gut_config.options.should_exit,
		gut_config.options.should_exit_on_success,
		override_exit_code)


# -------------
# Events
# -------------
func _on_tests_finished():
	_end_run()


# -------------
# Public
# -------------
# For internal use only, but still public.  Consider it "protected" and you
# don't have my permission to call this, unless "you" is "me".
func run_from_editor():
	_ran_from_editor = true
	var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
	runner_json_path = GutUtils.nvl(runner_json_path, GutEditorGlobals.editor_run_gut_config_path)
	result_bbcode_path = GutUtils.nvl(result_bbcode_path, GutEditorGlobals.editor_run_bbcode_results_path)
	result_json_path = GutUtils.nvl(result_json_path, GutEditorGlobals.editor_run_json_results_path)

	if(gut_config == null):
		gut_config = GutConfig.new()
		gut_config.load_options(runner_json_path)

	call_deferred('run_tests')


func run_tests(show_gui=true):
	_setup_gui(show_gui)

	if(gut_config.options.dirs.size() + gut_config.options.tests.size() == 0):
		var err_text = "You do not have any directories configured, so GUT doesn't know where to find the tests.  Tell GUT where to find the tests and GUT shall run the tests."
		lgr.error(err_text)
		push_error(err_text)
		_end_run(EXIT_ERROR)
		return

	var install_check_text = GutUtils.make_install_check_text()
	if(install_check_text != GutUtils.INSTALL_OK_TEXT):
		print("\n\n", GutUtils.version_numbers.get_version_text())
		lgr.error(install_check_text)
		push_error(install_check_text)
		_end_run(EXIT_ERROR)
		return

	gut.add_children_to = self
	if(gut.get_parent() == null):
		if(gut_config.options.gut_on_top):
			_gut_layer.add_child(gut)
		else:
			add_child(gut)

	gut.end_run.connect(_on_tests_finished)

	gut_config.apply_options(gut)
	var run_rest_of_scripts = gut_config.options.unit_test_name == ''

	gut.test_scripts(run_rest_of_scripts)


func set_gut_config(which):
	gut_config = which


# for backwards compatibility
func get_gut():
	return gut


func quit(exit_code):
	# Sometimes quitting takes a few seconds.  This gives some indicator
	# of what is going on.
	_gui.set_title("Exiting")
	await get_tree().process_frame

	lgr.info(str('Exiting with code ', exit_code))
	get_tree().quit(exit_code)




# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/gui/gut_config_gui.gd ---
var PanelControls = load("res://addons/gut/gui/panel_controls.gd")
var GutConfig = load('res://addons/gut/gut_config.gd')

const DIRS_TO_LIST = 6

var _base_container = null
# All the various PanelControls indexed by thier gut_config keys.
var _cfg_ctrls = {}

# specific titles that we need to do stuff with
var _titles = {
	dirs = null
}
# All titles so we can free them when we want.
var _all_titles = []


func _init(cont):
	_base_container = cont


func _add_title(text):
	var row = PanelControls.BaseGutPanelControl.new(text, text)
	_base_container.add_child(row)
	row.connect('draw', _on_title_cell_draw.bind(row))
	_all_titles.append(row)
	return row

func _add_ctrl(key, ctrl):
	_cfg_ctrls[key] = ctrl
	_base_container.add_child(ctrl)


func _add_number(key, value, disp_text, v_min, v_max, hint=''):
	var ctrl = PanelControls.NumberControl.new(disp_text, value, v_min, v_max, hint)
	_add_ctrl(key, ctrl)
	return ctrl


func _add_select(key, value, values, disp_text, hint=''):
	var ctrl = PanelControls.SelectControl.new(disp_text, value, values, hint)
	_add_ctrl(key, ctrl)
	return ctrl


func _add_value(key, value, disp_text, hint=''):
	var ctrl = PanelControls.StringControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	return ctrl


func _add_boolean(key, value, disp_text, hint=''):
	var ctrl = PanelControls.BooleanControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	return ctrl


func _add_directory(key, value, disp_text, hint=''):
	var ctrl = PanelControls.DirectoryControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	ctrl.dialog.title = disp_text
	return ctrl


func _add_file(key, value, disp_text, hint=''):
	var ctrl = PanelControls.DirectoryControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	ctrl.dialog.file_mode = ctrl.dialog.FILE_MODE_OPEN_FILE
	ctrl.dialog.title = disp_text
	return ctrl


func _add_save_file_anywhere(key, value, disp_text, hint=''):
	var ctrl = PanelControls.DirectoryControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	ctrl.dialog.file_mode = ctrl.dialog.FILE_MODE_SAVE_FILE
	ctrl.dialog.access = ctrl.dialog.ACCESS_FILESYSTEM
	ctrl.dialog.title = disp_text
	return ctrl


func _add_color(key, value, disp_text, hint=''):
	var ctrl = PanelControls.ColorControl.new(disp_text, value, hint)
	_add_ctrl(key, ctrl)
	return ctrl


func _add_save_load():
	var ctrl = PanelControls.SaveLoadControl.new('Config', '', '')
	_base_container.add_child(ctrl)

	ctrl.save_path_chosen.connect(_on_save_path_chosen)
	ctrl.load_path_chosen.connect(_on_load_path_chosen)

	_cfg_ctrls['save_load'] = ctrl
	return ctrl

# ------------------
# Events
# ------------------
func _on_title_cell_draw(which):
	which.draw_rect(Rect2(Vector2(0, 0), which.size), Color(0, 0, 0, .15))


func _on_save_path_chosen(path):
	save_file(path)


func _on_load_path_chosen(path):
	load_file.bind(path).call_deferred()

# ------------------
# Public
# ------------------
func get_config_issues():
	var to_return = []
	var has_directory = false

	for i in range(DIRS_TO_LIST):
		var key = str('directory_', i)
		var path = _cfg_ctrls[key].value
		if(path != null and path != ''):
			has_directory = true
			if(!DirAccess.dir_exists_absolute(path)):
				_cfg_ctrls[key].mark_invalid(true)
				to_return.append(str('Test directory ', path, ' does not exist.'))
			else:
				_cfg_ctrls[key].mark_invalid(false)
		else:
			_cfg_ctrls[key].mark_invalid(false)

	if(!has_directory):
		to_return.append('You do not have any directories set.')
		_titles.dirs.mark_invalid(true)
	else:
		_titles.dirs.mark_invalid(false)

	if(!_cfg_ctrls.suffix.value.ends_with('.gd')):
		_cfg_ctrls.suffix.mark_invalid(true)
		to_return.append("Script suffix must end in '.gd'")
	else:
		_cfg_ctrls.suffix.mark_invalid(false)

	return to_return


func clear():
	for key in _cfg_ctrls:
		_cfg_ctrls[key].free()

	_cfg_ctrls.clear()

	for entry in _all_titles:
		entry.free()

	_all_titles.clear()


func save_file(path):
	var gcfg = GutConfig.new()
	gcfg.options = get_options({})
	gcfg.save_file(path)



func load_file(path):
	var gcfg = GutConfig.new()
	gcfg.load_options(path)
	clear()
	set_options(gcfg.options)


# --------------
# SUPER dumb but VERY fun hack to hide settings.  The various _add methods will
# return what they add.  If you want to hide it, just assign the result to this.
# YES, I could have just put .visible at the end, but I didn't think of that
# until just now, and this was fun, non-permanent and the .visible at the end
# isn't as obvious as hide_this =
#
# Also, we can't just skip adding the controls because other things are looking
# for them and things start to blow up if you don't add them.
var hide_this = null :
	set(val):
		val.visible = false

# --------------

func set_options(opts):
	var options = opts.duplicate()

	# _add_title('Save/Load')
	_add_save_load()

	_add_title("Settings")
	_add_number("log_level", options.log_level, "Log Level", 0, 3,
		"Detail level for log messages.\n" + \
		"\t0: Errors and failures only.\n" + \
		"\t1: Adds all test names + warnings + info\n" + \
		"\t2: Shows all asserts\n" + \
		"\t3: Adds more stuff probably, maybe not.")
	_add_boolean('ignore_pause', options.ignore_pause, 'Ignore Pause',
		"Ignore calls to pause_before_teardown")
	_add_boolean('hide_orphans', options.hide_orphans, 'Hide Orphans',
		'Do not display orphan counts in output.')
	_add_boolean('should_exit', options.should_exit, 'Exit on Finish',
		"Exit when tests finished.")
	_add_boolean('should_exit_on_success', options.should_exit_on_success, 'Exit on Success',
		"Exit if there are no failures.  Does nothing if 'Exit on Finish' is enabled.")
	_add_select('double_strategy', 'Script Only', ['Include Native', 'Script Only'], 'Double Strategy',
		'"Include Native" will include native methods in Doubles.  "Script Only" will not.  ' + "\n" + \
		'The native method override warning is disabled when creating Doubles.' + "\n" + \
		'This is the default, you can override this at the script level or when creating doubles.')
	_cfg_ctrls.double_strategy.value = GutUtils.get_enum_value(
		options.double_strategy, GutUtils.DOUBLE_STRATEGY, GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY)
	_add_boolean('errors_cause_failure', !options.errors_do_not_cause_failure, 'Errors cause failures.',
		"When GUT generates an error (not an engine error) it causes tests to fail.")


	_add_title('Runner Appearance')
	hide_this = _add_boolean("gut_on_top", options.gut_on_top, "On Top",
		"The GUT Runner appears above children added during tests.")
	_add_number('opacity', options.opacity, 'Opacity', 0, 100,
		"The opacity of GUT when tests are running.")
	hide_this = _add_boolean('should_maximize', options.should_maximize, 'Maximize',
		"Maximize GUT when tests are being run.")
	_add_boolean('compact_mode', options.compact_mode, 'Compact Mode',
		'The runner will be in compact mode.  This overrides Maximize.')
	_add_select('font_name', options.font_name, GutUtils.avail_fonts, 'Font',
		"The font to use for text output in the Gut Runner.")
	_add_number('font_size', options.font_size, 'Font Size', 5, 100,
		"The font size for text output in the Gut Runner.")
	hide_this = _add_color('font_color', options.font_color, 'Font Color',
		"The font color for text output in the Gut Runner.")
	_add_color('background_color', options.background_color, 'Background Color',
		"The background color for text output in the Gut Runner.")
	_add_boolean('disable_colors', options.disable_colors, 'Disable Formatting',
		'Disable formatting and colors used in the Runner.  Does not affect panel output.')


	_titles.dirs = _add_title('Test Directories')
	_add_boolean('include_subdirs', options.include_subdirs, 'Include Subdirs',
		"Include subdirectories of the directories configured below.")

	var dirs_to_load = options.configured_dirs
	if(options.dirs.size() > dirs_to_load.size()):
		dirs_to_load = options.dirs

	for i in range(DIRS_TO_LIST):
		var value = ''
		if(dirs_to_load.size() > i):
			value = dirs_to_load[i]

		var test_dir = _add_directory(str('directory_', i), value, str(i))
		test_dir.enabled_button.visible = true
		test_dir.enabled_button.button_pressed = options.dirs.has(value)


	_add_title("XML Output")
	_add_save_file_anywhere("junit_xml_file", options.junit_xml_file, "Output Path",
		"Path3D and filename where GUT should create a JUnit compliant XML file.  " +
		"This file will contain the results of the last test run.  To avoid " +
		"overriding the file use Include Timestamp.")
	_add_boolean("junit_xml_timestamp", options.junit_xml_timestamp, "Include Timestamp",
		"Include a timestamp in the filename so that each run gets its own xml file.")


	_add_title('Hooks')
	_add_file('pre_run_script', options.pre_run_script, 'Pre-Run Hook',
		'This script will be run by GUT before any tests are run.')
	_add_file('post_run_script', options.post_run_script, 'Post-Run Hook',
		'This script will be run by GUT after all tests are run.')


	_add_title('Misc')
	_add_value('prefix', options.prefix, 'Script Prefix',
		"The filename prefix for all test scripts.")
	_add_value('suffix', options.suffix, 'Script Suffix',
		"Script suffix, including .gd extension.  For example '_foo.gd'.")
	_add_number('paint_after', options.paint_after, 'Paint After', 0.0, 1.0,
		"How long GUT will wait before pausing for 1 frame to paint the screen.  0 is never.")

	# since _add_number doesn't set step property, it will default to a step of
	# 1 and cast values to int.  Give it a .5 step and re-set the value.
	_cfg_ctrls.paint_after.value_ctrl.step = .05
	_cfg_ctrls.paint_after.value = options.paint_after



func get_options(base_opts):
	var to_return = base_opts.duplicate()

	# Settings
	to_return.log_level = _cfg_ctrls.log_level.value
	to_return.ignore_pause = _cfg_ctrls.ignore_pause.value
	to_return.hide_orphans = _cfg_ctrls.hide_orphans.value
	to_return.should_exit = _cfg_ctrls.should_exit.value
	to_return.should_exit_on_success = _cfg_ctrls.should_exit_on_success.value
	to_return.double_strategy = _cfg_ctrls.double_strategy.value
	to_return.errors_do_not_cause_failure = !_cfg_ctrls.errors_cause_failure.value


	# Runner Appearance
	to_return.font_name = _cfg_ctrls.font_name.text
	to_return.font_size = _cfg_ctrls.font_size.value
	to_return.should_maximize = _cfg_ctrls.should_maximize.value
	to_return.compact_mode = _cfg_ctrls.compact_mode.value
	to_return.opacity = _cfg_ctrls.opacity.value
	to_return.background_color = _cfg_ctrls.background_color.value.to_html()
	to_return.font_color = _cfg_ctrls.font_color.value.to_html()
	to_return.disable_colors = _cfg_ctrls.disable_colors.value
	to_return.gut_on_top = _cfg_ctrls.gut_on_top.value
	to_return.paint_after = _cfg_ctrls.paint_after.value


	# Directories
	to_return.include_subdirs = _cfg_ctrls.include_subdirs.value
	var dirs = []
	var configured_dirs = []
	for i in range(DIRS_TO_LIST):
		var key = str('directory_', i)
		var ctrl = _cfg_ctrls[key]
		if(ctrl.value != '' and ctrl.value != null):
			configured_dirs.append(ctrl.value)
			if(ctrl.enabled_button.button_pressed):
				dirs.append(ctrl.value)
	to_return.dirs = dirs
	to_return.configured_dirs = configured_dirs

	# XML Output
	to_return.junit_xml_file = _cfg_ctrls.junit_xml_file.value
	to_return.junit_xml_timestamp = _cfg_ctrls.junit_xml_timestamp.value

	# Hooks
	to_return.pre_run_script = _cfg_ctrls.pre_run_script.value
	to_return.post_run_script = _cfg_ctrls.post_run_script.value

	# Misc
	to_return.prefix = _cfg_ctrls.prefix.value
	to_return.suffix = _cfg_ctrls.suffix.value

	return to_return


func mark_saved():
	for key in _cfg_ctrls:
		_cfg_ctrls[key].mark_unsaved(false)

--- SCRIPT: res://addons/gut/gui/gut_gui.gd ---
extends Control
# ##############################################################################
# This is the decoupled GUI for gut.gd
#
# This is a "generic" interface between a GUI and gut.gd.  It assumes there are
# certain controls with specific names.  It will then interact with those
# controls based on signals emitted from gut.gd in order to give the user
# feedback about the progress of the test run and the results.
#
# Optional controls are marked as such in the _ctrls dictionary.  The names
# of the controls can be found in _populate_ctrls.
# ##############################################################################
var _gut = null

var _ctrls = {
	btn_continue = null,
	path_dir = null,
	path_file = null,
	prog_script = null,
	prog_test = null,
	rtl = null,                 # optional
	rtl_bg = null,              # required if rtl exists
	switch_modes = null,
	time_label = null,
	title = null,
	title_bar = null,
}

var _title_mouse = {
	down = false
}


signal switch_modes()

var _max_position = Vector2(100, 100)

func _ready():
	_populate_ctrls()

	_ctrls.btn_continue.visible = false
	_ctrls.btn_continue.pressed.connect(_on_continue_pressed)
	_ctrls.switch_modes.pressed.connect(_on_switch_modes_pressed)
	_ctrls.title_bar.gui_input.connect(_on_title_bar_input)

	_ctrls.prog_script.value = 0
	_ctrls.prog_test.value = 0
	_ctrls.path_dir.text = ''
	_ctrls.path_file.text = ''
	_ctrls.time_label.text = ''

	_max_position = get_display_size() - Vector2(30, _ctrls.title_bar.size.y)


func _process(_delta):
	if(_gut != null and _gut.is_running()):
		set_elapsed_time(_gut.get_elapsed_time())


# ------------------
# Private
# ------------------
func get_display_size():
	return get_viewport().get_visible_rect().size


func _populate_ctrls():
	# Brute force, but flexible.  This allows for all the controls to exist
	# anywhere, and as long as they all have the right name, they will be
	# found.
	_ctrls.btn_continue = _get_first_child_named('Continue', self)
	_ctrls.path_dir = _get_first_child_named('Path', self)
	_ctrls.path_file = _get_first_child_named('File', self)
	_ctrls.prog_script = _get_first_child_named('ProgressScript', self)
	_ctrls.prog_test = _get_first_child_named('ProgressTest', self)
	_ctrls.rtl = _get_first_child_named('TestOutput', self)
	_ctrls.rtl_bg = _get_first_child_named('OutputBG', self)
	_ctrls.switch_modes = _get_first_child_named("SwitchModes", self)
	_ctrls.time_label = _get_first_child_named('TimeLabel', self)
	_ctrls.title = _get_first_child_named("Title", self)
	_ctrls.title_bar = _get_first_child_named("TitleBar", self)


func _get_first_child_named(obj_name, parent_obj):
	if(parent_obj == null):
		return null

	var kids = parent_obj.get_children()
	var index = 0
	var to_return = null

	while(index < kids.size() and to_return == null):
		if(str(kids[index]).find(str(obj_name, ':')) != -1):
			to_return = kids[index]
		else:
			to_return = _get_first_child_named(obj_name, kids[index])
			if(to_return == null):
				index += 1

	return to_return



# ------------------
# Events
# ------------------
func _on_title_bar_input(event : InputEvent):
	if(event is InputEventMouseMotion):
		if(_title_mouse.down):
			position += event.relative
			position.x = clamp(position.x, 0, _max_position.x)
			position.y = clamp(position.y, 0, _max_position.y)
	elif(event is InputEventMouseButton):
		if(event.button_index == MOUSE_BUTTON_LEFT):
			_title_mouse.down = event.pressed


func _on_continue_pressed():
	_gut.end_teardown_pause()


func _on_gut_start_run():
	if(_ctrls.rtl != null):
		_ctrls.rtl.clear()
	set_num_scripts(_gut.get_test_collector().scripts.size())


func _on_gut_end_run():
	_ctrls.prog_test.value = _ctrls.prog_test.max_value
	_ctrls.prog_script.value = _ctrls.prog_script.max_value


func _on_gut_start_script(script_obj):
	next_script(script_obj.get_full_name(), script_obj.tests.size())


func _on_gut_end_script():
	pass


func _on_gut_start_test(test_name):
	next_test(test_name)


func _on_gut_end_test():
	pass


func _on_gut_start_pause():
	pause_before_teardown()


func _on_gut_end_pause():
	_ctrls.btn_continue.visible = false


func _on_switch_modes_pressed():
	switch_modes.emit()

# ------------------
# Public
# ------------------
func set_num_scripts(val):
	_ctrls.prog_script.value = 0
	_ctrls.prog_script.max_value = val


func next_script(path, num_tests):
	_ctrls.prog_script.value += 1
	_ctrls.prog_test.value = 0
	_ctrls.prog_test.max_value = num_tests

	_ctrls.path_dir.text = path.get_base_dir()
	_ctrls.path_file.text = path.get_file()


func next_test(__test_name):
	_ctrls.prog_test.value += 1


func pause_before_teardown():
	_ctrls.btn_continue.visible = true


func set_gut(g):
	if(_gut == g):
		return
	_gut = g
	g.start_run.connect(_on_gut_start_run)
	g.end_run.connect(_on_gut_end_run)

	g.start_script.connect(_on_gut_start_script)
	g.end_script.connect(_on_gut_end_script)

	g.start_test.connect(_on_gut_start_test)
	g.end_test.connect(_on_gut_end_test)

	g.start_pause_before_teardown.connect(_on_gut_start_pause)
	g.end_pause_before_teardown.connect(_on_gut_end_pause)

func get_gut():
	return _gut

func get_textbox():
	return _ctrls.rtl

func set_elapsed_time(t):
	_ctrls.time_label.text = str("%6.1f" % t, 's')


func set_bg_color(c):
	_ctrls.rtl_bg.color = c


func set_title(text):
	_ctrls.title.text = text


func to_top_left():
	self.position = Vector2(5, 5)


func to_bottom_right():
	var win_size = get_display_size()
	self.position = win_size - Vector2(self.size) - Vector2(5, 5)


func align_right():
	var win_size = get_display_size()
	self.position.x = win_size.x - self.size.x -5
	self.position.y = 5
	self.size.y = win_size.y - 10

--- SCRIPT: res://addons/gut/gui/gut_user_preferences.gd ---
class GutEditorPref:
	var gut_pref_prefix = 'gut/'
	var pname = '__not_set__'
	var default = null
	var value = '__not_set__'
	var _settings = null

	func _init(n, d, s):
		pname = n
		default = d
		_settings = s
		load_it()

	func _prefstr():
		var to_return = str(gut_pref_prefix, pname)
		return to_return

	func save_it():
		_settings.set_setting(_prefstr(), value)

	func load_it():
		if(_settings.has_setting(_prefstr())):
			value = _settings.get_setting(_prefstr())
		else:
			value = default

	func erase():
		_settings.erase(_prefstr())


const EMPTY = '-- NOT_SET --'

# -- Editor ONLY Settings --
var output_font_name = null
var output_font_size = null
var hide_result_tree = null
var hide_output_text = null
var hide_settings = null
var use_colors = null	# ? might be output panel

# var shortcut_run_all = null
# var shortcut_run_current_script = null
# var shortcut_run_current_inner = null
# var shortcut_run_current_test = null
# var shortcut_panel_button = null


func _init(editor_settings):
	output_font_name = GutEditorPref.new('output_font_name', 'CourierPrime', editor_settings)
	output_font_size = GutEditorPref.new('output_font_size', 30, editor_settings)
	hide_result_tree = GutEditorPref.new('hide_result_tree', false, editor_settings)
	hide_output_text = GutEditorPref.new('hide_output_text', false, editor_settings)
	hide_settings = GutEditorPref.new('hide_settings', false, editor_settings)
	use_colors = GutEditorPref.new('use_colors', true, editor_settings)

	# shortcut_run_all = GutEditorPref.new('shortcut_run_all', EMPTY, editor_settings)
	# shortcut_run_current_script = GutEditorPref.new('shortcut_run_current_script', EMPTY, editor_settings)
	# shortcut_run_current_inner = GutEditorPref.new('shortcut_run_current_inner', EMPTY, editor_settings)
	# shortcut_run_current_test = GutEditorPref.new('shortcut_run_current_test', EMPTY, editor_settings)
	# shortcut_panel_button = GutEditorPref.new('shortcut_panel_button', EMPTY, editor_settings)

func save_it():
	for prop in get_property_list():
		var val = get(prop.name)
		if(val is GutEditorPref):
			val.save_it()


func load_it():
	for prop in get_property_list():
		var val = get(prop.name)
		if(val is GutEditorPref):
			val.load_it()


func erase_all():
	for prop in get_property_list():
		var val = get(prop.name)
		if(val is GutEditorPref):
			val.erase()

--- SCRIPT: res://addons/gut/gui/OutputText.gd ---
@tool
extends VBoxContainer

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
var PanelControls = load('res://addons/gut/gui/panel_controls.gd')

# ##############################################################################
# Keeps search results from the TextEdit
# ##############################################################################
class TextEditSearcher:
	var te : TextEdit
	var _last_term = ''
	var _last_pos = Vector2(-1, -1)
	var _ignore_caret_change = false

	func set_text_edit(which):
		te = which
		te.caret_changed.connect(_on_caret_changed)


	func _on_caret_changed():
		if(_ignore_caret_change):
			_ignore_caret_change = false
		else:
			_last_pos = _get_caret();


	func _get_caret():
		return Vector2(te.get_caret_column(), te.get_caret_line())


	func _set_caret_and_sel(pos, len):
		te.set_caret_line(pos.y)
		te.set_caret_column(pos.x)
		if(len > 0):
			te.select(pos.y, pos.x, pos.y, pos.x + len)


	func _find(term, search_flags):
		var pos = _get_caret()
		if(term == _last_term):
			if(search_flags == 0):
				pos = _last_pos
				pos.x += 1
			else:
				pos = _last_pos
				pos.x -= 1

		var result = te.search(term, search_flags, pos.y, pos.x)
#		print('searching from ', pos, ' for "', term, '" = ', result)
		if(result.y != -1):
			_ignore_caret_change = true
			_set_caret_and_sel(result, term.length())
			_last_pos = result

		_last_term = term

	func find_next(term):
		_find(term, 0)

	func find_prev(term):
		_find(term, te.SEARCH_BACKWARDS)


# ##############################################################################
# Start OutputText control code
# ##############################################################################
@onready var _ctrls = {
	output = $Output,
	settings_bar = $Settings,
	use_colors = $Settings/UseColors,
	word_wrap = $Settings/WordWrap,

	copy_button = $Toolbar/CopyButton,
	clear_button = $Toolbar/ClearButton,
	show_search = $Toolbar/ShowSearch,
	caret_position = $Toolbar/LblPosition,

	search_bar = {
		bar = $Search,
		search_term = $Search/SearchTerm,
	}
}

var _sr = TextEditSearcher.new()
var _highlighter : CodeHighlighter
var _font_name = null
var _user_prefs = GutEditorGlobals.user_prefs
var _font_name_pctrl = null
var _font_size_pctrl = null

# Automatically used when running the OutputText scene from the editor.  Changes
# to this method only affect test-running the control through the editor.
func _test_running_setup():
	_ctrls.use_colors.text = 'use colors'
	_ctrls.show_search.text = 'search'
	_ctrls.word_wrap.text = 'ww'

	set_all_fonts("CourierPrime")
	set_font_size(30)

	_ctrls.output.queue_redraw()
	load_file('user://.gut_editor.bbcode')
	await get_tree().process_frame

	show_search(true)
	_ctrls.output.set_caret_line(0)
	_ctrls.output.scroll_vertical = 0
	_ctrls.output.caret_changed.connect(_on_caret_changed)


func _ready():
	_sr.set_text_edit(_ctrls.output)
	_ctrls.use_colors.icon = get_theme_icon('RichTextEffect', 'EditorIcons')
	_ctrls.show_search.icon = get_theme_icon('Search', 'EditorIcons')
	_ctrls.word_wrap.icon = get_theme_icon('Loop', 'EditorIcons')

	_setup_colors()
	_ctrls.use_colors.button_pressed = true
	_use_highlighting(true)

	if(get_parent() == get_tree().root):
		_test_running_setup()

	_ctrls.settings_bar.visible = false
	_add_other_ctrls()


func _add_other_ctrls():
	var fname = 'CourierNew'
	if(_user_prefs != null):
		fname = _user_prefs.output_font_name.value
	_font_name_pctrl = PanelControls.SelectControl.new('Font', fname, GutUtils.avail_fonts,
		"The font, you know, for the text below.  Change it, see what it does.")
	_font_name_pctrl.changed.connect(_on_font_name_changed)
	_font_name_pctrl.label.size_flags_horizontal = SIZE_SHRINK_BEGIN
	_ctrls.settings_bar.add_child(_font_name_pctrl)
	set_all_fonts(fname)

	var fsize = 30
	if(_user_prefs != null):
		fsize = _user_prefs.output_font_size.value
	_font_size_pctrl = PanelControls.NumberControl.new('Font Size', fsize , 5, 100,
		"The size of 'The Font'.")
	_font_size_pctrl.changed.connect(_on_font_size_changed)
	_font_size_pctrl.label.size_flags_horizontal = SIZE_SHRINK_BEGIN
	_ctrls.settings_bar.add_child(_font_size_pctrl)
	set_font_size(fsize)


# ------------------
# Private
# ------------------

# Call this after changes in colors and the like to get them to apply.  reloads
# the text of the output control.
func _refresh_output():
	var orig_pos = _ctrls.output.scroll_vertical
	var text = _ctrls.output.text

	_ctrls.output.text = text
	_ctrls.output.scroll_vertical = orig_pos


func _create_highlighter(default_color=Color(1, 1, 1, 1)):
	var to_return = CodeHighlighter.new()

	to_return.function_color = default_color
	to_return.number_color = default_color
	to_return.symbol_color = default_color
	to_return.member_variable_color = default_color

	var keywords = [
		['Failed', Color.RED],
		['Passed', Color.GREEN],
		['Pending', Color.YELLOW],
		['Orphans', Color.YELLOW],
		['WARNING', Color.YELLOW],
		['ERROR', Color.RED]
	]

	for keyword in keywords:
		to_return.add_keyword_color(keyword[0], keyword[1])

	return to_return


func _setup_colors():
	_ctrls.output.clear()

	var f_color = null
	if (_ctrls.output.theme == null) :
		f_color = get_theme_color("font_color")
	else :
		f_color = _ctrls.output.theme.font_color

	_highlighter = _create_highlighter()
	_ctrls.output.queue_redraw()



func _use_highlighting(should):
	if(should):
		_ctrls.output.syntax_highlighter = _highlighter
	else:
		_ctrls.output.syntax_highlighter = null
	_refresh_output()

# ------------------
# Events
# ------------------
func _on_caret_changed():
	var txt = str("line:",_ctrls.output.get_caret_line(), ' col:', _ctrls.output.get_caret_column())
	_ctrls.caret_position.text = str(txt)

func _on_font_size_changed():
	set_font_size(_font_size_pctrl.value)
	if(_user_prefs != null):
		_user_prefs.output_font_size.value = _font_size_pctrl.value
		_user_prefs.output_font_size.save_it()

func _on_font_name_changed():
	set_all_fonts(_font_name_pctrl.text)
	if(_user_prefs != null):
		_user_prefs.output_font_name.value = _font_name_pctrl.text
		_user_prefs.output_font_name.save_it()

func _on_CopyButton_pressed():
	copy_to_clipboard()

func _on_UseColors_pressed():
	_use_highlighting(_ctrls.use_colors.button_pressed)

func _on_ClearButton_pressed():
	clear()

func _on_ShowSearch_pressed():
	show_search(_ctrls.show_search.button_pressed)

func _on_SearchTerm_focus_entered():
	_ctrls.search_bar.search_term.call_deferred('select_all')

func _on_SearchNext_pressed():
	_sr.find_next(_ctrls.search_bar.search_term.text)

func _on_SearchPrev_pressed():
	_sr.find_prev(_ctrls.search_bar.search_term.text)

func _on_SearchTerm_text_changed(new_text):
	if(new_text == ''):
		_ctrls.output.deselect()
	else:
		_sr.find_next(new_text)

func _on_SearchTerm_text_entered(new_text):
	if(Input.is_physical_key_pressed(KEY_SHIFT)):
		_sr.find_prev(new_text)
	else:
		_sr.find_next(new_text)

func _on_SearchTerm_gui_input(event):
	if(event is InputEventKey and !event.pressed and event.keycode == KEY_ESCAPE):
		show_search(false)

func _on_WordWrap_pressed():
	if(_ctrls.word_wrap.button_pressed):
		_ctrls.output.wrap_mode = TextEdit.LINE_WRAPPING_BOUNDARY
	else:
		_ctrls.output.wrap_mode = TextEdit.LINE_WRAPPING_NONE

	_ctrls.output.queue_redraw()

func _on_settings_pressed():
	_ctrls.settings_bar.visible = $Toolbar/ShowSettings.button_pressed

# ------------------
# Public
# ------------------
func show_search(should):
	_ctrls.search_bar.bar.visible = should
	if(should):
		_ctrls.search_bar.search_term.grab_focus()
		_ctrls.search_bar.search_term.select_all()
	_ctrls.show_search.button_pressed = should


func search(text, start_pos, highlight=true):
	return _sr.find_next(text)


func copy_to_clipboard():
	var selected = _ctrls.output.get_selected_text()
	if(selected != ''):
		DisplayServer.clipboard_set(selected)
	else:
		DisplayServer.clipboard_set(_ctrls.output.text)


func clear():
	_ctrls.output.text = ''


func _set_font(font_name, custom_name):
	var rtl = _ctrls.output
	if(font_name == null):
		rtl.remove_theme_font_override(custom_name)
	else:
		var dyn_font = FontFile.new()
		dyn_font.load_dynamic_font('res://addons/gut/fonts/' + font_name + '.ttf')
		rtl.add_theme_font_override(custom_name, dyn_font)


func set_all_fonts(base_name):
	_font_name = GutUtils.nvl(base_name, 'Default')

	if(base_name == 'Default'):
		_set_font(null, 'font')
		_set_font(null, 'normal_font')
		_set_font(null, 'bold_font')
		_set_font(null, 'italics_font')
		_set_font(null, 'bold_italics_font')
	else:
		_set_font(base_name + '-Regular', 'font')
		_set_font(base_name + '-Regular', 'normal_font')
		_set_font(base_name + '-Bold', 'bold_font')
		_set_font(base_name + '-Italic', 'italics_font')
		_set_font(base_name + '-BoldItalic', 'bold_italics_font')


func set_font_size(new_size):
	_ctrls.output.set("theme_override_font_sizes/font_size", new_size)


func set_use_colors(value):
	pass


func get_use_colors():
	return false;


func get_rich_text_edit():
	return _ctrls.output


func load_file(path):
	var f = FileAccess.open(path, FileAccess.READ)
	if(f == null):
		return

	var t = f.get_as_text()
	f = null # closes file
	_ctrls.output.text = t
	_ctrls.output.scroll_vertical = _ctrls.output.get_line_count()
	_ctrls.output.set_deferred('scroll_vertical', _ctrls.output.get_line_count())


func add_text(text):
	if(is_inside_tree()):
		_ctrls.output.text += text


func scroll_to_line(line):
	_ctrls.output.scroll_vertical = line
	_ctrls.output.set_caret_line(line)

--- SCRIPT: res://addons/gut/gui/panel_controls.gd ---
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class BaseGutPanelControl:
	extends HBoxContainer
	var label = Label.new()
	var _lbl_unsaved = Label.new()
	var _lbl_invalid = Label.new()

	var value = null:
		get: return get_value()
		set(val): set_value(val)

	signal changed

	func _init(title, val, hint=""):
		size_flags_horizontal = SIZE_EXPAND_FILL
		mouse_filter = MOUSE_FILTER_PASS

		label.size_flags_horizontal = label.SIZE_EXPAND_FILL
		label.mouse_filter = label.MOUSE_FILTER_STOP
		add_child(label)

		_lbl_unsaved.text = '*'
		_lbl_unsaved.visible = false
		add_child(_lbl_unsaved)

		_lbl_invalid.text = '!'
		_lbl_invalid.visible = false
		add_child(_lbl_invalid)

		label.text = title
		label.tooltip_text = hint


	func mark_unsaved(is_it=true):
		_lbl_unsaved.visible = is_it


	func mark_invalid(is_it):
		_lbl_invalid.visible = is_it

	# -- Virtual --
	#
	# value_ctrl (all should declare the value_ctrl)
	#
	func set_value(value):
		pass

	func get_value():
		pass


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class NumberControl:
	extends BaseGutPanelControl

	var value_ctrl = SpinBox.new()

	func _init(title, val, v_min, v_max, hint=""):
		super._init(title, val, hint)

		value_ctrl.value = val
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.min_value = v_min
		value_ctrl.max_value = v_max
		value_ctrl.value_changed.connect(_on_value_changed)
		value_ctrl.select_all_on_focus = true
		add_child(value_ctrl)

	func _on_value_changed(new_value):
		changed.emit()

	func get_value():
		return value_ctrl.value

	func set_value(val):
		value_ctrl.value = val


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class StringControl:
	extends BaseGutPanelControl

	var value_ctrl = LineEdit.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)

		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.text = val
		value_ctrl.text_changed.connect(_on_text_changed)
		value_ctrl.select_all_on_focus = true
		add_child(value_ctrl)

	func _on_text_changed(new_value):
		changed.emit()

	func get_value():
		return value_ctrl.text

	func set_value(val):
		value_ctrl.text = val



# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class BooleanControl:
	extends BaseGutPanelControl

	var value_ctrl = CheckBox.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)

		value_ctrl.button_pressed = val
		value_ctrl.toggled.connect(_on_button_toggled)
		add_child(value_ctrl)

	func _on_button_toggled(new_value):
		changed.emit()

	func get_value():
		return value_ctrl.button_pressed

	func set_value(val):
		value_ctrl.button_pressed = val


# ------------------------------------------------------------------------------
# value is "selected" and is gettable and settable
# text is the text value of the selected item, it is gettable only
# ------------------------------------------------------------------------------
class SelectControl:
	extends BaseGutPanelControl

	var value_ctrl = OptionButton.new()

	var text = '' :
		get: return value_ctrl.get_item_text(value_ctrl.selected)
		set(val): pass

	func _init(title, val, choices, hint=""):
		super._init(title, val, hint)

		var select_idx = 0
		for i in range(choices.size()):
			value_ctrl.add_item(choices[i])
			if(val == choices[i]):
				select_idx = i
		value_ctrl.selected = select_idx
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.item_selected.connect(_on_item_selected)
		add_child(value_ctrl)

	func _on_item_selected(idx):
		changed.emit()

	func get_value():
		return value_ctrl.selected

	func set_value(val):
		value_ctrl.selected = val


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class ColorControl:
	extends BaseGutPanelControl

	var value_ctrl = ColorPickerButton.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.color = val
		add_child(value_ctrl)

	func get_value():
		return value_ctrl.color

	func set_value(val):
		value_ctrl.color = val


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class DirectoryControl:
	extends BaseGutPanelControl

	var value_ctrl := LineEdit.new()
	var dialog := FileDialog.new()
	var enabled_button = CheckButton.new()

	var _btn_dir := Button.new()

	func _init(title, val, hint=""):
		super._init(title, val, hint)

		label.size_flags_horizontal = Control.SIZE_SHRINK_BEGIN

		_btn_dir.text = '...'
		_btn_dir.pressed.connect(_on_dir_button_pressed)

		value_ctrl.text = val
		value_ctrl.size_flags_horizontal = value_ctrl.SIZE_EXPAND_FILL
		value_ctrl.select_all_on_focus = true
		value_ctrl.text_changed.connect(_on_value_changed)

		dialog.file_mode = dialog.FILE_MODE_OPEN_DIR
		dialog.unresizable = false
		dialog.dir_selected.connect(_on_selected)
		dialog.file_selected.connect(_on_selected)

		enabled_button.button_pressed = true
		enabled_button.visible = false

		add_child(enabled_button)
		add_child(value_ctrl)
		add_child(_btn_dir)
		add_child(dialog)

	func _update_display():
		var is_empty = value_ctrl.text == ''
		enabled_button.button_pressed = !is_empty
		enabled_button.disabled = is_empty


	func _ready():
		if(Engine.is_editor_hint()):
			dialog.size = Vector2(1000, 700)
		else:
			dialog.size = Vector2(500, 350)
		_update_display()

	func _on_value_changed(new_text):
		_update_display()

	func _on_selected(path):
		value_ctrl.text = path
		_update_display()

	func _on_dir_button_pressed():
		dialog.current_dir = value_ctrl.text
		dialog.popup_centered()

	func get_value():
		return value_ctrl.text

	func set_value(val):
		value_ctrl.text = val


# ------------------------------------------------------------------------------
# Features:
# 	Buttons to pick res://, user://, or anywhere on the OS.
# ------------------------------------------------------------------------------
class FileDialogSuperPlus:
	extends FileDialog

	var show_diretory_types = true :
		set(val) :
			show_diretory_types = val
			_update_display()

	var show_res = true :
		set(val) :
			show_res = val
			_update_display()

	var show_user = true :
		set(val) :
			show_user = val
			_update_display()

	var show_os = true :
		set(val) :
			show_os = val
			_update_display()

	var _dir_type_hbox = null
	var _btn_res = null
	var _btn_user = null
	var _btn_os = null

	func _ready():
		_init_controls()
		_update_display()


	func _init_controls():
		_dir_type_hbox = HBoxContainer.new()

		_btn_res = Button.new()
		_btn_user = Button.new()
		_btn_os = Button.new()
		var spacer1 = CenterContainer.new()
		spacer1.size_flags_horizontal = spacer1.SIZE_EXPAND_FILL
		var spacer2 = spacer1.duplicate()

		_dir_type_hbox.add_child(spacer1)
		_dir_type_hbox.add_child(_btn_res)
		_dir_type_hbox.add_child(_btn_user)
		_dir_type_hbox.add_child(_btn_os)
		_dir_type_hbox.add_child(spacer2)

		_btn_res.text = 'res://'
		_btn_user.text = 'user://'
		_btn_os.text = '  OS  '

		get_vbox().add_child(_dir_type_hbox)
		get_vbox().move_child(_dir_type_hbox, 0)

		_btn_res.pressed.connect(func(): access = ACCESS_RESOURCES)
		_btn_user.pressed.connect(func(): access = ACCESS_USERDATA)
		_btn_os.pressed.connect(func(): access = ACCESS_FILESYSTEM)


	func _update_display():
		if(is_inside_tree()):
			_dir_type_hbox.visible = show_diretory_types
			_btn_res.visible = show_res
			_btn_user.visible = show_user
			_btn_os.visible = show_os


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class SaveLoadControl:
	extends BaseGutPanelControl

	var btn_load = Button.new()
	var btn_save = Button.new()

	var dlg_load := FileDialogSuperPlus.new()
	var dlg_save := FileDialogSuperPlus.new()

	signal save_path_chosen(path)
	signal load_path_chosen(path)

	func _init(title, val, hint):
		super._init(title, val, hint)

		btn_load.text = "Load"
		btn_load.custom_minimum_size.x = 100
		btn_load.pressed.connect(_on_load_pressed)
		add_child(btn_load)

		btn_save.text = "Save As"
		btn_save.custom_minimum_size.x = 100
		btn_save.pressed.connect(_on_save_pressed)
		add_child(btn_save)

		dlg_load.file_mode = dlg_load.FILE_MODE_OPEN_FILE
		dlg_load.unresizable = false
		dlg_load.dir_selected.connect(_on_load_selected)
		dlg_load.file_selected.connect(_on_load_selected)
		add_child(dlg_load)

		dlg_save.file_mode = dlg_save.FILE_MODE_SAVE_FILE
		dlg_save.unresizable = false
		dlg_save.dir_selected.connect(_on_save_selected)
		dlg_save.file_selected.connect(_on_save_selected)
		add_child(dlg_save)


	func _ready():
		if(Engine.is_editor_hint()):
			dlg_load.size = Vector2(1000, 700)
			dlg_save.size = Vector2(1000, 700)
		else:
			dlg_load.size = Vector2(500, 350)
			dlg_save.size = Vector2(500, 350)

	func _on_load_selected(path):
		load_path_chosen.emit(path)

	func _on_save_selected(path):
		save_path_chosen.emit(path)

	func _on_load_pressed():
		dlg_load.popup_centered()

	func _on_save_pressed():
		dlg_save.popup_centered()

# ------------------------------------------------------------------------------
# This one was never used in gut_config_gui...but I put some work into it and
# I'm a sucker for that kinda thing.  Delete this when you get tired of looking
# at it.
# ------------------------------------------------------------------------------
# class Vector2Ctrl:
# 	extends VBoxContainer

# 	var value = Vector2(-1, -1) :
# 		get:
# 			return get_value()
# 		set(val):
# 			set_value(val)
# 	var disabled = false :
# 		get:
# 			return get_disabled()
# 		set(val):
# 			set_disabled(val)
# 	var x_spin = SpinBox.new()
# 	var y_spin = SpinBox.new()

# 	func _init():
# 		add_child(_make_one('x:  ', x_spin))
# 		add_child(_make_one('y:  ', y_spin))

# 	func _make_one(txt, spinner):
# 		var hbox = HBoxContainer.new()
# 		var lbl = Label.new()
# 		lbl.text = txt
# 		hbox.add_child(lbl)
# 		hbox.add_child(spinner)
# 		spinner.min_value = -1
# 		spinner.max_value = 10000
# 		spinner.size_flags_horizontal = spinner.SIZE_EXPAND_FILL
# 		return hbox

# 	func set_value(v):
# 		if(v != null):
# 			x_spin.value = v[0]
# 			y_spin.value = v[1]

# 	# Returns array instead of vector2 b/c that is what is stored in
# 	# in the dictionary and what is expected everywhere else.
# 	func get_value():
# 		return [x_spin.value, y_spin.value]

# 	func set_disabled(should):
# 		get_parent().visible = !should
# 		x_spin.visible = !should
# 		y_spin.visible = !should

# 	func get_disabled():
# 		pass

--- SCRIPT: res://addons/gut/gui/ResizeHandle.gd ---
@tool
extends ColorRect
# #############################################################################
# Resize Handle control.  Place onto a control.  Set the orientation, then
# set the control that this should resize.  Then you can resize the control
# by dragging this thing around.  It's pretty neat.
# #############################################################################
enum ORIENTATION {
	LEFT,
	RIGHT
}

@export var orientation := ORIENTATION.RIGHT :
	get: return orientation
	set(val):
		orientation = val
		queue_redraw()
@export var resize_control : Control = null
@export var vertical_resize := true

var _line_width = .5
var _line_color = Color(.4, .4, .4)
var _active_line_color = Color(.3, .3, .3)
var _invalid_line_color = Color(1, 0, 0)

var _line_space = 3
var _num_lines = 8

var _mouse_down = false
# Called when the node enters the scene tree for the first time.


func _draw():
	var c = _line_color
	if(resize_control == null):
		c = _invalid_line_color
	elif(_mouse_down):
		c = _active_line_color

	if(orientation == ORIENTATION.LEFT):
		_draw_resize_handle_left(c)
	else:
		_draw_resize_handle_right(c)


func _gui_input(event):
	if(resize_control == null):
		return

	if(orientation == ORIENTATION.LEFT):
		_handle_left_input(event)
	else:
		_handle_right_input(event)


# Draw the lines in the corner to show where you can
# drag to resize the dialog
func _draw_resize_handle_right(draw_color):
	var br = size

	for i in range(_num_lines):
		var start = br - Vector2(i * _line_space, 0)
		var end = br - Vector2(0, i * _line_space)
		draw_line(start, end, draw_color, _line_width, true)


func _draw_resize_handle_left(draw_color):
	var bl = Vector2(0, size.y)

	for i in range(_num_lines):
		var start = bl + Vector2(i * _line_space, 0)
		var end = bl -  Vector2(0, i * _line_space)
		draw_line(start, end, draw_color, _line_width, true)


func _handle_right_input(event : InputEvent):
	if(event is InputEventMouseMotion):
		if(_mouse_down and
			event.global_position.x > 0 and
			event.global_position.y < DisplayServer.window_get_size().y):

			if(vertical_resize):
				resize_control.size.y += event.relative.y
			resize_control.size.x += event.relative.x
	elif(event is InputEventMouseButton):
		if(event.button_index == MOUSE_BUTTON_LEFT):
			_mouse_down = event.pressed
			queue_redraw()


func _handle_left_input(event : InputEvent):
	if(event is InputEventMouseMotion):
		if(_mouse_down and
			event.global_position.x > 0 and
			event.global_position.y < DisplayServer.window_get_size().y):

			var start_size = resize_control.size
			resize_control.size.x -= event.relative.x
			if(resize_control.size.x != start_size.x):
				resize_control.global_position.x += event.relative.x

			if(vertical_resize):
				resize_control.size.y += event.relative.y
	elif(event is InputEventMouseButton):
		if(event.button_index == MOUSE_BUTTON_LEFT):
			_mouse_down = event.pressed
			queue_redraw()

--- SCRIPT: res://addons/gut/gui/ResultsTree.gd ---
@tool
extends Control

var _show_orphans = true
var show_orphans = true :
	get: return _show_orphans
	set(val): _show_orphans = val


var _hide_passing = true
var hide_passing = true :
	get: return _hide_passing
	set(val): _hide_passing = val


var _icons = {
	red = load('res://addons/gut/images/red.png'),
	green = load('res://addons/gut/images/green.png'),
	yellow = load('res://addons/gut/images/yellow.png'),
}
const _col_1_bg_color = Color(0, 0, 0, .1)
var _max_icon_width = 10
var _root : TreeItem

@onready var _ctrls = {
	tree = $Tree,
	lbl_overlay = $Tree/TextOverlay
}


signal item_selected(script_path, inner_class, test_name, line_number)
# -------------------
# Private
# -------------------
func _ready():
	_root = _ctrls.tree.create_item()
	_root = _ctrls.tree.create_item()
	_ctrls.tree.set_hide_root(true)
	_ctrls.tree.columns = 2
	_ctrls.tree.set_column_expand(0, true)
	_ctrls.tree.set_column_expand(1, false)
	_ctrls.tree.set_column_clip_content(0, true)

	$Tree.item_selected.connect(_on_tree_item_selected)

	if(get_parent() == get_tree().root):
		_test_running_setup()

func _test_running_setup():
	load_json_file('user://.gut_editor.json')


func _on_tree_item_selected():
	var item = _ctrls.tree.get_selected()
	var item_meta = item.get_metadata(0)
	var item_type = null

	# Only select the left side of the tree item, cause I like that better.
	# you can still click the right, but only the left gets highlighted.
	if(item.is_selected(1)):
		item.deselect(1)
		item.select(0)

	if(item_meta == null):
		return
	else:
		item_type = item_meta.type

	var script_path = '';
	var line = -1;
	var test_name = ''
	var inner_class = ''

	if(item_type == 'test'):
		var s_item = item.get_parent()
		script_path = s_item.get_metadata(0)['path']
		inner_class = s_item.get_metadata(0)['inner_class']
		line = -1
		test_name = item.get_text(0)
	elif(item_type == 'assert'):
		var s_item = item.get_parent().get_parent()
		script_path = s_item.get_metadata(0)['path']
		inner_class = s_item.get_metadata(0)['inner_class']
		line = _get_line_number_from_assert_msg(item.get_text(0))
		test_name = item.get_parent().get_text(0)
	elif(item_type == 'script'):
		script_path = item.get_metadata(0)['path']
		if(item.get_parent() != _root):
			inner_class = item.get_text(0)
		line = -1
		test_name = ''
	else:
		return

	item_selected.emit(script_path, inner_class, test_name, line)


func _get_line_number_from_assert_msg(msg):
	var line = -1
	if(msg.find('at line') > 0):
		line = msg.split("at line")[-1].split(" ")[-1].to_int()
	return line


func _get_path_and_inner_class_name_from_test_path(path):
	var to_return = {
		path = '',
		inner_class = ''
	}

	to_return.path = path
	if !path.ends_with('.gd'):
		var loc = path.find('.gd')
		to_return.inner_class = path.split('.')[-1]
		to_return.path = path.substr(0, loc + 3)
	return to_return


func _find_script_item_with_path(path):
	var items = _root.get_children()
	var to_return = null

	var idx = 0
	while(idx < items.size() and to_return == null):
		var item = items[idx]
		if(item.get_metadata(0).path == path):
			to_return = item
		else:
			idx += 1

	return to_return


func _add_script_tree_item(script_path, script_json):
	var path_info = _get_path_and_inner_class_name_from_test_path(script_path)
	var item_text = script_path
	var parent = _root

	if(path_info.inner_class != ''):
		parent = _find_script_item_with_path(path_info.path)
		item_text = path_info.inner_class
		if(parent == null):
			parent = _add_script_tree_item(path_info.path, {})

		parent.get_metadata(0).inner_tests += script_json['props']['tests']
		parent.get_metadata(0).inner_passing += script_json['props']['tests']
		parent.get_metadata(0).inner_passing -= script_json['props']['failures']
		parent.get_metadata(0).inner_passing -= script_json['props']['pending']

		var total_text = str("All ", parent.get_metadata(0).inner_tests, " passed")
		if(parent.get_metadata(0).inner_passing != parent.get_metadata(0).inner_tests):
			total_text = str(parent.get_metadata(0).inner_passing, '/', parent.get_metadata(0).inner_tests, ' passed.')
		parent.set_text(1, total_text)

	var item = _ctrls.tree.create_item(parent)
	item.set_text(0, item_text)
	var meta = {
		"type":"script",
		"path":path_info.path,
		"inner_class":path_info.inner_class,
		"json":script_json,
		"inner_passing":0,
		"inner_tests":0
	}
	item.set_metadata(0, meta)
	item.set_custom_bg_color(1, _col_1_bg_color)

	return item


func _add_assert_item(text, icon, parent_item):
	# print('        * adding assert')
	var assert_item = _ctrls.tree.create_item(parent_item)
	assert_item.set_icon_max_width(0, _max_icon_width)
	assert_item.set_text(0, text)
	assert_item.set_metadata(0, {"type":"assert"})
	assert_item.set_icon(0, icon)
	assert_item.set_custom_bg_color(1, _col_1_bg_color)

	return assert_item


func _add_test_tree_item(test_name, test_json, script_item):
	# print('    * adding test ', test_name)
	var no_orphans_to_show = !_show_orphans or (_show_orphans and test_json.orphans == 0)
	if(_hide_passing and test_json['status'] == 'pass' and no_orphans_to_show):
		return

	var item = _ctrls.tree.create_item(script_item)
	var status = test_json['status']
	var meta = {"type":"test", "json":test_json}

	item.set_text(0, test_name)
	item.set_text(1, status)
	item.set_text_alignment(1, HORIZONTAL_ALIGNMENT_RIGHT)
	item.set_custom_bg_color(1, _col_1_bg_color)

	item.set_metadata(0, meta)
	item.set_icon_max_width(0, _max_icon_width)

	var orphan_text = 'orphans'
	if(test_json.orphans == 1):
		orphan_text = 'orphan'
	orphan_text = str(test_json.orphans, ' ', orphan_text)

	if(status == 'pass' and no_orphans_to_show):
		item.set_icon(0, _icons.green)
	elif(status == 'pass' and !no_orphans_to_show):
		item.set_icon(0, _icons.yellow)
		item.set_text(1, orphan_text)
	elif(status == 'fail'):
		item.set_icon(0, _icons.red)
	else:
		item.set_icon(0, _icons.yellow)

	if(!_hide_passing):
		for passing in test_json.passing:
			_add_assert_item('pass: ' + passing, _icons.green, item)

	for failure in test_json.failing:
		_add_assert_item("fail:  " + failure.replace("\n", ''), _icons.red, item)

	for pending in test_json.pending:
		_add_assert_item("pending:  " + pending.replace("\n", ''), _icons.yellow, item)

	if(status != 'pass' and !no_orphans_to_show):
		_add_assert_item(orphan_text, _icons.yellow, item)

	return item


func _add_script_to_tree(key, script_json):
	var tests = script_json['tests']
	var test_keys = tests.keys()
	var s_item = _add_script_tree_item(key, script_json)
	var bad_count = 0

	for test_key in test_keys:
		var t_item = _add_test_tree_item(test_key, tests[test_key], s_item)
		if(tests[test_key].status != 'pass'):
			bad_count += 1
		elif(t_item != null):
			t_item.collapsed = true

	if(s_item.get_children().size() == 0):
		s_item.free()
	else:
		var total_text = str('All ', test_keys.size(), ' passed')
		if(bad_count == 0):
			s_item.collapsed = true
		else:
			total_text = str(test_keys.size() - bad_count, '/', test_keys.size(), ' passed')
		s_item.set_text(1, total_text)


func _free_childless_scripts():
	var items = _root.get_children()
	for item in items:
		var next_item = item.get_next()
		if(item.get_children().size() == 0):
			item.free()
		item = next_item


func _show_all_passed():
	if(_root.get_children().size() == 0):
		add_centered_text('Everything passed!')


func _load_result_tree(j):
	var scripts = j['test_scripts']['scripts']
	var script_keys = scripts.keys()
	# if we made it here, the json is valid and we did something, otherwise the
	# 'nothing to see here' should be visible.
	clear_centered_text()

	var add_count = 0
	for key in script_keys:
		if(scripts[key]['props']['tests'] > 0):
			add_count += 1
			_add_script_to_tree(key, scripts[key])

	_free_childless_scripts()
	if(add_count == 0):
		add_centered_text('Nothing was run')
	else:
		_show_all_passed()


# -------------------
# Public
# -------------------
func load_json_file(path):
	var file = FileAccess.open(path, FileAccess.READ)
	var text = ''
	if(file != null):
		text = file.get_as_text()

	if(text != ''):
		var test_json_conv = JSON.new()
		var result = test_json_conv.parse(text)
		if(result != OK):
			add_centered_text(str(path, " has invalid json in it \n",
				'Error ', result, "@", test_json_conv.get_error_line(), "\n",
				test_json_conv.get_error_message()))
			return

		var data = test_json_conv.get_data()
		load_json_results(data)
	else:
		add_centered_text(str(path, ' was empty or does not exist.'))


func load_json_results(j):
	clear()
	_load_result_tree(j)


func clear():
	_ctrls.tree.clear()
	_root = _ctrls.tree.create_item()


func set_summary_min_width(width):
	_ctrls.tree.set_column_custom_minimum_width(1, width)


func add_centered_text(t):
	_ctrls.lbl_overlay.visible = true
	_ctrls.lbl_overlay.text = t


func clear_centered_text():
	_ctrls.lbl_overlay.visible = false
	_ctrls.lbl_overlay.text = ''


func collapse_all():
	set_collapsed_on_all(_root, true)


func expand_all():
	set_collapsed_on_all(_root, false)


func set_collapsed_on_all(item, value):
	item.set_collapsed_recursive(value)
	if(item == _root and value):
		item.set_collapsed(false)


func get_selected():
	return _ctrls.tree.get_selected()

--- SCRIPT: res://addons/gut/gui/RunAtCursor.gd ---
@tool
extends Control


var ScriptTextEditors = load('res://addons/gut/gui/script_text_editor_controls.gd')

@onready var _ctrls = {
	btn_script = $HBox/BtnRunScript,
	btn_inner = $HBox/BtnRunInnerClass,
	btn_method = $HBox/BtnRunMethod,
	lbl_none = $HBox/LblNoneSelected,
	arrow_1 = $HBox/Arrow1,
	arrow_2 = $HBox/Arrow2
}

var _editors = null
var _cur_editor = null
var _last_line = -1
var _cur_script_path = null
var _last_info = {
	script = null,
	inner_class = null,
	test_method = null
}


signal run_tests(what)


func _ready():
	_ctrls.lbl_none.visible = true
	_ctrls.btn_script.visible = false
	_ctrls.btn_inner.visible = false
	_ctrls.btn_method.visible = false
	_ctrls.arrow_1.visible = false
	_ctrls.arrow_2.visible = false

# ----------------
# Private
# ----------------
func _set_editor(which):
	_last_line = -1
	if(_cur_editor != null and _cur_editor.get_ref()):
		# _cur_editor.get_ref().disconnect('cursor_changed',Callable(self,'_on_cursor_changed'))
		_cur_editor.get_ref().caret_changed.disconnect(_on_cursor_changed)

	if(which != null):
		_cur_editor = weakref(which)
		which.caret_changed.connect(_on_cursor_changed.bind(which))
		# which.connect('cursor_changed',Callable(self,'_on_cursor_changed'),[which])

		_last_line = which.get_caret_line()
		_last_info = _editors.get_line_info()
		_update_buttons(_last_info)


func _update_buttons(info):
	_ctrls.lbl_none.visible = _cur_script_path == null
	_ctrls.btn_script.visible = _cur_script_path != null

	_ctrls.btn_inner.visible = info.inner_class != null
	_ctrls.arrow_1.visible = info.inner_class != null
	_ctrls.btn_inner.text = str(info.inner_class)
	_ctrls.btn_inner.tooltip_text = str("Run all tests in Inner-Test-Class ", info.inner_class)

	_ctrls.btn_method.visible = info.test_method != null
	_ctrls.arrow_2.visible = info.test_method != null
	_ctrls.btn_method.text = str(info.test_method)
	_ctrls.btn_method.tooltip_text = str("Run test ", info.test_method)

	# The button's new size won't take effect until the next frame.
	# This appears to be what was causing the button to not be clickable the
	# first time.
	call_deferred("_update_size")

func _update_size():
	custom_minimum_size.x = _ctrls.btn_method.size.x + _ctrls.btn_method.position.x

# ----------------
# Events
# ----------------
func _on_cursor_changed(which):
	if(which.get_caret_line() != _last_line):
		_last_line = which.get_caret_line()
		_last_info = _editors.get_line_info()
		_update_buttons(_last_info)


func _on_BtnRunScript_pressed():
	var info = _last_info.duplicate()
	info.script = _cur_script_path.get_file()
	info.inner_class = null
	info.test_method = null
	emit_signal("run_tests", info)


func _on_BtnRunInnerClass_pressed():
	var info = _last_info.duplicate()
	info.script = _cur_script_path.get_file()
	info.test_method = null
	emit_signal("run_tests", info)


func _on_BtnRunMethod_pressed():
	var info = _last_info.duplicate()
	info.script = _cur_script_path.get_file()
	emit_signal("run_tests", info)


# ----------------
# Public
# ----------------
func set_script_text_editors(value):
	_editors = value


func activate_for_script(path):
	_ctrls.btn_script.visible = true
	_ctrls.btn_script.text = path.get_file()
	_ctrls.btn_script.tooltip_text = str("Run all tests in script ", path)
	_cur_script_path = path
	_editors.refresh()
	# We have to wait a beat for the visibility to change on
	# the editors, otherwise we always get the first one.
	await get_tree().process_frame
	_set_editor(_editors.get_current_text_edit())


func get_script_button():
	return _ctrls.btn_script


func get_inner_button():
	return _ctrls.btn_inner


func get_test_button():
	return _ctrls.btn_method


# not used, thought was configurable but it's just the script prefix
func set_method_prefix(value):
	_editors.set_method_prefix(value)


# not used, thought was configurable but it's just the script prefix
func set_inner_class_prefix(value):
	_editors.set_inner_class_prefix(value)


# Mashed this function in here b/c it has _editors.  Probably should be
# somewhere else (possibly in script_text_editor_controls).
func search_current_editor_for_text(txt):
	var te = _editors.get_current_text_edit()
	var result = te.search(txt, 0, 0, 0)
	var to_return = -1

	return to_return

--- SCRIPT: res://addons/gut/gui/RunResults.gd ---
@tool
extends Control

var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')

var _interface = null
var _font = null
var _font_size = null
var _editors = null # script_text_editor_controls.gd
var _output_control = null

@onready var _ctrls = {
	tree = $VBox/Output/Scroll/Tree,
	toolbar = {
		toolbar = $VBox/Toolbar,
		collapse = $VBox/Toolbar/Collapse,
		collapse_all = $VBox/Toolbar/CollapseAll,
		expand = $VBox/Toolbar/Expand,
		expand_all = $VBox/Toolbar/ExpandAll,
		hide_passing = $VBox/Toolbar/HidePassing,
		show_script = $VBox/Toolbar/ShowScript,
		scroll_output = $VBox/Toolbar/ScrollOutput
	}
}

func _ready():
	var f = null
	if ($FontSampler.get_label_settings() == null) :
		f = get_theme_default_font()
	else :
		f = $FontSampler.get_label_settings().font
	var s_size = f.get_string_size("000 of 000 passed")
	_ctrls.tree.set_summary_min_width(s_size.x)

	_set_toolbutton_icon(_ctrls.toolbar.collapse, 'CollapseTree', 'c')
	_set_toolbutton_icon(_ctrls.toolbar.collapse_all, 'CollapseTree', 'c')
	_set_toolbutton_icon(_ctrls.toolbar.expand, 'ExpandTree', 'e')
	_set_toolbutton_icon(_ctrls.toolbar.expand_all, 'ExpandTree', 'e')
	_set_toolbutton_icon(_ctrls.toolbar.show_script, 'Script', 'ss')
	_set_toolbutton_icon(_ctrls.toolbar.scroll_output, 'Font', 'so')

	_ctrls.tree.hide_passing = true
	_ctrls.toolbar.hide_passing.button_pressed = false
	_ctrls.tree.show_orphans = true
	_ctrls.tree.item_selected.connect(_on_item_selected)

	if(get_parent() == get_tree().root):
		_test_running_setup()

	call_deferred('_update_min_width')


func _test_running_setup():
	_ctrls.tree.hide_passing = true
	_ctrls.tree.show_orphans = true

	_ctrls.toolbar.hide_passing.text = '[hp]'
	_ctrls.tree.load_json_file(GutEditorGlobals.editor_run_json_results_path)


func _set_toolbutton_icon(btn, icon_name, text):
	if(Engine.is_editor_hint()):
		btn.icon = get_theme_icon(icon_name, 'EditorIcons')
	else:
		btn.text = str('[', text, ']')


func _update_min_width():
	custom_minimum_size.x = _ctrls.toolbar.toolbar.size.x


func _open_script_in_editor(path, line_number):
	if(_interface == null):
		print('Too soon, wait a bit and try again.')
		return

	var r = load(path)
	if(line_number != null and line_number != -1):
		_interface.edit_script(r, line_number)
	else:
		_interface.edit_script(r)

	if(_ctrls.toolbar.show_script.pressed):
		_interface.set_main_screen_editor('Script')


# starts at beginning of text edit and searches for each search term, moving
# through the text as it goes; ensuring that, when done, it found the first
# occurance of the last srting that happend after the first occurance of
# each string before it.  (Generic way of searching for a method name in an
# inner class that may have be a duplicate of a method name in a different
# inner class)
func _get_line_number_for_seq_search(search_strings, te):
	if(te == null):
		print("No Text editor to get line number for")
		return 0;

	var result = null
	var line = Vector2i(0, 0)
	var s_flags = 0

	var i = 0
	var string_found = true
	while(i < search_strings.size() and string_found):
		result = te.search(search_strings[i], s_flags, line.y, line.x)
		if(result.x != -1):
			line = result
		else:
			string_found = false
		i += 1

	return line.y


func _goto_code(path, line, method_name='', inner_class =''):
	if(_interface == null):
		print('going to ', [path, line, method_name, inner_class])
		return

	_open_script_in_editor(path, line)
	if(line == -1):
		var search_strings = []
		if(inner_class != ''):
			search_strings.append(inner_class)

		if(method_name != ''):
			search_strings.append(method_name)

		await get_tree().process_frame
		line = _get_line_number_for_seq_search(search_strings, _editors.get_current_text_edit())
		if(line != null and line != -1):
			_interface.get_script_editor().goto_line(line)


func _goto_output(path, method_name, inner_class):
	if(_output_control == null):
		return

	var search_strings = [path]

	if(inner_class != ''):
		search_strings.append(inner_class)

	if(method_name != ''):
		search_strings.append(method_name)

	var line = _get_line_number_for_seq_search(search_strings, _output_control.get_rich_text_edit())
	if(line != null and line != -1):
		_output_control.scroll_to_line(line)




# --------------
# Events
# --------------
func _on_Collapse_pressed():
	collapse_selected()


func _on_Expand_pressed():
	expand_selected()


func _on_CollapseAll_pressed():
	collapse_all()


func _on_ExpandAll_pressed():
	expand_all()


func _on_Hide_Passing_pressed():
	_ctrls.tree.hide_passing = !_ctrls.toolbar.hide_passing.button_pressed
	_ctrls.tree.load_json_file(GutEditorGlobals.editor_run_json_results_path)


func _on_item_selected(script_path, inner_class, test_name, line):
	if(_ctrls.toolbar.show_script.button_pressed):
		_goto_code(script_path, line, test_name, inner_class)
	if(_ctrls.toolbar.scroll_output.button_pressed):
		_goto_output(script_path, test_name, inner_class)




# --------------
# Public
# --------------
func add_centered_text(t):
	_ctrls.tree.add_centered_text(t)


func clear_centered_text():
	_ctrls.tree.clear_centered_text()


func clear():
	_ctrls.tree.clear()
	clear_centered_text()


func set_interface(which):
	_interface = which


func set_script_text_editors(value):
	_editors = value


func collapse_all():
	_ctrls.tree.collapse_all()


func expand_all():
	_ctrls.tree.expand_all()


func collapse_selected():
	var item = _ctrls.tree.get_selected()
	if(item != null):
		_ctrls.tree.set_collapsed_on_all(item, true)


func expand_selected():
	var item = _ctrls.tree.get_selected()
	if(item != null):
		_ctrls.tree.set_collapsed_on_all(item, false)


func set_show_orphans(should):
	_ctrls.tree.show_orphans = should


func set_font(font_name, size):
	pass
#	var dyn_font = FontFile.new()
#	var font_data = FontFile.new()
#	font_data.font_path = 'res://addons/gut/fonts/' + font_name + '-Regular.ttf'
#	font_data.antialiased = true
#	dyn_font.font_data = font_data
#
#	_font = dyn_font
#	_font.size = size
#	_font_size = size


func set_output_control(value):
	_output_control = value


func load_json_results(j):
	_ctrls.tree.load_json_results(j)

--- SCRIPT: res://addons/gut/gui/run_from_editor.gd ---
# ------------------------------------------------------------------------------
# This is the entry point when running tests from the editor.
#
# This script should conform to, or ignore, the strictest warning settings.
# ------------------------------------------------------------------------------
extends Node2D

var GutLoader : Object

func _init() -> void:
	GutLoader = load("res://addons/gut/gut_loader.gd")


@warning_ignore("unsafe_method_access")
func _ready() -> void:
	var runner : Node = load("res://addons/gut/gui/GutRunner.tscn").instantiate()
	add_child(runner)
	runner.run_from_editor()
	GutLoader.restore_ignore_addons()

--- SCRIPT: res://addons/gut/gui/script_text_editor_controls.gd ---
# Holds weakrefs to a ScriptTextEditor and related children nodes
# that might be useful.  Though the CodeEdit is really the only one, but
# since the tree may change, the first TextEdit under a CodeTextEditor is
# the one we use...so we hold a ref to the CodeTextEditor too.
class ScriptEditorControlRef:
	var _text_edit = null
	var _script_editor = null
	var _code_editor = null

	func _init(script_edit):
		_script_editor = weakref(script_edit)
		_populate_controls()
		# print("_script_editor = ", script_edit, ' vis = ', is_visible())


	func _populate_controls():
		# who knows if the tree will change so get the first instance of each
		# type of control we care about.  Chances are there won't be more than
		# one of these in the future, but their position in the tree may change.
		_code_editor = weakref(_get_first_child_named('CodeTextEditor', _script_editor.get_ref()))
		_text_edit = weakref(_get_first_child_named("CodeEdit", _code_editor.get_ref()))


	func _get_first_child_named(obj_name, parent_obj):
		if(parent_obj == null):
			return null

		var kids = parent_obj.get_children()
		var index = 0
		var to_return = null

		while(index < kids.size() and to_return == null):
			if(str(kids[index]).find(str("<", obj_name)) != -1):
				to_return = kids[index]
			else:
				to_return = _get_first_child_named(obj_name, kids[index])
				if(to_return == null):
					index += 1

		return to_return


	func get_script_text_edit():
		return _script_editor.get_ref()


	func get_text_edit():
		# ScriptTextEditors that are loaded when the project is opened
		# do not have their children populated yet.  So if we may have to
		# _populate_controls again if we don't have one.
		if(_text_edit == null):
			_populate_controls()
		return _text_edit.get_ref()


	func get_script_editor():
		return _script_editor


	func is_visible():
		var to_return = false
		if(_script_editor.get_ref()):
			to_return = _script_editor.get_ref().visible
		return to_return

# ##############################################################################
#
# ##############################################################################

# Used to make searching for the controls easier and faster.
var _script_editors_parent = null
# reference the ScriptEditor instance
var _script_editor = null
# Array of ScriptEditorControlRef containing all the opened ScriptTextEditors
# and related controls at the time of the last refresh.
var _script_editor_controls = []

var _method_prefix = 'test_'
var _inner_class_prefix = 'Test'

func _init(script_edit):
	_script_editor = script_edit
	refresh()


func _is_script_editor(obj):
	return str(obj).find('<ScriptTextEditor') != -1


# Find the first ScriptTextEditor and then get its parent.  Done this way
# because who knows if the parent object will change.  This is somewhat
# future proofed.
func _find_script_editors_parent():
	var _first_editor = _get_first_child_of_type_name("ScriptTextEditor", _script_editor)
	if(_first_editor != null):
		_script_editors_parent = _first_editor.get_parent()


func _populate_editors():
	if(_script_editors_parent == null):
		return

	_script_editor_controls.clear()
	for child in _script_editors_parent.get_children():
		if(_is_script_editor(child)):
			var ref = ScriptEditorControlRef.new(child)
			_script_editor_controls.append(ref)

# Yes, this is the same as the one above but with a different name.  This was
# easier than trying to find a place where it could be used by both.
func _get_first_child_of_type_name(obj_name, parent_obj):
	if(parent_obj == null):
		# print('aborting search for ', obj_name, ' parent is null')
		return null

	var kids = parent_obj.get_children()
	var index = 0
	var to_return = null

	var search_for = str("<", obj_name)
	# print('searching for ', search_for, ' in ', parent_obj, ' kids ', kids.size())
	while(index < kids.size() and to_return == null):
		var this_one = str(kids[index])
		# print(search_for, ' :: ', this_one)
		if(this_one.find(search_for) != -1):
			to_return = kids[index]
		else:
			to_return = _get_first_child_of_type_name(obj_name, kids[index])
			if(to_return == null):
				index += 1

	return to_return


func _get_func_name_from_line(text):
	text = text.strip_edges()
	var left = text.split("(")[0]
	var func_name = left.split(" ")[1]
	return func_name


func _get_class_name_from_line(text):
	text = text.strip_edges()
	var right = text.split(" ")[1]
	var the_name = right.rstrip(":")
	return the_name

func refresh():
	if(_script_editors_parent == null):
		_find_script_editors_parent()
		# print("script editors parent = ", _script_editors_parent)

	if(_script_editors_parent != null):
		_populate_editors()

	# print("script editor controls = ", _script_editor_controls)


func get_current_text_edit():
	var cur_script_editor = null
	var idx = 0

	while(idx < _script_editor_controls.size() and cur_script_editor == null):
		if(_script_editor_controls[idx].is_visible()):
			cur_script_editor = _script_editor_controls[idx]
		else:
			idx += 1

	var to_return = null
	if(cur_script_editor != null):
		to_return = cur_script_editor.get_text_edit()

	return to_return


func get_script_editor_controls():
	var to_return = []
	for ctrl_ref in _script_editor_controls:
		to_return.append(ctrl_ref.get_script_text_edit())

	return to_return


func get_line_info():
	var editor = get_current_text_edit()
	if(editor == null):
		return

	var info = {
		script = null,
		inner_class = null,
		test_method = null
	}

	var line = editor.get_caret_line()
	var done_func = false
	var done_inner = false
	while(line > 0 and (!done_func or !done_inner)):
		if(editor.can_fold_line(line)):
			var text = editor.get_line(line)
			var strip_text = text.strip_edges(true, false) # only left

			if(!done_func and strip_text.begins_with("func ")):
				var func_name = _get_func_name_from_line(text)
				if(func_name.begins_with(_method_prefix)):
					info.test_method = func_name
				done_func = true
				# If the func line is left justified then there won't be any
				# inner classes above it.
				if(strip_text == text):
					done_inner = true

			if(!done_inner and strip_text.begins_with("class")):
				var inner_name = _get_class_name_from_line(text)
				if(inner_name.begins_with(_inner_class_prefix)):
					info.inner_class = inner_name
					done_inner = true
					# if we found an inner class then we are already past
					# any test the cursor could be in.
					done_func = true
		line -= 1

	return info


func get_method_prefix():
	return _method_prefix


func set_method_prefix(method_prefix):
	_method_prefix = method_prefix


func get_inner_class_prefix():
	return _inner_class_prefix


func set_inner_class_prefix(inner_class_prefix):
	_inner_class_prefix = inner_class_prefix

--- SCRIPT: res://addons/gut/gui/ShortcutButton.gd ---
@tool
extends Control


@onready var _ctrls = {
	shortcut_label = $Layout/lblShortcut,
	set_button = $Layout/SetButton,
	save_button = $Layout/SaveButton,
	cancel_button = $Layout/CancelButton,
	clear_button = $Layout/ClearButton
}

signal changed
signal start_edit
signal end_edit

const NO_SHORTCUT = '<None>'

var _source_event = InputEventKey.new()
var _pre_edit_event = null
var _key_disp = NO_SHORTCUT
var _editing = false

var _modifier_keys = [KEY_ALT, KEY_CTRL, KEY_META, KEY_SHIFT]

# Called when the node enters the scene tree for the first time.
func _ready():
	set_process_unhandled_key_input(false)


func _display_shortcut():
	if(_key_disp == ''):
		_key_disp = NO_SHORTCUT
	_ctrls.shortcut_label.text = _key_disp


func _is_shift_only_modifier():
	return _source_event.shift_pressed and \
		!(_source_event.alt_pressed or \
			_source_event.ctrl_pressed or \
			_source_event.meta_pressed) \
		and !_is_modifier(_source_event.keycode)


func _has_modifier(event):
	return event.alt_pressed or event.ctrl_pressed or \
		event.meta_pressed or event.shift_pressed


func _is_modifier(keycode):
	return _modifier_keys.has(keycode)


func _edit_mode(should):
	_editing = should
	set_process_unhandled_key_input(should)
	_ctrls.set_button.visible = !should
	_ctrls.save_button.visible = should
	_ctrls.save_button.disabled = should
	_ctrls.cancel_button.visible = should
	_ctrls.clear_button.visible = !should

	if(should and to_s() == ''):
		_ctrls.shortcut_label.text = 'press buttons'
	else:
		_ctrls.shortcut_label.text = to_s()

	if(should):
		emit_signal("start_edit")
	else:
		emit_signal("end_edit")

# ---------------
# Events
# ---------------
func _unhandled_key_input(event):
	if(event is InputEventKey):
		if(event.pressed):
			if(_has_modifier(event) and !_is_modifier(event.get_keycode_with_modifiers())):
				_source_event = event
				_key_disp = OS.get_keycode_string(event.get_keycode_with_modifiers())
			else:
				_source_event = InputEventKey.new()
				_key_disp = NO_SHORTCUT
			_display_shortcut()
			_ctrls.save_button.disabled = !is_valid()


func _on_SetButton_pressed():
	_pre_edit_event = _source_event.duplicate(true)
	_edit_mode(true)


func _on_SaveButton_pressed():
	_edit_mode(false)
	_pre_edit_event = null
	emit_signal('changed')


func _on_CancelButton_pressed():
	cancel()


func _on_ClearButton_pressed():
	clear_shortcut()

# ---------------
# Public
# ---------------
func to_s():
	return OS.get_keycode_string(_source_event.get_keycode_with_modifiers())


func is_valid():
	return _has_modifier(_source_event) and !_is_shift_only_modifier()


func get_shortcut():
	var to_return = Shortcut.new()
	to_return.events.append(_source_event)
	return to_return


func set_shortcut(sc):
	if(sc == null or sc.events == null || sc.events.size() <= 0):
		clear_shortcut()
	else:
		_source_event = sc.events[0]
		_key_disp = to_s()
		_display_shortcut()


func clear_shortcut():
	_source_event = InputEventKey.new()
	_key_disp = NO_SHORTCUT
	_display_shortcut()


func disable_set(should):
	_ctrls.set_button.disabled = should


func disable_clear(should):
	_ctrls.clear_button.disabled = should
	
	
func cancel():
	if(_editing):
		_edit_mode(false)
		_source_event = _pre_edit_event
		_key_disp = to_s()
		_display_shortcut()

--- SCRIPT: res://addons/gut/gut.gd ---
extends 'res://addons/gut/gut_to_move.gd'
class_name GutMain
## The GUT brains.
##
## Most of this class is for internal use only.  Features that can be used are
## have descriptions and can be accessed through the [member GutTest.gut] variable
## in your test scripts (extends [GutTest]).
## The wiki page for this class contains only the usable features.
## [br][br]
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url]
## [br]
## @ignore-uncommented


# ---------------------------
# Constants
# ---------------------------
const LOG_LEVEL_FAIL_ONLY = 0
const LOG_LEVEL_TEST_AND_FAILURES = 1
const LOG_LEVEL_ALL_ASSERTS = 2
const WAITING_MESSAGE = '/# waiting #/'
const PAUSE_MESSAGE = '/# Pausing.  Press continue button...#/'
const COMPLETED = 'completed'

# ---------------------------
# Signals
# ---------------------------
signal start_pause_before_teardown
signal end_pause_before_teardown

signal start_run
signal end_run
signal start_script(test_script_obj)
signal end_script
signal start_test(test_name)
signal end_test


# ---------------------------
# Settings
#
# These are properties that are usually set before a run is started through
# gutconfig.
# ---------------------------

var _inner_class_name = ''
# When set, GUT will only run Inner-Test-Classes that contain this string.
var inner_class_name = _inner_class_name :
	get: return _inner_class_name
	set(val): _inner_class_name = val

var _ignore_pause_before_teardown = false
# For batch processing purposes, you may want to ignore any calls to
# pause_before_teardown that you forgot to remove_at.
var ignore_pause_before_teardown = _ignore_pause_before_teardown :
	get: return _ignore_pause_before_teardown
	set(val): _ignore_pause_before_teardown = val

var _log_level = 1
## The log detail level.  Valid values are 0 - 2.  Larger values do not matter.
var log_level = _log_level:
	get: return _log_level
	set(val): _set_log_level(val)

# TODO 4.0
# This appears to not be used anymore.  Going to wait for more tests to be
# ported before removing.
var _disable_strict_datatype_checks = false
var disable_strict_datatype_checks = false :
	get: return _disable_strict_datatype_checks
	set(val): _disable_strict_datatype_checks = val

var _export_path = ''
# Path to file that GUT will create which holds a list of all test scripts so
# that GUT can run tests when a project is exported.
var export_path = '' :
	get: return _export_path
	set(val): _export_path = val

var _include_subdirectories = false
# Setting this to true will make GUT search all subdirectories of any directory
# you have configured GUT to search for tests in.
var include_subdirectories = _include_subdirectories :
	get: return _include_subdirectories
	set(val): _include_subdirectories = val


var _double_strategy = GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY
# TODO rework what this is and then document it here.
var double_strategy = _double_strategy  :
	get: return _double_strategy
	set(val):
		if(GutUtils.DOUBLE_STRATEGY.values().has(val)):
			_double_strategy = val
			_doubler.set_strategy(double_strategy)
		else:
			_lgr.error(str("gut.gd:  invalid double_strategy ", val))

var _pre_run_script = ''
# Path to the script that will be run before all tests are run.  This script
# must extend GutHookScript
var pre_run_script = _pre_run_script :
	get: return _pre_run_script
	set(val): _pre_run_script = val

var _post_run_script = ''
# Path to the script that will run after all tests have run.  The script
# must extend GutHookScript
var post_run_script = _post_run_script :
	get: return _post_run_script
	set(val): _post_run_script = val

var _color_output = false
# Flag to color output at the command line and in the GUT GUI.
var color_output = false :
	get: return _color_output
	set(val):
		_color_output = val
		_lgr.disable_formatting(!_color_output)

var _junit_xml_file = ''
# The full path to where GUT should write a JUnit compliant XML file to which
# contains the results of all tests run.
var junit_xml_file = '' :
	get: return _junit_xml_file
	set(val): _junit_xml_file = val

var _junit_xml_timestamp = false
# When true and junit_xml_file is set, the file name will include a
# timestamp so that previous files are not overwritten.
var junit_xml_timestamp = false :
	get: return _junit_xml_timestamp
	set(val): _junit_xml_timestamp = val

# The minimum amout of time GUT will wait before pausing for 1 frame to allow
# the screen to paint.  GUT checkes after each test to see if enough time has
# passed.
var paint_after = .1:
	get: return paint_after
	set(val): paint_after = val

var _unit_test_name = ''
# When set GUT will only run tests that contain this string.
var unit_test_name = _unit_test_name :
	get: return _unit_test_name
	set(val): _unit_test_name = val

var _parameter_handler = null
# This is populated by test.gd each time a paramterized test is encountered
# for the first time.
# FOR INTERNAL USE ONLY
var parameter_handler = _parameter_handler :
	get: return _parameter_handler
	set(val):
		_parameter_handler = val
		_parameter_handler.set_logger(_lgr)

var _lgr = GutUtils.get_logger()
# Local reference for the common logger.
var logger = _lgr :
	get: return _lgr
	set(val):
		_lgr = val
		_lgr.set_gut(self)

var _add_children_to = self
# Sets the object that GUT will add test objects to as it creates them.  The
# default is self, but can be set to other objects so that GUT is not obscured
# by the objects added during tests.
var add_children_to = self :
	get: return _add_children_to
	set(val): _add_children_to = val


var _treat_error_as_failure = true
var treat_error_as_failure = _treat_error_as_failure:
	get: return _treat_error_as_failure
	set(val): _treat_error_as_failure = val

# ------------
# Read only
# ------------
var _test_collector = GutUtils.TestCollector.new()
func get_test_collector():
	return _test_collector

# var version = null :
func get_version():
	return GutUtils.version_numbers.gut_version

var _orphan_counter =  GutUtils.OrphanCounter.new()
func get_orphan_counter():
	return _orphan_counter

var _autofree = GutUtils.AutoFree.new()
func get_autofree():
	return _autofree

var _stubber = GutUtils.Stubber.new()
func get_stubber():
	return _stubber

var _doubler = GutUtils.Doubler.new()
func get_doubler():
	return _doubler

var _spy = GutUtils.Spy.new()
func get_spy():
	return _spy

var _is_running = false
func is_running():
	return _is_running


# ---------------------------
# Private
# ---------------------------
var  _should_print_versions = true # used to cut down on output in tests.
var _should_print_summary = true

var _file_prefix = 'test_'
var _inner_class_prefix = 'Test'

var _select_script = ''
var _last_paint_time = 0.0
var _strutils = GutUtils.Strutils.new()

# The instance that is created from _pre_run_script.  Accessible from
# get_pre_run_script_instance.  These are created at the start of the run
# and then referenced at the appropriate time.  This allows us to validate the
# scripts prior to running.
var _pre_run_script_instance = null
var _post_run_script_instance = null

var _script_name = null

# The instanced scripts.  This is populated as the scripts are run.
var _test_script_objects = []

var _waiting = false

# msecs ticks when run was started
var _start_time = 0.0

# Collected Test instance for the current test being run.
var _current_test = null
var _pause_before_teardown = false


# Used to cancel importing scripts if an error has occurred in the setup.  This
# prevents tests from being run if they were exported and ensures that the
# error displayed is seen since importing generates a lot of text.
#
# TODO this appears to only be checked and never set anywhere.  Verify that this
# was not broken somewhere and remove if no longer used.
var _cancel_import = false

# this is how long Gut will wait when there are items that must be queued free
# when a test completes (due to calls to add_child_autoqfree)
var _auto_queue_free_delay = .1

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _init():
	# When running tests for GUT itself, GutUtils has been setup to always return
	# a new logger so this does not set the gut instance on the base logger
	# when creating test instances of GUT.
	_lgr.set_gut(self) # HEY!  What about tests?  ^^^^^^^^^

	_doubler.set_stubber(_stubber)
	_doubler.set_spy(_spy)
	_doubler.set_gut(self)

	update_loggers()

# Public for tests that set the logger.  This makes it much easier to propigate
# test loggers.
func update_loggers():
	_doubler.set_logger(_lgr)
	_spy.set_logger(_lgr)
	_stubber.set_logger(_lgr)
	_test_collector.set_logger(_lgr)


# ------------------------------------------------------------------------------
# Initialize controls
# ------------------------------------------------------------------------------
func _ready():
	if(_should_print_versions):
		_lgr.log('---  GUT  ---')
		_lgr.info(str('using [', OS.get_user_data_dir(), '] for temporary output.'))

	if(_select_script != null):
		select_script(_select_script)

	_print_versions()

# ------------------------------------------------------------------------------
# Runs right before free is called.  Can't override `free`.
# ------------------------------------------------------------------------------
func _notification(what):
	if(what == NOTIFICATION_PREDELETE):
		for ts in _test_script_objects:
			if(is_instance_valid(ts)):
				ts.free()

		_test_script_objects = []


func _print_versions(send_all = true):
	if(!_should_print_versions):
		return

	var info = GutUtils.version_numbers.get_version_text()

	if(send_all):
		p(info)
	else:
		_lgr.get_printer('gui').send(info + "\n")




# ---------------------------
#
# Accessor code
#
# ---------------------------


# ------------------------------------------------------------------------------
# Set the log level.  Use one of the various LOG_LEVEL_* constants.
# ------------------------------------------------------------------------------
func _set_log_level(level):
	_log_level = max(level, 0)

	# Level 0 settings
	_lgr.set_less_test_names(level == 0)
	# Explicitly always enabled
	_lgr.set_type_enabled(_lgr.types.normal, true)
	_lgr.set_type_enabled(_lgr.types.error, true)
	_lgr.set_type_enabled(_lgr.types.pending, true)

	# Level 1 types
	_lgr.set_type_enabled(_lgr.types.warn, level > 0)
	_lgr.set_type_enabled(_lgr.types.deprecated, level > 0)

	# Level 2 types
	_lgr.set_type_enabled(_lgr.types.passed, level > 1)
	_lgr.set_type_enabled(_lgr.types.info, level > 1)
	_lgr.set_type_enabled(_lgr.types.debug, level > 1)

# ---------------------------
#
# Events
#
# ---------------------------
func end_teardown_pause():
	_pause_before_teardown = false
	_waiting = false
	end_pause_before_teardown.emit()

# ---------------------------
#
# Private
#
# ---------------------------
func _log_test_children_warning(test_script):
	if(!_lgr.is_type_enabled(_lgr.types.orphan)):
		return

	var kids = test_script.get_children()
	if(kids.size() > 1):
		var msg = ''
		if(_log_level == 2):
			msg = "Test script still has children when all tests finisehd.\n"
			for i in range(kids.size()):
				msg += str("  ", _strutils.type2str(kids[i]), "\n")
			msg += "You can use autofree, autoqfree, add_child_autofree, or add_child_autoqfree to automatically free objects."
		else:
			msg = str("Test script has ", kids.size(), " unfreed children.  Increase log level for more details.")

		_lgr.warn(msg)


func _log_end_run():
	if(_should_print_summary):
		var summary = GutUtils.Summary.new(self)
		summary.log_end_run()


func _validate_hook_script(path):
	var result = {
		valid = true,
		instance = null
	}

	# empty path is valid but will have a null instance
	if(path == ''):
		return result

	if(FileAccess.file_exists(path)):
		var inst = load(path).new()
		if(inst and inst is GutHookScript):
			result.instance = inst
			result.valid = true
		else:
			result.valid = false
			_lgr.error('The hook script [' + path + '] does not extend GutHookScript')
	else:
		result.valid = false
		_lgr.error('The hook script [' + path + '] does not exist.')

	return result


# ------------------------------------------------------------------------------
# Runs a hook script.  Script must exist, and must extend
# GutHookScript or addons/gut/hook_script.gd
# ------------------------------------------------------------------------------
func _run_hook_script(inst):
	if(inst != null):
		inst.gut = self
		await inst.run()
	return inst

# ------------------------------------------------------------------------------
# Initialize variables for each run of a single test script.
# ------------------------------------------------------------------------------
func _init_run():
	var valid = true
	_test_collector.set_test_class_prefix(_inner_class_prefix)
	_test_script_objects = []
	_current_test = null
	_is_running = true

	var pre_hook_result = _validate_hook_script(_pre_run_script)
	_pre_run_script_instance = pre_hook_result.instance
	var post_hook_result = _validate_hook_script(_post_run_script)
	_post_run_script_instance  = post_hook_result.instance

	valid = pre_hook_result.valid and  post_hook_result.valid

	return valid


# ------------------------------------------------------------------------------
# Print out run information and close out the run.
# ------------------------------------------------------------------------------
func _end_run():
	_log_end_run()
	_is_running = false

	await _run_hook_script(get_post_run_script_instance())
	_export_results()
	end_run.emit()


# ------------------------------------------------------------------------------
# Add additional export types here.
# ------------------------------------------------------------------------------
func _export_results():
	if(_junit_xml_file != ''):
		_export_junit_xml()

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _export_junit_xml():
	var exporter = GutUtils.JunitXmlExport.new()
	var output_file = _junit_xml_file

	if(_junit_xml_timestamp):
		var ext = "." + output_file.get_extension()
		output_file = output_file.replace(ext, str("_", Time.get_unix_time_from_system(), ext))

	var f_result = exporter.write_file(self, output_file)
	if(f_result == OK):
		p(str("Results saved to ", output_file))


# ------------------------------------------------------------------------------
# Print out the heading for a new script
# ------------------------------------------------------------------------------
func _print_script_heading(coll_script):
	if(_does_class_name_match(_inner_class_name, coll_script.inner_class_name)):
		_lgr.log(str("\n\n", coll_script.get_full_name()), _lgr.fmts.underline)


# ------------------------------------------------------------------------------
# Yes if the class name is null or the script's class name includes class_name
# ------------------------------------------------------------------------------
func _does_class_name_match(the_class_name, script_class_name):
	return (the_class_name == null or the_class_name == '') or \
		(script_class_name != null and str(script_class_name).findn(the_class_name) != -1)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _setup_script(test_script, collected_script):
	test_script.gut = self
	test_script.set_logger(_lgr)
	_add_children_to.add_child(test_script)
	_test_script_objects.append(test_script)

	if(!test_script._was_ready_called):
		test_script._do_ready_stuff()
		_lgr.warn(str("!!! YOU HAVE UPSET YOUR GUT !!!\n",
			"You have overridden _ready in [", collected_script.get_filename_and_inner(), "] ",
			"but it does not call super._ready().  New additions (or maybe old ",
			"by the time you see this) require that super._ready() is called.",
			"\n\n",
			"GUT is working around this infraction, but may not be able to in ",
			"the future.  GUT also reserves the right to decide it does not want ",
			"to work around it in the future.  ",
			"You should probably use before_all instead of _ready.  I can think ",
			"of a few reasons why you would want to use _ready but I won't list ",
			"them here because I think they are bad ideas.  I know they are bad ",
			"ideas because I did them.  Hence the warning.  This message is ",
			"intentially long so that it bothers you and you change your ways.\n\n",
			"Thank you for using GUT."))


# ------------------------------------------------------------------------------
# returns self so it can be integrated into the yield call.
# ------------------------------------------------------------------------------
func _wait_for_continue_button():
	p(PAUSE_MESSAGE, 0)
	_waiting = true
	return self


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _get_indexes_matching_script_name(script_name):
	var indexes = [] # empty runs all
	for i in range(_test_collector.scripts.size()):
		if(_test_collector.scripts[i].get_filename().find(script_name) != -1):
			indexes.append(i)
	return indexes


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _get_indexes_matching_path(path):
	var indexes = []
	for i in range(_test_collector.scripts.size()):
		if(_test_collector.scripts[i].path == path):
			indexes.append(i)
	return indexes


# ------------------------------------------------------------------------------
# Execute all calls of a parameterized test.
# ------------------------------------------------------------------------------
func _run_parameterized_test(test_script, test_name):
	await _run_test(test_script, test_name)

	if(_current_test.assert_count == 0 and !_current_test.pending):
		_lgr.risky('Test did not assert')

	if(_parameter_handler == null):
		_lgr.error(str('Parameterized test ', _current_test.name, ' did not call use_parameters for the default value of the parameter.'))
		_fail(str('Parameterized test ', _current_test.name, ' did not call use_parameters for the default value of the parameter.'))
	else:
		while(!_parameter_handler.is_done()):
			var cur_assert_count = _current_test.assert_count
			await _run_test(test_script, test_name)
			if(_current_test.assert_count == cur_assert_count and !_current_test.pending):
				_lgr.risky('Test did not assert')

	_parameter_handler = null


# ------------------------------------------------------------------------------
# Runs a single test given a test.gd instance and the name of the test to run.
# ------------------------------------------------------------------------------
func _run_test(script_inst, test_name):
	_lgr.log_test_name()
	_lgr.set_indent_level(1)
	_orphan_counter.add_counter('test')

	await script_inst.before_each()

	start_test.emit(test_name)

	await script_inst.call(test_name)

	# if the test called pause_before_teardown then await until
	# the continue button is pressed.
	if(_pause_before_teardown and !_ignore_pause_before_teardown):
		start_pause_before_teardown.emit()
		await _wait_for_continue_button().end_pause_before_teardown

	script_inst.clear_signal_watcher()

	# call each post-each-test method until teardown is removed.
	await script_inst.after_each()

	# Free up everything in the _autofree.  Yield for a bit if we
	# have anything with a queue_free so that they have time to
	# free and are not found by the orphan counter.
	var aqf_count = _autofree.get_queue_free_count()
	_autofree.free_all()
	if(aqf_count > 0):
		await get_tree().create_timer(_auto_queue_free_delay).timeout

	if(_log_level > 0):
		_orphan_counter.print_orphans('test', _lgr)

	_doubler.get_ignored_methods().clear()


# ------------------------------------------------------------------------------
# Calls after_all on the passed in test script and takes care of settings so all
# logger output appears indented and with a proper heading
#
# Calls both pre-all-tests methods until prerun_setup is removed
# ------------------------------------------------------------------------------
func _call_before_all(test_script, collected_script):
	var before_all_test_obj = GutUtils.CollectedTest.new()
	before_all_test_obj.has_printed_name = false
	before_all_test_obj.name = 'before_all'

	collected_script.setup_teardown_tests.append(before_all_test_obj)
	_current_test = before_all_test_obj

	_lgr.inc_indent()
	await test_script.before_all()
	# before all does not need to assert anything so only mark it as run if
	# some assert was done.
	before_all_test_obj.was_run = before_all_test_obj.did_something()

	_lgr.dec_indent()

	_current_test = null


# ------------------------------------------------------------------------------
# Calls after_all on the passed in test script and takes care of settings so all
# logger output appears indented and with a proper heading
#
# Calls both post-all-tests methods until postrun_teardown is removed.
# ------------------------------------------------------------------------------
func _call_after_all(test_script, collected_script):
	var after_all_test_obj = GutUtils.CollectedTest.new()
	after_all_test_obj.has_printed_name = false
	after_all_test_obj.name = 'after_all'

	collected_script.setup_teardown_tests.append(after_all_test_obj)
	_current_test = after_all_test_obj

	_lgr.inc_indent()
	await test_script.after_all()
	# after all does not need to assert anything so only mark it as run if
	# some assert was done.
	after_all_test_obj.was_run = after_all_test_obj.did_something()
	_lgr.dec_indent()

	_current_test = null


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _should_skip_script(test_script, collected_script):
	var skip_message = 'not skipped'
	var skip_value = test_script.get('skip_script')
	var should_skip = false

	if(skip_value == null):
		skip_value = await test_script.should_skip_script()
	else:
		_lgr.deprecated('Using the skip_script var has been deprecated.  Implement the new should_skip_script() method in your test instead.')

	if(skip_value != null):
		if(typeof(skip_value) == TYPE_BOOL):
			should_skip = skip_value
			if(skip_value):
				skip_message = 'script marked to skip'
		elif(typeof(skip_value) == TYPE_STRING):
			should_skip = true
			skip_message = skip_value

	if(should_skip):
		var msg = str('- [Script skipped]:  ', skip_message)
		_lgr.inc_indent()
		_lgr.log(msg, _lgr.fmts.yellow)
		_lgr.dec_indent()
		collected_script.skip_reason = skip_message
		collected_script.was_skipped = true

	return should_skip

# ------------------------------------------------------------------------------
# Run all tests in a script.  This is the core logic for running tests.
# ------------------------------------------------------------------------------
func _test_the_scripts(indexes=[]):
	_orphan_counter.add_counter('pre_run')

	_print_versions(false)
	var is_valid = _init_run()
	if(!is_valid):
		_lgr.error('Something went wrong and the run was aborted.')
		return

	await _run_hook_script(get_pre_run_script_instance())
	if(_pre_run_script_instance!= null and _pre_run_script_instance.should_abort()):
		_lgr.error('pre-run abort')
		end_run.emit()
		return

	start_run.emit()
	_start_time = Time.get_ticks_msec()
	_last_paint_time = _start_time

	var indexes_to_run = []
	if(indexes.size()==0):
		for i in range(_test_collector.scripts.size()):
			indexes_to_run.append(i)
	else:
		indexes_to_run = indexes


	# loop through scripts
	for test_indexes in range(indexes_to_run.size()):
		var coll_script = _test_collector.scripts[indexes_to_run[test_indexes]]
		_orphan_counter.add_counter('script')

		if(coll_script.tests.size() > 0):
			_lgr.set_indent_level(0)
			_print_script_heading(coll_script)

		if(!coll_script.is_loaded):
			break

		start_script.emit(coll_script)

		var test_script = coll_script.get_new()

		_setup_script(test_script, coll_script)
		_doubler.set_strategy(_double_strategy)

		# ----
		# SHORTCIRCUIT
		# skip_script logic
		if(await _should_skip_script(test_script, coll_script)):
			continue
		# ----

		# !!!
		# Hack so there isn't another indent to this monster of a method.  if
		# inner class is set and we do not have a match then empty the tests
		# for the current test.
		# !!!
		if(!_does_class_name_match(_inner_class_name, coll_script.inner_class_name)):
			coll_script.tests = []
		else:
			coll_script.was_run = true
			await _call_before_all(test_script, coll_script)

		# Each test in the script
		for i in range(coll_script.tests.size()):
			_stubber.clear()
			_spy.clear()
			_current_test = coll_script.tests[i]

			if((_unit_test_name != '' and _current_test.name.find(_unit_test_name) > -1) or
				(_unit_test_name == '')):

				var ticks_before := Time.get_ticks_usec()

				if(_current_test.arg_count > 1):
					_lgr.error(str('Parameterized test ', _current_test.name,
						' has too many parameters:  ', _current_test.arg_count, '.'))
				elif(_current_test.arg_count == 1):
					_current_test.was_run = true
					await _run_parameterized_test(test_script, _current_test.name)
				else:
					_current_test.was_run = true
					await _run_test(test_script, _current_test.name)

				if(!_current_test.did_something()):
					_lgr.risky(str(_current_test.name, ' did not assert'))

				_current_test.has_printed_name = false

				_current_test.time_taken = (Time.get_ticks_usec() - ticks_before) / 1000000.0

				end_test.emit()

				# After each test, check to see if we shoudl wait a frame to
				# paint based on how much time has elapsed since we last 'painted'
				if(paint_after > 0.0):
					var now = Time.get_ticks_msec()
					var time_since = (now - _last_paint_time) / 1000.0
					if(time_since > paint_after):
						_last_paint_time = now
						await get_tree().process_frame

		_current_test = null
		_lgr.dec_indent()
		_orphan_counter.print_orphans('script', _lgr)

		if(_does_class_name_match(_inner_class_name, coll_script.inner_class_name)):
			await _call_after_all(test_script, coll_script)

		_log_test_children_warning(test_script)
		# This might end up being very resource intensive if the scripts
		# don't clean up after themselves.  Might have to consolidate output
		# into some other structure and kill the script objects with
		# test_script.free() instead of remove_at child.
		_add_children_to.remove_child(test_script)

		_lgr.set_indent_level(0)
		if(test_script.get_assert_count() > 0):
			var script_sum = str(coll_script.get_passing_test_count(), '/', coll_script.get_ran_test_count(), ' passed.')
			_lgr.log(script_sum, _lgr.fmts.bold)

		end_script.emit()
		# END TEST SCRIPT LOOP

	_lgr.set_indent_level(0)
	# Give anything that is queued to be freed time to be freed before we count
	# the orphans.  Without this, the last test's awaiter won't be freed
	# yet, which messes with the orphans total.  There could also be objects
	# the user has queued to be freed as well.
	await get_tree().create_timer(.1).timeout
	_end_run()


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _pass(text=''):
	if(_current_test):
		_current_test.add_pass(text)


# ------------------------------------------------------------------------------
# Returns an empty string or "(call #x) " if the current test being run has
# parameters.  The
# ------------------------------------------------------------------------------
func get_call_count_text():
	var to_return = ''
	if(_parameter_handler != null):
		# This uses get_call_count -1 because test.gd's use_parameters method
		# should have been called before we get to any calls for this method
		# just due to how use_parameters works.  There isn't a way to know
		# whether we are before or after that call.
		to_return = str('params[', _parameter_handler.get_call_count() -1, '] ')
	return to_return


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _fail(text=''):
	if(_current_test != null):
		var line_number = _extract_line_number(_current_test)
		var line_text = '  at line ' + str(line_number)
		p(line_text, LOG_LEVEL_FAIL_ONLY)
		# format for summary
		line_text =  "\n    " + line_text
		var call_count_text = get_call_count_text()
		_current_test.line_number = line_number
		_current_test.add_fail(call_count_text + text + line_text)


# ------------------------------------------------------------------------------
# This is "private" but is only used by the logger, it is not used internally.
# It was either, make this weird method or "do it the right way" with signals
# or some other crazy mechanism.
# ------------------------------------------------------------------------------
func _fail_for_error(err_text):
	if(_current_test != null and treat_error_as_failure):
		_fail(err_text)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _pending(text=''):
	if(_current_test):
		_current_test.add_pending(text)


# ------------------------------------------------------------------------------
# Extracts the line number from curren stacktrace by matching the test case name
# ------------------------------------------------------------------------------
func _extract_line_number(current_test):
	var line_number = -1
	# if stack trace available than extraxt the test case line number
	var stackTrace = get_stack()
	if(stackTrace!=null):
		for index in stackTrace.size():
			var line = stackTrace[index]
			var function = line.get("function")
			if function == current_test.name:
				line_number = line.get("line")
	return line_number


# ------------------------------------------------------------------------------
# Gets all the files in a directory and all subdirectories if include_subdirectories
# is true.  The files returned are all sorted by name.
# ------------------------------------------------------------------------------
func _get_files(path, prefix, suffix):
	var files = []
	var directories = []
	# ignore addons/gut per issue 294
	if(path == 'res://addons/gut'):
		return [];

	var d = DirAccess.open(path)
	d.include_hidden = false
	d.include_navigational = false

	# Traversing a directory is kinda odd.  You have to start the process of
	# listing the contents of a directory with list_dir_begin then use get_next
	# until it returns an empty string.  Then I guess you should end it.
	d.list_dir_begin()
	var fs_item = d.get_next()
	var full_path = ''
	while(fs_item != ''):
		full_path = path.path_join(fs_item)

		# MUST use FileAccess since d.file_exists returns false for exported
		# projects
		if(FileAccess.file_exists(full_path)):
			if(fs_item.begins_with(prefix) and fs_item.ends_with(suffix)):
				files.append(full_path)
		# MUST use DirAccess, d.dir_exists is false for exported projects.
		elif(include_subdirectories and DirAccess.dir_exists_absolute(full_path)):
			directories.append(full_path)

		fs_item = d.get_next()
	d.list_dir_end()

	for dir in range(directories.size()):
		var dir_files = _get_files(directories[dir], prefix, suffix)
		for i in range(dir_files.size()):
			files.append(dir_files[i])

	files.sort()
	return files


# ---------------------------
#
# public
#
# ---------------------------

func get_elapsed_time() -> float:
	var to_return = 0.0
	if(_start_time != 0.0):
		to_return = Time.get_ticks_msec() - _start_time
	to_return = to_return / 1000.0

	return to_return

# ------------------------------------------------------------------------------
# Conditionally prints the text to the console/results variable based on the
# current log level and what level is passed in.  Whenever currently in a test,
# the text will be indented under the test.  It can be further indented if
# desired.
#
# The first time output is generated when in a test, the test name will be
# printed.
# ------------------------------------------------------------------------------
func p(text, level=0):
	var str_text = str(text)

	if(level <= GutUtils.nvl(_log_level, 0)):
		_lgr.log(str_text)

# ---------------------------
#
# RUN TESTS/ADD SCRIPTS
#
# ---------------------------

# ------------------------------------------------------------------------------
# Runs all the scripts that were added using add_script
# ------------------------------------------------------------------------------
func test_scripts(_run_rest=false):
	if(_script_name != null and _script_name != ''):
		var indexes = _get_indexes_matching_script_name(_script_name)
		if(indexes == []):
			_lgr.error(str(
				"Could not find script matching '", _script_name, "'.\n",
				"Check your directory settings and Script Prefix/Suffix settings."))
			end_run.emit()
		else:
			_test_the_scripts(indexes)
	else:
		_test_the_scripts([])

# alias
func run_tests(run_rest=false):
	test_scripts(run_rest)


# ------------------------------------------------------------------------------
# Runs a single script passed in.
# ------------------------------------------------------------------------------
# func run_test_script(script):
# 	_test_collector.set_test_class_prefix(_inner_class_prefix)
# 	_test_collector.clear()
# 	_test_collector.add_script(script)
# 	_test_the_scripts()


# ------------------------------------------------------------------------------
# Adds a script to be run when test_scripts called.
# ------------------------------------------------------------------------------
func add_script(script):
	if(!Engine.is_editor_hint()):
		_test_collector.set_test_class_prefix(_inner_class_prefix)
		_test_collector.add_script(script)


# ------------------------------------------------------------------------------
# Add all scripts in the specified directory that start with the prefix and end
# with the suffix.  Does not look in sub directories.  Can be called multiple
# times.
# ------------------------------------------------------------------------------
func add_directory(path, prefix=_file_prefix, suffix=".gd"):
	# check for '' b/c the calls to addin the exported directories 1-6 will pass
	# '' if the field has not been populated.  This will cause res:// to be
	# processed which will include all files if include_subdirectories is true.
	if(path == '' or path == null):
		return

	var dir = DirAccess.open(path)
	if(dir == null):
		_lgr.error(str('The path [', path, '] does not exist.'))
	else:
		var files = _get_files(path, prefix, suffix)
		for i in range(files.size()):
			if(_script_name == null or _script_name == '' or \
					(_script_name != null and files[i].findn(_script_name) != -1)):
				add_script(files[i])


# ------------------------------------------------------------------------------
# This will try to find a script in the list of scripts to test that contains
# the specified script name.  It does not have to be a full match.  It will
# select the first matching occurrence so that this script will run when run_tests
# is called.  Works the same as the select_this_one option of add_script.
#
# returns whether it found a match or not
# ------------------------------------------------------------------------------
func select_script(script_name):
	_script_name = script_name
	_select_script = script_name


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func export_tests(path=_export_path):
	if(path == null):
		_lgr.error('You must pass a path or set the export_path before calling export_tests')
	else:
		var result = _test_collector.export_tests(path)
		if(result):
			_lgr.info(_test_collector.to_s())
			_lgr.info("Exported to " + path)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func import_tests(path=_export_path):
	if(!FileAccess.file_exists(path)):
		_lgr.error(str('Cannot import tests:  the path [', path, '] does not exist.'))
	else:
		_test_collector.clear()
		var result = _test_collector.import_tests(path)
		if(result):
			_lgr.info("\n" + _test_collector.to_s())
			_lgr.info("Imported from " + path)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func import_tests_if_none_found():
	if(!_cancel_import and _test_collector.scripts.size() == 0):
		import_tests()


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func export_if_tests_found():
	if(_test_collector.scripts.size() > 0):
		export_tests()

# ---------------------------
#
# MISC
#
# ---------------------------


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func maximize():
	_lgr.deprecated('gut.maximize')


# ------------------------------------------------------------------------------
# Clears the text of the text box.  This resets all counters.
# ------------------------------------------------------------------------------
func clear_text():
	_lgr.deprecated('gut.clear_text')


# ------------------------------------------------------------------------------
# Get the number of tests that were ran
# ------------------------------------------------------------------------------
func get_test_count():
	return _test_collector.get_ran_test_count()

# ------------------------------------------------------------------------------
## Get the number of assertions that were made
func get_assert_count():
	return _test_collector.get_assert_count()

# ------------------------------------------------------------------------------
## Get the number of assertions that passed
func get_pass_count():
	return _test_collector.get_pass_count()

# ------------------------------------------------------------------------------
## Get the number of assertions that failed
func get_fail_count():
	return _test_collector.get_fail_count()

# ------------------------------------------------------------------------------
## Get the number of tests flagged as pending
func get_pending_count():
	return _test_collector.get_pending_count()


# ------------------------------------------------------------------------------
# Call this method to make the test pause before teardown so that you can inspect
# anything that you have rendered to the screen.
# ------------------------------------------------------------------------------
func pause_before_teardown():
	_pause_before_teardown = true;


# ------------------------------------------------------------------------------
# Returns the script object instance that is currently being run.
# ------------------------------------------------------------------------------
func get_current_script_object():
	var to_return = null
	if(_test_script_objects.size() > 0):
		to_return = _test_script_objects[-1]
	return to_return


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_current_test_object():
	return _current_test


## Returns a summary.gd object that contains all the information about
## the run results.
func get_summary():
	return GutUtils.Summary.new(self)

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_pre_run_script_instance():
	return _pre_run_script_instance

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_post_run_script_instance():
	return _post_run_script_instance

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func show_orphans(should):
	_lgr.set_type_enabled(_lgr.types.orphan, should)


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_logger():
	return _lgr


# ------------------------------------------------------------------------------
## Returns the number of test scripts.  Inner Test classes each count as a
## script.
func get_test_script_count():
	return _test_script_objects.size()




# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/GutScene.gd ---
extends Node2D
# ##############################################################################
# This is a wrapper around the normal and compact gui controls and serves as
# the interface between gut.gd and the gui.  The GutRunner creates an instance
# of this and then this takes care of managing the different GUI controls.
# ##############################################################################
@onready var _normal_gui = $Normal
@onready var _compact_gui = $Compact

var gut = null :
	set(val):
		gut = val
		_set_gut(val)


func _ready():
	_normal_gui.switch_modes.connect(use_compact_mode.bind(true))
	_compact_gui.switch_modes.connect(use_compact_mode.bind(false))

	_normal_gui.set_title("GUT")
	_compact_gui.set_title("GUT")

	_normal_gui.align_right()
	_compact_gui.to_bottom_right()

	use_compact_mode(false)

	if(get_parent() == get_tree().root):
		_test_running_setup()

func _test_running_setup():
	set_font_size(100)
	_normal_gui.get_textbox().text = "hello world, how are you doing?"

# ------------------------
# Private
# ------------------------
func _set_gut(val):
	if(_normal_gui.get_gut() == val):
		return
	_normal_gui.set_gut(val)
	_compact_gui.set_gut(val)

	val.start_run.connect(_on_gut_start_run)
	val.end_run.connect(_on_gut_end_run)
	val.start_pause_before_teardown.connect(_on_gut_pause)
	val.end_pause_before_teardown.connect(_on_pause_end)

func _set_both_titles(text):
	_normal_gui.set_title(text)
	_compact_gui.set_title(text)


# ------------------------
# Events
# ------------------------
func _on_gut_start_run():
	_set_both_titles('Running')

func _on_gut_end_run():
	_set_both_titles('Finished')

func _on_gut_pause():
	_set_both_titles('-- Paused --')

func _on_pause_end():
	_set_both_titles('Running')


# ------------------------
# Public
# ------------------------
func get_textbox():
	return _normal_gui.get_textbox()


func set_font_size(new_size):
	var rtl = _normal_gui.get_textbox()

	rtl.set('theme_override_font_sizes/bold_italics_font_size', new_size)
	rtl.set('theme_override_font_sizes/bold_font_size', new_size)
	rtl.set('theme_override_font_sizes/italics_font_size', new_size)
	rtl.set('theme_override_font_sizes/normal_font_size', new_size)


func set_font(font_name):
	_set_all_fonts_in_rtl(_normal_gui.get_textbox(), font_name)


func _set_font(rtl, font_name, custom_name):
	if(font_name == null):
		rtl.remove_theme_font_override(custom_name)
	else:
		var dyn_font = FontFile.new()
		dyn_font.load_dynamic_font('res://addons/gut/fonts/' + font_name + '.ttf')
		rtl.add_theme_font_override(custom_name, dyn_font)


func _set_all_fonts_in_rtl(rtl, base_name):
	if(base_name == 'Default'):
		_set_font(rtl, null, 'normal_font')
		_set_font(rtl, null, 'bold_font')
		_set_font(rtl, null, 'italics_font')
		_set_font(rtl, null, 'bold_italics_font')
	else:
		_set_font(rtl, base_name + '-Regular', 'normal_font')
		_set_font(rtl, base_name + '-Bold', 'bold_font')
		_set_font(rtl, base_name + '-Italic', 'italics_font')
		_set_font(rtl, base_name + '-BoldItalic', 'bold_italics_font')


func set_default_font_color(color):
	_normal_gui.get_textbox().set('custom_colors/default_color', color)


func set_background_color(color):
	_normal_gui.set_bg_color(color)


func use_compact_mode(should=true):
	_compact_gui.visible = should
	_normal_gui.visible = !should


func set_opacity(val):
	_normal_gui.modulate.a = val
	_compact_gui.modulate.a = val

func set_title(text):
	_set_both_titles(text)

--- SCRIPT: res://addons/gut/gut_cmdln.gd ---
# ------------------------------------------------------------------------------
# Description
# -----------
# Entry point for the command line interface.  The actual logic for GUT's CLI
# is in addons/gut/cli/gut_cli.gd.
#
# This script should conform to, or ignore, the strictest warning settings.
# ------------------------------------------------------------------------------
extends SceneTree

var VersionConversion = load("res://addons/gut/version_conversion.gd")

@warning_ignore("unsafe_method_access")
@warning_ignore("inferred_declaration")
func _init() -> void:
	if(VersionConversion.error_if_not_all_classes_imported()):
		quit(0)
		return

	var max_iter := 20
	var iter := 0

	var Loader : Object = load("res://addons/gut/gut_loader.gd")

	# Not seen this wait more than 1.
	while(Engine.get_main_loop() == null and iter < max_iter):
		await create_timer(.01).timeout
		iter += 1

	if(Engine.get_main_loop() == null):
		push_error('Main loop did not start in time.')
		quit(0)
		return

	var cli : Node = load('res://addons/gut/cli/gut_cli.gd').new()
	get_root().add_child(cli)

	Loader.restore_ignore_addons()
	cli.main()




# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/gut_config.gd ---
# ##############################################################################
#
# This holds all the configuratoin values for GUT.  It can load and save values
# to a json file.  It is also responsible for applying these settings to GUT.
#
# ##############################################################################
var valid_fonts = ['AnonymousPro', 'CourierPro', 'LobsterTwo', 'Default']

var default_options = {
	background_color = Color(.15, .15, .15, 1).to_html(),
	config_file = 'res://.gutconfig.json',
	# used by editor to handle enabled/disabled dirs.  All dirs configured go
	# here and only the enabled dirs go into dirs
	configured_dirs = [],
	dirs = [],
	disable_colors = false,
	# double strategy can be the name of the enum value, the enum value or
	# lowercase name with spaces:  0/SCRIPT_ONLY/script only
	# The GUI gut config expects the value to be the enum value and not a string
	# when saved.
	double_strategy = 'SCRIPT_ONLY',
	# named differently than gut option so we can use it as a flag in the cli
	errors_do_not_cause_failure = false,
	font_color = Color(.8, .8, .8, 1).to_html(),
	font_name = 'CourierPrime',
	font_size = 16,
	hide_orphans = false,
	ignore_pause = false,
	include_subdirs = false,
	inner_class = '',
	junit_xml_file = '',
	junit_xml_timestamp = false,
	log_level = 1,
	opacity = 100,
	paint_after = .1,
	post_run_script = '',
	pre_run_script = '',
	prefix = 'test_',
	selected = '',
	should_exit = false,
	should_exit_on_success = false,
	should_maximize = false,
	compact_mode = false,
	show_help = false,
	suffix = '.gd',
	tests = [],
	unit_test_name = '',

	gut_on_top = true,
}


var options = default_options.duplicate()
var logger = GutUtils.get_logger()

func _null_copy(h):
	var new_hash = {}
	for key in h:
		new_hash[key] = null
	return new_hash


func _load_options_from_config_file(file_path, into):
	if(!FileAccess.file_exists(file_path)):
		# Default files are ok to be missing.  Maybe this is too deep a place
		# to implement this, but here it is.
		if(file_path != 'res://.gutconfig.json' and file_path != GutUtils.EditorGlobals.editor_run_gut_config_path):
			logger.error(str('Config File "', file_path, '" does not exist.'))
			return -1
		else:
			return 1

	var f = FileAccess.open(file_path, FileAccess.READ)
	if(f == null):
		var result = FileAccess.get_open_error()
		logger.error(str("Could not load data ", file_path, ' ', result))
		return result

	var json = f.get_as_text()
	f = null # close file

	var test_json_conv = JSON.new()
	test_json_conv.parse(json)
	var results = test_json_conv.get_data()
	# SHORTCIRCUIT
	if(results == null):
		logger.error(str("Could not parse file:  ", file_path))
		return -1

	# Get all the options out of the config file using the option name.  The
	# options hash is now the default source of truth for the name of an option.
	_load_dict_into(results, into)

	return 1

func _load_dict_into(source, dest):
	for key in dest:
		if(source.has(key)):
			if(source[key] != null):
				if(typeof(source[key]) == TYPE_DICTIONARY):
					_load_dict_into(source[key], dest[key])
				else:
					dest[key] = source[key]


# Apply all the options specified to tester.  This is where the rubber meets
# the road.
func _apply_options(opts, gut):
	gut.include_subdirectories = opts.include_subdirs

	if(opts.inner_class != ''):
		gut.inner_class_name = opts.inner_class
	gut.log_level = opts.log_level
	gut.ignore_pause_before_teardown = opts.ignore_pause

	gut.select_script(opts.selected)

	for i in range(opts.dirs.size()):
		gut.add_directory(opts.dirs[i], opts.prefix, opts.suffix)

	for i in range(opts.tests.size()):
		gut.add_script(opts.tests[i])

	# Sometimes it is the index, sometimes it's a string.  This sets it regardless
	gut.double_strategy = GutUtils.get_enum_value(
		opts.double_strategy, GutUtils.DOUBLE_STRATEGY,
		GutUtils.DOUBLE_STRATEGY.SCRIPT_ONLY)

	gut.unit_test_name = opts.unit_test_name
	gut.pre_run_script = opts.pre_run_script
	gut.post_run_script = opts.post_run_script
	gut.color_output = !opts.disable_colors
	gut.show_orphans(!opts.hide_orphans)
	gut.junit_xml_file = opts.junit_xml_file
	gut.junit_xml_timestamp = opts.junit_xml_timestamp
	gut.paint_after = str(opts.paint_after).to_float()
	gut.treat_error_as_failure = !opts.errors_do_not_cause_failure

	return gut

# --------------------------
# Public
# --------------------------
func write_options(path):
	var content = JSON.stringify(options, ' ')

	var f = FileAccess.open(path, FileAccess.WRITE)
	var result = FileAccess.get_open_error()
	if(f != null):
		f.store_string(content)
		f = null # closes file
	else:
		logger.error(str("Could not open file ", path, ' ', result))
	return result


# consistent name
func save_file(path):
	write_options(path)


func load_options(path):
	return _load_options_from_config_file(path, options)


# consistent name
func load_file(path):
	return load_options(path)


func load_options_no_defaults(path):
	options = _null_copy(default_options)
	return _load_options_from_config_file(path, options)


func apply_options(gut):
	_apply_options(options, gut)




# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/gut_loader.gd ---
# ------------------------------------------------------------------------------
# This script should be loaded as soon as possible when running tests.  This
# will disable warnings and then load all scripts that are registered with the
# LazyLoader.
#
# Once you are ready to run tests, restore_ignore_addons should be called so
# that it has the expected value.  This should be done after whatever loaded
# this is done loading and doing setup stuff.
#
# This was created after a first attempt to suppress all GUT warnings did not
# work for the strictest warning settings.  This has turned the LazyLoader into
# just a Loader...so maybe all that should be reworked or renamed.  A problem
# for a time when we are absolutely sure that all warnings are being correctly
# suppressed I suppose.
#
# You can use the cli script test/resources/change_project_warnings.gd to
# quickly alter project warning levels for testing purposes.
# 	gdscript test/resources/change_project_warnings.gd --headless ++ -h
#
# You can set project warning settings from the command line with:
#	godot -s addons/gut/cli/change_project_warnings.gd ++ -h
#
# This script should conform to, or ignore, the strictest warning settings.
# ------------------------------------------------------------------------------
const WARNING_PATH : String = 'debug/gdscript/warnings/'


static var were_addons_disabled : bool = true


@warning_ignore("unsafe_method_access")
@warning_ignore("unsafe_property_access")
@warning_ignore("untyped_declaration")
static func _static_init() -> void:
	were_addons_disabled = ProjectSettings.get(str(WARNING_PATH, 'exclude_addons'))
	ProjectSettings.set(str(WARNING_PATH, 'exclude_addons'), true)

	var WarningsManager = load('res://addons/gut/warnings_manager.gd')

	# Turn everything back on (if it originally was on) if the warnings manager
	# is disabled.  This makes sure we see all the warnings for all the scripts
	# in the LazyLoader (except WarningsManager, but that's not a big deal).
	#
	# With the warnings manager disabled and all_warn warnings:
	#	test_warnings_manager.gd 	-> 5471 errors
	#	full run 				 	-> 131,742 errors
	#
	# With the warnings manager disabled and gut_default warnings:
	#	test_warnings_manager.gd 	-> 46 errors
	#	full run 					-> 165 errors.
	if(WarningsManager.disabled):
		ProjectSettings.set(str(WARNING_PATH, 'exclude_addons'), were_addons_disabled)

	# Force a reference to utils.gd by path.  Using the class_name would cause
	# utils.gd to load when this script loads, before we could turn off the
	# warnings.
	var _utils : Object = load('res://addons/gut/utils.gd')

	# Since load_all exists on the LazyLoader, it should be done now so nothing
	# sneaks in later...This essentially defeats the "lazy" part of the
	# LazyLoader, but not the "loader" part of LazyLoader.
	_utils.LazyLoader.load_all()

	# Make sure that the values set in WarningsManager's static_init actually
	# reflect the project settings and not whatever we do here to make things
	# not warn.
	WarningsManager._project_warnings.exclude_addons = were_addons_disabled


# this can be called before tests are run to reinstate whatever exclude_addons
# was set to before this script disabled it.
static func restore_ignore_addons() -> void:
	ProjectSettings.set(str(WARNING_PATH, 'exclude_addons'), were_addons_disabled)




# ##############################################################################
# (G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/gut_plugin.gd ---
@tool
extends EditorPlugin
var VersionConversion = load("res://addons/gut/version_conversion.gd")
var _bottom_panel = null

func _init():
	if(VersionConversion.error_if_not_all_classes_imported()):
		return


func _version_conversion():
	var EditorGlobals = load("res://addons/gut/gui/editor_globals.gd")
	EditorGlobals.create_temp_directory()

	if(VersionConversion.error_if_not_all_classes_imported()):
		return false

	VersionConversion.convert()
	return true


func _enter_tree():
	if(!_version_conversion()):
		return

	_bottom_panel = preload('res://addons/gut/gui/GutBottomPanel.tscn').instantiate()

	var button = add_control_to_bottom_panel(_bottom_panel, 'GUT')
	button.shortcut_in_tooltip = true

	# ---------
	# I removed this delay because it was causing issues with the shortcut button.
	# The shortcut button wouldn't work right until load_shortcuts is called., but
	# the delay gave you 3 seconds to click it before they were loaded.  This
	# await came with the conversion to 4 and probably isn't needed anymore.
	# I'm leaving it here becuase I don't know why it showed up to begin with
	# and if it's needed, it will be pretty hard to debug without seeing this.
	#
	# This should be deleted after the next release or two if not needed.
	# await get_tree().create_timer(3).timeout
	# ---
	_bottom_panel.set_interface(get_editor_interface())
	_bottom_panel.set_plugin(self)
	_bottom_panel.set_panel_button(button)
	_bottom_panel.load_shortcuts()


func _exit_tree():
	# Clean-up of the plugin goes here
	# Always remember to remove_at it from the engine when deactivated
	remove_control_from_bottom_panel(_bottom_panel)
	_bottom_panel.free()


# This seems like a good idea at first, but it deletes the settings for ALL
# projects.  If by chance you want to do that you can uncomment this, reload the
# project and then disable GUT.
# func _disable_plugin():
#	var GutEditorGlobals = load('res://addons/gut/gui/editor_globals.gd')
# 	GutEditorGlobals.user_prefs.erase_all()

--- SCRIPT: res://addons/gut/gut_to_move.gd ---
# Temporary base script for gut.gd to hold the things to be remvoed and added
# to some utility somewhere.
extends Node

# ------------------------------------------------------------------------------
# deletes all files in a given directory
# ------------------------------------------------------------------------------
func directory_delete_files(path):
	var d = DirAccess.open(path)

	# SHORTCIRCUIT
	if(d == null):
		return

	# Traversing a directory is kinda odd.  You have to start the process of listing
	# the contents of a directory with list_dir_begin then use get_next until it
	# returns an empty string.  Then I guess you should end it.
	d.list_dir_begin() # TODOGODOT4 fill missing arguments https://github.com/godotengine/godot/pull/40547
	var thing = d.get_next() # could be a dir or a file or something else maybe?
	var full_path = ''
	while(thing != ''):
		full_path = path + "/" + thing
		# file_exists returns fasle for directories
		if(d.file_exists(full_path)):
			d.remove(full_path)
		thing = d.get_next()

	d.list_dir_end()

# ------------------------------------------------------------------------------
# deletes the file at the specified path
# ------------------------------------------------------------------------------
func file_delete(path):
	var d = DirAccess.open(path.get_base_dir())
	if(d != null):
		d.remove(path)

# ------------------------------------------------------------------------------
# Checks to see if the passed in file has any data in it.
# ------------------------------------------------------------------------------
func is_file_empty(path):
	var f = FileAccess.open(path, FileAccess.READ)
	var result = FileAccess.get_open_error()
	var empty = true
	if(result == OK):
		empty = f.get_length() == 0
	f = null
	return empty

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func get_file_as_text(path):
	return GutUtils.get_file_as_text(path)

# ------------------------------------------------------------------------------
# Creates an empty file at the specified path
# ------------------------------------------------------------------------------
func file_touch(path):
	FileAccess.open(path, FileAccess.WRITE)

# ------------------------------------------------------------------------------
# Simulate a number of frames by calling '_process' and '_physics_process' (if
# the methods exist) on an object and all of its descendents. The specified frame
# time, 'delta', will be passed to each simulated call.
#
# NOTE: Objects can disable their processing methods using 'set_process(false)' and
# 'set_physics_process(false)'. This is reflected in the 'Object' methods
# 'is_processing()' and 'is_physics_processing()', respectively. To make 'simulate'
# respect this status, for example if you are testing an object which toggles
# processing, pass 'check_is_processing' as 'true'.
# ------------------------------------------------------------------------------
func simulate(obj, times, delta, check_is_processing: bool = false):
	for _i in range(times):
		if (
			obj.has_method("_process")
			and (
				not check_is_processing
				or obj.is_processing()
			)
		):
			obj._process(delta)
		if(
			obj.has_method("_physics_process")
			and (
				not check_is_processing
				or obj.is_physics_processing()
			)
		):
			obj._physics_process(delta)

		for kid in obj.get_children():
			simulate(kid, 1, delta, check_is_processing)

--- SCRIPT: res://addons/gut/gut_vscode_debugger.gd ---
# ------------------------------------------------------------------------------
# Entry point for using the debugger through VSCode.  The gut-extension for
# VSCode launches this instead of gut_cmdln.gd when running tests through the
# debugger.
#
# This could become more complex overtime, but right now all we have to do is
# to make sure the console printer is enabled or you do not get any output.
# ------------------------------------------------------------------------------
extends 'res://addons/gut/gut_cmdln.gd'

func run_tests(runner):
	runner.get_gut().get_logger().disable_printer('console', false)
	runner.run_tests()


# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/hook_script.gd ---
class_name GutHookScript
## This script is the base for custom scripts to be used in pre and post
## run hooks.
##
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url]
## [br][br]
## Creating a hook script requires that you:[br]
##  - Inherit [code skip-lint]GutHookScript[/code][br]
##  - Implement a [code skip-lint]run()[/code] method[br]
##  - Configure the path in GUT (gutconfig aand/or editor) as the approparite hook (pre or post).[br]
##
## See [wiki]Hooks[/wiki]


## Class responsible for generating xml.  You could use this to generate XML
## yourself instead of using the built in GUT xml generation options.  See
## [addons/gut/junit_xml_export.gd]
var JunitXmlExport = load('res://addons/gut/junit_xml_export.gd')

## This is the instance of [GutMain] that is running the tests.  You can get
## information about the run from this object.  This is set by GUT when the
## script is instantiated.
var gut  = null

# the exit code to be used by gut_cmdln.  See set method.
var _exit_code = null

var _should_abort =  false

## Virtual method that will be called by GUT after instantiating this script.
## This is where you put all of your logic.
func run():
	gut.logger.error("Run method not overloaded.  Create a 'run()' method in your hook script to run your code.")


## Set the exit code when running from the command line.  If not set then the
## default exit code will be returned (0 when no tests fail, 1 when any tests
## fail).
func set_exit_code(code : int):
	_exit_code  = code

## Returns the exit code set with [code skip-lint]set_exit_code[/code]
func get_exit_code():
	return _exit_code

## Usable by pre-run script to cause the run to end AFTER the run() method
## finishes.  GUT will quit and post-run script will not be ran.
func abort():
	_should_abort = true

## Returns if [code skip-lint]abort[/code] was called.
func should_abort():
	return _should_abort

--- SCRIPT: res://addons/gut/inner_class_registry.gd ---
var _registry = {}


func _create_reg_entry(base_path, subpath):
	var to_return = {
		"base_path":base_path,
		"subpath":subpath,
		"base_resource":load(base_path),
		"full_path":str("'", base_path, "'", subpath)
	}
	return to_return

func _register_inners(base_path, obj, prev_inner = ''):
	var const_map = obj.get_script_constant_map()
	var consts = const_map.keys()
	var const_idx = 0

	while(const_idx < consts.size()):
		var key = consts[const_idx]
		var thing = const_map[key]

		if(typeof(thing) == TYPE_OBJECT):
			var cur_inner = str(prev_inner, ".", key)
			_registry[thing] = _create_reg_entry(base_path, cur_inner)
			_register_inners(base_path, thing, cur_inner)

		const_idx += 1


func register(base_script):
	var base_path = base_script.resource_path
	_register_inners(base_path, base_script)


func get_extends_path(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].full_path
	else:
		return null

# returns the subpath for the inner class.  This includes the leading "." in
# the path.
func get_subpath(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].subpath
	else:
		return ''

func get_base_path(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].base_path


func has(inner_class):
	return _registry.has(inner_class)


func get_base_resource(inner_class):
	if(_registry.has(inner_class)):
		return _registry[inner_class].base_resource


func to_s():
	var text = ""
	for key in _registry:
		text += str(key, ": ", _registry[key], "\n")
	return text

--- SCRIPT: res://addons/gut/input_factory.gd ---
class_name GutInputFactory
## Static class full of helper methods to make InputEvent instances.
##
## This thing makes InputEvents.  Enjoy.

# Implemented InputEvent* convenience methods
# 	InputEventAction
# 	InputEventKey
# 	InputEventMouseButton
# 	InputEventMouseMotion

# Yet to implement InputEvents
# 	InputEventJoypadButton
# 	InputEventJoypadMotion
# 	InputEventMagnifyGesture
# 	InputEventMIDI
# 	InputEventPanGesture
# 	InputEventScreenDrag
# 	InputEventScreenTouch


static func _to_scancode(which):
	var key_code = which
	if(typeof(key_code) == TYPE_STRING):
		key_code = key_code.to_upper().to_ascii_buffer()[0]
	return key_code


## Creates a new button with the given propoerties.
static func new_mouse_button_event(position, global_position, pressed, button_index) -> InputEventMouseButton:
	var event = InputEventMouseButton.new()
	event.position = position
	if(global_position != null):
		event.global_position = global_position
	event.pressed = pressed
	event.button_index = button_index

	return event


## Returns an [InputEventKey] event with [code]pressed = false[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
static func key_up(which) -> InputEventKey:
	var event = InputEventKey.new()
	event.keycode = _to_scancode(which)
	event.pressed = false
	return event


## Returns an [InputEventKey] event with [code]pressed = true[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
static func key_down(which) -> InputEventKey:
	var event = InputEventKey.new()
	event.keycode = _to_scancode(which)
	event.pressed = true
	return event


## Returns an "action up" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
static func action_up(which, strength=1.0) -> InputEventAction:
	var event  = InputEventAction.new()
	event.action = which
	event.strength = strength
	return event


## Returns an "action down" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
static func action_down(which, strength=1.0) -> InputEventAction:
	var event  = InputEventAction.new()
	event.action = which
	event.strength = strength
	event.pressed = true
	return event


## Returns a "button down" [InputEventMouseButton] for the left mouse button.
static func mouse_left_button_down(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, true, MOUSE_BUTTON_LEFT)
	return event


## Returns a "button up" [InputEventMouseButton] for the left mouse button.
static func mouse_left_button_up(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, false, MOUSE_BUTTON_LEFT)
	return event


## Returns a "double click" [InputEventMouseButton] for the left mouse button.
static func mouse_double_click(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, false, MOUSE_BUTTON_LEFT)
	event.double_click = true
	return event


## Returns a "button down" [InputEventMouseButton] for the right mouse button.
static func mouse_right_button_down(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, true, MOUSE_BUTTON_RIGHT)
	return event


## Returns a "button up" [InputEventMouseButton] for the right mouse button.
static func mouse_right_button_up(position, global_position=null) -> InputEventMouseButton:
	var event = new_mouse_button_event(position, global_position, false, MOUSE_BUTTON_RIGHT)
	return event


## Returns a [InputEventMouseMotion] to move the mouse the specified positions.
static func mouse_motion(position, global_position=null) -> InputEventMouseMotion:
	var event = InputEventMouseMotion.new()
	event.position = position
	if(global_position != null):
		event.global_position = global_position
	return event


## Returns an [InputEventMouseMotion] that moves the mouse [param offset]
## from the last [method mouse_motion] or [method mouse_motion] call.
static func mouse_relative_motion(offset, last_motion_event=null, speed=Vector2(0, 0)) -> InputEventMouseMotion:
	var event = null
	if(last_motion_event == null):
		event = mouse_motion(offset)
		event.velocity = speed
	else:
		event = last_motion_event.duplicate()
		event.position += offset
		event.global_position += offset
		event.relative = offset
		event.velocity = speed
	return event

# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# Description
# -----------
# ##############################################################################

--- SCRIPT: res://addons/gut/input_sender.gd ---
class_name GutInputSender
## The GutInputSender class.  It sends input to places.
##
## [br][br]
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url][br]
## See [wiki]Mocking-Input[/wiki] for examples.
## [br][br]
## This class can be used to send [code]InputEvent*[/code] events to various
## objects.  It also allows you to script out a series of inputs and play
## them back in real time.  You could use it to:[br]
##  - Verify that jump height depends on how long the jump button is pressed.[br]
##  - Double tap a direction performs a dash.[br]
##  - Down, Down-Forward, Forward + punch throws a fireball.[br]
## [br][br]
## And much much more.
## [br][br]
## As of 9.3.1 you can use [code skip-lint]GutInputSender[/code] instead of [code]InputSender[/code].  It's the same thing, but [code skip-lint]GutInputSender[/code] is a [code]class_name[/code] so you may have less warnings and auto-complete will work.
## [br][br]
## [b]Warning[/b][br]
## If you move the Godot window to a different monitor while tests are running it can cause input tests to fail.  [url=https://github.com/bitwes/Gut/issues/643]This issue[/url] has more details.



# Implemented InputEvent* convenience methods
# 	InputEventAction
# 	InputEventKey
# 	InputEventMouseButton
#	InputEventMouseMotion

# Yet to implement InputEvents
# 	InputEventJoypadButton
# 	InputEventJoypadMotion
# 	InputEventMagnifyGesture
# 	InputEventMIDI
# 	InputEventPanGesture
# 	InputEventScreenDrag
# 	InputEventScreenTouch



# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class InputQueueItem:
	extends Node

	var events = []
	var time_delay = null
	var frame_delay = null
	var _waited_frames = 0
	var _is_ready = false
	var _delay_started = false

	signal event_ready

	# TODO should this be done in _physics_process instead or should it be
	# configurable?
	func _physics_process(delta):
		if(frame_delay > 0 and _delay_started):
			_waited_frames += 1
			if(_waited_frames >= frame_delay):
				event_ready.emit()

	func _init(t_delay,f_delay):
		time_delay = t_delay
		frame_delay = f_delay
		_is_ready = time_delay == 0 and frame_delay == 0

	func _on_time_timeout():
		_is_ready = true
		event_ready.emit()

	func _delay_timer(t):
		return Engine.get_main_loop().root.get_tree().create_timer(t)

	func is_ready():
		return _is_ready

	func start():
		_delay_started = true
		if(time_delay > 0):
			var t = _delay_timer(time_delay)
			t.connect("timeout",Callable(self,"_on_time_timeout"))




# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class MouseDraw:
	extends Node2D

	var down_color = Color(1, 1, 1, .25)
	var up_color = Color(0, 0, 0, .25)
	var line_color = Color(1, 0, 0)
	var disabled = true :
		get : return disabled
		set(val) :
			disabled = val
			queue_redraw()

	var _draw_at = Vector2(0, 0)
	var _b1_down = false
	var _b2_down = false


	func draw_event(event):
		if(event is InputEventMouse):
			_draw_at = event.position
			if(event is InputEventMouseButton):
				if(event.button_index == MOUSE_BUTTON_LEFT):
					_b1_down = event.pressed
				elif(event.button_index == MOUSE_BUTTON_RIGHT):
					_b2_down = event.pressed
		queue_redraw()


	func _draw_cicled_cursor():
		var r = 10
		var b1_color = up_color
		var b2_color = up_color

		if(_b1_down):
			var pos = _draw_at - (Vector2(r * 1.5, 0))
			draw_arc(pos, r / 2, 0, 360, 180, b1_color)

		if(_b2_down):
			var pos = _draw_at + (Vector2(r * 1.5, 0))
			draw_arc(pos, r / 2, 0, 360, 180, b2_color)

		draw_arc(_draw_at, r, 0, 360, 360, line_color, 1)
		draw_line(_draw_at - Vector2(0, r), _draw_at + Vector2(0, r), line_color)
		draw_line(_draw_at - Vector2(r, 0), _draw_at + Vector2(r, 0), line_color)


	func _draw_square_cursor():
		var r = 10
		var b1_color = up_color
		var b2_color = up_color

		if(_b1_down):
			b1_color = down_color

		if(_b2_down):
			b2_color = down_color

		var blen = r * .75
		# left button rectangle
		draw_rect(Rect2(_draw_at - Vector2(blen, blen), Vector2(blen, blen * 2)), b1_color)
		# right button rectrangle
		draw_rect(Rect2(_draw_at - Vector2(0, blen), Vector2(blen, blen * 2)), b2_color)
		# Crosshair
		draw_line(_draw_at - Vector2(0, r), _draw_at + Vector2(0, r), line_color)
		draw_line(_draw_at - Vector2(r, 0), _draw_at + Vector2(r, 0), line_color)


	func _draw():
		if(disabled):
			return
		_draw_square_cursor()







# ##############################################################################
#
# ##############################################################################
## Local reference to the GutInputFactory static class
const INPUT_WARN = 'If using Input as a reciever it will not respond to *_down events until a *_up event is recieved.  Call the appropriate *_up event or use hold_for(...) to automatically release after some duration.'

var _lgr = GutUtils.get_logger()
var _receivers = []
var _input_queue = []
var _next_queue_item = null

# used by hold_for and echo.
var _last_event = null
# indexed by keycode, each entry contains a boolean value indicating the
# last emitted "pressed" value for that keycode.
var _pressed_keys = {}
var _pressed_actions = {}
var _pressed_mouse_buttons = {}

var _auto_flush_input = false
var _tree_items_parent = null
var _mouse_draw = null;

var _default_mouse_position = {
	position = Vector2(0, 0),
	global_position = Vector2(0, 0)
}

var _last_mouse_position = {
}

## Warp mouse when sending InputEventMouse* events
var mouse_warp = false
## Draw mouse position cross hairs.  Useful to see where the mouse is at
## when not using [member mouse_warp]
var draw_mouse = true

## Emitted when all events in the input queue have been sent.
signal idle


## Accepts a single optional receiver.
func _init(r=null):
	if(r != null):
		add_receiver(r)

	_last_mouse_position = _default_mouse_position.duplicate()
	_tree_items_parent = Node.new()
	Engine.get_main_loop().root.add_child(_tree_items_parent)

	_mouse_draw = MouseDraw.new()
	_tree_items_parent.add_child(_mouse_draw)
	_mouse_draw.disabled = false


func _notification(what):
	if(what == NOTIFICATION_PREDELETE):
		if(is_instance_valid(_tree_items_parent)):
			_tree_items_parent.queue_free()


func _add_queue_item(item):
	item.connect("event_ready", _on_queue_item_ready.bind(item))
	_next_queue_item = item
	_input_queue.append(item)
	_tree_items_parent.add_child(item)
	if(_input_queue.size() == 1):
		item.start()


func _handle_pressed_keys(event):
	if(event is InputEventKey):
		if((event.pressed and !event.echo) and is_key_pressed(event.keycode)):
			_lgr.warn(str("InputSender:  key_down called for ", event.as_text(), " when that key is already pressed.  ", INPUT_WARN))
		_pressed_keys[event.keycode] = event.pressed
	elif(event is InputEventAction):
		if(event.pressed and is_action_pressed(event.action)):
			_lgr.warn(str("InputSender:  action_down called for ", event.action, " when that action is already pressed.  ", INPUT_WARN))
		_pressed_actions[event.action] = event.pressed
	elif(event is InputEventMouseButton):
		if(event.pressed and is_mouse_button_pressed(event.button_index)):
			_lgr.warn(str("InputSender:  mouse_button_down called for ", event.button_index, " when that mouse button is already pressed.  ", INPUT_WARN))
		_pressed_mouse_buttons[event.button_index] = event


func _handle_mouse_position(event):
	if(event is InputEventMouse):
		_mouse_draw.disabled = !draw_mouse
		_mouse_draw.draw_event(event)
		if(mouse_warp):
			DisplayServer.warp_mouse(event.position)


func _send_event(event):
	_handle_mouse_position(event)
	_handle_pressed_keys(event)

	for r in _receivers:
		if(r == Input):
			Input.parse_input_event(event)
			if(event is InputEventAction):
				if(event.pressed):
					Input.action_press(event.action)
				else:
					Input.action_release(event.action)
			if(_auto_flush_input):
				Input.flush_buffered_events()
		else:
			if(r.has_method(&"_input")):
				r._input(event)

			if(r.has_signal(&"gui_input")):
				r.gui_input.emit(event)

			if(r.has_method(&"_gui_input")):
				r._gui_input(event)

			if(r.has_method(&"_unhandled_input")):
				r._unhandled_input(event)


func _send_or_record_event(event):
	_last_event = event
	if(_next_queue_item != null):
		_next_queue_item.events.append(event)
	else:
		_send_event(event)


func _set_last_mouse_positions(event : InputEventMouse):
	_last_mouse_position.position = event.position
	_last_mouse_position.global_position = event.global_position


func _apply_last_position_and_set_last_position(event, position, global_position):
	event.position = GutUtils.nvl(position, _last_mouse_position.position)
	event.global_position = GutUtils.nvl(
		global_position, _last_mouse_position.global_position)
	_set_last_mouse_positions(event)


func _new_defaulted_mouse_button_event(position, global_position):
	var event = InputEventMouseButton.new()
	_apply_last_position_and_set_last_position(event, position, global_position)
	return event


func _new_defaulted_mouse_motion_event(position, global_position):
	var event = InputEventMouseMotion.new()
	_apply_last_position_and_set_last_position(event, position, global_position)
	for key in _pressed_mouse_buttons:
		if(_pressed_mouse_buttons[key].pressed):
			event.button_mask += key
	return event


# ------------------------------
# Events
# ------------------------------
func _on_queue_item_ready(item):
	for event in item.events:
		_send_event(event)

	var done_event = _input_queue.pop_front()
	done_event.queue_free()

	if(_input_queue.size() == 0):
		_next_queue_item = null
		idle.emit()
	else:
		_input_queue[0].start()


# ------------------------------
# Public
# ------------------------------


## Add an object to receive input events.
func add_receiver(obj):
	_receivers.append(obj)


## Returns the receivers that have been added.
func get_receivers():
	return _receivers


## Returns true if the input queue has items to be processed, false if not.
func is_idle():
	return _input_queue.size() == 0

func is_key_pressed(which):
	var event = GutInputFactory.key_up(which)
	return _pressed_keys.has(event.keycode) and _pressed_keys[event.keycode]

func is_action_pressed(which):
	return _pressed_actions.has(which) and _pressed_actions[which]

func is_mouse_button_pressed(which):
	return _pressed_mouse_buttons.has(which) and _pressed_mouse_buttons[which].pressed


## Get the value of [method set_auto_flush_input].
func get_auto_flush_input():
	return _auto_flush_input


## Enable/Disable auto flushing of input.  When enabled the [GutInputSender]
## will call [code]Input.flush_buffered_events[/code] after each event is sent.
## See the "use_accumulated_input" section in [wiki]Mocking-Input[/wiki] for more
## information.
func set_auto_flush_input(val):
	_auto_flush_input = val


## Adds a delay between the last input queue item added and any queue item added
## next.  By default this will wait [param t] seconds.  You can specify a
## number of frames to wait by passing a string composed of a number and "f".
## For example [code]wait("5f")[/code] will wait 5 frames.
func wait(t):
	if(typeof(t) == TYPE_STRING):
		var suffix = t.substr(t.length() -1, 1)
		var val = t.rstrip('s').rstrip('f').to_float()

		if(suffix.to_lower() == 's'):
			wait_secs(val)
		elif(suffix.to_lower() == 'f'):
			wait_frames(val)
	else:
		wait_secs(t)

	return self


## Clears the input queue and any state such as the last event sent and any
## pressed actions/buttons.  Does not clear the list of receivers.
## [br][br]
## This should be done between each test when the [GutInputSender] is a class
## level variable so that state does not leak between tests.
func clear():
	_last_event = null
	_next_queue_item = null

	for item in _input_queue:
		item.free()
	_input_queue.clear()

	_pressed_keys.clear()
	_pressed_actions.clear()
	_pressed_mouse_buttons.clear()
	_last_mouse_position = _default_mouse_position.duplicate()


# ------------------------------
# Event methods
# ------------------------------

## Sends a [InputEventKey] event with [code]pressed = false[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
func key_up(which):
	var event = GutInputFactory.key_up(which)
	_send_or_record_event(event)
	return self


## Sends a [InputEventKey] event with [code]pressed = true[/code].  [param which] can be a character or a [code]KEY_*[/code] constant.
func key_down(which):
	var event = GutInputFactory.key_down(which)
	_send_or_record_event(event)
	return self


## Sends an echo [InputEventKey] event of the last key event.
func key_echo():
	if(_last_event != null and _last_event is InputEventKey):
		var new_key = _last_event.duplicate()
		new_key.echo = true
		_send_or_record_event(new_key)
	return self


## Sends a "action up" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
func action_up(which, strength=1.0):
	var event  = GutInputFactory.action_up(which, strength)
	_send_or_record_event(event)
	return self


## Sends a "action down" [InputEventAction] instance.  [param which] is the name of the action defined in the Key Map.
func action_down(which, strength=1.0):
	var event  = GutInputFactory.action_down(which, strength)
	_send_or_record_event(event)
	return self


## Sends a "button down" [InputEventMouseButton] for the left mouse button.
func mouse_left_button_down(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = true
	event.button_index = MOUSE_BUTTON_LEFT
	_send_or_record_event(event)
	return self


## Sends a "button up" [InputEventMouseButton] for the left mouse button.
func mouse_left_button_up(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = false
	event.button_index = MOUSE_BUTTON_LEFT
	_send_or_record_event(event)
	return self


## Sends a "double click" [InputEventMouseButton] for the left mouse button.
func mouse_double_click(position=null, global_position=null):
	var event = GutInputFactory.mouse_double_click(position, global_position)
	event.double_click = true
	_send_or_record_event(event)
	return self


## Sends a "button down" [InputEventMouseButton] for the right mouse button.
func mouse_right_button_down(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = true
	event.button_index = MOUSE_BUTTON_RIGHT
	_send_or_record_event(event)
	return self


## Sends a "button up" [InputEventMouseButton] for the right mouse button.
func mouse_right_button_up(position=null, global_position=null):
	var event = _new_defaulted_mouse_button_event(position, global_position)
	event.pressed = false
	event.button_index = MOUSE_BUTTON_RIGHT
	_send_or_record_event(event)
	return self


## Sends a [InputEventMouseMotion] to move the mouse the specified positions.
func mouse_motion(position, global_position=null):
	var event = _new_defaulted_mouse_motion_event(position, global_position)
	_send_or_record_event(event)
	return self


## Sends a [InputEventMouseMotion] that moves the mouse [param offset]
## from the last [method mouse_motion] or [method mouse_set_position] call.
func mouse_relative_motion(offset, speed=Vector2(0, 0)):
	var last_event = _new_defaulted_mouse_motion_event(null, null)
	var event = GutInputFactory.mouse_relative_motion(offset, last_event, speed)
	_set_last_mouse_positions(event)
	_send_or_record_event(event)
	return self


## Sets the mouse's position.  This does not send an event.  This position will
## be used for the next call to [method mouse_relative_motion].
func mouse_set_position(position, global_position=null):
	var event = _new_defaulted_mouse_motion_event(position, global_position)
	return self


## Performs a left click at the given position.
func mouse_left_click_at(where, duration = '5f'):
	wait_frames(1)
	mouse_left_button_down(where)
	hold_for(duration)
	wait_frames(10)
	return self


## Create your own event and use this to send it to all receivers.
func send_event(event):
	_send_or_record_event(event)
	return self


## Releases all [InputEventKey], [InputEventAction], and [InputEventMouseButton]
## events that have passed through this instance.  These events could have been
## generated via the various [code]_down[/code] methods or passed to
## [method send_event].
## [br][br]
## This will send the "release" event ([code]pressed = false[/code]) to all
## receivers.  This should be done between each test when using `Input` as a
## receiver.
func release_all():
	for key in _pressed_keys:
		if(_pressed_keys[key]):
			_send_event(GutInputFactory.key_up(key))
	_pressed_keys.clear()

	for key in _pressed_actions:
		if(_pressed_actions[key]):
			_send_event(GutInputFactory.action_up(key))
	_pressed_actions.clear()

	for key in _pressed_mouse_buttons:
		var event = _pressed_mouse_buttons[key].duplicate()
		if(event.pressed):
			event.pressed = false
			_send_event(event)
	_pressed_mouse_buttons.clear()

	return self

## Same as [method wait] but only accepts a number of frames to wait.
func wait_frames(num_frames):
	var item = InputQueueItem.new(0, num_frames)
	_add_queue_item(item)
	return self


## Same as [method wait] but only accepts a number of seconds to wait.
func wait_secs(num_secs):
	var item = InputQueueItem.new(num_secs, 0)
	_add_queue_item(item)
	return self


## This is a special [method wait] that will emit the previous input queue item
## with [code]pressed = false[/code] after a delay.  If you pass a number then
## it will wait that many seconds.  You can also use the `"4f"` format to wait
## a specific number of frames.
## [br][br]
## For example [code]sender.action_down('jump').hold_for("10f")[/code] will
## cause two [InputEventAction] instances to be sent.  The "jump-down" event
## from [method action_down] and then a "jump-up" event after 10 frames.
func hold_for(duration):
	if(_last_event != null and _last_event.pressed):
		var next_event = _last_event.duplicate()
		next_event.pressed = false

		wait(duration)
		send_event(next_event)
	return self


## Same as [method hold_for] but specifically holds for a number of physics
## frames.
func hold_frames(duration:int):
	return hold_for(str(duration, 'f'))


## Same as [method hold_for] but specifically holds for a number of seconds.
func hold_seconds(duration:float):
	return hold_for(duration)


# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# Description
# -----------
# This class sends input to one or more recievers.  The receivers' _input,
# _unhandled_input, and _gui_input are called sending InputEvent* events.
# InputEvents can be sent via the helper methods or a custom made InputEvent
# can be sent via send_event(...)
#
# ##############################################################################

--- SCRIPT: res://addons/gut/junit_xml_export.gd ---
## Creates an export of a test run in the JUnit XML format.
##
## More words needed?

var _exporter = GutUtils.ResultExporter.new()

## @ignore should be private I think
func indent(s, ind):
	var to_return = ind + s
	to_return = to_return.replace("\n", "\n" + ind)
	return to_return

# Wraps content in CDATA section because it may contain special characters
# e.g. str(null) becomes <null> and can break XML parsing.
func wrap_cdata(content):
	return "<![CDATA[" + str(content) + "]]>"

## @ignore should be private I think
func add_attr(name, value):
	return str(name, '="', value, '" ')


func _export_test_result(test):
	var to_return = ''

	# Right now the pending and failure messages won't fit in the message
	# attribute because they can span multiple lines and need to be escaped.
	if(test.status == 'pending'):
		var skip_tag = str("<skipped message=\"pending\">", wrap_cdata(test.pending[0]), "</skipped>")
		to_return += skip_tag
	elif(test.status == 'fail'):
		var fail_tag = str("<failure message=\"failed\">", wrap_cdata(test.failing[0]), "</failure>")
		to_return += fail_tag

	return to_return


func _export_tests(script_result, classname):
	var to_return = ""

	for key in script_result.keys():
		var test = script_result[key]
		var assert_count = test.passing.size() + test.failing.size()
		to_return += "<testcase "
		to_return += add_attr("name", key)
		to_return += add_attr("assertions", assert_count)
		to_return += add_attr("status", test.status)
		to_return += add_attr("classname", classname.replace("res://", ""))
		to_return += add_attr("time", test.time_taken)
		to_return += ">\n"

		to_return += _export_test_result(test)

		to_return += "</testcase>\n"

	return to_return


func _sum_test_time(script_result, classname)->float:
	var to_return := 0.0

	for key in script_result.keys():
		var test = script_result[key]
		to_return += test.time_taken

	return to_return


func _export_scripts(exp_results):
	var to_return = ""
	for key in exp_results.test_scripts.scripts.keys():
		var s = exp_results.test_scripts.scripts[key]
		to_return += "<testsuite "
		to_return += add_attr("name", key.replace("res://", ""))
		to_return += add_attr("tests", s.props.tests)
		to_return += add_attr("failures", s.props.failures)
		to_return += add_attr("skipped", s.props.pending)
		to_return += add_attr("time", _sum_test_time(s.tests, key) )
		to_return += ">\n"

		to_return += indent(_export_tests(s.tests, key), "    ")

		to_return += "</testsuite>\n"

	return to_return


## Takes in an instance of GutMain and returns a string of XML representing the
## results of the run.
func get_results_xml(gut):
	var exp_results = _exporter.get_results_dictionary(gut)
	var to_return = '<?xml version="1.0" encoding="UTF-8"?>' + "\n"
	to_return += '<testsuites '
	to_return += add_attr("name", 'GutTests')
	to_return += add_attr("failures", exp_results.test_scripts.props.failures)
	to_return += add_attr('tests', exp_results.test_scripts.props.tests)
	to_return += ">\n"

	to_return += indent(_export_scripts(exp_results), "  ")

	to_return += '</testsuites>'
	return to_return


## Takes in an instance of GutMain and writes the XML file to the specified
## path
func write_file(gut, path):
	var xml = get_results_xml(gut)

	var f_result = GutUtils.write_file(path, xml)
	if(f_result != OK):
		var msg = str("Error:  ", f_result, ".  Could not create export file ", path)
		GutUtils.get_logger().error(msg)

	return f_result

--- SCRIPT: res://addons/gut/lazy_loader.gd ---
@tool
# ------------------------------------------------------------------------------
# Static
# ------------------------------------------------------------------------------
static var usage_counter = load('res://addons/gut/thing_counter.gd').new()
static var WarningsManager = load('res://addons/gut/warnings_manager.gd')

static func load_all():
	for key in usage_counter.things:
		key.get_loaded()


static func print_usage():
	for key in usage_counter.things:
		print(key._path, '  (', usage_counter.things[key], ')')


# ------------------------------------------------------------------------------
# Class
# ------------------------------------------------------------------------------
var _loaded = null
var _path = null

func _init(path):
	_path = path
	usage_counter.add_thing_to_count(self)


func get_loaded():
	if(_loaded == null):
		_loaded = WarningsManager.load_script_ignoring_all_warnings(_path)
	usage_counter.add(self)
	return _loaded

--- SCRIPT: res://addons/gut/logger.gd ---
var types = {
	debug = 'debug',
	deprecated = 'deprecated',
	error = 'error',
	failed = 'failed',
	info = 'info',
	normal = 'normal',
	orphan = 'orphan',
	passed = 'passed',
	pending = 'pending',
	risky = 'risky',
	warn = 'warn',
}

var fmts = {
	red = 'red',
	yellow = 'yellow',
	green = 'green',

	bold = 'bold',
	underline = 'underline',

	none = null
}

var _type_data = {
	types.debug:		{disp='DEBUG', 		enabled=true, fmt=fmts.bold},
	types.deprecated:	{disp='DEPRECATED', enabled=true, fmt=fmts.none},
	types.error:		{disp='ERROR', 		enabled=true, fmt=fmts.red},
	types.failed:		{disp='Failed', 	enabled=true, fmt=fmts.red},
	types.info:			{disp='INFO', 		enabled=true, fmt=fmts.bold},
	types.normal:		{disp='NORMAL', 	enabled=true, fmt=fmts.none},
	types.orphan:		{disp='Orphans',	enabled=true, fmt=fmts.yellow},
	types.passed:		{disp='Passed', 	enabled=true, fmt=fmts.green},
	types.pending:		{disp='Pending',	enabled=true, fmt=fmts.yellow},
	types.risky:		{disp='Risky',		enabled=true, fmt=fmts.yellow},
	types.warn:			{disp='WARNING', 	enabled=true, fmt=fmts.yellow},
}

var _logs = {
	types.warn: [],
	types.error: [],
	types.info: [],
	types.debug: [],
	types.deprecated: [],
}

var _printers = {
	terminal = null,
	gui = null,
	console = null
}

var _gut = null
var _indent_level = 0
var _min_indent_level = 0
var _indent_string = '    '
var _less_test_names = false
var _yield_calls = 0
var _last_yield_text = ''

func _init():
	_printers.terminal = GutUtils.Printers.TerminalPrinter.new()
	_printers.console = GutUtils.Printers.ConsolePrinter.new()
	# There were some problems in the timing of disabling this at the right
	# time in gut_cmdln so it is disabled by default.  This is enabled
	# by plugin_control.gd based on settings.
	_printers.console.set_disabled(true)

func get_indent_text():
	var pad = ''
	for i in range(_indent_level):
		pad += _indent_string

	return pad

func _indent_text(text):
	var to_return = text
	var ending_newline = ''

	if(text.ends_with("\n")):
		ending_newline = "\n"
		to_return = to_return.left(to_return.length() -1)

	var pad = get_indent_text()
	to_return = to_return.replace("\n", "\n" + pad)
	to_return += ending_newline

	return pad + to_return

func _should_print_to_printer(key_name):
	return _printers[key_name] != null and !_printers[key_name].get_disabled()

func _print_test_name():
	if(_gut == null):
		return

	var cur_test = _gut.get_current_test_object()
	if(cur_test == null):
		return false

	if(!cur_test.has_printed_name):
		var param_text = ''
		if(cur_test.arg_count > 0):
			# Just an FYI, parameter_handler in gut might not be set yet so can't
			# use it here for cooler output.
			param_text = '<parameterized>'
		_output(str('* ', cur_test.name, param_text, "\n"))
		cur_test.has_printed_name = true

func _output(text, fmt=null):
	for key in _printers:
		if(_should_print_to_printer(key)):
			_printers[key].send(text, fmt)

func _log(text, fmt=fmts.none):
	_print_test_name()
	var indented = _indent_text(text)
	_output(indented, fmt)

# ---------------
# Get Methods
# ---------------
func get_warnings():
	return get_log_entries(types.warn)

func get_errors():
	return get_log_entries(types.error)

func get_infos():
	return get_log_entries(types.info)

func get_debugs():
	return get_log_entries(types.debug)

func get_deprecated():
	return get_log_entries(types.deprecated)

func get_count(log_type=null):
	var count = 0
	if(log_type == null):
		for key in _logs:
			count += _logs[key].size()
	else:
		count = _logs[log_type].size()
	return count

func get_log_entries(log_type):
	return _logs[log_type]

# ---------------
# Log methods
# ---------------
func _output_type(type, text):
	var td = _type_data[type]
	if(!td.enabled):
		# if(_logs.has(type)):
		# 	_logs[type].append(text)
		return

	_print_test_name()
	if(type != types.normal):
		if(_logs.has(type)):
			_logs[type].append(text)

		var start = str('[', td.disp, ']')
		if(text != null and text != ''):
			start += ':  '
		else:
			start += ' '
		var indented_start = _indent_text(start)
		var indented_end = _indent_text(text)
		indented_end = indented_end.lstrip(_indent_string)
		_output(indented_start, td.fmt)
		_output(indented_end + "\n")


func debug(text):
	_output_type(types.debug, text)

# supply some text or the name of the deprecated method and the replacement.
func deprecated(text, alt_method=null):
	var msg = text
	if(alt_method):
		msg = str('The method ', text, ' is deprecated, use ', alt_method , ' instead.')
	return _output_type(types.deprecated, msg)

func error(text):
	_output_type(types.error, text)
	if(_gut != null):
		_gut._fail_for_error(text)

func failed(text):
	_output_type(types.failed, text)

func info(text):
	_output_type(types.info, text)

func orphan(text):
	_output_type(types.orphan, text)

func passed(text):
	_output_type(types.passed, text)

func pending(text):
	_output_type(types.pending, text)

func risky(text):
	_output_type(types.risky, text)

func warn(text):
	_output_type(types.warn, text)

func log(text='', fmt=fmts.none):
	end_yield()
	if(text == ''):
		_output("\n")
	else:
		_log(text + "\n", fmt)
	return null

func lograw(text, fmt=fmts.none):
	return _output(text, fmt)

# Print the test name if we aren't skipping names of tests that pass (basically
# what _less_test_names means))
func log_test_name():
	# suppress output if we haven't printed the test name yet and
	# what to print is the test name.
	if(!_less_test_names):
		_print_test_name()

# ---------------
# Misc
# ---------------
func get_gut():
	return _gut

func set_gut(gut):
	_gut = gut
	if(_gut == null):
		_printers.gui = null
	else:
		if(_printers.gui == null):
			_printers.gui = GutUtils.Printers.GutGuiPrinter.new()


func get_indent_level():
	return _indent_level

func set_indent_level(indent_level):
	_indent_level = max(_min_indent_level, indent_level)

func get_indent_string():
	return _indent_string

func set_indent_string(indent_string):
	_indent_string = indent_string

func clear():
	for key in _logs:
		_logs[key].clear()

func inc_indent():
	_indent_level += 1

func dec_indent():
	_indent_level = max(_min_indent_level, _indent_level -1)

func is_type_enabled(type):
	return _type_data[type].enabled

func set_type_enabled(type, is_enabled):
	_type_data[type].enabled = is_enabled

func get_less_test_names():
	return _less_test_names

func set_less_test_names(less_test_names):
	_less_test_names = less_test_names

func disable_printer(name, is_disabled):
	if(_printers[name] != null):
		_printers[name].set_disabled(is_disabled)

func is_printer_disabled(name):
	return _printers[name].get_disabled()

func disable_formatting(is_disabled):
	for key in _printers:
		_printers[key].set_format_enabled(!is_disabled)

func disable_all_printers(is_disabled):
	for p in _printers:
		disable_printer(p, is_disabled)

func get_printer(printer_key):
	return _printers[printer_key]

func _yield_text_terminal(text):
	var printer = _printers['terminal']
	if(_yield_calls != 0):
		printer.clear_line()
		printer.back(_last_yield_text.length())
	printer.send(text, fmts.yellow)

func _end_yield_terminal():
	var printer = _printers['terminal']
	printer.clear_line()
	printer.back(_last_yield_text.length())

func _yield_text_gui(text):
	pass
	# var lbl = _gut.get_gui().get_waiting_label()
	# lbl.visible = true
	# lbl.set_bbcode('[color=yellow]' + text + '[/color]')

func _end_yield_gui():
	pass
	# var lbl = _gut.get_gui().get_waiting_label()
	# lbl.visible = false
	# lbl.set_text('')

# This is used for displaying the "yield detected" and "yielding to" messages.
func yield_msg(text):
	if(_type_data.warn.enabled):
		self.log(text, fmts.yellow)

# This is used for the animated "waiting" message
func yield_text(text):
	_yield_text_terminal(text)
	_yield_text_gui(text)
	_last_yield_text = text
	_yield_calls += 1

# This is used for the animated "waiting" message
func end_yield():
	if(_yield_calls == 0):
		return
	_end_yield_terminal()
	_end_yield_gui()
	_yield_calls = 0
	_last_yield_text = ''

func get_gui_bbcode():
	return _printers.gui.get_bbcode()



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# This class wraps around the various printers and supplies formatting for the
# various message types (error, warning, etc).
# ##############################################################################

--- SCRIPT: res://addons/gut/method_maker.gd ---
class CallParameters:
	var p_name = null
	var default = null

	func _init(n,d):
		p_name = n
		default = d


# ------------------------------------------------------------------------------
# This class will generate method declaration lines based on method meta
# data.  It will create defaults that match the method data.
#
# --------------------
# function meta data
# --------------------
# name:
# flags:
# args: [{
# 	(class_name:),
# 	(hint:0),
# 	(hint_string:),
# 	(name:),
# 	(type:4),
# 	(usage:7)
# }]
# default_args []

var _lgr = GutUtils.get_logger()
var default_vararg_arg_count = 10
const PARAM_PREFIX = 'p_'

# ------------------------------------------------------
# _supported_defaults
#
# This array contains all the data types that are supported for default values.
# If a value is supported it will contain either an empty string or a prefix
# that should be used when setting the parameter default value.
# For example int, real, bool do not need anything func(p1=1, p2=2.2, p3=false)
# but things like Vectors and Colors do since only the parameters to create a
# new Vector or Color are included in the metadata.
# ------------------------------------------------------
	# TYPE_NIL = 0  Variable is of type nil (only applied for null).
	# TYPE_BOOL = 1  Variable is of type bool.
	# TYPE_INT = 2  Variable is of type int.
	# TYPE_FLOAT = 3  Variable is of type float/real.
	# TYPE_STRING = 4  Variable is of type String.
	# TYPE_VECTOR2 = 5  Variable is of type Vector2.
	# TYPE_RECT2 = 6  Variable is of type Rect2.
	# TYPE_VECTOR3 = 7  Variable is of type Vector3.
	# TYPE_COLOR = 14  Variable is of type Color.
	# TYPE_OBJECT = 17  Variable is of type Object.
	# TYPE_DICTIONARY = 18  Variable is of type Dictionary.
	# TYPE_ARRAY = 19  Variable is of type Array.
	# TYPE_PACKED_VECTOR2_ARRAY = 24  Variable is of type PackedVector2Array.
	# TYPE_TRANSFORM3D = 13  Variable is of type Transform3D.
	# TYPE_TRANSFORM2D = 8  Variable is of type Transform2D.
	# TYPE_RID = 16  Variable is of type RID.
	# TYPE_PACKED_INT32_ARRAY = 21  Variable is of type PackedInt32Array.
	# TYPE_PACKED_FLOAT32_ARRAY = 22  Variable is of type PackedFloat32Array.
	# TYPE_PACKED_STRING_ARRAY = 23  Variable is of type PackedStringArray.


# TYPE_PLANE = 9  Variable is of type Plane.
# TYPE_QUATERNION = 10  Variable is of type Quaternion.
# TYPE_AABB = 11  Variable is of type AABB.
# TYPE_BASIS = 12  Variable is of type Basis.
# TYPE_NODE_PATH = 15  Variable is of type NodePath.
# TYPE_PACKED_BYTE_ARRAY = 20  Variable is of type PackedByteArray.
# TYPE_PACKED_VECTOR3_ARRAY = 25  Variable is of type PackedVector3Array.
# TYPE_PACKED_COLOR_ARRAY = 26  Variable is of type PackedColorArray.
# TYPE_MAX = 27  Marker for end of type constants.
# ------------------------------------------------------
var _supported_defaults = []

func _init():
	for _i in range(TYPE_MAX):
		_supported_defaults.append(null)

	# These types do not require a prefix for defaults
	_supported_defaults[TYPE_NIL] = ''
	_supported_defaults[TYPE_BOOL] = ''
	_supported_defaults[TYPE_INT] = ''
	_supported_defaults[TYPE_FLOAT] = ''
	_supported_defaults[TYPE_OBJECT] = ''
	_supported_defaults[TYPE_ARRAY] = ''
	_supported_defaults[TYPE_STRING] = ''
	_supported_defaults[TYPE_STRING_NAME] = ''
	_supported_defaults[TYPE_DICTIONARY] = ''
	_supported_defaults[TYPE_PACKED_VECTOR2_ARRAY] = ''
	_supported_defaults[TYPE_RID] = ''

	# These require a prefix for whatever default is provided
	_supported_defaults[TYPE_VECTOR2] = 'Vector2'
	_supported_defaults[TYPE_VECTOR2I] = 'Vector2i'
	_supported_defaults[TYPE_RECT2] = 'Rect2'
	_supported_defaults[TYPE_RECT2I] = 'Rect2i'
	_supported_defaults[TYPE_VECTOR3] = 'Vector3'
	_supported_defaults[TYPE_COLOR] = 'Color'
	_supported_defaults[TYPE_TRANSFORM2D] = 'Transform2D'
	_supported_defaults[TYPE_TRANSFORM3D] = 'Transform3D'
	_supported_defaults[TYPE_PACKED_INT32_ARRAY] = 'PackedInt32Array'
	_supported_defaults[TYPE_PACKED_FLOAT32_ARRAY] = 'PackedFloat32Array'
	_supported_defaults[TYPE_PACKED_STRING_ARRAY] = 'PackedStringArray'

# ###############
# Private
# ###############
var _func_text = GutUtils.get_file_as_text('res://addons/gut/double_templates/function_template.txt')
var _init_text = GutUtils.get_file_as_text('res://addons/gut/double_templates/init_template.txt')

func _is_supported_default(type_flag):
	return type_flag >= 0 and type_flag < _supported_defaults.size() and _supported_defaults[type_flag] != null


func _make_stub_default(method, index):
	return str('__gutdbl.default_val("', method, '",', index, ')')


func _make_arg_array(method_meta, override_size):
	var to_return = []

	var has_unsupported_defaults = false

	for i in range(method_meta.args.size()):
		var pname = method_meta.args[i].name
		var dflt_text = _make_stub_default(method_meta.name, i)
		to_return.append(CallParameters.new(PARAM_PREFIX + pname, dflt_text))

	var extra_params = GutUtils.nvl(override_size, 0)
	if(extra_params == 0):
		if(method_meta.flags & METHOD_FLAG_VARARG):
			extra_params = default_vararg_arg_count

	# Add in extra parameters from stub settings.
	if(extra_params > 0):
		for i in range(method_meta.args.size(), extra_params):
			var pname = str(PARAM_PREFIX, 'arg', i)
			var dflt_text = _make_stub_default(method_meta.name, i)
			to_return.append(CallParameters.new(pname, dflt_text))

	return [has_unsupported_defaults, to_return];


# Creates a list of parameters with defaults of null unless a default value is
# found in the metadata.  If a default is found in the meta then it is used if
# it is one we know how support.
#
# If a default is found that we don't know how to handle then this method will
# return null.
func _get_arg_text(arg_array):
	var text = ''

	for i in range(arg_array.size()):
		text += str(arg_array[i].p_name, '=', arg_array[i].default)
		if(i != arg_array.size() -1):
			text += ', '

	return text


# creates a call to the function in meta in the super's class.
func _get_super_call_text(method_name, args):
	var params = ''
	for i in range(args.size()):
		params += args[i].p_name
		if(i != args.size() -1):
			params += ', '

	return str('await super(', params, ')')


func _get_spy_call_parameters_text(args):
	var called_with = 'null'

	if(args.size() > 0):
		called_with = '['
		for i in range(args.size()):
			called_with += args[i].p_name
			if(i < args.size() - 1):
				called_with += ', '
		called_with += ']'

	return called_with


# ###############
# Public
# ###############

func _get_init_text(meta, args, method_params, param_array):
	var text = null

	var decleration = str('func ', meta.name, '(', method_params, ')')
	var super_params = ''
	if(args.size() > 0):
		for i in range(args.size()):
			super_params += args[i].p_name
			if(i != args.size() -1):
				super_params += ', '

	text = _init_text.format({
		"func_decleration":decleration,
		"super_params":super_params,
		"param_array":param_array,
		"method_name":meta.name,
	})

	return text


# Creates a delceration for a function based off of function metadata.  All
# types whose defaults are supported will have their values.  If a datatype
# is not supported and the parameter has a default, a warning message will be
# printed and the declaration will return null.
func get_function_text(meta, override_size=null):
	var method_params = ''
	var text = null
	var result = _make_arg_array(meta, override_size)
	var has_unsupported = result[0]
	var args = result[1]
	var vararg_warning = ""

	var param_array = _get_spy_call_parameters_text(args)
	if(has_unsupported):
		# This will cause a runtime error.  This is the most convenient way to
		# to stop running before the error gets more obscure.  _make_arg_array
		# generates a gut error when unsupported defaults are found.
		method_params = null
	else:
		method_params = _get_arg_text(args);

	if(param_array == 'null'):
		param_array = '[]'

	if(meta.flags & METHOD_FLAG_VARARG and override_size == null):
		vararg_warning = "__gutdbl.vararg_warning()\n\t"

	if(method_params != null):
		if(meta.name == '_init'):
			text =  _get_init_text(meta, args, method_params, param_array)
		else:
			var decleration = str('func ', meta.name, '(', method_params, '):')
			text = _func_text.format({
				"func_decleration":decleration,
				"method_name":meta.name,
				"param_array":param_array,
				"super_call":_get_super_call_text(meta.name, args),
				"vararg_warning":vararg_warning,
			})

	return text


func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger

--- SCRIPT: res://addons/gut/one_to_many.gd ---
# ------------------------------------------------------------------------------
# This datastructure represents a simple one-to-many relationship.  It manages
# a dictionary of value/array pairs.  It ignores duplicates of both the "one"
# and the "many".
# ------------------------------------------------------------------------------
var _items = {}

# return the size of _items or the size of an element in _items if "one" was
# specified.
func size(one=null):
	var to_return = 0
	if(one == null):
		to_return = _items.size()
	elif(_items.has(one)):
		to_return = _items[one].size()
	return to_return

# Add an element to "one" if it does not already exist
func add(one, many_item):
	if(_items.has(one) and !_items[one].has(many_item)):
		_items[one].append(many_item)
	else:
		_items[one] = [many_item]

func clear():
	_items.clear()

func has(one, many_item):
	var to_return = false
	if(_items.has(one)):
		to_return = _items[one].has(many_item)
	return to_return

func to_s():
	var to_return = ''
	for key in _items:
		to_return += str(key, ":  ", _items[key], "\n")
	return to_return

--- SCRIPT: res://addons/gut/orphan_counter.gd ---
# ------------------------------------------------------------------------------
# This is used to track the change in orphans over different intervals.
# You use this by adding a counter at the start of an interval and then
# using get_orphans_since to find out how many orphans have been created since
# that counter was added.
#
# For example, when a test starts, gut adds a counter for "test" which
# creates/sets the counter's value to the current orphan count.  At the end of
# the test GUT uses get_orphans_since("test") to find out how many orphans
# were created by the test.
# ------------------------------------------------------------------------------
var _counters = {}

func orphan_count():
	return Performance.get_monitor(Performance.OBJECT_ORPHAN_NODE_COUNT)

func add_counter(name):
	_counters[name] = orphan_count()

# Returns the number of orphans created since add_counter was last called for
# the name.  Returns -1 to avoid blowing up with an invalid name but still
# be somewhat visible that we've done something wrong.
func get_orphans_since(name):
	return orphan_count() - _counters[name] if _counters.has(name) else -1

func get_count(name):
	return _counters.get(name, -1)

func print_orphans(name, lgr):
	var count = get_orphans_since(name)

	if(count > 0):
		var o = 'orphan'
		if(count > 1):
			o = 'orphans'
		lgr.orphan(str(count, ' new ', o, ' in ', name, '.'))

func print_all():
	var msg = str("Total Orphans ", orphan_count(), "\n", JSON.stringify(_counters, "    "))
	print(msg)



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# This is a utility for tracking changes in the orphan count.  Each time
# add_counter is called it adds/resets the value in the dictionary to the
# current number of orphans.  Each call to get_counter will return the change
# in orphans since add_counter was last called.
# ##############################################################################

--- SCRIPT: res://addons/gut/parameter_factory.gd ---
## Creates parameter structures for parameterized tests.
##
## This is a static class accessible in a [GutTest] script through
## [member GutTest.ParameterFactory].  It contains methods for constructing parameters to be
## used in parameterized tests.  It currently only has one, if you have anyu
## ideas for more, make an issue.  More of them would be great since I prematurely
## decided to make this static class and it has such a long name.  I'd feel a lot
## better about it if there was more in here.
## [br]
## Additional Helper Ideas?[br]
## [li]File.  IDK what it would look like.  csv maybe.[/li]
## [li]Random values within a range?[/li]
## [li]All int values in a range or add an optioanal step.[/li]




## Creates an array of dictionaries.  It pairs up the names array with each set
## of values in values.  If more names than values are specified then the missing
## values will be filled with nulls.  If more values than names are specified
## those values will be ignored.
##
## Example:
##[codeblock]
## create_named_parameters(['a', 'b'], [[1, 2], ['one', 'two']]) returns
##    [{a:1, b:2}, {a:'one', b:'two'}]
##[/codeblock]
## [br]
## This allows you to increase readability of your parameterized tests:
## [br]
##[codeblock]
## var params = create_named_parameters(['a', 'b'], [[1, 2], ['one', 'two']])
## func test_foo(p = use_parameters(params)):
##    assert_eq(p.a, p.b)
##[/codeblock]
## [br]
## Parameters:[br]
##[li]names:  an array of names to be used as keys in the dictionaries[/li]
##[li]values:  an array of arrays of values.[/li]
static func named_parameters(names, values):
	var named = []
	for i in range(values.size()):
		var entry = {}

		var parray = values[i]
		if(typeof(parray) != TYPE_ARRAY):
			parray = [values[i]]

		for j in range(names.size()):
			if(j >= parray.size()):
				entry[names[j]] = null
			else:
				entry[names[j]] = parray[j]
		named.append(entry)

	return named



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# This is the home for all parameter creation helpers.  These functions should
# all return an array of values to be used as parameters for parameterized
# tests.
# ##############################################################################

--- SCRIPT: res://addons/gut/parameter_handler.gd ---
var _params = null
var _call_count = 0
var _logger = null

func _init(params=null):
	_params = params
	_logger = GutUtils.get_logger()
	if(typeof(_params) != TYPE_ARRAY):
		_logger.error('You must pass an array to parameter_handler constructor.')
		_params = null


func next_parameters():
	_call_count += 1
	return _params[_call_count -1]

func get_current_parameters():
	return _params[_call_count]

func is_done():
	var done = true
	if(_params != null):
		done = _call_count == _params.size()
	return done

func get_logger():
	return _logger

func set_logger(logger):
	_logger = logger

func get_call_count():
	return _call_count

func get_parameter_count():
	return _params.size()

--- SCRIPT: res://addons/gut/printers.gd ---
# ------------------------------------------------------------------------------
# Interface and some basic functionality for all printers.
# ------------------------------------------------------------------------------
class Printer:
	var _format_enabled = true
	var _disabled = false
	var _printer_name = 'NOT SET'
	var _show_name = false # used for debugging, set manually

	func get_format_enabled():
		return _format_enabled

	func set_format_enabled(format_enabled):
		_format_enabled = format_enabled

	func send(text, fmt=null):
		if(_disabled):
			return

		var formatted = text
		if(fmt != null and _format_enabled):
			formatted = format_text(text, fmt)

		if(_show_name):
			formatted = str('(', _printer_name, ')') + formatted

		_output(formatted)

	func get_disabled():
		return _disabled

	func set_disabled(disabled):
		_disabled = disabled

	# --------------------
	# Virtual Methods (some have some default behavior)
	# --------------------
	func _output(text):
		pass

	func format_text(text, fmt):
		return text

# ------------------------------------------------------------------------------
# Responsible for sending text to a GUT gui.
# ------------------------------------------------------------------------------
class GutGuiPrinter:
	extends Printer
	var _textbox = null

	var _colors = {
			red = Color.RED,
			yellow = Color.YELLOW,
			green = Color.GREEN
	}

	func _init():
		_printer_name = 'gui'

	func _wrap_with_tag(text, tag):
		return str('[', tag, ']', text, '[/', tag, ']')

	func _color_text(text, c_word):
		return '[color=' + c_word + ']' + text + '[/color]'

	# Remember, we have to use push and pop because the output from the tests
	# can contain [] in it which can mess up the formatting.  There is no way
	# as of 3.4 that you can get the bbcode out of RTL when using push and pop.
	#
	# The only way we could get around this is by adding in non-printable
	# whitespace after each "[" that is in the text.  Then we could maybe do
	# this another way and still be able to get the bbcode out, or generate it
	# at the same time in a buffer (like we tried that one time).
	#
	# Since RTL doesn't have good search and selection methods, and those are
	# really handy in the editor, it isn't worth making bbcode that can be used
	# there as well.
	#
	# You'll try to get it so the colors can be the same in the editor as they
	# are in the output.  Good luck, and I hope I typed enough to not go too
	# far that rabbit hole before finding out it's not worth it.
	func format_text(text, fmt):
		if(_textbox == null):
			return

		if(fmt == 'bold'):
			_textbox.push_bold()
		elif(fmt == 'underline'):
			_textbox.push_underline()
		elif(_colors.has(fmt)):
			_textbox.push_color(_colors[fmt])
		else:
			# just pushing something to pop.
			_textbox.push_normal()

		_textbox.add_text(text)
		_textbox.pop()

		return ''

	func _output(text):
		if(_textbox == null):
			return

		_textbox.add_text(text)

	func get_textbox():
		return _textbox

	func set_textbox(textbox):
		_textbox = textbox

	# This can be very very slow when the box has a lot of text.
	func clear_line():
		_textbox.remove_line(_textbox.get_line_count() - 1)
		_textbox.queue_redraw()

	func get_bbcode():
		return _textbox.text

	func get_disabled():
		return _disabled and _textbox != null

# ------------------------------------------------------------------------------
# This AND TerminalPrinter should not be enabled at the same time since it will
# result in duplicate output.  printraw does not print to the console so i had
# to make another one.
# ------------------------------------------------------------------------------
class ConsolePrinter:
	extends Printer
	var _buffer = ''

	func _init():
		_printer_name = 'console'

	# suppresses output until it encounters a newline to keep things
	# inline as much as possible.
	func _output(text):
		if(text.ends_with("\n")):
			print(_buffer + text.left(text.length() -1))
			_buffer = ''
		else:
			_buffer += text

# ------------------------------------------------------------------------------
# Prints text to terminal, formats some words.
# ------------------------------------------------------------------------------
class TerminalPrinter:
	extends Printer

	var escape = PackedByteArray([0x1b]).get_string_from_ascii()
	var cmd_colors  = {
		red = escape + '[31m',
		yellow = escape + '[33m',
		green = escape + '[32m',

		underline = escape + '[4m',
		bold = escape + '[1m',

		default = escape + '[0m',

		clear_line = escape + '[2K'
	}

	func _init():
		_printer_name = 'terminal'

	func _output(text):
		# Note, printraw does not print to the console.
		printraw(text)

	func format_text(text, fmt):
		return cmd_colors[fmt] + text + cmd_colors.default

	func clear_line():
		send(cmd_colors.clear_line)

	func back(n):
		send(escape + str('[', n, 'D'))

	func forward(n):
		send(escape + str('[', n, 'C'))

--- SCRIPT: res://addons/gut/result_exporter.gd ---
# ------------------------------------------------------------------------------
# Creates a structure that contains all the data about the results of running
# tests.  This was created to make an intermediate step organizing the result
# of a run and exporting it in a specific format.  This can also serve as a
# unofficial GUT export format.
# ------------------------------------------------------------------------------
var json = JSON.new()

func _export_tests(collected_script):
	var to_return = {}
	var tests = collected_script.tests
	for test in tests:
		if(test.get_status_text() != GutUtils.TEST_STATUSES.NOT_RUN):
			to_return[test.name] = {
				"status":test.get_status_text(),
				"passing":test.pass_texts,
				"failing":test.fail_texts,
				"pending":test.pending_texts,
				"orphans":test.orphans,
				"time_taken": test.time_taken
			}

	return to_return

# TODO
#	errors
func _export_scripts(collector):
	if(collector == null):
		return {}

	var scripts = {}

	for s in collector.scripts:
		var test_data = _export_tests(s)
		scripts[s.get_full_name()] = {
			'props':{
				"tests":test_data.keys().size(),
				"pending":s.get_pending_count(),
				"failures":s.get_fail_count(),
			},
			"tests":test_data
		}
	return scripts

func _make_results_dict():
	var result =  {
		'test_scripts':{
			"props":{
				"pending":0,
				"failures":0,
				"passing":0,
				"tests":0,
				"time":0,
				"orphans":0,
				"errors":0,
				"warnings":0
			},
			"scripts":[]
		}
	}
	return result


func get_results_dictionary(gut, include_scripts=true):
	var scripts = []

	if(include_scripts):
		scripts = _export_scripts(gut.get_test_collector())

	var result =  _make_results_dict()

	var totals = gut.get_summary().get_totals()

	var props = result.test_scripts.props
	props.pending = totals.pending
	props.failures = totals.failing
	props.passing = totals.passing_tests
	props.tests = totals.tests
	props.errors = gut.logger.get_errors().size()
	props.warnings = gut.logger.get_warnings().size()
	props.time =  gut.get_elapsed_time()
	props.orphans = gut.get_orphan_counter().get_orphans_since('pre_run')
	result.test_scripts.scripts = scripts

	return result


func write_json_file(gut, path):
	var dict = get_results_dictionary(gut)
	var json_text = JSON.stringify(dict, ' ')

	var f_result = GutUtils.write_file(path, json_text)
	if(f_result != OK):
		var msg = str("Error:  ", f_result, ".  Could not create export file ", path)
		GutUtils.get_logger().error(msg)

	return f_result



func write_summary_file(gut, path):
	var dict = get_results_dictionary(gut, false)
	var json_text = JSON.stringify(dict, ' ')

	var f_result = GutUtils.write_file(path, json_text)
	if(f_result != OK):
		var msg = str("Error:  ", f_result, ".  Could not create export file ", path)
		GutUtils.get_logger().error(msg)

	return f_result

--- SCRIPT: res://addons/gut/script_parser.gd ---
# These methods didn't have flags that would exclude them from being used
# in a double and they appear to break things if they are included.
const BLACKLIST = [
	'get_script',
	'has_method',
]


# ------------------------------------------------------------------------------
# Combins the meta for the method with additional information.
# * flag for whether the method is local
# * adds a 'default' property to all parameters that can be easily checked per
#   parameter
# ------------------------------------------------------------------------------
class ParsedMethod:
	const NO_DEFAULT = '__no__default__'

	var _meta = {}
	var meta = _meta :
		get: return _meta
		set(val): return;

	var is_local = false
	var _parameters = []

	func _init(metadata):
		_meta = metadata
		var start_default = _meta.args.size() - _meta.default_args.size()
		for i in range(_meta.args.size()):
			var arg = _meta.args[i]
			# Add a "default" property to the metadata so we don't have to do
			# weird default paramter position math again.
			if(i >= start_default):
				arg['default'] = _meta.default_args[start_default - i]
			else:
				arg['default'] = NO_DEFAULT
			_parameters.append(arg)


	func is_eligible_for_doubling():
		var has_bad_flag = _meta.flags & \
			(METHOD_FLAG_OBJECT_CORE | METHOD_FLAG_VIRTUAL | METHOD_FLAG_STATIC)
		return !has_bad_flag and BLACKLIST.find(_meta.name) == -1


	func is_accessor():
		return _meta.name.begins_with('@') and \
			(_meta.name.ends_with('_getter') or _meta.name.ends_with('_setter'))


	func to_s():
		var s = _meta.name + "("

		for i in range(_meta.args.size()):
			var arg = _meta.args[i]
			if(str(arg.default) != NO_DEFAULT):
				var val = str(arg.default)
				if(val == ''):
					val = '""'
				s += str(arg.name, ' = ', val)
			else:
				s += str(arg.name)

			if(i != _meta.args.size() -1):
				s += ', '

		s += ")"
		return s




# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
class ParsedScript:
	# All methods indexed by name.
	var _methods_by_name = {}

	var _script_path = null
	var script_path = _script_path :
		get: return _script_path
		set(val): return;

	var _subpath = null
	var subpath = null :
		get: return _subpath
		set(val): return;

	var _resource = null
	var resource = null :
		get: return _resource
		set(val): return;


	var _is_native = false
	var is_native = _is_native:
		get: return _is_native
		set(val): return;

	var _native_methods = {}
	var _native_class_name = ""



	func _init(script_or_inst, inner_class=null):
		var to_load = script_or_inst

		if(GutUtils.is_native_class(to_load)):
			_resource = to_load
			_is_native = true
			var inst = to_load.new()
			_native_class_name = inst.get_class()
			_native_methods = inst.get_method_list()
			if(!inst is RefCounted):
				inst.free()
		else:
			if(!script_or_inst is Resource):
				to_load = load(script_or_inst.get_script().get_path())

			_script_path = to_load.resource_path
			if(inner_class != null):
				_subpath = _find_subpath(to_load, inner_class)

			if(inner_class == null):
				_resource = to_load
			else:
				_resource = inner_class
				to_load = inner_class

		_parse_methods(to_load)


	func _print_flags(meta):
		print(str(meta.name, ':').rpad(30), str(meta.flags).rpad(4), ' = ', GutUtils.dec2bistr(meta.flags, 10))


	func _get_native_methods(base_type):
		var to_return = []
		if(base_type != null):
			var source = str('extends ', base_type)
			var inst = GutUtils.create_script_from_source(source).new()
			to_return = inst.get_method_list()
			if(! inst is RefCounted):
				inst.free()
		return to_return


	func _parse_methods(thing):
		var methods = []
		if(is_native):
			methods = _native_methods.duplicate()
		else:
			var base_type = thing.get_instance_base_type()
			methods = _get_native_methods(base_type)

		for m in methods:
			var parsed = ParsedMethod.new(m)
			_methods_by_name[m.name] = parsed
			# _init must always be included so that we can initialize
			# double_tools
			if(m.name == '_init'):
				parsed.is_local = true


		# This loop will overwrite all entries in _methods_by_name with the local
		# method object so there is only ever one listing for a function with
		# the right "is_local" flag.
		if(!is_native):
			methods = thing.get_script_method_list()
			for m in methods:
				var parsed_method = ParsedMethod.new(m)
				parsed_method.is_local = true
				_methods_by_name[m.name] = parsed_method


	func _find_subpath(parent_script, inner):
		var const_map = parent_script.get_script_constant_map()
		var consts = const_map.keys()
		var const_idx = 0
		var found = false
		var to_return = null

		while(const_idx < consts.size() and !found):
			var key = consts[const_idx]
			var const_val = const_map[key]
			if(typeof(const_val) == TYPE_OBJECT):
				if(const_val == inner):
					found = true
					to_return = key
				else:
					to_return = _find_subpath(const_val, inner)
					if(to_return != null):
						to_return = str(key, '.', to_return)
						found = true

			const_idx += 1

		return to_return


	func get_method(name):
		return _methods_by_name[name]


	func get_super_method(name):
		var to_return = get_method(name)
		if(to_return.is_local):
			to_return = null

		return to_return

	func get_local_method(name):
		var to_return = get_method(name)
		if(!to_return.is_local):
			to_return = null

		return to_return


	func get_sorted_method_names():
		var keys = _methods_by_name.keys()
		keys.sort()
		return keys


	func get_local_method_names():
		var names = []
		for method in _methods_by_name:
			if(_methods_by_name[method].is_local):
				names.append(method)

		return names


	func get_super_method_names():
		var names = []
		for method in _methods_by_name:
			if(!_methods_by_name[method].is_local):
				names.append(method)

		return names


	func get_local_methods():
		var to_return = []
		for key in _methods_by_name:
			var method = _methods_by_name[key]
			if(method.is_local):
				to_return.append(method)
		return to_return


	func get_super_methods():
		var to_return = []
		for key in _methods_by_name:
			var method = _methods_by_name[key]
			if(!method.is_local):
				to_return.append(method)
		return to_return


	func get_extends_text():
		var text = null
		if(is_native):
			text = str("extends ", _native_class_name)
		else:
			text = str("extends '", _script_path, "'")
			if(_subpath != null):
				text += '.' + _subpath
		return text


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
var scripts = {}

func _get_instance_id(thing):
	var inst_id = null

	if(GutUtils.is_native_class(thing)):
		var id_str = str(thing).replace("<", '').replace(">", '').split('#')[1]
		inst_id = id_str.to_int()
	elif(typeof(thing) == TYPE_STRING):
		if(FileAccess.file_exists(thing)):
			inst_id = load(thing).get_instance_id()
	else:
		inst_id = thing.get_instance_id()

	return inst_id


func parse(thing, inner_thing=null):
	var key = -1
	if(inner_thing == null):
		key = _get_instance_id(thing)
	else:
		key = _get_instance_id(inner_thing)

	var parsed = null

	if(key != null):
		if(scripts.has(key)):
			parsed = scripts[key]
		else:
			var obj = instance_from_id(_get_instance_id(thing))
			var inner = null
			if(inner_thing != null):
				inner = instance_from_id(_get_instance_id(inner_thing))

			if(obj is Resource or GutUtils.is_native_class(obj)):
				parsed = ParsedScript.new(obj, inner)
				scripts[key] = parsed

	return parsed

--- SCRIPT: res://addons/gut/signal_watcher.gd ---
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

# Some arbitrary string that should never show up by accident.  If it does, then
# shame on  you.
const ARG_NOT_SET = '_*_argument_*_is_*_not_set_*_'

# This hash holds the objects that are being watched, the signals that are being
# watched, and an array of arrays that contains arguments that were passed
# each time the signal was emitted.
#
# For example:
#	_watched_signals => {
#		ref1 => {
#			'signal1' => [[], [], []],
#			'signal2' => [[p1, p2]],
#			'signal3' => [[p1]]
#		},
#		ref2 => {
#			'some_signal' => [],
#			'other_signal' => [[p1, p2, p3], [p1, p2, p3], [p1, p2, p3]]
#		}
#	}
#
# In this sample:
#	- signal1 on the ref1 object was emitted 3 times and each time, zero
#	parameters were passed.
#	- signal3 on ref1 was emitted once and passed a single parameter
#	- some_signal on ref2 was never emitted.
#	- other_signal on ref2 was emitted 3 times, each time with 3 parameters.
var _watched_signals = {}
var _lgr = GutUtils.get_logger()

func _add_watched_signal(obj, name):
	# SHORTCIRCUIT - ignore dupes
	if(_watched_signals.has(obj) and _watched_signals[obj].has(name)):
		return

	if(!_watched_signals.has(obj)):
		_watched_signals[obj] = {name:[]}
	else:
		_watched_signals[obj][name] = []
	obj.connect(name,Callable(self,'_on_watched_signal').bind(obj,name))

# This handles all the signals that are watched.  It supports up to 9 parameters
# which could be emitted by the signal and the two parameters used when it is
# connected via watch_signal.  I chose 9 since you can only specify up to 9
# parameters when dynamically calling a method via call (per the Godot
# documentation, i.e. some_object.call('some_method', 1, 2, 3...)).
#
# Based on the documentation of emit_signal, it appears you can only pass up
# to 4 parameters when firing a signal.  I haven't verified this, but this should
# future proof this some if the value ever grows.
func _on_watched_signal(arg1=ARG_NOT_SET, arg2=ARG_NOT_SET, arg3=ARG_NOT_SET, \
						arg4=ARG_NOT_SET, arg5=ARG_NOT_SET, arg6=ARG_NOT_SET, \
						arg7=ARG_NOT_SET, arg8=ARG_NOT_SET, arg9=ARG_NOT_SET, \
						arg10=ARG_NOT_SET, arg11=ARG_NOT_SET):
	var args = [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11]

	# strip off any unused vars.
	var idx = args.size() -1
	while(str(args[idx]) == ARG_NOT_SET):
		args.remove_at(idx)
		idx -= 1

	# retrieve object and signal name from the array and remove_at them.  These
	# will always be at the end since they are added when the connect happens.
	var signal_name = args[args.size() -1]
	args.pop_back()
	var object = args[args.size() -1]
	args.pop_back()

	if(_watched_signals.has(object)):
		_watched_signals[object][signal_name].append(args)
	else:
		_lgr.error(str("signal_watcher._on_watched_signal:  Got signal for unwatched object:  ", object, '::', signal_name))

# This parameter stuff should go into test.gd not here.  This thing works
# just fine the way it is.
func _obj_name_pair(obj_or_signal, signal_name=null):
	var to_return = {
		'object' : obj_or_signal,
		'signal_name' : signal_name
	}
	if(obj_or_signal is Signal):
		to_return.object =  obj_or_signal.get_object()
		to_return.signal_name = obj_or_signal.get_name()

	return to_return


func does_object_have_signal(object, signal_name):
	var signals = object.get_signal_list()
	for i in range(signals.size()):
		if(signals[i]['name'] == signal_name):
			return true
	return false

func watch_signals(object):
	var signals = object.get_signal_list()
	for i in range(signals.size()):
		_add_watched_signal(object, signals[i]['name'])

func watch_signal(object, signal_name):
	var did = false
	if(does_object_have_signal(object, signal_name)):
		_add_watched_signal(object, signal_name)
		did = true
	else:
		GutUtils.get_logger().warn(str(object, ' does not have signal ', signal_name))
	return did

func get_emit_count(object, signal_name):
	var to_return = -1
	if(is_watching(object, signal_name)):
		to_return = _watched_signals[object][signal_name].size()
	return to_return

func did_emit(object, signal_name=null):
	var vals = _obj_name_pair(object, signal_name)
	var did = false
	if(is_watching(vals.object, vals.signal_name)):
		did = get_emit_count(vals.object, vals.signal_name) != 0
	return did

func print_object_signals(object):
	var list = object.get_signal_list()
	for i in range(list.size()):
		print(list[i].name, "\n  ", list[i])

func get_signal_parameters(object, signal_name, index=-1):
	var params = null
	if(is_watching(object, signal_name)):
		var all_params = _watched_signals[object][signal_name]
		if(all_params.size() > 0):
			if(index == -1):
				index = all_params.size() -1
			params = all_params[index]
	return params

func is_watching_object(object):
	return _watched_signals.has(object)

func is_watching(object, signal_name):
	return _watched_signals.has(object) and _watched_signals[object].has(signal_name)

func clear():
	for obj in _watched_signals:
		if(GutUtils.is_not_freed(obj)):
			for signal_name in _watched_signals[obj]:
				obj.disconnect(signal_name, Callable(self,'_on_watched_signal'))
	_watched_signals.clear()

# Returns a list of all the signal names that were emitted by the object.
# If the object is not being watched then an empty list is returned.
func get_signals_emitted(obj):
	var emitted = []
	if(is_watching_object(obj)):
		for signal_name in _watched_signals[obj]:
			if(_watched_signals[obj][signal_name].size() > 0):
				emitted.append(signal_name)

	return emitted


func get_signal_summary(obj):
	var emitted = {}
	if(is_watching_object(obj)):
		for signal_name in _watched_signals[obj]:
			if(_watched_signals[obj][signal_name].size() > 0):
				# maybe this could return parameters if any were sent.  should
				# have an empty list if no parameters were ever sent to the
				# signal.  Or this all just gets moved into print_signal_summary
				# since this wouldn't be that useful without more data in the
				# summary.
				var entry = {
					emit_count = get_emit_count(obj, signal_name)
				}
				emitted[signal_name] = entry

	return emitted


func print_signal_summary(obj):
	if(!is_watching_object(obj)):
		var msg = str('Not watching signals for ', obj)
		GutUtils.get_logger().warn(msg)
		return

	var summary = get_signal_summary(obj)
	print(obj, '::Signals')
	var sorted = summary.keys()
	sorted.sort()
	for key in sorted:
		print(' -  ', key, ' x ', summary[key].emit_count)

--- SCRIPT: res://addons/gut/spy.gd ---
# {
#   instance_id_or_path1:{
#       method1:[ [p1, p2], [p1, p2] ],
#       method2:[ [p1, p2], [p1, p2] ]
#   },
#   instance_id_or_path1:{
#       method1:[ [p1, p2], [p1, p2] ],
#       method2:[ [p1, p2], [p1, p2] ]
#   },
# }
var _calls = {}
var _lgr = GutUtils.get_logger()
var _compare = GutUtils.Comparator.new()

func _find_parameters(call_params, params_to_find):
	var found = false
	var idx = 0
	while(idx < call_params.size() and !found):
		var result = _compare.deep(call_params[idx], params_to_find)
		if(result.are_equal):
			found = true
		else:
			idx += 1
	return found


func _get_params_as_string(params):
	var to_return = ''
	if(params == null):
		return ''

	for i in range(params.size()):
		if(params[i] == null):
			to_return += 'null'
		else:
			if(typeof(params[i]) == TYPE_STRING):
				to_return += str('"', params[i], '"')
			else:
				to_return += str(params[i])
		if(i != params.size() -1):
			to_return += ', '
	return to_return


func add_call(variant, method_name, parameters=null):
	if(!_calls.has(variant)):
		_calls[variant] = {}

	if(!_calls[variant].has(method_name)):
		_calls[variant][method_name] = []

	_calls[variant][method_name].append(parameters)


func was_called(variant, method_name, parameters=null):
	var to_return = false
	if(_calls.has(variant) and _calls[variant].has(method_name)):
		if(parameters):
			to_return = _find_parameters(_calls[variant][method_name], parameters)
		else:
			to_return = true
	return to_return


func get_call_parameters(variant, method_name, index=-1):
	var to_return = null
	var get_index = -1

	if(_calls.has(variant) and _calls[variant].has(method_name)):
		var call_size = _calls[variant][method_name].size()
		if(index == -1):
			# get the most recent call by default
			get_index =  call_size -1
		else:
			get_index = index

		if(get_index < call_size):
			to_return = _calls[variant][method_name][get_index]
		else:
			_lgr.error(str('Specified index ', index, ' is outside range of the number of registered calls:  ', call_size))

	return to_return


func call_count(instance, method_name, parameters=null):
	var to_return = 0

	if(was_called(instance, method_name)):
		if(parameters):
			for i in range(_calls[instance][method_name].size()):
				if(_calls[instance][method_name][i] == parameters):
					to_return += 1
		else:
			to_return = _calls[instance][method_name].size()
	return to_return


func clear():
	_calls = {}


func get_call_list_as_string(instance):
	var to_return = ''
	if(_calls.has(instance)):
		for method in _calls[instance]:
			for i in range(_calls[instance][method].size()):
				to_return += str(method, '(', _get_params_as_string(_calls[instance][method][i]), ")\n")
	return to_return


func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger

--- SCRIPT: res://addons/gut/strutils.gd ---
class_name GutStringUtils

# Hash containing all the built in types in Godot.  This provides an English
# name for the types that corosponds with the type constants defined in the
# engine.
var types = {}

func _init_types_dictionary():
	types[TYPE_NIL] = 'NIL'
	types[TYPE_AABB] = 'AABB'
	types[TYPE_ARRAY] = 'ARRAY'
	types[TYPE_BASIS] = 'BASIS'
	types[TYPE_BOOL] = 'BOOL'
	types[TYPE_CALLABLE] = 'CALLABLE'
	types[TYPE_COLOR] = 'COLOR'
	types[TYPE_DICTIONARY] = 'DICTIONARY'
	types[TYPE_FLOAT] = 'FLOAT'
	types[TYPE_INT] = 'INT'
	types[TYPE_MAX] = 'MAX'
	types[TYPE_NODE_PATH] = 'NODE_PATH'
	types[TYPE_OBJECT] = 'OBJECT'
	types[TYPE_PACKED_BYTE_ARRAY] = 'PACKED_BYTE_ARRAY'
	types[TYPE_PACKED_COLOR_ARRAY] = 'PACKED_COLOR_ARRAY'
	types[TYPE_PACKED_FLOAT32_ARRAY] = 'PACKED_FLOAT32_ARRAY'
	types[TYPE_PACKED_FLOAT64_ARRAY] = 'PACKED_FLOAT64_ARRAY'
	types[TYPE_PACKED_INT32_ARRAY] = 'PACKED_INT32_ARRAY'
	types[TYPE_PACKED_INT64_ARRAY] = 'PACKED_INT64_ARRAY'
	types[TYPE_PACKED_STRING_ARRAY] = 'PACKED_STRING_ARRAY'
	types[TYPE_PACKED_VECTOR2_ARRAY] = 'PACKED_VECTOR2_ARRAY'
	types[TYPE_PACKED_VECTOR3_ARRAY] = 'PACKED_VECTOR3_ARRAY'
	types[TYPE_PLANE] = 'PLANE'
	types[TYPE_PROJECTION] = 'PROJECTION'
	types[TYPE_QUATERNION] = 'QUATERNION'
	types[TYPE_RECT2] = 'RECT2'
	types[TYPE_RECT2I] = 'RECT2I'
	types[TYPE_RID] = 'RID'
	types[TYPE_SIGNAL] = 'SIGNAL'
	types[TYPE_STRING_NAME] = 'STRING_NAME'
	types[TYPE_STRING] = 'STRING'
	types[TYPE_TRANSFORM2D] = 'TRANSFORM2D'
	types[TYPE_TRANSFORM3D] = 'TRANSFORM3D'
	types[TYPE_VECTOR2] = 'VECTOR2'
	types[TYPE_VECTOR2I] = 'VECTOR2I'
	types[TYPE_VECTOR3] = 'VECTOR3'
	types[TYPE_VECTOR3I] = 'VECTOR3I'
	types[TYPE_VECTOR4] = 'VECTOR4'
	types[TYPE_VECTOR4I] = 'VECTOR4I'

# Types to not be formatted when using _str
var _str_ignore_types = [
	TYPE_INT, TYPE_FLOAT, TYPE_STRING,
	TYPE_NIL, TYPE_BOOL
]

func _init():
	_init_types_dictionary()

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
func _get_filename(path):
	return path.split('/')[-1]

# ------------------------------------------------------------------------------
# Gets the filename of an object passed in.  This does not return the
# full path to the object, just the filename.
# ------------------------------------------------------------------------------
func _get_obj_filename(thing):
	var filename = null

	if(thing == null or
		GutUtils.is_native_class(thing) or
		!is_instance_valid(thing) or
		str(thing) == '<Object#null>' or
		typeof(thing) != TYPE_OBJECT or
		GutUtils.is_double(thing)):
		return

	if(thing.get_script() == null):
		if(thing is PackedScene):
			filename = _get_filename(thing.resource_path)
		else:
			# If it isn't a packed scene and it doesn't have a script then
			# we do nothing.  This just reads better.
			pass
	elif(!GutUtils.is_native_class(thing)):
		var dict = inst_to_dict(thing)
		filename = _get_filename(dict['@path'])
		if(str(dict['@subpath']) != ''):
			filename += str('/', dict['@subpath'])

	return filename

# ------------------------------------------------------------------------------
# Better object/thing to string conversion.  Includes extra details about
# whatever is passed in when it can/should.
# ------------------------------------------------------------------------------
func type2str(thing):
	var filename = _get_obj_filename(thing)
	var str_thing = str(thing)

	if(thing == null):
		# According to str there is a difference between null and an Object
		# that is somehow null.  To avoid getting '[Object:null]' as output
		# always set it to str(null) instead of str(thing).  A null object
		# will pass typeof(thing) == TYPE_OBJECT check so this has to be
		# before that.
		str_thing = str(null)
	elif(typeof(thing) == TYPE_FLOAT):
		if(!'.' in str_thing):
			str_thing += '.0'
	elif(typeof(thing) == TYPE_STRING):
		str_thing = str('"', thing, '"')
	elif(typeof(thing) in _str_ignore_types):
		# do nothing b/c we already have str(thing) in
		# to_return.  I think this just reads a little
		# better this way.
		pass
	elif(typeof(thing) == TYPE_OBJECT):
		if(GutUtils.is_native_class(thing)):
			str_thing = GutUtils.get_native_class_name(thing)
		elif(GutUtils.is_double(thing)):
			var double_path = _get_filename(thing.__gutdbl.thepath)
			if(thing.__gutdbl.subpath != ''):
				double_path += str('/', thing.__gutdbl.subpath)
			elif(thing.__gutdbl.from_singleton != ''):
				double_path = thing.__gutdbl.from_singleton + " Singleton"

			var double_type = "double"
			if(thing.__gutdbl.is_partial):
				double_type = "partial-double"

			str_thing += str("(", double_type, " of ", double_path, ")")

			filename = null
	elif(types.has(typeof(thing))):
		if(!str_thing.begins_with('(')):
			str_thing = '(' + str_thing + ')'
		str_thing = str(types[typeof(thing)], str_thing)

	if(filename != null):
		str_thing += str('(', filename, ')')
	return str_thing

# ------------------------------------------------------------------------------
# Returns the string truncated with an '...' in it.  Shows the start and last
# 10 chars.  If the string is  smaller than max_size the entire string is
# returned.  If max_size is -1 then truncation is skipped.
# ------------------------------------------------------------------------------
func truncate_string(src, max_size):
	var to_return = src
	if(src.length() > max_size - 10 and max_size != -1):
		to_return = str(src.substr(0, max_size - 10), '...',  src.substr(src.length() - 10, src.length()))
	return to_return


func _get_indent_text(times, pad):
	var to_return = ''
	for i in range(times):
		to_return += pad

	return to_return

func indent_text(text, times, pad):
	if(times == 0):
		return text

	var to_return = text
	var ending_newline = ''

	if(text.ends_with("\n")):
		ending_newline = "\n"
		to_return = to_return.left(to_return.length() -1)

	var padding = _get_indent_text(times, pad)
	to_return = to_return.replace("\n", "\n" + padding)
	to_return += ending_newline

	return padding + to_return

--- SCRIPT: res://addons/gut/stubber.gd ---
# -------------
# returns{} and parameters {} have the followin structure
# -------------
# {
# 	inst_id_or_path1:{
# 		method_name1: [StubParams, StubParams],
# 		method_name2: [StubParams, StubParams]
# 	},
# 	inst_id_or_path2:{
# 		method_name1: [StubParams, StubParams],
# 		method_name2: [StubParams, StubParams]
# 	}
# }
var returns = {}
var _lgr = GutUtils.get_logger()
var _strutils = GutUtils.Strutils.new()
var _class_db_name_hash = {}

func _init():
	_class_db_name_hash = _make_crazy_dynamic_over_engineered_class_db_hash()

# So, I couldn't figure out how to get to a reference for a GDNative Class
# using a string.  ClassDB has all thier names...so I made a hash using those
# names and the classes.  Then I dynmaically make a script that has that as
# the source and grab the hash out of it and return it.  Super Rube Golbergery,
# but tons of fun.
func _make_crazy_dynamic_over_engineered_class_db_hash():
	var text = "var all_the_classes: Dictionary = {\n"
	for classname in ClassDB.get_class_list():
		if(ClassDB.can_instantiate(classname)):
			text += str('"', classname, '": ', classname, ", \n")
		else:
			text += str('# ', classname, "\n")
	text += "}"
	var inst =  GutUtils.create_script_from_source(text).new()
	return inst.all_the_classes


func _find_matches(obj, method):
	var matches = null
	var last_not_null_parent = null

	# Search for what is passed in first.  This could be a class or an instance.
	# We want to find the instance before we find the class.  If we do not have
	# an entry for the instance then see if we have an entry for the class.
	if(returns.has(obj) and returns[obj].has(method)):
		matches = returns[obj][method]
	elif(GutUtils.is_instance(obj)):
		var parent = obj.get_script()
		var found = false
		while(parent != null and !found):
			found = returns.has(parent)

			if(!found):
				last_not_null_parent = parent
				parent = parent.get_base_script()

		# Could not find the script so check to see if a native class of this
		# type was stubbed.
		if(!found):
			var base_type = last_not_null_parent.get_instance_base_type()
			if(_class_db_name_hash.has(base_type)):
				parent = _class_db_name_hash[base_type]
				found = returns.has(parent)

		if(found and returns[parent].has(method)):
			matches = returns[parent][method]

	return matches


# Searches returns for an entry that matches the instance or the class that
# passed in obj is.
#
# obj can be an instance, class, or a path.
func _find_stub(obj, method, parameters=null, find_overloads=false):
	var to_return = null
	var matches = _find_matches(obj, method)

	if(matches == null):
		return null

	var param_match = null
	var null_match = null
	var overload_match = null

	for i in range(matches.size()):
		var cur_stub = matches[i]
		if(cur_stub.parameters == parameters):
			param_match = cur_stub

		if(cur_stub.parameters == null and !cur_stub.is_param_override_only()):
			null_match = cur_stub

		if(cur_stub.has_param_override()):
			if(overload_match == null || overload_match.is_script_default):
				overload_match = cur_stub

	if(find_overloads and overload_match != null):
		to_return = overload_match
	# We have matching parameter values so return the stub value for that
	elif(param_match != null):
		to_return = param_match
	# We found a case where the parameters were not specified so return
	# parameters for that.  Only do this if the null match is not *just*
	# a paramerter override stub.
	elif(null_match != null):
		to_return = null_match

	return to_return



# ##############
# Public
# ##############

func add_stub(stub_params):
	stub_params._lgr = _lgr
	var key = stub_params.stub_target

	if(!returns.has(key)):
		returns[key] = {}

	if(!returns[key].has(stub_params.stub_method)):
		returns[key][stub_params.stub_method] = []

	returns[key][stub_params.stub_method].append(stub_params)


# Gets a stubbed return value for the object and method passed in.  If the
# instance was stubbed it will use that, otherwise it will use the path and
# subpath of the object to try to find a value.
#
# It will also use the optional list of parameter values to find a value.  If
# the object was stubbed with no parameters than any parameters will match.
# If it was stubbed with specific parameter values then it will try to match.
# If the parameters do not match BUT there was also an empty parameter list stub
# then it will return those.
# If it cannot find anything that matches then null is returned.for
#
# Parameters
# obj:  this should be an instance of a doubled object.
# method:  the method called
# parameters:  optional array of parameter vales to find a return value for.
func get_return(obj, method, parameters=null):
	var stub_info = _find_stub(obj, method, parameters)

	if(stub_info != null):
		return stub_info.return_val
	else:
		_lgr.info(str('Call to [', method, '] was not stubbed for the supplied parameters ', parameters, '.  Null was returned.'))
		return null


func should_call_super(obj, method, parameters=null):
	var stub_info = _find_stub(obj, method, parameters)

	var is_partial = false
	if(typeof(obj) != TYPE_STRING): # some stubber tests test with strings
		is_partial = obj.__gutdbl.is_partial
	var should = is_partial

	if(stub_info != null):
		should = stub_info.call_super
	elif(!is_partial):
		# this log message is here because of how the generated doubled scripts
		# are structured.  With this log msg here, you will only see one
		# "unstubbed" info instead of multiple.
		_lgr.info('Unstubbed call to ' + method + '::' + _strutils.type2str(obj))
		should = false

	return should


func get_call_this(obj, method, parameters=null):
	var stub_info = _find_stub(obj, method, parameters)

	if(stub_info != null):
		return stub_info.call_this


func get_parameter_count(obj, method):
	var to_return = null
	var stub_info = _find_stub(obj, method, null, true)

	if(stub_info != null and stub_info.has_param_override()):
		to_return = stub_info.parameter_count

	return to_return


func get_default_value(obj, method, p_index):
	var to_return = null
	var stub_info = _find_stub(obj, method, null, true)

	if(stub_info != null and
		stub_info.parameter_defaults != null and
		stub_info.parameter_defaults.size() > p_index):

		to_return = stub_info.parameter_defaults[p_index]

	return to_return


func clear():
	returns.clear()


func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger


func to_s():
	var text = ''
	for thing in returns:
		text += str("-- ", thing, " --\n")
		for method in returns[thing]:
			text += str("\t", method, "\n")
			for i in range(returns[thing][method].size()):
				text += "\t\t" + returns[thing][method][i].to_s() + "\n"

	if(text == ''):
		text = 'Stubber is empty';

	return text


func stub_defaults_from_meta(target, method_meta):
	var params = GutUtils.StubParams.new(target, method_meta)
	params.is_script_default = true
	add_stub(params)

--- SCRIPT: res://addons/gut/stub_params.gd ---

var _lgr = GutUtils.get_logger()
var logger = _lgr :
	get: return _lgr
	set(val): _lgr = val

var return_val = null
var stub_target = null
# the parameter values to match method call on.
var parameters = null
var stub_method = null
var call_super = false
var call_this = null
# Whether this is a stub for default parameter values as they are defined in
# the script, and not an overridden default value.
var is_script_default = false

# -- Paramter Override --
# Parmater overrides are stored in here along with all the other stub info
# so that you can chain stubbing parameter overrides along with all the
# other stubbing.  This adds some complexity to the logic that tries to
# find the correct stub for a call by a double.  Since an instance of this
# class could be just a parameter override, or it could have been chained
# we have to have _paramter_override_only so that we know when to tell the
# difference.
var parameter_count = -1
var parameter_defaults = null
# Anything that would make this stub not just an override of paramters
# must set this flag to false.  This must be private bc the actual logic
# to determine if this stub is only an override is more complicated.
var _parameter_override_only = true
# --

const NOT_SET = '|_1_this_is_not_set_1_|'

func _init(target=null, method=null, _subpath=null):
	stub_target = target
	stub_method = method

	if(typeof(target) == TYPE_CALLABLE):
		stub_target = target.get_object()
		stub_method = target.get_method()
		parameters = target.get_bound_arguments()
		if(parameters.size() == 0):
			parameters = null
	elif(typeof(target) == TYPE_STRING):
		if(target.is_absolute_path()):
			stub_target = load(str(target))
		else:
			_lgr.warn(str(target, ' is not a valid path'))

	if(stub_target is PackedScene):
		stub_target = GutUtils.get_scene_script_object(stub_target)

	# this is used internally to stub default parameters for everything that is
	# doubled...or something.  Look for stub_defaults_from_meta for usage.  This
	# behavior is not to be used by end users.
	if(typeof(method) == TYPE_DICTIONARY):
		_load_defaults_from_metadata(method)


func _load_defaults_from_metadata(meta):
	stub_method = meta.name
	var values = meta.default_args.duplicate()
	while (values.size() < meta.args.size()):
		values.push_front(null)

	param_defaults(values)


func to_return(val):
	if(stub_method == '_init'):
		_lgr.error("You cannot stub _init to do nothing.  Super's _init is always called.")
	else:
		return_val = val
		call_super = false
		_parameter_override_only = false
	return self


func to_do_nothing():
	to_return(null)
	return self


func to_call_super():
	call_super = true
	_parameter_override_only = false
	return self


func to_call(callable : Callable):
	call_this = callable
	return self


func when_passed(p1=NOT_SET,p2=NOT_SET,p3=NOT_SET,p4=NOT_SET,p5=NOT_SET,p6=NOT_SET,p7=NOT_SET,p8=NOT_SET,p9=NOT_SET,p10=NOT_SET):
	parameters = [p1,p2,p3,p4,p5,p6,p7,p8,p9,p10]
	var idx = 0
	while(idx < parameters.size()):
		if(str(parameters[idx]) == NOT_SET):
			parameters.remove_at(idx)
		else:
			idx += 1
	return self


func param_count(x):
	parameter_count = x
	return self


func param_defaults(values):
	parameter_count = values.size()
	parameter_defaults = values
	return self


func has_param_override():
	return parameter_count != -1


func is_param_override_only():
	var ret_val = false
	if(has_param_override()):
		ret_val = _parameter_override_only
	return ret_val


func to_s():
	var base_string = str(stub_target, '.', stub_method)

	if(has_param_override()):
		base_string += str(' (param count override=', parameter_count, ' defaults=', parameter_defaults)
		if(is_param_override_only()):
			base_string += " ONLY"
		if(is_script_default):
			base_string += " script default"
		base_string += ') '

	if(call_super):
		base_string += " to call SUPER"

	if(call_this != null):
		base_string += str(" to call ", call_this)

	if(parameters != null):
		base_string += str(' with params (', parameters, ') returns ', return_val)
	else:
		base_string += str(' returns ', return_val)

	return base_string

--- SCRIPT: res://addons/gut/summary.gd ---
# ------------------------------------------------------------------------------
# Prints things, mostly.  Knows too much about gut.gd, but it's only supposed to
# work with gut.gd, so I'm fine with that.
# ------------------------------------------------------------------------------
# a _test_collector to use when one is not provided.
var _gut = null


func _init(gut=null):
	_gut = gut

# ---------------------
# Private
# ---------------------
func _log_end_run_header(gut):
	var lgr = gut.get_logger()
	lgr.log("\n\n\n")
	lgr.log('==============================================', lgr.fmts.yellow)
	lgr.log("= Run Summary", lgr.fmts.yellow)
	lgr.log('==============================================', lgr.fmts.yellow)


func _log_what_was_run(gut):
	if(!GutUtils.is_null_or_empty(gut._select_script)):
		gut.p('Ran Scripts matching "' + gut._select_script + '"')
	if(!GutUtils.is_null_or_empty(gut._unit_test_name)):
		gut.p('Ran Tests matching "' + gut._unit_test_name + '"')
	if(!GutUtils.is_null_or_empty(gut._inner_class_name)):
		gut.p('Ran Inner Classes matching "' + gut._inner_class_name + '"')


func _log_orphans_and_disclaimer(gut):
	var lgr = gut.get_logger()
	if(!lgr.is_type_enabled('orphan')):
		return

	var counter = gut.get_orphan_counter()
	# Do not count any of the test scripts since these will be released when GUT
	# is released.
	var do_not_count_orphans = counter.get_count("pre_run") + gut.get_test_script_count()
	var total_run_orphans = counter.orphan_count() - do_not_count_orphans

	if(total_run_orphans > 0):
		lgr.orphan(str("Total orphans in run ", total_run_orphans))
		gut.p("Note:  This count does not include GUT objects that will be freed upon exit.")
		gut.p("       It also does not include any orphans created by global scripts")
		gut.p("       loaded before tests were ran.")
		gut.p(str("Total orphans = ", counter.orphan_count()))
		gut.p('')


func _total_fmt(text, value):
	var space = 18
	if(str(value) == '0'):
		value = 'none'
	return str(text.rpad(space), value)


func _log_non_zero_total(text, value, lgr):
	if(str(value) != '0'):
		lgr.log(_total_fmt(text, value))
		return 1
	else:
		return 0


func _log_totals(gut, totals):
	var lgr = gut.get_logger()
	lgr.log()

	lgr.log("---- Totals ----")
	var issue_count = 0
	issue_count += _log_non_zero_total('Errors', totals.errors, lgr)
	issue_count += _log_non_zero_total('Warnings', totals.warnings, lgr)
	issue_count += _log_non_zero_total('Deprecated', totals.deprecated, lgr)
	if(issue_count > 0):
		lgr.log("")

	lgr.log(_total_fmt( 'Scripts', totals.scripts))
	lgr.log(_total_fmt( 'Tests', gut.get_test_collector().get_ran_test_count()))
	lgr.log(_total_fmt( '  Passing', totals.passing_tests))
	_log_non_zero_total('  Failing', totals.failing_tests, lgr)
	_log_non_zero_total('  Risky/Pending', totals.risky + totals.pending, lgr)
	lgr.log(_total_fmt( 'Asserts', totals.passing + totals.failing))
	lgr.log(_total_fmt( 'Time', str(gut.get_elapsed_time(), 's')))

	return totals


func _log_nothing_run(gut):
	var lgr = gut.get_logger()
	lgr.error("Nothing was run.")
	lgr.log('On the one hand nothing failed, on the other hand nothing did anything.')


# ---------------------
# Public
# ---------------------
func log_all_non_passing_tests(gut=_gut):
	var test_collector = gut.get_test_collector()
	var lgr = gut.get_logger()

	var to_return = {
		passing = 0,
		non_passing = 0
	}

	for test_script in test_collector.scripts:
		lgr.set_indent_level(0)

		if(test_script.was_skipped or test_script.get_fail_count() > 0 or test_script.get_pending_count() > 0):
			lgr.log("\n" + test_script.get_full_name(), lgr.fmts.underline)

		if(test_script.was_skipped):
			lgr.inc_indent()
			var skip_msg = str('[Risky] Script was skipped:  ', test_script.skip_reason)
			lgr.log(skip_msg, lgr.fmts.yellow)
			lgr.dec_indent()

		for test in test_script.tests:
			if(test.was_run):
				if(test.is_passing()):
					to_return.passing += 1
				else:
					to_return.non_passing += 1
					lgr.log(str('- ', test.name))
					lgr.inc_indent()

					for i in range(test.fail_texts.size()):
						lgr.failed(test.fail_texts[i])
					for i in range(test.pending_texts.size()):
						lgr.pending(test.pending_texts[i])
					if(test.is_risky()):
						lgr.risky('Did not assert')
					lgr.dec_indent()

	return to_return


func log_the_final_line(totals, gut):
	var lgr = gut.get_logger()
	var grand_total_text = ""
	var grand_total_fmt = lgr.fmts.none
	if(totals.failing_tests > 0):
		grand_total_text = str(totals.failing_tests, " failing tests")
		grand_total_fmt = lgr.fmts.red
	elif(totals.risky > 0 or totals.pending > 0):
		grand_total_text = str(totals.risky + totals.pending, " pending/risky tests.")
		grand_total_fmt = lgr.fmts.yellow
	else:
		grand_total_text = "All tests passed!"
		grand_total_fmt = lgr.fmts.green

	lgr.log(str("---- ", grand_total_text, " ----"), grand_total_fmt)


func log_totals(gut, totals):
	var lgr = gut.get_logger()
	var orig_indent = lgr.get_indent_level()
	lgr.set_indent_level(0)
	_log_totals(gut, totals)
	lgr.set_indent_level(orig_indent)


func get_totals(gut=_gut):
	var tc = gut.get_test_collector()
	var lgr = gut.get_logger()

	var totals = {
		failing = 0,
		failing_tests = 0,
		passing = 0,
		passing_tests = 0,
		pending = 0,
		risky = 0,
		scripts = tc.get_ran_script_count(),
		tests = 0,

		deprecated = lgr.get_deprecated().size(),
		errors = lgr.get_errors().size(),
		warnings = lgr.get_warnings().size(),
	}

	for s in tc.scripts:
		# assert totals
		totals.passing += s.get_pass_count()
		totals.pending += s.get_pending_count()
		totals.failing += s.get_fail_count()

		# test totals
		totals.tests += s.get_ran_test_count()
		totals.passing_tests += s.get_passing_test_count()
		totals.failing_tests += s.get_failing_test_count()
		totals.risky += s.get_risky_count()

	return totals


func log_end_run(gut=_gut):
	var totals = get_totals(gut)
	if(totals.tests == 0):
		_log_nothing_run(gut)
		return

	_log_end_run_header(gut)
	var lgr = gut.get_logger()

	log_all_non_passing_tests(gut)
	log_totals(gut, totals)
	lgr.log("\n")

	_log_orphans_and_disclaimer(gut)
	_log_what_was_run(gut)
	log_the_final_line(totals, gut)
	lgr.log("")

--- SCRIPT: res://addons/gut/test.gd ---
class_name GutTest
extends Node
## This is the base class for your GUT test scripts.[br]
## [br]
## GUT Wiki:  [url=https://gut.readthedocs.io]https://gut.readthedocs.io[/url]
## [br]
## Simple Example
## [codeblock]
##    extends GutTest
##
##    func before_all():
##        gut.p("before_all called"
##
##    func before_each():
##        gut.p("before_each called")
##
##    func after_each():
##        gut.p("after_each called")
##
##    func after_all():
##        gut.p("after_all called")
##
##    func test_assert_eq_letters():
##        assert_eq("asdf", "asdf", "Should pass")
##
##    func test_assert_eq_number_not_equal():
##        assert_eq(1, 2, "Should fail.  1 != 2")
## [/codeblock]


# Normalizes p1 and p2 into object/signal_name/signal_ref(sig).  Additional
# parameters are optional and will be placed into the others array.  This
# class is used in refactoring signal methods to accept a reference to the
# signal instead an object and the signal name.
class SignalAssertParameters:
	var object = null
	var signal_name = null
	var sig = null
	var others := []

	func _init(p1, p2, p3=null, p4=null, p5=null, p6=null):
		others = [p3, p4, p5, p6]
		if(p1 is Signal):
			object = p1.get_object()
			signal_name = p1.get_name()
			others.push_front(p2)
			sig = p1
		else:
			object = p1
			signal_name = p2
			sig = object.get(signal_name)


const EDITOR_PROPERTY = PROPERTY_USAGE_SCRIPT_VARIABLE | PROPERTY_USAGE_DEFAULT
const VARIABLE_PROPERTY = PROPERTY_USAGE_SCRIPT_VARIABLE
# Convenience copy of GutUtils.DOUBLE_STRATEGY
var DOUBLE_STRATEGY = GutUtils.DOUBLE_STRATEGY

## Reference to [addons/gut/parameter_factory.gd] script.
var ParameterFactory = GutUtils.ParameterFactory
## @ignore
var CompareResult = GutUtils.CompareResult
## Reference to [GutInputFactory] class that was originally used to reference
## the Input Factory before the class_name was introduced.
var InputFactory = GutInputFactory
## Reference to [GutInputSender].  This was the way you got to the [GutInputSender]
## before it was given a [code]class_name[/code]
var InputSender = GutUtils.InputSender

# Need a reference to the instance that is running the tests.  This
# is set by the gut class when it runs the test script.
var gut: GutMain = null


var _compare = GutUtils.Comparator.new()
var _disable_strict_datatype_checks = false
# Holds all the text for a test's fail/pass.  This is used for testing purposes
# to see the text of a failed sub-test in test_test.gd
var _fail_pass_text = []
# Summary counts for the test.
var _summary = {
	asserts = 0,
	passed = 0,
	failed = 0,
	tests = 0,
	pending = 0
}
# This is used to watch signals so we can make assertions about them.
var _signal_watcher = load('res://addons/gut/signal_watcher.gd').new()
var _lgr = GutUtils.get_logger()
var _strutils = GutUtils.Strutils.new()
var _awaiter = null
var _was_ready_called = false

# I haven't decided if we should be using _ready or not.  Right now gut.gd will
# call this if _ready was not called (because it was overridden without a super
# call).  Maybe gut.gd should just call _do_ready_stuff (after we rename it to
# something better).  I'm leaving all this as it is until it bothers me more.
func _do_ready_stuff():
	_awaiter = GutUtils.Awaiter.new()
	add_child(_awaiter)
	_was_ready_called = true


func _ready():
	_do_ready_stuff()


func _notification(what):
	# Tests are never expected to re-enter the tree.  Tests are removed from the
	# tree after they are run.
	if(what == NOTIFICATION_EXIT_TREE):
		_awaiter.queue_free()


#region Private
# ----------------


func _str(thing):
	return _strutils.type2str(thing)


func _str_precision(value, precision):
	var to_return = _str(value)
	var format = str('%.', precision, 'f')
	if(typeof(value) == TYPE_FLOAT):
		to_return = format % value
	elif(typeof(value) == TYPE_VECTOR2):
		to_return = str('VECTOR2(', format % value.x, ', ', format %value.y, ')')
	elif(typeof(value) == TYPE_VECTOR3):
		to_return = str('VECTOR3(', format % value.x, ', ', format %value.y, ', ', format % value.z, ')')

	return to_return


# Fail an assertion.  Causes test and script to fail as well.
func _fail(text):
	_summary.asserts += 1
	_summary.failed += 1
	_fail_pass_text.append('failed:  ' + text)
	if(gut):
		_lgr.failed(gut.get_call_count_text() + text)
		gut._fail(text)


# Pass an assertion.
func _pass(text):
	_summary.asserts += 1
	_summary.passed += 1
	_fail_pass_text.append('passed:  ' + text)
	if(gut):
		_lgr.passed(text)
		gut._pass(text)


# Checks if the datatypes passed in match.  If they do not then this will cause
# a fail to occur.  If they match then TRUE is returned, FALSE if not.  This is
# used in all the assertions that compare values.
func _do_datatypes_match__fail_if_not(got, expected, text):
	var did_pass = true

	if(!_disable_strict_datatype_checks):
		var got_type = typeof(got)
		var expect_type = typeof(expected)
		if(got_type != expect_type and got != null and expected != null):
			# If we have a mismatch between float and int (types 2 and 3) then
			# print out a warning but do not fail.
			if([2, 3].has(got_type) and [2, 3].has(expect_type)):
				_lgr.warn(str('Warn:  Float/Int comparison.  Got ', _strutils.types[got_type],
					' but expected ', _strutils.types[expect_type]))
			elif([TYPE_STRING, TYPE_STRING_NAME].has(got_type) and [TYPE_STRING, TYPE_STRING_NAME].has(expect_type)):
				pass
			else:
				_fail('Cannot compare ' + _strutils.types[got_type] + '[' + _str(got) + '] to ' + \
					_strutils.types[expect_type] + '[' + _str(expected) + '].  ' + text)
				did_pass = false

	return did_pass


# Create a string that lists all the methods that were called on an spied
# instance.
func _get_desc_of_calls_to_instance(inst):
	var BULLET = '  * '
	var calls = gut.get_spy().get_call_list_as_string(inst)
	# indent all the calls
	calls = BULLET + calls.replace("\n", "\n" + BULLET)
	# remove_at trailing newline and bullet
	calls = calls.substr(0, calls.length() - BULLET.length() - 1)
	return "Calls made on " + str(inst) + "\n" + calls



# Signal assertion helper.  Do not call directly, use _can_make_signal_assertions
func _fail_if_does_not_have_signal(object, signal_name):
	var did_fail = false
	if(!_signal_watcher.does_object_have_signal(object, signal_name)):
		_fail(str('Object ', object, ' does not have the signal [', signal_name, ']'))
		did_fail = true
	return did_fail


# Signal assertion helper.  Do not call directly, use _can_make_signal_assertions
func _fail_if_not_watching(object):
	var did_fail = false
	if(!_signal_watcher.is_watching_object(object)):
		_fail(str('Cannot make signal assertions because the object ', object, \
				' is not being watched.  Call watch_signals(some_object) to be able to make assertions about signals.'))
		did_fail = true
	return did_fail


# Returns text that contains original text and a list of all the signals that
# were emitted for the passed in object.
func _get_fail_msg_including_emitted_signals(text, object):
	return str(text," (Signals emitted: ", _signal_watcher.get_signals_emitted(object), ")")


# This validates that parameters is an array and generates a specific error
# and a failure with a specific message
func _fail_if_parameters_not_array(parameters):
	var invalid = parameters != null and typeof(parameters) != TYPE_ARRAY
	if(invalid):
		_lgr.error('The "parameters" parameter must be an array of expected parameter values.')
		_fail('Cannot compare parameter values because an array was not passed.')
	return invalid


# A bunch of common checkes used when validating a double/method pair.  If
# everything is ok then an empty string is returned, otherwise the message
# is returned.
func _get_bad_double_or_method_message(inst, method_name, what_you_cant_do):
	var to_return = ''

	if(!GutUtils.is_double(inst)):
		to_return = str("An instance of a Double was expected, you passed:  ", _str(inst))
	elif(!inst.has_method(method_name)):
		to_return = str("You cannot ", what_you_cant_do, " [", method_name, "] because the method does not exist.  ",
			"This can happen if the method is virtual and not overloaded (i.e. _ready) ",
			"or you have mistyped the name of the method.")
	elif(!inst.__gutdbl_values.doubled_methods.has(method_name)):
		to_return = str("You cannot ", what_you_cant_do, " [", method_name, "] because ",
			_str(inst), ' does not overload it or it was ignored with ',
			'ignore_method_when_doubling.  See Doubling ',
			'Strategy in the wiki for details on including non-overloaded ',
			'methods in a double.')

	return to_return


func _fail_if_not_double_or_does_not_have_method(inst, method_name):
	var to_return = OK

	var msg = _get_bad_double_or_method_message(inst, method_name, 'spy on')
	if(msg != ''):
		_fail(msg)
		to_return = ERR_INVALID_DATA

	return to_return


func _create_obj_from_type(type):
	var obj = null
	if type.is_class("PackedScene"):
		obj = type.instantiate()
		add_child(obj)
	else:
		obj = type.new()
	return obj


# Converts a Callabe passed through inst or inst/method_name/parameters into a
# hash so that methods that interact with Spy can accept both more easily.
func _convert_spy_args(inst, method_name, parameters):
	var to_return = {
		'object':inst,
		'method_name':method_name,
		'arguments':parameters,
		'invalid_message':'ok'
	}

	if(inst is Callable):
		if(parameters != null):
			to_return.invalid_message =\
				"3rd parameter to assert_called not supported when using a Callable."
		elif(method_name != null):
			to_return.invalid_message =\
				"2nd parameter to assert_called not supported when using a Callable."
		else:
			if(inst.get_bound_arguments_count() > 0):
				to_return.arguments = inst.get_bound_arguments()
			to_return.method_name = inst.get_method()
			to_return.object = inst.get_object()

	return to_return


func _get_typeof_string(the_type):
	var to_return = ""
	if(_strutils.types.has(the_type)):
		to_return += str(the_type, '(',  _strutils.types[the_type], ')')
	else:
		to_return += str(the_type)
	return to_return


# Validates the singleton_name is a string and exists.  Errors when conditions
# are not met.  Returns true/false if singleton_name is valid or not.
func _validate_singleton_name(singleton_name):
	var is_valid = true
	if(typeof(singleton_name) != TYPE_STRING):
		_lgr.error("double_singleton requires a Godot singleton name, you passed " + _str(singleton_name))
		is_valid = false
	# Sometimes they have underscores in front of them, sometimes they do not.
	# The doubler is smart enought of ind the right thing, so this has to be
	# that smart as well.
	elif(!ClassDB.class_exists(singleton_name) and !ClassDB.class_exists('_' + singleton_name)):
		var txt = str("The singleton [", singleton_name, "] could not be found.  ",
					"Check the GlobalScope page for a list of singletons.")
		_lgr.error(txt)
		is_valid = false
	return is_valid


# Checks the object for 'get_' and 'set_' methods for the specified property.
# If found a warning is generated.
func _warn_for_public_accessors(obj, property_name):
	var public_accessors = []
	var accessor_names = [
		str('get_', property_name),
		str('is_', property_name),
		str('set_', property_name)
	]

	for acc in accessor_names:
		if(obj.has_method(acc)):
			public_accessors.append(acc)

	if(public_accessors.size() > 0):
		_lgr.warn (str('Public accessors ', public_accessors, ' found for property ', property_name))


func _smart_double(thing, double_strat, partial):
	var override_strat = GutUtils.nvl(double_strat, gut.get_doubler().get_strategy())
	var to_return = null

	if(thing is PackedScene):
		if(partial):
			to_return =  gut.get_doubler().partial_double_scene(thing, override_strat)
		else:
			to_return =  gut.get_doubler().double_scene(thing, override_strat)

	elif(GutUtils.is_native_class(thing)):
		if(partial):
			to_return = gut.get_doubler().partial_double_gdnative(thing)
		else:
			to_return = gut.get_doubler().double_gdnative(thing)

	elif(thing is GDScript):
		if(partial):
			to_return = gut.get_doubler().partial_double(thing, override_strat)
		else:
			to_return = gut.get_doubler().double(thing, override_strat)

	return to_return


# This is here to aid in the transition to the new doubling sytnax.  Once this
# has been established it could be removed.  We must keep the is_instance check
# going forward though.
func _are_double_parameters_valid(thing, p2, p3):
	var bad_msg = ""
	if(p3 != null or typeof(p2) == TYPE_STRING):
		bad_msg += "Doubling using a subpath is not supported.  Call register_inner_class and then pass the Inner Class to double().\n"

	if(typeof(thing) == TYPE_STRING):
		bad_msg += "Doubling using the path to a script or scene is no longer supported.  Load the script or scene and pass that to double instead.\n"

	if(GutUtils.is_instance(thing)):
		bad_msg += "double requires a script, you passed an instance:  " + _str(thing)

	if(bad_msg != ""):
		_lgr.error(bad_msg)

	return bad_msg == ""

# ----------------
#endregion
#region Virtual Methods
# ----------------

## Virtual Method.  This is run after the script has been prepped for execution, but before `before_all` is executed.  If you implement this method and return `true` or a `String` (the string is displayed in the log) then GUT will stop executing the script and mark it as risky.  You might want to do this because:
## - You are porting tests from 3.x to 4.x and you don't want to comment everything out.[br]
## - Skipping tests that should not be run when in `headless` mode such as input testing that does not work in headless.[br]
## [codeblock]
##    func should_skip_script():
##        if DisplayServer.get_name() == "headless":
##            return "Skip Input tests when running headless"
## [/codeblock]
## - If you have tests that would normally cause the debugger to break on an error, you can skip the script if the debugger is enabled so that the run is not interrupted.[br]
## [codeblock]
##    func should_skip_script():
##        return EngineDebugger.is_active()
## [/codeblock]
func should_skip_script():
	return false


## Virtual method.  Run once before anything else in the test script is run.
func before_all():
	pass


## Virtual method.  Run before each test is executed
func before_each():
	pass

## Virtual method.  Run after each test is executed.
func after_each():
	pass


## Virtual method.  Run after all tests have been run.
func after_all():
	pass

# ----------------
#endregion
#region Misc Public
# ----------------
## Mark the current test as pending.
func pending(text=""):
	_summary.pending += 1
	if(gut):
		_lgr.pending(text)
		gut._pending(text)


## Returns true if the test is passing as of the time of this call.  False if not.
func is_passing():
	if(gut.get_current_test_object() != null and
		!['before_all', 'after_all'].has(gut.get_current_test_object().name)):
		return gut.get_current_test_object().is_passing() and \
			gut.get_current_test_object().assert_count > 0
	else:
		_lgr.error('No current test object found.  is_passing must be called inside a test.')
		return null


## Returns true if the test is failing as of the time of this call.  False if not.
func is_failing():
	if(gut.get_current_test_object() != null and
		!['before_all', 'after_all'].has(gut.get_current_test_object().name)):

		return gut.get_current_test_object().is_failing()
	else:
		_lgr.error('No current test object found.  is_failing must be called inside a test.')
		return null


## Marks the test as passing.  Does not override any failing asserts or calls to
## fail_test.  Same as a passing assert.
func pass_test(text):
	_pass(text)


## Marks the test as failing.  Same as a failing assert.
func fail_test(text):
	_fail(text)

## @internal
func clear_signal_watcher():
	_signal_watcher.clear()


## Returns the current double strategy.
func get_double_strategy():
	return gut.get_doubler().get_strategy()


## Sets the double strategy for all tests in the script.  This should usually
## be done in [method before_all].  The double strtegy can be set per
## run/script/double.  See [wiki]Double-Strategy[/wiki]
func set_double_strategy(double_strategy):
	gut.get_doubler().set_strategy(double_strategy)


## This method will cause Gut to pause before it moves on to the next test.
## This is useful for debugging, for instance if you want to investigate the
## screen or anything else after a test has finished executing.
## [br]
## Sometimes you get lazy, and you don't remove calls to
## [code skip-lint]pause_before_teardown[/code] after you are done with them.  You can
## tell GUT to ignore calls to this method through the panel or
## the command line.  Setting this in your `.gutconfig.json` file is recommended
## for CI/CD Pipelines.
func pause_before_teardown():
	gut.pause_before_teardown()


## @internal
func get_logger():
	return _lgr

## @internal
func set_logger(logger):
	_lgr = logger


## This must be called in order to make assertions based on signals being
## emitted.  __Right now, this only supports signals that are emitted with 9 or
## less parameters.__  This can be extended but nine seemed like enough for now.
## The Godot documentation suggests that the limit is four but in my testing
## I found you can pass more.
## [br]
## This must be called in each test in which you want to make signal based
## assertions in.  You can call it multiple times with different objects.
## You should not call it multiple times with the same object in the same test.
## The objects that are watched are cleared after each test (specifically right
## before `teardown` is called).  Under the covers, Gut will connect to all the
## signals an object has and it will track each time they fire.  You can then
## use the following asserts and methods to verify things are acting correct.
func watch_signals(object):
	_signal_watcher.watch_signals(object)


## This will return the number of times a signal was fired.  This gives you
## the freedom to make more complicated assertions if the spirit moves you.
## This will return -1 if the signal was not fired or the object was not being
## watched, or if the object does not have the signal.
## [br][br]
## Accepts either the object and the signal name or the signal.
func get_signal_emit_count(p1, p2=null):
	var sp = SignalAssertParameters.new(p1, p2)
	return _signal_watcher.get_emit_count(sp.object, sp.signal_name)


## If you need to inspect the parameters in order to make more complicate assertions, then this will give you access to
## the parameters of any watched signal.  This works the same way that
## [code skip-lint]assert_signal_emitted_with_parameters[/code] does.  It takes an object, signal name, and an optional
## index.  If the index is not specified then the parameters from the most recent emission will be returned.  If the
## object is not being watched, the signal was not fired, or the object does not have the signal then `null` will be
## returned.
##
## [br][br]
## [b]Signatures:[/b][br]
## - get_signal_parameters([param p1]:Signal, [param p2]:parameter-index (optional))[br]
## - get_signal_parameters([param p1]:object, [param p2]:signal name, [param p3]:parameter-index (optional)) [br]
## [br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
##
## func test_get_signal_parameters():
##     var obj = SignalObject.new()
##     watch_signals(obj)
##     obj.some_signal.emit(1, 2, 3)
##     obj.some_signal.emit('a', 'b', 'c')
##
##     # -- Passing --
##     # passes because get_signal_parameters returns the most recent emission
##     # by default
##     assert_eq(get_signal_parameters(obj, 'some_signal'), ['a', 'b', 'c'])
##     assert_eq(get_signal_parameters(obj.some_signal), ['a', 'b', 'c'])
##
##     assert_eq(get_signal_parameters(obj, 'some_signal', 0), [1, 2, 3])
##     assert_eq(get_signal_parameters(obj.some_signal, 0), [1, 2, 3])
##
##     # if the signal was not fired null is returned
##     assert_null(get_signal_parameters(obj, 'other_signal'))
##     # if the signal does not exist or isn't being watched null is returned
##     assert_null(get_signal_parameters(obj, 'signal_dne'))
##
##     # -- Failing --
##     assert_eq(get_signal_parameters(obj, 'some_signal'), [1, 2, 3])
##     assert_eq(get_signal_parameters(obj.some_signal, 0), ['a', 'b', 'c'])
## [/codeblock]
func get_signal_parameters(p1, p2=null, p3=-1):
	var sp := SignalAssertParameters.new(p1, GutUtils.nvl(p2, -1), p3)
	return _signal_watcher.get_signal_parameters(sp.object, sp.signal_name, sp.others[0])


## Get the parameters for a method call to a doubled object.  By default it will
## return the most recent call.  You can optionally specify an index for which
## call you want to get the parameters for.
##
## Can be called using a Callable for the first parameter instead of specifying
## an object and method name.  When you do this, the seoncd parameter is used
## as the index.
##
## Returns:
## * an array of parameter values if a call the method was found
## * null when a call to the method was not found or the index specified was
##   invalid.
func get_call_parameters(object, method_name_or_index = -1, idx=-1):
	var to_return = null
	var index = idx
	if(object is Callable):
		index = method_name_or_index
		method_name_or_index = null
	var converted = _convert_spy_args(object, method_name_or_index, null)

	if(GutUtils.is_double(converted.object)):
		to_return = gut.get_spy().get_call_parameters(
			converted.object, converted.method_name, index)
	else:
		_lgr.error('You must pass a doulbed object to get_call_parameters.')

	return to_return


## Returns the call count for a method with optional paramter matching.
##
## Can be called with a Callable instead of an object, method_name, and
## parameters.  Bound arguments will be used to match call arguments.
func get_call_count(object, method_name=null, parameters=null):
	var converted = _convert_spy_args(object, method_name, parameters)
	return gut.get_spy().call_count(converted.object, converted.method_name, converted.arguments)


## Simulate a number of frames by calling '_process' and '_physics_process' (if
## the methods exist) on an object and all of its descendents. The specified frame
## time, 'delta', will be passed to each simulated call.
##
## NOTE: Objects can disable their processing methods using 'set_process(false)' and
## 'set_physics_process(false)'. This is reflected in the 'Object' methods
## 'is_processing()' and 'is_physics_processing()', respectively. To make 'simulate'
## respect this status, for example if you are testing an object which toggles
## processing, pass 'check_is_processing' as 'true'.
func simulate(obj, times, delta, check_is_processing: bool = false):
	gut.simulate(obj, times, delta, check_is_processing)


# ------------------------------------------------------------------------------
## Replace the node at base_node.get_node(path) with with_this.  All references
## to the node via $ and get_node(...) will now return with_this.  with_this will
## get all the groups that the node that was replaced had.
## [br]
## The node that was replaced is queued to be freed.
## [br]
## TODO see replace_by method, this could simplify the logic here.
# ------------------------------------------------------------------------------
func replace_node(base_node, path_or_node, with_this):
	var path = path_or_node

	if(typeof(path_or_node) != TYPE_STRING):
		# This will cause an engine error if it fails.  It always returns a
		# NodePath, even if it fails.  Checking the name count is the only way
		# I found to check if it found something or not (after it worked I
		# didn't look any farther).
		path = base_node.get_path_to(path_or_node)
		if(path.get_name_count() == 0):
			_lgr.error('You passed an object that base_node does not have.  Cannot replace node.')
			return

	if(!base_node.has_node(path)):
		_lgr.error(str('Could not find node at path [', path, ']'))
		return

	var to_replace = base_node.get_node(path)
	var parent = to_replace.get_parent()
	var replace_name = to_replace.get_name()

	parent.remove_child(to_replace)
	parent.add_child(with_this)
	with_this.set_name(replace_name)
	with_this.set_owner(parent)

	var groups = to_replace.get_groups()
	for i in range(groups.size()):
		with_this.add_to_group(groups[i])

	to_replace.queue_free()


## Use this as the default value for the first parameter to a test to create
## a parameterized test.  See also the ParameterFactory and Parameterized Tests.
## [br][br]
## [b]Example[/b]
## [codeblock]
##    func test_with_parameters(p = use_parameters([1, 2, 3])):
## [/codeblock]
func use_parameters(params):
	var ph = gut.parameter_handler
	if(ph == null):
		ph = GutUtils.ParameterHandler.new(params)
		gut.parameter_handler = ph

	# DO NOT use gut.gd's get_call_count_text here since it decrements the
	# get_call_count value.  This method increments the call count in its
	# return statement.
	var output = str('- params[', ph.get_call_count(), ']','(', ph.get_current_parameters(), ')')
	gut.p(output, gut.LOG_LEVEL_TEST_AND_FAILURES)

	return ph.next_parameters()


## @internal
## When used as the default for a test method parameter, it will cause the test
## to be run x times.
##
## I Hacked this together to test a method that was occassionally failing due to
## timing issues.  I don't think it's a great idea, but you be the judge.  If
## you find a good use for it, let me know and I'll make it a legit member
## of the api.
func run_x_times(x):
	var ph = gut.parameter_handler
	if(ph == null):
		_lgr.warn(
			str("This test uses run_x_times and you really should not be ",
			"using it.  I don't think it's a good thing, but I did find it ",
			"temporarily useful so I left it in here and didn't document it.  ",
			"Well, you found it, might as well open up an issue and let me ",
			"know why you're doing this."))
		var params = []
		for i in range(x):
			params.append(i)

		ph = GutUtils.ParameterHandler.new(params)
		gut.parameter_handler = ph
	return ph.next_parameters()


## Checks the passed in version string (x.x.x) against the engine version to see
## if the engine version is less than the expected version.  If it is then the
## test is mareked as passed (for a lack of anything better to do).  The result
## of the check is returned.
## [br][br]
## [b]Example[/b]
## [codeblock]
##    if(skip_if_godot_version_lt('3.5.0')):
##        return
## [/codeblock]
func skip_if_godot_version_lt(expected):
	var should_skip = !GutUtils.is_godot_version_gte(expected)
	if(should_skip):
		_pass(str('Skipping: ', GutUtils.godot_version_string(), ' is less than ', expected))
	return should_skip


## Checks if the passed in version matches the engine version.  The passed in
## version can contain just the major, major.minor or major.minor.path.  If
## the version is not the same then the test is marked as passed.  The result of
## the check is returned.
## [br][br]
## [b]Example[/b]
## [codeblock]
##     if(skip_if_godot_version_ne('3.4')):
##        return
## [/codeblock]
func skip_if_godot_version_ne(expected):
	var should_skip = !GutUtils.is_godot_version(expected)
	if(should_skip):
		_pass(str('Skipping: ', GutUtils.godot_version_string(), ' is not ', expected))
	return should_skip


## Registers all the inner classes in a script with the doubler.  This is required
## before you can double any inner class.
func register_inner_classes(base_script):
	gut.get_doubler().inner_class_registry.register(base_script)


## Peforms a deep compare on both values, a CompareResult instnace is returned.
## The optional max_differences paramter sets the max_differences to be displayed.
func compare_deep(v1, v2, max_differences=null):
	var result = _compare.deep(v1, v2)
	if(max_differences != null):
		result.max_differences = max_differences
	return result


# ----------------
#endregion
#region Asserts
# ----------------

## Asserts that the expected value equals the value got.
## assert got == expected and prints optional text.  See [wiki]Comparing-Things[/wiki]
## for information about comparing dictionaries and arrays.
## [br]
## See also: [method assert_ne], [method assert_same], [method assert_not_same]
## [codeblock]
##    var one = 1
##    var node1 = Node.new()
##    var node2 = node1
##
##    # Passing
##    assert_eq(one, 1, 'one should equal one')
##    assert_eq('racecar', 'racecar')
##    assert_eq(node2, node1)
##    assert_eq([1, 2, 3], [1, 2, 3])
##    var d1_pass = {'a':1}
##    var d2_pass = d1_pass
##    assert_eq(d1_pass, d2_pass)
##
##    # Failing
##    assert_eq(1, 2) # FAIL
##    assert_eq('hello', 'world')
##    assert_eq(self, node1)
##    assert_eq([1, 'two', 3], [1, 2, 3, 4])
##    assert_eq({'a':1}, {'a':1})
## [/codeblock]
func assert_eq(got, expected, text=""):

	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		var disp = "[" + _str(got) + "] expected to equal [" + _str(expected) + "]:  " + text
		var result = null

		result = _compare.simple(got, expected)

		if(typeof(got) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			disp = str(result.summary, '  ', text)
			_lgr.info('Array/Dictionary compared by value.  Use assert_same to compare references.  Use assert_eq_deep to see diff when failing.')

		if(result.are_equal):
			_pass(disp)
		else:
			_fail(disp)


## asserts got != expected and prints optional text.  See
## [wiki]Comparing-Things[/wiki] for information about comparing dictionaries
## and arrays.
##[br]
## See also: [method assert_eq], [method assert_same], [method assert_not_same]
## [codeblock]
##    var two = 2
##    var node1 = Node.new()
##
##    # Passing
##    assert_ne(two, 1, 'Two should not equal one.')
##    assert_ne('hello', 'world')
##    assert_ne(self, node1)
##
##    # Failing
##    assert_ne(two, 2)
##    assert_ne('one', 'one')
##    assert_ne('2', 2)
## [/codeblock]
func assert_ne(got, not_expected, text=""):
	if(_do_datatypes_match__fail_if_not(got, not_expected, text)):
		var disp = "[" + _str(got) + "] expected to not equal [" + _str(not_expected) + "]:  " + text
		var result = null

		result = _compare.simple(got, not_expected)

		if(typeof(got) in [TYPE_ARRAY, TYPE_DICTIONARY]):
			disp = str(result.summary, '  ', text)
			_lgr.info('Array/Dictionary compared by value.  Use assert_not_same to compare references.  Use assert_ne_deep to see diff.')

		if(result.are_equal):
			_fail(disp)
		else:
			_pass(disp)


## Asserts that [param got] is within the range of [param expected] +/- [param error_interval].
## The upper and lower bounds are included in the check.  Verified to work with
## integers, floats, and Vector2.  Should work with anything that can be
## added/subtracted.
##
## [codeblock]
##    # Passing
##    assert_almost_eq(0, 1, 1, '0 within range of 1 +/- 1')
##    assert_almost_eq(2, 1, 1, '2 within range of 1 +/- 1')
##    assert_almost_eq(1.2, 1.0, .5, '1.2 within range of 1 +/- .5')
##    assert_almost_eq(.5, 1.0, .5, '.5 within range of 1 +/- .5')
##    assert_almost_eq(Vector2(.5, 1.5), Vector2(1.0, 1.0), Vector2(.5, .5))
##    assert_almost_eq(Vector2(.5, 1.5), Vector2(1.0, 1.0), Vector2(.25, .25))
##
##    # Failing
##    assert_almost_eq(1, 3, 1, '1 outside range of 3 +/- 1')
##    assert_almost_eq(2.6, 3.0, .2, '2.6 outside range of 3 +/- .2')
## [/codeblock]
func assert_almost_eq(got, expected, error_interval, text=''):
	var disp = "[" + _str_precision(got, 20) + "] expected to equal [" + _str(expected) + "] +/- [" + str(error_interval) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text) and _do_datatypes_match__fail_if_not(got, error_interval, text)):
		if not _is_almost_eq(got, expected, error_interval):
			_fail(disp)
		else:
			_pass(disp)


## This is the inverse of [method assert_almost_eq].  This will pass if [param got] is
## outside the range of [param not_expected] +/- [param error_interval].
func assert_almost_ne(got, not_expected, error_interval, text=''):
	var disp = "[" + _str_precision(got, 20) + "] expected to not equal [" + _str(not_expected) + "] +/- [" + str(error_interval) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, not_expected, text) and _do_datatypes_match__fail_if_not(got, error_interval, text)):
		if _is_almost_eq(got, not_expected, error_interval):
			_fail(disp)
		else:
			_pass(disp)

# ------------------------------------------------------------------------------
# Helper function compares a value against a expected and a +/- range.  Compares
# all components of Vector2, Vector3, and Vector4 as well.
# ------------------------------------------------------------------------------
func _is_almost_eq(got, expected, error_interval) -> bool:
	var result = false
	var upper = expected + error_interval
	var lower = expected - error_interval

	if typeof(got) in [TYPE_VECTOR2, TYPE_VECTOR3, TYPE_VECTOR4]:
		result = got.clamp(lower, upper) == got
	else:
		result = got >= (lower) and got <= (upper)

	return(result)

## assserts got > expected
## [codeblock]
##    var bigger = 5
##    var smaller = 0
##
##    # Passing
##    assert_gt(bigger, smaller, 'Bigger should be greater than smaller')
##    assert_gt('b', 'a')
##    assert_gt('a', 'A')
##    assert_gt(1.1, 1)
##
##    # Failing
##    assert_gt('a', 'a')
##    assert_gt(1.0, 1)
##    assert_gt(smaller, bigger)
## [/codeblock]
func assert_gt(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be > than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got > expected):
			_pass(disp)
		else:
			_fail(disp)


## Asserts got is greater than or equal to expected.
## [codeblock]
##    var bigger = 5
##    var smaller = 0
##
##    # Passing
##    assert_gte(bigger, smaller, 'Bigger should be greater than or equal to smaller')
##    assert_gte('b', 'a')
##    assert_gte('a', 'A')
##    assert_gte(1.1, 1)
##    assert_gte('a', 'a')
##
##    # Failing
##    assert_gte(0.9, 1.0)
##    assert_gte(smaller, bigger)
## [/codeblock]
func assert_gte(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be >= than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got >= expected):
			_pass(disp)
		else:
			_fail(disp)

## Asserts [param got] is less than [param expected]
## [codeblock]
##    var bigger = 5
##    var smaller = 0
##
##    # Passing
##    assert_lt(smaller, bigger, 'Smaller should be less than bigger')
##    assert_lt('a', 'b')
##    assert_lt(99, 100)
##
##    # Failing
##    assert_lt('z', 'x')
##    assert_lt(-5, -5)
## [/codeblock]
func assert_lt(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be < than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got < expected):
			_pass(disp)
		else:
			_fail(disp)


## Asserts got is less than or equal to expected
func assert_lte(got, expected, text=""):
	var disp = "[" + _str(got) + "] expected to be <= than [" + _str(expected) + "]:  " + text
	if(_do_datatypes_match__fail_if_not(got, expected, text)):
		if(got <= expected):
			_pass(disp)
		else:
			_fail(disp)


## asserts that got is true.  Does not assert truthiness, only boolean values
## will pass.
func assert_true(got, text=""):
	if(typeof(got) == TYPE_BOOL):
		if(got):
			_pass(text)
		else:
			_fail(text)
	else:
		var msg = str("Cannot convert ", _strutils.type2str(got), " to boolean")
		_fail(msg)


## Asserts that got is false.  Does not assert truthiness, only boolean values
## will pass.
func assert_false(got, text=""):
	if(typeof(got) == TYPE_BOOL):
		if(got):
			_fail(text)
		else:
			_pass(text)
	else:
		var msg = str("Cannot convert ", _strutils.type2str(got), " to boolean")
		_fail(msg)


## Asserts value is between (inclusive) the two expected values.[br]
## got >= expect_low and <= expect_high
## [codeblock]
##    # Passing
##    assert_between(5, 0, 10, 'Five should be between 0 and 10')
##    assert_between(10, 0, 10)
##    assert_between(0, 0, 10)
##    assert_between(2.25, 2, 4.0)
##
##    # Failing
##    assert_between('a', 'b', 'c')
##    assert_between(1, 5, 10)
## [/codeblock]
func assert_between(got, expect_low, expect_high, text=""):
	var disp = "[" + _str_precision(got, 20) + "] expected to be between [" + _str(expect_low) + "] and [" + str(expect_high) + "]:  " + text

	if(_do_datatypes_match__fail_if_not(got, expect_low, text) and _do_datatypes_match__fail_if_not(got, expect_high, text)):
		if(expect_low > expect_high):
			disp = "INVALID range.  [" + str(expect_low) + "] is not less than [" + str(expect_high) + "]"
			_fail(disp)
		else:
			if(got < expect_low or got > expect_high):
				_fail(disp)
			else:
				_pass(disp)


## Asserts value is not between (exclusive) the two expected values.[br]
## asserts that got <= expect_low or got >=  expect_high.
## [codeblock]
##    # Passing
##    assert_not_between(1, 5, 10)
##    assert_not_between('a', 'b', 'd')
##    assert_not_between('d', 'b', 'd')
##    assert_not_between(10, 0, 10)
##    assert_not_between(-2, -2, 10)
##
##    # Failing
##    assert_not_between(5, 0, 10, 'Five shouldnt be between 0 and 10')
##    assert_not_between(0.25, -2.0, 4.0)
## [/codeblock]
func assert_not_between(got, expect_low, expect_high, text=""):
	var disp = "[" + _str_precision(got, 20) + "] expected not to be between [" + _str(expect_low) + "] and [" + str(expect_high) + "]:  " + text

	if(_do_datatypes_match__fail_if_not(got, expect_low, text) and _do_datatypes_match__fail_if_not(got, expect_high, text)):
		if(expect_low > expect_high):
			disp = "INVALID range.  [" + str(expect_low) + "] is not less than [" + str(expect_high) + "]"
			_fail(disp)
		else:
			if(got > expect_low and got < expect_high):
				_fail(disp)
			else:
				_pass(disp)


## Uses the 'has' method of the object passed in to determine if it contains
## the passed in element.
## [codeblock]
##    var an_array = [1, 2, 3, 'four', 'five']
##    var a_hash = { 'one':1, 'two':2, '3':'three'}
##
##    # Passing
##    assert_has(an_array, 'four') # PASS
##    assert_has(an_array, 2) # PASS
##    # the hash's has method checks indexes not values
##    assert_has(a_hash, 'one') # PASS
##    assert_has(a_hash, '3') # PASS
##
##    # Failing
##    assert_has(an_array, 5) # FAIL
##    assert_has(an_array, self) # FAIL
##    assert_has(a_hash, 3) # FAIL
##    assert_has(a_hash, 'three') # FAIL
## [/codeblock]
func assert_has(obj, element, text=""):
	var disp = str('Expected [', _str(obj), '] to contain value:  [', _str(element), ']:  ', text)
	if(obj.has(element)):
		_pass(disp)
	else:
		_fail(disp)


## The inverse of assert_has.
func assert_does_not_have(obj, element, text=""):
	var disp = str('Expected [', _str(obj), '] to NOT contain value:  [', _str(element), ']:  ', text)
	if(obj.has(element)):
		_fail(disp)
	else:
		_pass(disp)


## asserts a file exists at the specified path
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_exists():
##        # Passing
##        assert_file_exists('res://addons/gut/gut.gd')
##        assert_file_exists('user://some_test_file')
##
##        # Failing
##        assert_file_exists('user://file_does_not.exist')
##        assert_file_exists('res://some_dir/another_dir/file_does_not.exist')
## [/codeblock]
func assert_file_exists(file_path):
	var disp = 'expected [' + file_path + '] to exist.'
	if(FileAccess.file_exists(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## asserts a file does not exist at the specified path
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_does_not_exist():
##        # Passing
##        assert_file_does_not_exist('user://file_does_not.exist')
##        assert_file_does_not_exist('res://some_dir/another_dir/file_does_not.exist')
##
##        # Failing
##        assert_file_does_not_exist('res://addons/gut/gut.gd')
## [/codeblock]
func assert_file_does_not_exist(file_path):
	var disp = 'expected [' + file_path + '] to NOT exist'
	if(!FileAccess.file_exists(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## asserts the specified file is empty
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_empty():
##        # Passing
##        assert_file_empty('user://some_test_file')
##
##        # Failing
##        assert_file_empty('res://addons/gut/gut.gd')
## [/codeblock]
func assert_file_empty(file_path):
	var disp = 'expected [' + file_path + '] to be empty'
	if(FileAccess.file_exists(file_path) and gut.is_file_empty(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## Asserts the specified file is not empty
## [codeblock]
##    func before_each():
##        gut.file_touch('user://some_test_file')
##
##    func after_each():
##        gut.file_delete('user://some_test_file')
##
##    func test_assert_file_not_empty():
##        # Passing
##        assert_file_not_empty('res://addons/gut/gut.gd') # PASS
##
##        # Failing
##        assert_file_not_empty('user://some_test_file') # FAIL
## [/codeblock]
func assert_file_not_empty(file_path):
	var disp = 'expected [' + file_path + '] to contain data'
	if(!gut.is_file_empty(file_path)):
		_pass(disp)
	else:
		_fail(disp)


## Asserts that the passed in object has a method named [param method].
func assert_has_method(obj, method, text=''):
	var disp = _str(obj) + ' should have method: ' + method
	if(text != ''):
		disp = _str(obj) + ' ' + text
	assert_true(obj.has_method(method), disp)


## This is meant to make testing public get/set methods for a member variable.  This was originally created for early Godot 3.x setter and getter methods.  See [method assert_property] for verifying Godot 4.x accessors.  This makes multiple assertions to verify:
## [br]
## [li]The object has a method called [code]get_<PROPERTY_NAME>[/code][/li]
## [li]The object has a method called [code]set_<PROPERTY_NAME>[/code][/li]
## [li]The method [code]get_<PROPERTY_NAME>[/code] returns the expected default value when first called.[/li]
## [li]Once you set the property, the [code]get_<PROPERTY_NAME>[/code] returns the new value.[/li]
## [br]
func assert_accessors(obj, property, default, set_to):
	var fail_count = _summary.failed
	var get_func = 'get_' + property
	var set_func = 'set_' + property

	if(obj.has_method('is_' + property)):
		get_func = 'is_' + property

	assert_has_method(obj, get_func, 'should have getter starting with get_ or is_')
	assert_has_method(obj, set_func)
	# SHORT CIRCUIT
	if(_summary.failed > fail_count):
		return
	assert_eq(obj.call(get_func), default, 'It should have the expected default value.')
	obj.call(set_func, set_to)
	assert_eq(obj.call(get_func), set_to, 'The set value should have been returned.')


# Property search helper.  Used to retrieve Dictionary of specified property
# from passed object. Returns null if not found.
# If provided, property_usage constrains the type of property returned by
# passing either:
# EDITOR_PROPERTY for properties defined as: export var some_value: int
# VARIABLE_PROPERTY for properties defined as: var another_value
func _find_object_property(obj, property_name, property_usage=null):
	var result = null
	var found = false
	var properties = obj.get_property_list()

	while !found and !properties.is_empty():
		var property = properties.pop_back()
		if property['name'] == property_name:
			if property_usage == null or property['usage'] == property_usage:
				result = property
				found = true
	return result


## Asserts that [param obj] exports a property with the name
## [param property_name] and a type of [param type].  The [param type] must be
## one of the various Godot built-in [code]TYPE_[/code] constants.
## [codeblock]
##    class ExportClass:
##        export var some_number = 5
##        export(PackedScene) var some_scene
##        var some_variable = 1
##
##    func test_assert_exports():
##        var obj = ExportClass.new()
##
##        # Passing
##        assert_exports(obj, "some_number", TYPE_INT)
##        assert_exports(obj, "some_scene", TYPE_OBJECT)
##
##        # Failing
##        assert_exports(obj, 'some_number', TYPE_VECTOR2)
##        assert_exports(obj, 'some_scene', TYPE_AABB)
##        assert_exports(obj, 'some_variable', TYPE_INT)
## [/codeblock]
func assert_exports(obj, property_name, type):
	var disp = 'expected %s to have editor property [%s]' % [_str(obj), property_name]
	var property = _find_object_property(obj, property_name, EDITOR_PROPERTY)
	if property != null:
		disp += ' of type [%s]. Got type [%s].' % [_strutils.types[type], _strutils.types[property['type']]]
		if property['type'] == type:
			_pass(disp)
		else:
			_fail(disp)
	else:
		_fail(disp)


# Signal assertion helper.
#
# Verifies that the object and signal are valid for making signal assertions.
# This will fail with specific messages that indicate why they are not valid.
# This returns true/false to indicate if the object and signal are valid.
func _can_make_signal_assertions(object, signal_name):
	return !(_fail_if_not_watching(object) or _fail_if_does_not_have_signal(object, signal_name))


# Check if an object is connected to a signal on another object. Returns True
# if it is and false otherwise
func _is_connected(signaler_obj, connect_to_obj, signal_name, method_name=""):
	if(method_name != ""):
		return signaler_obj.is_connected(signal_name,Callable(connect_to_obj,method_name))
	else:
		var connections = signaler_obj.get_signal_connection_list(signal_name)
		for conn in connections:
			if(conn['signal'].get_name() == signal_name and conn['callable'].get_object() == connect_to_obj):
				return true
		return false


## Asserts that `signaler_obj` is connected to `connect_to_obj` on signal `signal_name`.  The method that is connected is optional.  If `method_name` is supplied then this will pass only if the signal is connected to the  method.  If it is not provided then any connection to the signal will cause a pass.
## [br][br]
## [b]Signatures:[/b][br]
## - assert_connected([param p1]:Signal, [param p2]:connected-object)[br]
## - assert_connected([param p1]:Signal, [param p2]:connected-method)[br]
## - assert_connected([param p1]:object, [param p2]:connected-object, [param p3]:signal-name, [param p4]: connected-method-name <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class Signaler:
##     signal the_signal
##
## class Connector:
##     func connect_this():
##         pass
##     func  other_method():
##         pass
##
## func test_assert_connected():
##     var signaler = Signaler.new()
##     var connector  = Connector.new()
##     signaler.the_signal.connect(connector.connect_this)
##
##     # Passing
##     assert_connected(signaler.the_signal, connector.connect_this)
##     assert_connected(signaler.the_signal, connector)
##     assert_connected(signaler, connector, 'the_signal')
##     assert_connected(signaler, connector, 'the_signal', 'connect_this')
##
##     # Failing
##     assert_connected(signaler.the_signal, connector.other_method)
##
##     var foo = Connector.new()
##     assert_connected(signaler,  connector, 'the_signal', 'other_method')
##     assert_connected(signaler, connector, 'other_signal')
##     assert_connected(signaler, foo, 'the_signal')
## [/codeblock]
func assert_connected(p1, p2, p3=null, p4=""):
	var sp := SignalAssertParameters.new(p1, p3)
	var connect_to_obj = p2
	var method_name = p4

	if(connect_to_obj is  Callable):
		method_name = connect_to_obj.get_method()
		connect_to_obj = connect_to_obj.get_object()

	var method_disp = ''
	if (method_name != ""):
		method_disp = str(' using method: [', method_name, '] ')
	var disp = str('Expected object ', _str(sp.object),\
		' to be connected to signal: [', sp.signal_name, '] on ',\
		_str(connect_to_obj), method_disp)
	if(_is_connected(sp.object, connect_to_obj, sp.signal_name, method_name)):
		_pass(disp)
	else:
		_fail(disp)


## The inverse of [method assert_connected].  See [method assert_connected] for parameter syntax.
## [br]
## This will fail with specific messages if the target object is connected to the specified signal on the source object.
func assert_not_connected(p1, p2, p3=null, p4=""):
	var sp := SignalAssertParameters.new(p1, p3)
	var connect_to_obj = p2
	var method_name = p4

	if(connect_to_obj is  Callable):
		method_name = connect_to_obj.get_method()
		connect_to_obj = connect_to_obj.get_object()

	var method_disp = ''
	if (method_name != ""):
		method_disp = str(' using method: [', method_name, '] ')
	var disp = str('Expected object ', _str(sp.object),\
		' to not be connected to signal: [', sp.signal_name, '] on ',\
		_str(sp.object), method_disp)
	if(_is_connected(sp.object, connect_to_obj, sp.signal_name, method_name)):
		_fail(disp)
	else:
		_pass(disp)


## Assert that the specified object emitted the named signal.  You must call
## [method watch_signals] and pass it the object that you are making assertions about.
## This will fail if the object is not being watched or if the object does not
## have the specified signal.  Since this will fail if the signal does not
## exist, you can often skip using [method assert_has_signal].
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_emitted([param p1]:Signal, [param p2]: text <optional>)[br]
## - assert_signal_emitted([param p1]:object, [param p2]:signal-name, [param p3]: text <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
##
## func test_assert_signal_emitted():
##     var obj = SignalObject.new()
##
##     watch_signals(obj)
##     obj.emit_signal('some_signal')
##
##     ## Passing
##     assert_signal_emitted(obj, 'some_signal')
##     assert_signal_emitted(obj.some_signal)
##
##     ## Failing
##     # Fails with specific message that the object does not have the signal
##     assert_signal_emitted(obj, 'signal_does_not_exist')
##     # Fails because the object passed is not being watched
##     assert_signal_emitted(SignalObject.new(), 'some_signal')
##     # Fails because the signal was not emitted
##     assert_signal_emitted(obj, 'other_signal')
##     assert_signal_emitted(obj.other_signal)
## [/codeblock]
func assert_signal_emitted(p1, p2='', p3=""):
	var sp := SignalAssertParameters.new(p1, p2, p3)
	var disp = str('Expected object ', _str(sp.object), ' to have emitted signal [', sp.signal_name, ']:  ', sp.others[0])
	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		if(_signal_watcher.did_emit(sp.object, sp.signal_name)):
			_pass(disp)
		else:
			_fail(_get_fail_msg_including_emitted_signals(disp, sp.object))


## This works opposite of `assert_signal_emitted`.  This will fail if the object
## is not being watched or if the object does not have the signal.
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_not_emitted([param p1]:Signal, [param p2]: text <optional>)[br]
## - assert_signal_not_emitted([param p1]:object, [param p2]:signal-name, [param p3]: text <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
##    class SignalObject:
##        signal some_signal
##        signal other_signal
##
##    func test_assert_signal_not_emitted():
##        var obj = SignalObject.new()
##
##        watch_signals(obj)
##        obj.emit_signal('some_signal')
##
##        # Passing
##        assert_signal_not_emitted(obj, 'other_signal')
##        assert_signal_not_emitted(obj.other_signal)
##
##        # Failing
##        # Fails with specific message that the object does not have the signal
##        assert_signal_not_emitted(obj, 'signal_does_not_exist')
##        # Fails because the object passed is not being watched
##        assert_signal_not_emitted(SignalObject.new(), 'some_signal')
##        # Fails because the signal was emitted
##        assert_signal_not_emitted(obj, 'some_signal')
## [/codeblock]
func assert_signal_not_emitted(p1, p2='', p3=''):
	var sp := SignalAssertParameters.new(p1, p2, p3)
	var disp = str('Expected object ', _str(sp.object), ' to NOT emit signal [', sp.signal_name, ']:  ', sp.others[0])
	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		if(_signal_watcher.did_emit(sp.object, sp.signal_name)):
			_fail(disp)
		else:
			_pass(disp)


## Asserts that a signal was fired with the specified parameters.  The expected
## parameters should be passed in as an array.  An optional index can be passed
## when a signal has fired more than once.  The default is to retrieve the most
## recent emission of the signal.
## [br]
## This will fail with specific messages if the object is not being watched or
## the object does not have the specified signal
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_emitted_with_parameters([param p1]:Signal, [param p2]:expected-parameters, [param p3]: index <optional>)[br]
## - assert_signal_emitted_with_parameters([param p1]:object, [param p2]:signal-name, [param p3]:expected-parameters, [param p4]: index <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
## func test_assert_signal_emitted_with_parameters():
##     var obj = SignalObject.new()
##
##     watch_signals(obj)
##     # emit the signal 3 times to illustrate how the index works in
##     # assert_signal_emitted_with_parameters
##     obj.emit_signal('some_signal', 1, 2, 3)
##     obj.emit_signal('some_signal', 'a', 'b', 'c')
##     obj.emit_signal('some_signal', 'one', 'two', 'three')
##
##     # Passing
##     # Passes b/c the default parameters to check are the last emission of
##     # the signal
##     assert_signal_emitted_with_parameters(obj, 'some_signal', ['one', 'two', 'three'])
##     assert_signal_emitted_with_parameters(obj.some_signal, ['one', 'two', 'three'])
##
##     # Passes because the parameters match the specified emission based on index.
##     assert_signal_emitted_with_parameters(obj, 'some_signal', [1, 2, 3], 0)
##     assert_signal_emitted_with_parameters(obj.some_signal, [1, 2, 3], 0)
##
##     # Failing
##     # Fails with specific message that the object does not have the signal
##     assert_signal_emitted_with_parameters(obj, 'signal_does_not_exist', [])
##     # Fails because the object passed is not being watched
##     assert_signal_emitted_with_parameters(SignalObject.new(), 'some_signal', [])
##     # Fails because parameters do not match latest emission
##     assert_signal_emitted_with_parameters(obj, 'some_signal', [1, 2, 3])
##     # Fails because the parameters for the specified index do not match
##     assert_signal_emitted_with_parameters(obj, 'some_signal', [1, 2, 3], 1)
## [/codeblock]
func assert_signal_emitted_with_parameters(p1, p2, p3=-1, p4=-1):
	var sp := SignalAssertParameters.new(p1, p2, p3, p4)
	var parameters = sp.others[0]
	var index = sp.others[1]

	if(typeof(parameters) != TYPE_ARRAY):
		_lgr.error("The expected parameters must be wrapped in an array, you passed:  " + _str(parameters))
		_fail("Bad Parameters")
		return

	var disp = str('Expected object ', _str(sp.object), ' to emit signal [', sp.signal_name, '] with parameters ', parameters, ', got ')
	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		if(_signal_watcher.did_emit(sp.object, sp.signal_name)):
			var parms_got = _signal_watcher.get_signal_parameters(sp.object, sp.signal_name, index)
			var diff_result = _compare.deep(parameters, parms_got)
			if(diff_result.are_equal):
				_pass(str(disp, parms_got))
			else:
				_fail(str('Expected object ', _str(sp.object), ' to emit signal [', sp.signal_name, '] with parameters ', diff_result.summarize()))
		else:
			var text = str('Object ', sp.object, ' did not emit signal [', sp.signal_name, ']')
			_fail(_get_fail_msg_including_emitted_signals(text, sp.object))


## Asserts that a signal fired a specific number of times.
## [br][br]
## [b]Signatures:[/b][br]
## - assert_signal_emit_count([param p1]:Signal, [param p2]:expected-count, [param p3]: text <optional>)[br]
## - assert_signal_emit_count([param p1]:object, [param p2]:signal-name, [param p3]:expected-count, [param p4]: text <optional>)
## [br][br]
## [b]Examples:[/b]
## [codeblock]
## class SignalObject:
##     signal some_signal
##     signal other_signal
##
##
## func test_assert_signal_emit_count():
##     var obj_a = SignalObject.new()
##     var obj_b = SignalObject.new()
##
##     watch_signals(obj_a)
##     watch_signals(obj_b)
##
##     obj_a.emit_signal('some_signal')
##     obj_a.emit_signal('some_signal')
##
##     obj_b.emit_signal('some_signal')
##     obj_b.emit_signal('other_signal')
##
##     # Passing
##     assert_signal_emit_count(obj_a, 'some_signal', 2, 'passes')
##     assert_signal_emit_count(obj_a.some_signal, 2, 'passes')
##
##     assert_signal_emit_count(obj_a, 'other_signal', 0)
##     assert_signal_emit_count(obj_a.other_signal, 0)
##
##     assert_signal_emit_count(obj_b, 'other_signal', 1)
##
##     # Failing
##     # Fails with specific message that the object does not have the signal
##     assert_signal_emit_count(obj_a, 'signal_does_not_exist', 99)
##     # Fails because the object passed is not being watched
##     assert_signal_emit_count(SignalObject.new(), 'some_signal', 99)
##     # The following fail for obvious reasons
##     assert_signal_emit_count(obj_a, 'some_signal', 0)
##     assert_signal_emit_count(obj_b, 'other_signal', 283)
## [/codeblock]
func assert_signal_emit_count(p1, p2, p3=0, p4=""):
	var sp := SignalAssertParameters.new(p1, p2, p3, p4)
	var times = sp.others[0]
	var text = sp.others[1]

	if(_can_make_signal_assertions(sp.object, sp.signal_name)):
		var count = _signal_watcher.get_emit_count(sp.object, sp.signal_name)
		var disp = str('Expected the signal [', sp.signal_name, '] emit count of [', count, '] to equal [', times, ']: ', text)
		if(count== times):
			_pass(disp)
		else:
			_fail(_get_fail_msg_including_emitted_signals(disp, sp.object))


## Asserts the passed in object has a signal with the specified name.  It
## should be noted that all the asserts that verify a signal was/wasn't emitted
## will first check that the object has the signal being asserted against.  If
## it does not, a specific failure message will be given.  This means you can
## usually skip the step of specifically verifying that the object has a signal
## and move on to making sure it emits the signal correctly.
## [codeblock]
##    class SignalObject:
##        signal some_signal
##        signal other_signal
##
##    func test_assert_has_signal():
##        var obj = SignalObject.new()
##
##        ## Passing
##        assert_has_signal(obj, 'some_signal')
##        assert_has_signal(obj, 'other_signal')
##
##        ## Failing
##        assert_has_signal(obj, 'not_a real SIGNAL')
##        assert_has_signal(obj, 'yea, this one doesnt exist either')
##        # Fails because the signal is not a user signal.  Node2D does have the
##        # specified signal but it can't be checked this way.  It could be watched
##        # and asserted that it fired though.
##        assert_has_signal(Node2D.new(), 'exit_tree')
## [/codeblock]
func assert_has_signal(object, signal_name, text=""):
	var disp = str('Expected object ', _str(object), ' to have signal [', signal_name, ']:  ', text)
	if(_signal_watcher.does_object_have_signal(object, signal_name)):
		_pass(disp)
	else:
		_fail(disp)


## Asserts that [param object] extends [param a_class].  object must be an instance of an
## object.  It cannot be any of the built in classes like Array or Int or Float.
## [param a_class] must be a class, it can be loaded via load, a GDNative class such as
## Node or Label or anything else.
## [codeblock]
##    # Passing
##    assert_is(Node2D.new(), Node2D)
##    assert_is(Label.new(), CanvasItem)
##    assert_is(SubClass.new(), BaseClass)
##    # Since this is a test script that inherits from test.gd, so
##    # this passes.  It's not obvious w/o seeing the whole script
##    # so I'm telling you.  You'll just have to trust me.
##    assert_is(self, load('res://addons/gut/test.gd'))
##
##    var Gut = load('res://addons/gut/gut.gd')
##    var a_gut = Gut.new()
##    assert_is(a_gut, Gut)
##
##    # Failing
##    assert_is(Node2D.new(), Node2D.new())
##    assert_is(BaseClass.new(), SubClass)
##    assert_is('a', 'b')
##    assert_is([], Node)
## [/codeblock]
func assert_is(object, a_class, text=''):
	var disp  = ''#var disp = str('Expected [', _str(object), '] to be type of [', a_class, ']: ', text)
	var bad_param_2 = 'Parameter 2 must be a Class (like Node2D or Label).  You passed '

	if(typeof(object) != TYPE_OBJECT):
		_fail(str('Parameter 1 must be an instance of an object.  You passed:  ', _str(object)))
	elif(typeof(a_class) != TYPE_OBJECT):
		_fail(str(bad_param_2, _str(a_class)))
	else:
		var a_str = _str(a_class)
		disp = str('Expected [', _str(object), '] to extend [', a_str, ']: ', text)
		if(!GutUtils.is_native_class(a_class) and !GutUtils.is_gdscript(a_class)):
			_fail(str(bad_param_2, a_str))
		else:
			if(is_instance_of(object, a_class)):
				_pass(disp)
			else:
				_fail(disp)


## Asserts that [param object] is the the [param type] specified.  [param type]
## should be one of the Godot [code]TYPE_[/code] constants.
## [codeblock]
##    # Passing
##    var c = Color(1, 1, 1, 1)
##    gr.test.assert_typeof(c, TYPE_COLOR)
##    assert_pass(gr.test)
##
##    # Failing
##    gr.test.assert_typeof('some string', TYPE_INT)
##    assert_fail(gr.test)
## [/codeblock]
func assert_typeof(object, type, text=''):
	var disp = str('Expected [typeof(', object, ') = ')
	disp += _get_typeof_string(typeof(object))
	disp += '] to equal ['
	disp += _get_typeof_string(type) +  ']'
	disp += '.  ' + text
	if(typeof(object) == type):
		_pass(disp)
	else:
		_fail(disp)


## The inverse of [method assert_typeof]
func assert_not_typeof(object, type, text=''):
	var disp = str('Expected [typeof(', object, ') = ')
	disp += _get_typeof_string(typeof(object))
	disp += '] to not equal ['
	disp += _get_typeof_string(type) +  ']'
	disp += '.  ' + text
	if(typeof(object) != type):
		_pass(disp)
	else:
		_fail(disp)


## Assert that `text` contains `search`.  Can perform case insensitive search
## by passing false for `match_case`.
## [codeblock]
##    # Passing
##    assert_string_contains('abc 123', 'a')
##    assert_string_contains('abc 123', 'BC', false)
##    assert_string_contains('abc 123', '3')
##
##    # Failing
##    assert_string_contains('abc 123', 'A')
##    assert_string_contains('abc 123', 'BC')
##    assert_string_contains('abc 123', '012')
## [/codeblock]
func assert_string_contains(text, search, match_case=true):
	const empty_search = 'Expected text and search strings to be non-empty. You passed %s and %s.'
	const non_strings = 'Expected text and search to both be strings.  You passed %s and %s.'
	var disp = 'Expected \'%s\' to contain \'%s\', match_case=%s' % [text, search, match_case]
	if(typeof(text) != TYPE_STRING or typeof(search) != TYPE_STRING):
		_fail(non_strings % [_str(text), _str(search)])
	elif(text == '' or search == ''):
		_fail(empty_search % [_str(text), _str(search)])
	elif(match_case):
		if(text.find(search) == -1):
			_fail(disp)
		else:
			_pass(disp)
	else:
		if(text.to_lower().find(search.to_lower()) == -1):
			_fail(disp)
		else:
			_pass(disp)


## Assert that text starts with search.  Can perform case insensitive check
## by passing false for match_case
## [codeblock]
##    # Passing
##    assert_string_starts_with('abc 123', 'a')
##    assert_string_starts_with('abc 123', 'ABC', false)
##    assert_string_starts_with('abc 123', 'abc 123')
##
##    ## Failing
##    assert_string_starts_with('abc 123', 'z')
##    assert_string_starts_with('abc 123', 'ABC')
##    assert_string_starts_with('abc 123', 'abc 1234')
## [/codeblock]
func assert_string_starts_with(text, search, match_case=true):
	var empty_search = 'Expected text and search strings to be non-empty. You passed \'%s\' and \'%s\'.'
	var disp = 'Expected \'%s\' to start with \'%s\', match_case=%s' % [text, search, match_case]
	if(text == '' or search == ''):
		_fail(empty_search % [text, search])
	elif(match_case):
		if(text.find(search) == 0):
			_pass(disp)
		else:
			_fail(disp)
	else:
		if(text.to_lower().find(search.to_lower()) == 0):
			_pass(disp)
		else:
			_fail(disp)


## Assert that [param text] ends with [param search].  Can perform case insensitive check by passing false for [param match_case]
## [codeblock]
##    ## Passing
##    assert_string_ends_with('abc 123', '123')
##    assert_string_ends_with('abc 123', 'C 123', false)
##    assert_string_ends_with('abc 123', 'abc 123')
##
##    ## Failing
##    assert_string_ends_with('abc 123', '1234')
##    assert_string_ends_with('abc 123', 'C 123')
##    assert_string_ends_with('abc 123', 'nope')
## [/codeblock]
func assert_string_ends_with(text, search, match_case=true):
	var empty_search = 'Expected text and search strings to be non-empty. You passed \'%s\' and \'%s\'.'
	var disp = 'Expected \'%s\' to end with \'%s\', match_case=%s' % [text, search, match_case]
	var required_index = len(text) - len(search)
	if(text == '' or search == ''):
		_fail(empty_search % [text, search])
	elif(match_case):
		if(text.find(search) == required_index):
			_pass(disp)
		else:
			_fail(disp)
	else:
		if(text.to_lower().find(search.to_lower()) == required_index):
			_pass(disp)
		else:
			_fail(disp)


# ------------------------------------------------------------------------------
## Assert that a method was called on an instance of a doubled class.  If
## parameters are supplied then the params passed in when called must match.
##
## Can be called with a Callabe instead of specifying the object, method_name,
## and parameters.  The Callable's object must be a double.  Bound arguments
## will be used to match calls based on values passed to the method.
## [br]
## See also: [wiki]Doubles[/wiki], [wiki]Spies[/wiki]
## [br][br]
## [b]Examples[/b]
## [codeblock]
##    var my_double = double(Foobar).new()
##    ...
##    assert_called(my_double, 'foo')
##    assert_called(my_double.foo)
##    assert_called(my_double, 'foo', [1, 2, 3])
##    assert_called(my_double.foo.bind(1, 2, 3))
## [/codeblock]
func assert_called(inst, method_name=null, parameters=null):

	if(_fail_if_parameters_not_array(parameters)):
		return

	var converted = _convert_spy_args(inst, method_name, parameters)
	if(converted.invalid_message != 'ok'):
		fail_test(converted.invalid_message)
		return

	var disp = str('Expected [',converted.method_name,'] to have been called on ',_str(converted.object))
	if(converted.arguments != null):
		disp += str(' with parameters ', converted.arguments)

	if(_fail_if_not_double_or_does_not_have_method(converted.object, converted.method_name) == OK):
		if(gut.get_spy().was_called(
			converted.object, converted.method_name, converted.arguments)):
			_pass(disp)
		else:
			_fail(str(disp, "\n", _get_desc_of_calls_to_instance(converted.object)))


# ------------------------------------------------------------------------------
## Assert that a method was not called on an instance of a doubled class.  If
## parameters are specified then this will only fail if it finds a call that was
## sent matching parameters.
##
## Can be called with a Callabe instead of specifying the object, method_name,
## and parameters.  The Callable's object must be a double.  Bound arguments
## will be used to match calls based on values passed to the method.
## [br]
## See also: [wiki]Doubles[/wiki], [wiki]Spies[/wiki]
## [br][br]
## [b]Examples[/b]
## [codeblock]
##    assert_not_called(my_double, 'foo')
##    assert_not_called(my_double.foo)
##    assert_not_called(my_double, 'foo', [1, 2, 3])
##    assert_not_called(my_double.foo.bind(1, 2, 3))
## [/codeblock]
func assert_not_called(inst, method_name=null, parameters=null):

	if(_fail_if_parameters_not_array(parameters)):
		return

	var converted = _convert_spy_args(inst, method_name, parameters)
	if(converted.invalid_message != 'ok'):
		fail_test(converted.invalid_message)
		return

	var disp = str('Expected [', converted.method_name, '] to NOT have been called on ', _str(converted.object))

	if(_fail_if_not_double_or_does_not_have_method(converted.object, converted.method_name) == OK):
		if(gut.get_spy().was_called(
			converted.object, converted.method_name, converted.arguments)):
			if(converted.arguments != null):
				disp += str(' with parameters ', converted.arguments)
			_fail(str(disp, "\n", _get_desc_of_calls_to_instance(converted.object)))
		else:
			_pass(disp)


## Asserts the the method of a double was called an expected number of times.
## If any arguments are bound to the callable then only calls with matching
## arguments will be counted.
## [br]
## See also: [wiki]Doubles[/wiki], [wiki]Spies[/wiki]
## [br][br]
## [b]Examples[/b]
## [codeblock]
##    # assert foo was called on my_double 5 times
##    assert_called_count(my_double.foo, 5)
##    # assert foo, with parameters [1,2,3], was called on my_double 4 times.
##    assert_called_count(my_double.foo.bind(1, 2, 3), 4)
## [/codeblock]
func assert_called_count(callable : Callable, expected_count : int):
	var converted = _convert_spy_args(callable, null, null)
	var count = gut.get_spy().call_count(converted.object, converted.method_name, converted.arguments)

	var param_text = ''
	if(callable.get_bound_arguments_count() > 0):
		param_text = ' with parameters ' + str(callable.get_bound_arguments())
	var disp = 'Expected [%s] on %s to be called [%s] times%s.  It was called [%s] times.'
	disp = disp % [converted.method_name, _str(converted.object), expected_count, param_text, count]


	if(_fail_if_not_double_or_does_not_have_method(converted.object, converted.method_name) == OK):
		if(count == expected_count):
			_pass(disp)
		else:
			_fail(str(disp, "\n", _get_desc_of_calls_to_instance(converted.object)))


## Asserts the passed in value is null
func assert_null(got, text=''):
	var disp = str('Expected [', _str(got), '] to be NULL:  ', text)
	if(got == null):
		_pass(disp)
	else:
		_fail(disp)


## Asserts the passed in value is not null.
func assert_not_null(got, text=''):
	var disp = str('Expected [', _str(got), '] to be anything but NULL:  ', text)
	if(got == null):
		_fail(disp)
	else:
		_pass(disp)


## Asserts that the passed in object has been freed.  This assertion requires
## that  you pass in some text in the form of a title since, if the object is
## freed, we won't have anything to convert to a string to put in the output
## statement.
## [br]
## [b]Note[/b] that this currently does not detect if a node has been queued free.
## [codeblock]
##    var obj = Node.new()
##    obj.free()
##    test.assert_freed(obj, "New Node")
## [/codeblock]
func assert_freed(obj, title='something'):
	var disp = title
	if(is_instance_valid(obj)):
		disp = _strutils.type2str(obj) + title
	assert_true(not is_instance_valid(obj), "Expected [%s] to be freed" % disp)


## The inverse of [method assert_freed]
func assert_not_freed(obj, title='something'):
	var disp = title
	if(is_instance_valid(obj)):
		disp = _strutils.type2str(obj) + title
	assert_true(is_instance_valid(obj), "Expected [%s] to not be freed" % disp)


## This method will assert that no orphaned nodes have been introduced by the
## test when the assert is executed.  See the [wiki]Memory-Management[/wiki]
## page for more information.
func assert_no_new_orphans(text=''):
	var count = gut.get_orphan_counter().get_orphans_since('test')
	var msg = ''
	if(text != ''):
		msg = ':  ' + text
	# Note that get_counter will return -1 if the counter does not exist.  This
	# can happen with a misplaced assert_no_new_orphans.  Checking for > 0
	# ensures this will not cause some weird failure.
	if(count > 0):
		_fail(str('Expected no orphans, but found ', count, msg))
	else:
		_pass('No new orphans found.' + msg)


## @ignore
func assert_set_property(obj, property_name, new_value, expected_value):
	pending("this hasn't been implemented yet")


## @ignore
func assert_readonly_property(obj, property_name, new_value, expected_value):
	pending("this hasn't been implemented yet")


## Assumes backing varible with be _<property_name>.  This will perform all the
## asserts of assert_property.  Then this will set the value through the setter
## and check the backing variable value.  It will then reset throught the setter
## and set the backing variable and check the getter.
func assert_property_with_backing_variable(obj, property_name, default_value, new_value, backed_by_name=null):
	var setter_name = str('@', property_name, '_setter')
	var getter_name = str('@', property_name, '_getter')
	var backing_name = GutUtils.nvl(backed_by_name, str('_', property_name))
	var pre_fail_count = get_fail_count()

	var props = obj.get_property_list()
	var found = false
	var idx = 0
	while(idx < props.size() and !found):
		found = props[idx].name == backing_name
		idx += 1

	assert_true(found, str(obj, ' has ', backing_name, ' variable.'))
	assert_true(obj.has_method(setter_name), str('There should be a setter for ', property_name))
	assert_true(obj.has_method(getter_name), str('There should be a getter for ', property_name))

	if(pre_fail_count == get_fail_count()):
		var call_setter = Callable(obj, setter_name)
		var call_getter = Callable(obj, getter_name)

		assert_eq(obj.get(backing_name), default_value, str('Variable ', backing_name, ' has default value.'))
		assert_eq(call_getter.call(), default_value, 'Getter returns default value.')
		call_setter.call(new_value)
		assert_eq(call_getter.call(), new_value, 'Getter returns value from Setter.')
		assert_eq(obj.get(backing_name), new_value, str('Variable ', backing_name, ' was set'))

	_warn_for_public_accessors(obj, property_name)


## This will verify that the method has a setter and getter for the property.
## It will then use the getter to check the default.  Then use the
## setter with new_value and verify the getter returns the same value.
func assert_property(obj, property_name, default_value, new_value) -> void:
	var pre_fail_count = get_fail_count()

	var setter_name = str('@', property_name, '_setter')
	var getter_name = str('@', property_name, '_getter')

	if(typeof(obj) != TYPE_OBJECT):
		_fail(str(_str(obj), ' is not an object'))
		return

	assert_has_method(obj, setter_name)
	assert_has_method(obj, getter_name)

	if(pre_fail_count == get_fail_count()):
		var call_setter = Callable(obj, setter_name)
		var call_getter = Callable(obj, getter_name)

		assert_eq(call_getter.call(), default_value, 'Default value')
		call_setter.call(new_value)
		assert_eq(call_getter.call(), new_value, 'Getter gets Setter value')

	_warn_for_public_accessors(obj, property_name)


## Performs a deep comparison between two arrays or dictionaries and asserts
## they are equal.  If they are not equal then a formatted list of differences
## are displayed.  See [wiki]Comparing-Things[/wiki] for more information.
func assert_eq_deep(v1, v2):
	var result = compare_deep(v1, v2)
	if(result.are_equal):
		_pass(result.get_short_summary())
	else:
		_fail(result.summary)


## Performs a deep comparison of two arrays or dictionaries and asserts they
## are not equal.  See [wiki]Comparing-Things[/wiki] for more information.
func assert_ne_deep(v1, v2):
	var result = compare_deep(v1, v2)
	if(!result.are_equal):
		_pass(result.get_short_summary())
	else:
		_fail(result.get_short_summary())


## Assert v1 and v2 are the same using [code]is_same[/code].  See @GlobalScope.is_same.
func assert_same(v1, v2, text=''):
	var disp = "[" + _str(v1) + "] expected to be same as  [" + _str(v2) + "]:  " + text
	if(is_same(v1, v2)):
		_pass(disp)
	else:
		_fail(disp)


## Assert using v1 and v2 are not the same using [code]is_same[/code].  See @GlobalScope.is_same.
func assert_not_same(v1, v2, text=''):
	var disp = "[" + _str(v1) + "] expected to not be same as  [" + _str(v2) + "]:  " + text
	if(is_same(v1, v2)):
		_fail(disp)
	else:
		_pass(disp)


# ----------------
#endregion
#region Await Helpers
# ----------------


## Use with await to wait an amount of time in seconds.  The optional message
## will be printed when the await starts.[br]
## See [wiki]Awaiting[/wiki]
func wait_seconds(time, msg=''):
	_lgr.yield_msg(str('-- Awaiting ', time, ' second(s) -- ', msg))
	_awaiter.wait_seconds(time)
	return _awaiter.timeout


## Use with await to wait for a signal to be emitted or a maximum amount of
## time.  Returns true if the signal was emitted, false if not.[br]
## See [wiki]Awaiting[/wiki]
func wait_for_signal(sig : Signal, max_wait, msg=''):
	watch_signals(sig.get_object())
	_lgr.yield_msg(str('-- Awaiting signal "', sig.get_name(), '" or for ', max_wait, ' second(s) -- ', msg))
	_awaiter.wait_for_signal(sig, max_wait)
	await _awaiter.timeout
	return !_awaiter.did_last_wait_timeout


## @deprecated
## Use wait_physics_frames or wait_process_frames
## See [wiki]Awaiting[/wiki]
func wait_frames(frames : int, msg=''):
	_lgr.deprecated("wait_frames has been replaced with wait_physics_frames which is counted in _physics_process.  " +
		"wait_process_frames has also been added which is counted in _process.")
	return wait_physics_frames(frames, msg)


## This returns a signal that is emitted after [param x] physics frames have
## elpased.  You can await this method directly to pause execution for [param x]
## physics frames.  The frames are counted prior to _physics_process being called
## on any node (when [signal SceneTree.physics_frame] is emitted).  This means the
## signal is emitted after [param x] frames and just before the x + 1 frame starts.
## [codeblock]
## await wait_physics_frames(10)
## [/codeblock]
## See [wiki]Awaiting[/wiki]
func wait_physics_frames(x :int , msg=''):
	if(x <= 0):
		var text = str('wait_physics_frames:  frames must be > 0, you passed  ', x, '.  1 frames waited.')
		_lgr.error(text)
		x = 1

	_lgr.yield_msg(str('-- Awaiting ', x, ' physics frame(s) -- ', msg))
	_awaiter.wait_physics_frames(x)
	return _awaiter.timeout


## Alias for [method GutTest.wait_process_frames]
func wait_idle_frames(x : int, msg=''):
	return wait_process_frames(x, msg)


## This returns a signal that is emitted after [param x] process/idle frames have
## elpased.  You can await this method directly to pause execution for [param x]
## process/idle frames.  The frames are counted prior to _process being called
## on any node (when [signal SceneTree.process_frame] is emitted).  This means the
## signal is emitted after [param x] frames and just before the x + 1 frame starts.
## [codeblock]
## await wait_process_frames(10)
## # wait_idle_frames is an alias of wait_process_frames
## await wait_idle_frames(10)
## [/codeblock]
## See [wiki]Awaiting[/wiki]
func wait_process_frames(x : int, msg=''):
	if(x <= 0):
		var text = str('wait_process_frames:  frames must be > 0, you passed  ', x, '.  1 frames waited.')
		_lgr.error(text)
		x = 1

	_lgr.yield_msg(str('-- Awaiting ', x, ' idle frame(s) -- ', msg))
	_awaiter.wait_process_frames(x)
	return _awaiter.timeout


## Use with await to wait for [param callable] to return the boolean value
## [code]true[/code] or a maximum amount of time.  All values that are not the
## boolean value [code]true[/code] are ignored.  [param callable] is called
## every [code]_physics_process[/code] tick unless an optional time between
## calls is specified.[br]
## [param p3] can be the optional message or an amount of time to wait between calls.[br]
## [param p4] is the optional message if you have specified an amount of time to
## wait between calls.[br]
## Returns [code]true[/code] if [param callable] returned true before the timeout, false if not.
##[br]
##[codeblock]
## var foo = 1
## func test_example():
##     var foo_func = func():
##         foo += 1
##         return foo == 10
##     foo = 1
##     wait_until(foo_func, 5, 'optional message')
##     # or give it a time between
##     foo = 1
##     wait_until(foo_func, 5, 1,
##         'this will timeout because we call it every second and are waiting a max of 10 seconds')
##
##[/codeblock]
## See also [method wait_while][br]
## See [wiki]Awaiting[/wiki]
func wait_until(callable, max_wait, p3='', p4=''):
	var time_between = 0.0
	var message = p4
	if(typeof(p3) != TYPE_STRING):
		time_between = p3
	else:
		message = p3

	_lgr.yield_msg(str("--Awaiting callable to return TRUE or ", max_wait, "s.  ", message))
	_awaiter.wait_until(callable, max_wait, time_between)
	await _awaiter.timeout
	return !_awaiter.did_last_wait_timeout


## This is the inverse of [method wait_until].  This will continue to wait while
## [param callable] returns the boolean value [code]true[/code].  If [b]ANY[/b]
## other value is is returned then the wait will end.
## Returns [code]true[/code] if [param callable] returned a value other than
## [code]true[/code] before the timeout, [code]false[/code] if not.
##[codeblock]
## var foo = 1
## func test_example():
##     var foo_func = func():
##         foo += 1
##         if(foo < 10):
##             return true
##         else:
##             return 'this is not a boolean'
##     foo = 1
##     wait_while(foo_func, 5, 'optional message')
##     # or give it a time between
##     foo = 1
##     wait_while(foo_func, 5, 1,
##         'this will timeout because we call it every second and are waiting a max of 10 seconds')
##
##[/codeblock]
## See [wiki]Awaiting[/wiki]
func wait_while(callable, max_wait, p3='', p4=''):
	var time_between = 0.0
	var message = p4
	if(typeof(p3) != TYPE_STRING):
		time_between = p3
	else:
		message = p3

	_lgr.yield_msg(str("--Awaiting callable to return FALSE or ", max_wait, "s.  ", message))
	_awaiter.wait_while(callable, max_wait, time_between)
	await _awaiter.timeout
	return !_awaiter.did_last_wait_timeout



## Returns whether the last wait_* method timed out.  This is always true if
## the last method was wait_xxx_frames or wait_seconds.  It will be false when
## using wait_for_signal and wait_until if the timeout occurs before what
## is being waited on.  The wait_* methods return this value so you should be
## able to avoid calling this directly, but you can.
func did_wait_timeout():
	return _awaiter.did_last_wait_timeout

# ----------------
#endregion
#region Summary Data
# ----------------

## @internal
func get_summary():
	return _summary


## Returns the number of failing asserts in this script at the time this
## method was called.  Call in [method after_all] to get total count for script.
func get_fail_count():
	return _summary.failed


## Returns the number of passing asserts in this script at the time this method
## was called.  Call in [method after_all] to get total count for script.
func get_pass_count():
	return _summary.passed


## Returns the number of pending tests in this script at the time this method
## was called.  Call in [method after_all] to get total count for script.
func get_pending_count():
	return _summary.pending


## Returns the total number of asserts this script has made as of the time of
## this was called.  Call in [method after_all] to get total count for script.
func get_assert_count():
	return _summary.asserts


# Convert the _summary dictionary into text
## @internal
func get_summary_text():
	var to_return = get_script().get_path() + "\n"
	to_return += str('  ', _summary.passed, ' of ', _summary.asserts, ' passed.')
	if(_summary.pending > 0):
		to_return += str("\n  ", _summary.pending, ' pending')
	if(_summary.failed > 0):
		to_return += str("\n  ", _summary.failed, ' failed.')
	return to_return


# ----------------
#endregion
#region Double Methods
# ----------------


## Create a Double of [param thing].  [param thing] should be a Class, script,
## or scene.  See [wiki]Doubles[/wiki]
func double(thing, double_strat=null, not_used_anymore=null):
	if(!_are_double_parameters_valid(thing, double_strat, not_used_anymore)):
		return null

	return _smart_double(thing, double_strat, false)


## Create a Partial Double of [param thing].  [param thing] should be a Class,
## script, or scene.  See [wiki]Partial-Doubles[/wiki]
func partial_double(thing, double_strat=null, not_used_anymore=null):
	if(!_are_double_parameters_valid(thing, double_strat, not_used_anymore)):
		return null

	return _smart_double(thing, double_strat, true)


## @internal
func double_singleton(singleton_name):
	return null
	# var to_return = null
	# if(_validate_singleton_name(singleton_name)):
	# 	to_return = gut.get_doubler().double_singleton(singleton_name)
	# return to_return


## @internal
func partial_double_singleton(singleton_name):
	return null
	# var to_return = null
	# if(_validate_singleton_name(singleton_name)):
	# 	to_return = gut.get_doubler().partial_double_singleton(singleton_name)
	# return to_return


## This was implemented to allow the doubling of classes with static methods.
## There might be other valid use cases for this method, but you should always
## try stubbing before using this method.  Using
## [code]stub(my_double, 'method').to_call_super()[/code] or  creating a
## [method partial_double] works for any other known scenario.  You cannot stub
## or spy on methods passed to [code skip-lint]ignore_method_when_doubling[/code].
func ignore_method_when_doubling(thing, method_name):
	if(typeof(thing) == TYPE_STRING):
		_lgr.error('ignore_method_when_doubling no longer supports paths to scripts or scenes.  Load them and pass them instead.')
		return

	var r = thing
	if(thing is PackedScene):
		r = GutUtils.get_scene_script_object(thing)

	gut.get_doubler().add_ignored_method(r, method_name)


## Stub something.  See [wiki]Stubbing[/wiki] for detailed information about stubbing.
func stub(thing, p2=null, p3=null):
	var method_name = p2
	var subpath = null

	if(p3 != null):
		subpath = p2
		method_name = p3

	if(GutUtils.is_instance(thing)):
		var msg = _get_bad_double_or_method_message(thing, method_name, 'stub')
		if(msg != ''):
			_lgr.error(msg)
			return GutUtils.StubParams.new()

	var sp = null
	if(typeof(thing) == TYPE_CALLABLE):
		if(p2 != null or p3 != null):
			_lgr.error("Only one parameter expected when using a callable.")
		sp = GutUtils.StubParams.new(thing)
	else:
		sp = GutUtils.StubParams.new(thing, method_name, subpath)

	sp.logger = _lgr
	gut.get_stubber().add_stub(sp)
	return sp

# ----------------
#endregion
#region Memory Mgmt
# ----------------


## Marks whatever is passed in to be freed after the test finishes.  It also
## returns what is passed in so you can save a line of code.
##   var thing = autofree(Thing.new())
func autofree(thing):
	gut.get_autofree().add_free(thing)
	return thing


## Works the same as autofree except queue_free will be called on the object
## instead.  This also imparts a brief pause after the test finishes so that
## the queued object has time to free.
func autoqfree(thing):
	gut.get_autofree().add_queue_free(thing)
	return thing


## The same as autofree but it also adds the object as a child of the test.
func add_child_autofree(node, legible_unique_name = false):
	gut.get_autofree().add_free(node)
	# Explicitly calling super here b/c add_child MIGHT change and I don't want
	# a bug sneaking its way in here.
	super.add_child(node, legible_unique_name)
	return node


## The same as autoqfree but it also adds the object as a child of the test.
func add_child_autoqfree(node, legible_unique_name=false):
	gut.get_autofree().add_queue_free(node)
	# Explicitly calling super here b/c add_child MIGHT change and I don't want
	# a bug sneaking its way in here.
	super.add_child(node, legible_unique_name)
	return node



# ----------------
#endregion
#region Deprecated/Removed
# ----------------


## REMOVED
## @ignore
func compare_shallow(v1, v2, max_differences=null):
	_fail('compare_shallow has been removed.  Use compare_deep or just compare using == instead.')
	_lgr.error('compare_shallow has been removed.  Use compare_deep or just compare using == instead.')
	return null


## REMOVED
## @ignore
func assert_eq_shallow(v1, v2):
	_fail('assert_eq_shallow has been removed.  Use assert_eq/assert_same/assert_eq_deep')


## REMOVED
## @ignore
func assert_ne_shallow(v1, v2):
	_fail('assert_eq_shallow has been removed.  Use assert_eq/assert_same/assert_eq_deep')


## @deprecated: use wait_seconds
func yield_for(time, msg=''):
	_lgr.deprecated('yield_for', 'wait_seconds')
	return wait_seconds(time, msg)


## @deprecated: use wait_for_signal
func yield_to(obj, signal_name, max_wait, msg=''):
	_lgr.deprecated('yield_to', 'wait_for_signal')
	return await wait_for_signal(Signal(obj, signal_name), max_wait, msg)


## @deprecated: use wait_frames
func yield_frames(frames, msg=''):
	_lgr.deprecated("yield_frames", "wait_frames")
	return wait_frames(frames, msg)


## @deprecated: no longer supported.  Use double
func double_scene(path, strategy=null):
	_lgr.deprecated('test.double_scene has been removed.', 'double')
	return null


## @deprecated: no longer supported.  Use double
func double_script(path, strategy=null):
	_lgr.deprecated('test.double_script has been removed.', 'double')
	return null

	# var override_strat = GutUtils.nvl(strategy, gut.get_doubler().get_strategy())
	# return gut.get_doubler().double(path, override_strat)


## @deprecated: no longer supported.  Use register_inner_classes + double
func double_inner(path, subpath, strategy=null):
	_lgr.deprecated('double_inner should not be used.  Use register_inner_classes and double instead.', 'double')
	return null

	var override_strat = GutUtils.nvl(strategy, gut.get_doubler().get_strategy())
	return gut.get_doubler().double_inner(path, subpath, override_strat)


## @deprecated:  Use [method assert_called_count] instead.
func assert_call_count(inst, method_name, expected_count, parameters=null):
	gut.logger.deprecated('This has been replaced with assert_called_count which accepts a Callable with optional bound arguments.')
	var callable = Callable.create(inst, method_name)
	if(parameters != null):
		callable = callable.bindv(parameters)
	assert_called_count(callable, expected_count)


## @deprecated: no longer supported.
func assert_setget(
	instance, name_property,
	const_or_setter = null, getter="__not_set__"):
	_lgr.deprecated('assert_property')
	_fail('assert_setget has been removed.  Use assert_property, assert_set_property, assert_readonly_property instead.')


# ----------------
#endregion



# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################
# View readme for usage details.
#
# Version - see gut.gd
# ##############################################################################
# Class that all test scripts must extend.`
#
# This provides all the asserts and other testing features.  Test scripts are
# run by the Gut class in gut.gd
# ##############################################################################

--- SCRIPT: res://addons/gut/test_collector.gd ---
# ------------------------------------------------------------------------------
# This class handles calling out to the test parser and maintaining an array of
# collected_script.gd.  This is used for both calling the tests and tracking
# the results of each script and test's execution.
#
# This also handles exporting and importing tests.
# ------------------------------------------------------------------------------
var CollectedScript = GutUtils.CollectedScript
var CollectedTest = GutUtils.CollectedTest

var _test_prefix = 'test_'
var _test_class_prefix = 'Test'

var _lgr = GutUtils.get_logger()


# Array of CollectedScripts.
var scripts = []


func _does_inherit_from_test(thing):
	var base_script = thing.get_base_script()
	var to_return = false
	if(base_script != null):
		var base_path = base_script.get_path()
		if(base_path == 'res://addons/gut/test.gd'):
			to_return = true
		else:
			to_return = _does_inherit_from_test(base_script)
	return to_return


func _populate_tests(test_script):
	var script =  test_script.load_script()
	if(script == null):
		print('  !!! ', test_script.path, ' could not be loaded')
		return false

	test_script.is_loaded = true
	var methods = script.get_script_method_list()
	for i in range(methods.size()):
		var name = methods[i]['name']
		if(name.begins_with(_test_prefix)):
			var t = CollectedTest.new()
			t.name = name
			t.arg_count = methods[i]['args'].size()
			test_script.tests.append(t)


func _get_inner_test_class_names(loaded):
	var inner_classes = []
	var const_map = loaded.get_script_constant_map()
	for key in const_map:
		var thing = const_map[key]
		if(GutUtils.is_gdscript(thing)):
			if(key.begins_with(_test_class_prefix)):
				if(_does_inherit_from_test(thing)):
					inner_classes.append(key)
				else:
					_lgr.warn(str('Ignoring Inner Class ', key,
						' because it does not extend GutTest'))

			# This could go deeper and find inner classes within inner classes
			# but requires more experimentation.  Right now I'm keeping it at
			# one level since that is what the previous version did and there
			# has been no demand for deeper nesting.
			# _populate_inner_test_classes(thing)
	return inner_classes


func _parse_script(test_script):
	var inner_classes = []
	var scripts_found = []

	var loaded = GutUtils.WarningsManager.load_script_using_custom_warnings(
		test_script.path,
		GutUtils.warnings_when_loading_test_scripts)

	if(_does_inherit_from_test(loaded)):
		_populate_tests(test_script)
		scripts_found.append(test_script.path)
		inner_classes = _get_inner_test_class_names(loaded)
	else:
		return []

	for i in range(inner_classes.size()):
		var loaded_inner = loaded.get(inner_classes[i])
		if(_does_inherit_from_test(loaded_inner)):
			var ts = CollectedScript.new(_lgr)
			ts.path = test_script.path
			ts.inner_class_name = inner_classes[i]
			_populate_tests(ts)
			scripts.append(ts)
			scripts_found.append(test_script.path + '[' + inner_classes[i] +']')

	return scripts_found


# -----------------
# Public
# -----------------
func add_script(path):
	# SHORTCIRCUIT
	if(has_script(path)):
		return []

	# SHORTCIRCUIT
	if(!FileAccess.file_exists(path)):
		# This check was added so tests could create dynmaic scripts and add
		# them to be run through gut.  This helps cut down on creating test
		# scripts to be used in test/resources.
		if(ResourceLoader.has_cached(path)):
			_lgr.debug("Using cached version of " + path)
		else:
			_lgr.error('Could not find script:  ' + path)
			return

	var ts = CollectedScript.new(_lgr)
	ts.path = path
	# Append right away because if we don't test_doubler.gd.TestInitParameters
	# will HARD crash.  I couldn't figure out what was causing the issue but
	# appending right away, and then removing if it's not valid seems to fix
	# things.  It might have to do with the ordering of the test classes in
	# the test collecter.  I'm not really sure.
	scripts.append(ts)
	var parse_results = _parse_script(ts)

	if(parse_results.find(path) == -1):
		_lgr.warn(str('Ignoring script ', path, ' because it does not extend GutTest'))
		scripts.remove_at(scripts.find(ts))

	return parse_results


func clear():
	scripts.clear()


func has_script(path):
	var found = false
	var idx = 0
	while(idx < scripts.size() and !found):
		if(scripts[idx].get_full_name() == path):
			found = true
		else:
			idx += 1
	return found


func export_tests(path):
	var success = true
	var f = ConfigFile.new()
	for i in range(scripts.size()):
		scripts[i].export_to(f, str('CollectedScript-', i))
	var result = f.save(path)
	if(result != OK):
		_lgr.error(str('Could not save exported tests to [', path, '].  Error code:  ', result))
		success = false
	return success


func import_tests(path):
	var success = false
	var f = ConfigFile.new()
	var result = f.load(path)
	if(result != OK):
		_lgr.error(str('Could not load exported tests from [', path, '].  Error code:  ', result))
	else:
		var sections = f.get_sections()
		for key in sections:
			var ts = CollectedScript.new(_lgr)
			ts.import_from(f, key)
			_populate_tests(ts)
			scripts.append(ts)
		success = true
	return success


func get_script_named(name):
	return GutUtils.search_array(scripts, 'get_filename_and_inner', name)


func get_test_named(script_name, test_name):
	var s = get_script_named(script_name)
	if(s != null):
		return s.get_test_named(test_name)
	else:
		return null


func to_s():
	var to_return = ''
	for i in range(scripts.size()):
		to_return += scripts[i].to_s() + "\n"
	return to_return

# ---------------------
# Accessors
# ---------------------
func get_logger():
	return _lgr


func set_logger(logger):
	_lgr = logger


func get_test_prefix():
	return _test_prefix


func set_test_prefix(test_prefix):
	_test_prefix = test_prefix


func get_test_class_prefix():
	return _test_class_prefix


func set_test_class_prefix(test_class_prefix):
	_test_class_prefix = test_class_prefix


func get_scripts():
	return scripts


func get_ran_test_count():
	var count = 0
	for s in scripts:
		count += s.get_ran_test_count()
	return count


func get_ran_script_count():
	var count = 0
	for s in scripts:
		if(s.was_run):
			count += 1
	return count

func get_test_count():
	var count = 0
	for s in scripts:
		count += s.tests.size()
	return count


func get_assert_count():
	var count = 0
	for s in scripts:
		count += s.get_assert_count()
	return count


func get_pass_count():
	var count = 0
	for s in scripts:
		count += s.get_pass_count()
	return count


func get_fail_count():
	var count = 0
	for s in scripts:
		count += s.get_fail_count()
	return count


func get_pending_count():
	var count = 0
	for s in scripts:
		count += s.get_pending_count()
	return count

--- SCRIPT: res://addons/gut/thing_counter.gd ---
var things = {}

func get_unique_count():
	return things.size()


func add_thing_to_count(thing):
	if(!things.has(thing)):
		things[thing] = 0


func add(thing):
	if(things.has(thing)):
		things[thing] += 1
	else:
		things[thing] = 1


func has(thing):
	return things.has(thing)


func count(thing):
	var to_return = 0
	if(things.has(thing)):
		to_return = things[thing]
	return to_return


func sum():
	var to_return = 0
	for key in things:
		to_return += things[key]
	return to_return


func to_s():
	var to_return = ""
	for key in things:
		to_return += str(key, ":  ", things[key], "\n")
	to_return += str("sum: ", sum())
	return to_return


func get_max_count():
	var max_val = null
	for key in things:
		if(max_val == null or things[key] > max_val):
			max_val = things[key]
	return max_val


func add_array_items(array):
	for i in range(array.size()):
		add(array[i])

--- SCRIPT: res://addons/gut/UserFileViewer.gd ---
extends Window

@onready var rtl = $TextDisplay/RichTextLabel

func _get_file_as_text(path):
	var to_return = null
	var f = FileAccess.open(path, FileAccess.READ)
	if(f != null):
		to_return = f.get_as_text()
	else:
		to_return = str('ERROR:  Could not open file.  Error code ', FileAccess.get_open_error())
	return to_return

func _ready():
	rtl.clear()

func _on_OpenFile_pressed():
	$FileDialog.popup_centered()

func _on_FileDialog_file_selected(path):
	show_file(path)

func _on_Close_pressed():
	self.hide()

func show_file(path):
	var text = _get_file_as_text(path)
	if(text == ''):
		text = '<Empty File>'
	rtl.set_text(text)
	self.window_title = path

func show_open():
	self.popup_centered()
	$FileDialog.popup_centered()

func get_rich_text_label():
	return $TextDisplay/RichTextLabel

func _on_Home_pressed():
	rtl.scroll_to_line(0)

func _on_End_pressed():
	rtl.scroll_to_line(rtl.get_line_count() -1)

func _on_Copy_pressed():
	return
	# OS.clipboard = rtl.text

func _on_file_dialog_visibility_changed():
	if rtl.text.length() == 0 and not $FileDialog.visible:
		self.hide()

--- SCRIPT: res://addons/gut/utils.gd ---
@tool
class_name GutUtils
extends Object

const GUT_METADATA = '__gutdbl'

# Note, these cannot change since places are checking for TYPE_INT to determine
# how to process parameters.
enum DOUBLE_STRATEGY{
	INCLUDE_NATIVE,
	SCRIPT_ONLY,
}

enum DIFF {
	DEEP,
	SIMPLE
}

const TEST_STATUSES = {
	NO_ASSERTS = 'no asserts',
	SKIPPED = 'skipped',
	NOT_RUN = 'not run',
	PENDING = 'pending',
	# These two got the "ed" b/c pass is a reserved word and I could not
	# think of better words.
	FAILED = 'fail',
	PASSED = 'pass'
}

const DOUBLE_TEMPLATES = {
	FUNCTION = 'res://addons/gut/double_templates/function_template.txt',
	INIT = 'res://addons/gut/double_templates/init_template.txt',
	SCRIPT = 'res://addons/gut/double_templates/script_template.txt',
}


static var GutScene = load('res://addons/gut/GutScene.tscn')
static var LazyLoader = load('res://addons/gut/lazy_loader.gd')
static var VersionNumbers = load("res://addons/gut/version_numbers.gd")
static var WarningsManager = load("res://addons/gut/warnings_manager.gd")
static var EditorGlobals = load("res://addons/gut/gui/editor_globals.gd")
# --------------------------------
# Lazy loaded scripts.  These scripts are lazy loaded so that they can be
# declared, but will not load when this script is loaded.  This gives us a
# window at the start of a run to adjust warning levels prior to loading
# everything.
# --------------------------------
static var AutoFree = LazyLoader.new('res://addons/gut/autofree.gd'):
	get: return AutoFree.get_loaded()
	set(val): pass
static var Awaiter = LazyLoader.new('res://addons/gut/awaiter.gd'):
	get: return Awaiter.get_loaded()
	set(val): pass
static var Comparator = LazyLoader.new('res://addons/gut/comparator.gd'):
	get: return Comparator.get_loaded()
	set(val): pass
static var CollectedTest = LazyLoader.new('res://addons/gut/collected_test.gd'):
	get: return CollectedTest.get_loaded()
	set(val): pass
static var CollectedScript = LazyLoader.new('res://addons/gut/collected_script.gd'):
	get: return CollectedScript.get_loaded()
	set(val): pass
static var CompareResult = LazyLoader.new('res://addons/gut/compare_result.gd'):
	get: return CompareResult.get_loaded()
	set(val): pass
static var DiffFormatter = LazyLoader.new("res://addons/gut/diff_formatter.gd"):
	get: return DiffFormatter.get_loaded()
	set(val): pass
static var DiffTool = LazyLoader.new('res://addons/gut/diff_tool.gd'):
	get: return DiffTool.get_loaded()
	set(val): pass
static var DoubleTools = LazyLoader.new("res://addons/gut/double_tools.gd"):
	get: return DoubleTools.get_loader()
	set(val): pass
static var Doubler = LazyLoader.new('res://addons/gut/doubler.gd'):
	get: return Doubler.get_loaded()
	set(val): pass
static var DynamicGdScript = LazyLoader.new("res://addons/gut/dynamic_gdscript.gd") :
	get: return DynamicGdScript.get_loaded()
	set(val): pass
static var Gut = LazyLoader.new('res://addons/gut/gut.gd'):
	get: return Gut.get_loaded()
	set(val): pass
static var GutConfig = LazyLoader.new('res://addons/gut/gut_config.gd'):
	get: return GutConfig.get_loaded()
	set(val): pass
static var HookScript = LazyLoader.new('res://addons/gut/hook_script.gd'):
	get: return HookScript.get_loaded()
	set(val): pass
static var InnerClassRegistry = LazyLoader.new('res://addons/gut/inner_class_registry.gd'):
	get: return InnerClassRegistry.get_loaded()
	set(val): pass
static var InputFactory = LazyLoader.new("res://addons/gut/input_factory.gd"):
	get: return InputFactory.get_loaded()
	set(val): pass
static var InputSender = LazyLoader.new("res://addons/gut/input_sender.gd"):
	get: return InputSender.get_loaded()
	set(val): pass
static var JunitXmlExport = LazyLoader.new('res://addons/gut/junit_xml_export.gd'):
	get: return JunitXmlExport.get_loaded()
	set(val): pass
static var GutLogger = LazyLoader.new('res://addons/gut/logger.gd') : # everything should use get_logger
	get: return GutLogger.get_loaded()
	set(val): pass
static var MethodMaker = LazyLoader.new('res://addons/gut/method_maker.gd'):
	get: return MethodMaker.get_loaded()
	set(val): pass
static var OneToMany = LazyLoader.new('res://addons/gut/one_to_many.gd'):
	get: return OneToMany.get_loaded()
	set(val): pass
static var OrphanCounter = LazyLoader.new('res://addons/gut/orphan_counter.gd'):
	get: return OrphanCounter.get_loaded()
	set(val): pass
static var ParameterFactory = LazyLoader.new('res://addons/gut/parameter_factory.gd'):
	get: return ParameterFactory.get_loaded()
	set(val): pass
static var ParameterHandler = LazyLoader.new('res://addons/gut/parameter_handler.gd'):
	get: return ParameterHandler.get_loaded()
	set(val): pass
static var Printers = LazyLoader.new('res://addons/gut/printers.gd'):
	get: return Printers.get_loaded()
	set(val): pass
static var ResultExporter = LazyLoader.new('res://addons/gut/result_exporter.gd'):
	get: return ResultExporter.get_loaded()
	set(val): pass
static var ScriptCollector = LazyLoader.new('res://addons/gut/script_parser.gd'):
	get: return ScriptCollector.get_loaded()
	set(val): pass
static var SignalWatcher = LazyLoader.new('res://addons/gut/signal_watcher.gd'):
	get: return SignalWatcher.get_loaded()
	set(val): pass
static var Spy = LazyLoader.new('res://addons/gut/spy.gd'):
	get: return Spy.get_loaded()
	set(val): pass
static var Strutils = LazyLoader.new('res://addons/gut/strutils.gd'):
	get: return Strutils.get_loaded()
	set(val): pass
static var Stubber = LazyLoader.new('res://addons/gut/stubber.gd'):
	get: return Stubber.get_loaded()
	set(val): pass
static var StubParams = LazyLoader.new('res://addons/gut/stub_params.gd'):
	get: return StubParams.get_loaded()
	set(val): pass
static var Summary = LazyLoader.new('res://addons/gut/summary.gd'):
	get: return Summary.get_loaded()
	set(val): pass
static var Test = LazyLoader.new('res://addons/gut/test.gd'):
	get: return Test.get_loaded()
	set(val): pass
static var TestCollector = LazyLoader.new('res://addons/gut/test_collector.gd'):
	get: return TestCollector.get_loaded()
	set(val): pass
static var ThingCounter = LazyLoader.new('res://addons/gut/thing_counter.gd'):
	get: return ThingCounter.get_loaded()
	set(val): pass
# --------------------------------

static var avail_fonts = ['AnonymousPro', 'CourierPrime', 'LobsterTwo', 'Default']

static var version_numbers = VersionNumbers.new(
	# gut_versrion (source of truth)
	'9.4.0',
	# required_godot_version
	'4.2.0'
)


static var warnings_at_start := { # WarningsManager dictionary
	exclude_addons = true
}

static var warnings_when_loading_test_scripts := { # WarningsManager dictionary
	enable = false
}


# ------------------------------------------------------------------------------
# Everything should get a logger through this.
#
# When running in test mode this will always return a new logger so that errors
# are not caused by getting bad warn/error/etc counts.
# ------------------------------------------------------------------------------
static var _test_mode = false
static var _lgr = null
static func get_logger():
	if(_test_mode):
		return GutLogger.new()
	else:
		if(_lgr == null):
			_lgr = GutLogger.new()
		return _lgr


static var _dyn_gdscript = DynamicGdScript.new()
static func create_script_from_source(source, override_path=null):
	var are_warnings_enabled = WarningsManager.are_warnings_enabled()
	WarningsManager.enable_warnings(false)

	var DynamicScript = _dyn_gdscript.create_script_from_source(source, override_path)
	if(typeof(DynamicScript) == TYPE_INT):
		var l = get_logger()
		l.error(str('Could not create script from source.  Error:  ', DynamicScript))
		l.info(str("Source Code:\n", add_line_numbers(source)))

	WarningsManager.enable_warnings(are_warnings_enabled)

	return DynamicScript


static func godot_version_string():
	return version_numbers.make_godot_version_string()


static func is_godot_version(expected):
	return VersionNumbers.VerNumTools.is_godot_version_eq(expected)


static func is_godot_version_gte(expected):
	return VersionNumbers.VerNumTools.is_godot_version_gte(expected)


const INSTALL_OK_TEXT = 'Everything checks out'
static func make_install_check_text(template_paths=DOUBLE_TEMPLATES, ver_nums=version_numbers):
	var text = INSTALL_OK_TEXT
	if(!FileAccess.file_exists(template_paths.FUNCTION) or
		!FileAccess.file_exists(template_paths.INIT) or
		!FileAccess.file_exists(template_paths.SCRIPT)):

		text = 'One or more GUT template files are missing.  If this is an exported project, you must include *.txt files in the export to run GUT.  If it is not an exported project then reinstall GUT.'
	elif(!ver_nums.is_godot_version_valid()):
		text = ver_nums.get_bad_version_text()

	return text


static func is_install_valid(template_paths=DOUBLE_TEMPLATES, ver_nums=version_numbers):
	return make_install_check_text(template_paths, ver_nums) == INSTALL_OK_TEXT


# ------------------------------------------------------------------------------
# Gets the root node without having to be in the tree and pushing out an error
# if we don't have a main loop ready to go yet.
# ------------------------------------------------------------------------------
# static func get_root_node():
# 	var main_loop = Engine.get_main_loop()
# 	if(main_loop != null):
# 		return main_loop.root
# 	else:
# 		push_error('No Main Loop Yet')
# 		return null


# ------------------------------------------------------------------------------
# Gets the value from an enum.
# - If passed an integer value as a string it will convert it to an int and
# 	processes the int value.
# - If the value is a float then it is converted to an int and then processes
#	the int value
# - If the value is an int, or was converted to an int, then the enum is checked
#	to see if it contains the value, if so then the value is returned.
#	Otherwise the default is returned.
# - If the value is a string then it is uppercased and all spaces are replaced
#	with underscores.  It then checks to see if enum contains a key of that
#	name.  If so then the value for that key is returned, otherwise the default
#	is returned.
#
# This description is longer than the code, you should have just read the code
# and the tests.
# ------------------------------------------------------------------------------
static func get_enum_value(thing, e, default=null):
	var to_return = default

	if(typeof(thing) == TYPE_STRING and str(thing.to_int()) == thing):
		thing = thing.to_int()
	elif(typeof(thing) == TYPE_FLOAT):
		thing = int(thing)

	if(typeof(thing) == TYPE_STRING):
		var converted = thing.to_upper().replace(' ', '_')
		if(e.keys().has(converted)):
			to_return = e[converted]
	else:
		if(e.values().has(thing)):
			to_return = thing

	return to_return


# ------------------------------------------------------------------------------
# return if_null if value is null otherwise return value
# ------------------------------------------------------------------------------
static func nvl(value, if_null):
	if(value == null):
		return if_null
	else:
		return value


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
static func pretty_print(dict, indent = '  '):
	print(JSON.stringify(dict, indent))


# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
static func print_properties(props, thing, print_all_meta=false):
	for i in range(props.size()):
		var prop_name = props[i].name
		var prop_value = thing.get(props[i].name)
		var print_value = str(prop_value)
		if(print_value.length() > 100):
			print_value = print_value.substr(0, 97) + '...'
		elif(print_value == ''):
			print_value = 'EMPTY'

		print(prop_name, ' = ', print_value)
		if(print_all_meta):
			print('  ', props[i])



# ------------------------------------------------------------------------------
# Gets the value of the node_property 'script' from a PackedScene's root node.
# This does not assume the location of the root node in the PackedScene's node
# list.  This also does not assume the index of the 'script' node property in
# a nodes's property list.
# ------------------------------------------------------------------------------
static func get_scene_script_object(scene):
	var state = scene.get_state()
	var to_return = null
	var root_node_path = NodePath(".")
	var node_idx = 0

	while(node_idx < state.get_node_count() and to_return == null):
		if(state.get_node_path(node_idx) == root_node_path):
			for i in range(state.get_node_property_count(node_idx)):
				if(state.get_node_property_name(node_idx, i) == 'script'):
					to_return = state.get_node_property_value(node_idx, i)

		node_idx += 1

	return to_return


# ------------------------------------------------------------------------------
# returns true if the object has been freed, false if not
#
# From what i've read, the weakref approach should work.  It seems to work most
# of the time but sometimes it does not catch it.  The str comparison seems to
# fill in the gaps.  I've not seen any errors after adding that check.
# ------------------------------------------------------------------------------
static func is_freed(obj):
	var wr = weakref(obj)
	return !(wr.get_ref() and str(obj) != '<Freed Object>')


# ------------------------------------------------------------------------------
# Pretty self explanitory.
# ------------------------------------------------------------------------------
static func is_not_freed(obj):
	return !is_freed(obj)


# ------------------------------------------------------------------------------
# Checks if the passed in object is a GUT Double or Partial Double.
# ------------------------------------------------------------------------------
static func is_double(obj):
	var to_return = false
	if(typeof(obj) == TYPE_OBJECT and is_instance_valid(obj)):
		to_return = obj.has_method('__gutdbl_check_method__')
	return to_return


# ------------------------------------------------------------------------------
# Checks an object to see if it is a GDScriptNativeClass
# ------------------------------------------------------------------------------
static func is_native_class(thing):
	var it_is = false
	if(typeof(thing) == TYPE_OBJECT):
		it_is = str(thing).begins_with("<GDScriptNativeClass#")
	return it_is


# ------------------------------------------------------------------------------
# Checks if the passed in is an instance of a class
# ------------------------------------------------------------------------------
static func is_instance(obj):
	return typeof(obj) == TYPE_OBJECT and \
		!is_native_class(obj) and \
		!obj.has_method('new') and \
		!obj.has_method('instantiate')


# ------------------------------------------------------------------------------
# Checks if the passed in is a GDScript
# ------------------------------------------------------------------------------
static func is_gdscript(obj):
	return typeof(obj) == TYPE_OBJECT and str(obj).begins_with('<GDScript#')


# ------------------------------------------------------------------------------
# Checks if the passed in is an inner class
#
# Looks like the resource_path will be populated for gdscripts, and not populated
# for gdscripts inside a gdscript.
# ------------------------------------------------------------------------------
static func is_inner_class(obj):
	return is_gdscript(obj) and obj.resource_path == ''


# ------------------------------------------------------------------------------
# Returns an array of values by calling get(property) on each element in source
# ------------------------------------------------------------------------------
static func extract_property_from_array(source, property):
	var to_return = []
	for i in (source.size()):
		to_return.append(source[i].get(property))
	return to_return


# ------------------------------------------------------------------------------
# true if what is passed in is null or an empty string.
# ------------------------------------------------------------------------------
static func is_null_or_empty(text):
	return text == null or text == ''


# ------------------------------------------------------------------------------
# Get the name of a native class or null if the object passed in is not a
# native class.
# ------------------------------------------------------------------------------
static func get_native_class_name(thing):
	var to_return = null
	if(is_native_class(thing)):
		var newone = thing.new()
		to_return = newone.get_class()
		if(!newone is RefCounted):
			newone.free()
	return to_return


# ------------------------------------------------------------------------------
# Write a file.
# ------------------------------------------------------------------------------
static func write_file(path, content):
	var f = FileAccess.open(path, FileAccess.WRITE)
	if(f != null):
		f.store_string(content)
	f = null;

	return FileAccess.get_open_error()


# ------------------------------------------------------------------------------
# Returns the text of a file or an empty string if the file could not be opened.
# ------------------------------------------------------------------------------
static func get_file_as_text(path):
	var to_return = ''
	var f = FileAccess.open(path, FileAccess.READ)
	if(f != null):
		to_return = f.get_as_text()
	else:
		var err = FileAccess.get_open_error()
		_lgr.error(str('Could not open file ', path, '.  Error ', err))
	f = null
	return to_return


# ------------------------------------------------------------------------------
# Loops through an array of things and calls a method or checks a property on
# each element until it finds the returned value.  -1 is returned if not found
# or the index is returned if found.
# ------------------------------------------------------------------------------
static func search_array_idx(ar, prop_method, value):
	var found = false
	var idx = 0

	while(idx < ar.size() and !found):
		var item = ar[idx]
		var prop = item.get(prop_method)
		if(!(prop is Callable)):
			if(item.get(prop_method) == value):
				found = true
		elif(prop != null):
			var called_val = prop.call()
			if(called_val == value):
				found = true

		if(!found):
			idx += 1

	if(found):
		return idx
	else:
		return -1


# ------------------------------------------------------------------------------
# Loops through an array of things and calls a method or checks a property on
# each element until it finds the returned value.  The item in the array is
# returned or null if it is not found (this method originally came first).
# ------------------------------------------------------------------------------
static func search_array(ar, prop_method, value):
	var idx = search_array_idx(ar, prop_method, value)

	if(idx != -1):
		return ar[idx]
	else:
		return null


static func are_datatypes_same(got, expected):
	return !(typeof(got) != typeof(expected) and got != null and expected != null)


static func get_script_text(obj):
	return obj.get_script().get_source_code()


# func get_singleton_by_name(name):
# 	var source = str("var singleton = ", name)
# 	var script = GDScript.new()
# 	script.set_source_code(source)
# 	script.reload()
# 	return script.new().singleton


static func dec2bistr(decimal_value, max_bits = 31):
	var binary_string = ""
	var temp
	var count = max_bits

	while(count >= 0):
		temp = decimal_value >> count
		if(temp & 1):
			binary_string = binary_string + "1"
		else:
			binary_string = binary_string + "0"
		count -= 1

	return binary_string


static func add_line_numbers(contents):
	if(contents == null):
		return ''

	var to_return = ""
	var lines = contents.split("\n")
	var line_num = 1
	for line in lines:
		var line_str = str(line_num).lpad(6, ' ')
		to_return += str(line_str, ' |', line, "\n")
		line_num += 1
	return to_return


static func get_display_size():
	return Engine.get_main_loop().get_viewport().get_visible_rect()





# ##############################################################################
#(G)odot (U)nit (T)est class
#
# ##############################################################################
# The MIT License (MIT)
# =====================
#
# Copyright (c) 2025 Tom "Butch" Wesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# ##############################################################################

--- SCRIPT: res://addons/gut/version_conversion.gd ---
class ConfigurationUpdater:
	var EditorGlobals = load("res://addons/gut/gui/editor_globals.gd")

	func warn(message):
		print('GUT Warning:  ', message)


	func info(message):
		print("GUT Info:  ", message)


	func moved_file(from, to):
		if(FileAccess.file_exists(from) and !FileAccess.file_exists(to)):
			info(str('Copying [', from, '] to [', to, ']'))
			var result = DirAccess.copy_absolute(from, to)
			if(result != OK):
				warn(str('Could not copy [', from, '] to [', to, ']'))

		if(FileAccess.file_exists(from) and FileAccess.file_exists(to)):
			warn(str('File [', from, '] has been moved to [', to, "].\n    You can delete ", from))


	func move_user_file(from, to):
		if(from.begins_with('user://') and to.begins_with('user://')):
			if(FileAccess.file_exists(from) and !FileAccess.file_exists(to)):
				info(str('Moving [', from, '] to [', to, ']'))
				var result = DirAccess.copy_absolute(from, to)
				if(result == OK):
					info(str('    ', 'Created ', to))
					result = DirAccess.remove_absolute(from)
					if(result != OK):
						warn(str('    ', 'Could not delete ', from))
					else:
						info(str('    ', 'Deleted ', from))
				else:
					warn(str('    ', 'Could not copy [', from, '] to [', to, ']'))
		else:
			warn(str('Attempt to move_user_file with files not in user:// ', from, '->', to))


	func remove_user_file(which):
		if(which.begins_with('user://') and FileAccess.file_exists(which)):
			info(str('Deleting obsolete file ', which))
			var result = DirAccess.remove_absolute(which)
			if(result != OK):
				warn(str('    ', 'Could not delete ', which))
			else:
				info(str('    ', 'Deleted ', which))

class v9_2_0:
	extends ConfigurationUpdater

	func validate():
		moved_file('res://.gut_editor_config.json', EditorGlobals.editor_run_gut_config_path)
		moved_file('res://.gut_editor_shortcuts.cfg', EditorGlobals.editor_shortcuts_path)
		remove_user_file('user://.gut_editor.bbcode')
		remove_user_file('user://.gut_editor.json')

# list=Array[Dictionary]([{
# "base": &"RefCounted",
# "class": &"DynamicGutTest",
# "icon": "",
# "language": &"GDScript",
# "path": "res://test/resources/tools/dynamic_gut_test.gd"
# }, {
# "base": &"RefCounted",
# "class": &"GutDoubleTestInnerClasses",
# "icon": "",
# "language": &"GDScript",
# "path": "res://test/resources/doubler_test_objects/inner_classes.gd"
# }, ... ])
static func get_missing_gut_class_names() -> Array:
	var gut_class_names = ["GutHookScript",
		"GutInputFactory",
		"GutInputSender",
		"GutMain",
		"GutStringUtils",
		"GutTest",
		"GutUtils",]

	var class_cach_path = 'res://.godot/global_script_class_cache.cfg'
	var cfg = ConfigFile.new()
	cfg.load(class_cach_path)

	var all_class_names = {}
	var missing  = []
	var class_cache_entries = cfg.get_value('', 'list', [])

	for entry in class_cache_entries:
		if(entry.path.begins_with(&"res://addons/gut/")):
			# print(entry["class"], ':  ', entry["path"])
			all_class_names[entry["class"]] = entry

	for cn in gut_class_names:
		if(!all_class_names.has(cn)):
			missing.append(cn)

	return missing


static func error_if_not_all_classes_imported() -> bool:
	var missing_class_names = get_missing_gut_class_names()
	if(missing_class_names.size() > 0):
		push_error(str("Some GUT class_names have not been imported.  Please restart the Editor or run godot --headless --import\n",
			"Missing class_names:  ",
			missing_class_names))
		return true
	else:
		return false




static func convert():
	var inst = v9_2_0.new()
	inst.validate()

--- SCRIPT: res://addons/gut/version_numbers.gd ---
# ##############################################################################
#
# ##############################################################################
class VerNumTools:

	static func _make_version_array_from_string(v):
		var parts = Array(v.split('.'))
		for i in range(parts.size()):
			var int_val = parts[i].to_int()
			if(str(int_val) == parts[i]):
				parts[i] = parts[i].to_int()
		return parts


	static func make_version_array(v):
		var to_return = []
		if(typeof(v) == TYPE_STRING):
			to_return = _make_version_array_from_string(v)
		elif(typeof(v) == TYPE_DICTIONARY):
			return [v.major, v.minor, v.patch]
		elif(typeof(v) == TYPE_ARRAY):
			to_return = v
		return to_return


	static func make_version_string(version_parts):
		var to_return = 'x.x.x'
		if(typeof(version_parts) == TYPE_ARRAY):
			to_return =  ".".join(version_parts)
		elif(typeof(version_parts) == TYPE_DICTIONARY):
			to_return = str(version_parts.major,  '.',  version_parts.minor,  '.',  version_parts.patch)
		elif(typeof(version_parts) == TYPE_STRING):
			to_return = version_parts
		return to_return


	static func is_version_gte(version, required):
		var is_ok = null
		var v = make_version_array(version)
		var r = make_version_array(required)

		var idx = 0
		while(is_ok == null and idx < v.size() and idx < r.size()):
			if(v[idx] > r[idx]):
				is_ok = true
			elif(v[idx] < r[idx]):
				is_ok = false

			idx += 1

		# still null means each index was the same.
		return GutUtils.nvl(is_ok, true)


	static func is_version_eq(version, expected):
		var version_array = make_version_array(version)
		var expected_array = make_version_array(expected)

		if(expected_array.size() > version_array.size()):
			return false

		var is_version = true
		var i = 0
		while(i < expected_array.size() and i < version_array.size() and is_version):
			if(expected_array[i] == version_array[i]):
				i += 1
			else:
				is_version = false

		return is_version


	static func is_godot_version_eq(expected):
		return VerNumTools.is_version_eq(Engine.get_version_info(), expected)


	static func is_godot_version_gte(expected):
		return VerNumTools.is_version_gte(Engine.get_version_info(), expected)




# ##############################################################################
#
# ##############################################################################
var gut_version = '0.0.0'
var required_godot_version = '0.0.0'

func _init(gut_v = gut_version, required_godot_v = required_godot_version):
	gut_version = gut_v
	required_godot_version = required_godot_v


# ------------------------------------------------------------------------------
# Blurb of text with GUT and Godot versions.
# ------------------------------------------------------------------------------
func get_version_text():
	var v_info = Engine.get_version_info()
	var gut_version_info =  str('GUT version:  ', gut_version)
	var godot_version_info  = str('Godot version:  ', v_info.major,  '.',  v_info.minor,  '.',  v_info.patch)
	return godot_version_info + "\n" + gut_version_info


# ------------------------------------------------------------------------------
# Returns a nice string for erroring out when we have a bad Godot version.
# ------------------------------------------------------------------------------
func get_bad_version_text():
	var info = Engine.get_version_info()
	var gd_version = str(info.major, '.', info.minor, '.', info.patch)
	return 'GUT ' + gut_version + ' requires Godot ' + required_godot_version + \
		' or greater.  Godot version is ' + gd_version


# ------------------------------------------------------------------------------
# Checks the Godot version against required_godot_version.
# ------------------------------------------------------------------------------
func is_godot_version_valid():
	return VerNumTools.is_version_gte(Engine.get_version_info(), required_godot_version)


func make_godot_version_string():
	return VerNumTools.make_version_string(Engine.get_version_info())

--- SCRIPT: res://addons/gut/warnings_manager.gd ---
const IGNORE = 0
const WARN = 1
const ERROR = 2


const WARNING_LOOKUP = {
	IGNORE : 'IGNORE',
	WARN : 'WARN',
	ERROR : 'ERROR'
}

const GDSCRIPT_WARNING = 'debug/gdscript/warnings/'


# ---------------------------------------
# Static
# ---------------------------------------
static var _static_init_called = false
# This is static and set in _static_init so that we can get the current settings as
# soon as possible.
static var _project_warnings : Dictionary = {}

static var _disabled = false
# should never be true, unless it is, but it shouldn't be.  Whatever it is, it
# should stay the same for the entire run.  Read only.
static var disabled = _disabled:
	get: return _disabled
	set(val):pass

static var project_warnings := {} :
	get:
		# somehow this gets called before _project_warnings is initialized when
		# loading a project in the editor.  It causes an error stating that
		# duplicate can't be called on nil.  It seems there might be an
		# implicit "get" call happening.  Using push_error I saw a message
		# in this method, but not one from _static_init upon loading the project
		if(_static_init_called):
			return _project_warnings.duplicate()
		else:
			return {}
	set(val): pass


static func _static_init():
	_project_warnings = create_warnings_dictionary_from_project_settings()
	_static_init_called = true
	if(disabled):
		print("""
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!! Warnings Manager has been disabled
		!!
		!! Do not push this up buddy
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		""".dedent())


static func are_warnings_enabled():
	return ProjectSettings.get(str(GDSCRIPT_WARNING, 'enable'))


## Turn all warnings on/off.  Use reset_warnings to restore the original value.
static func enable_warnings(should=true):
	if(disabled):
		return
	ProjectSettings.set(str(GDSCRIPT_WARNING, 'enable'), should)


## Turn on/off excluding addons.  Use reset_warnings to restore the original value.
static func exclude_addons(should=true):
	if(disabled):
		return
	ProjectSettings.set(str(GDSCRIPT_WARNING, 'exclude_addons'), should)


## Resets warning settings to what they are set to in Project Settings
static func reset_warnings():
	apply_warnings_dictionary(_project_warnings)



static func set_project_setting_warning(warning_name : String, value : Variant):
	if(disabled):
		return

	var property_name = str(GDSCRIPT_WARNING, warning_name)
	# This check will generate a warning if the setting does not exist
	if(property_name in ProjectSettings):
		ProjectSettings.set(property_name, value)


static func apply_warnings_dictionary(warning_values : Dictionary):
	if(disabled):
		return

	for key in warning_values:
		set_project_setting_warning(key, warning_values[key])


static func create_ignore_all_dictionary():
	return replace_warnings_values(project_warnings, -1, IGNORE)


static func create_warn_all_warnings_dictionary():
	return replace_warnings_values(project_warnings, -1, WARN)


static func replace_warnings_with_ignore(dict):
	return replace_warnings_values(dict, WARN, IGNORE)


static func replace_errors_with_warnings(dict):
	return replace_warnings_values(dict, ERROR, WARN)


static func replace_warnings_values(dict, replace_this, with_this):
	var to_return = dict.duplicate()
	for key in to_return:
		if(typeof(to_return[key]) == TYPE_INT and (replace_this == -1 or to_return[key] == replace_this)):
			to_return[key] = with_this
	return to_return


static func create_warnings_dictionary_from_project_settings() -> Dictionary :
	var props = ProjectSettings.get_property_list()
	var to_return = {}
	for i in props.size():
		if(props[i].name.begins_with(GDSCRIPT_WARNING)):
			var prop_name = props[i].name.replace(GDSCRIPT_WARNING, '')
			to_return[prop_name] = ProjectSettings.get(props[i].name)
	return to_return


static func print_warnings_dictionary(which : Dictionary):
	var is_valid = true
	for key in which:
		var value_str = str(which[key])
		if(_project_warnings.has(key)):
			if(typeof(which[key]) == TYPE_INT):
				if(WARNING_LOOKUP.has(which[key])):
					value_str = WARNING_LOOKUP[which[key]]
				else:
					push_warning(str(which[key], ' is not a valid value for ', key))
					is_valid = false
		else:
			push_warning(str(key, ' is not a valid warning setting'))
			is_valid = false
		var s = str(key, ' = ', value_str)
		print(s)
	return is_valid


static func load_script_ignoring_all_warnings(path : String) -> Variant:
	return load_script_using_custom_warnings(path, create_ignore_all_dictionary())


static func load_script_using_custom_warnings(path : String, warnings_dictionary : Dictionary) -> Variant:
	var current_warns = create_warnings_dictionary_from_project_settings()
	apply_warnings_dictionary(warnings_dictionary)
	var s = load(path)
	apply_warnings_dictionary(current_warns)

	return s

--- SCRIPT: res://addons/loggie/channels/discord.gd ---
class_name DiscordLoggieMsgChannel extends LoggieMsgChannel

const discord_msg_character_limit = 2000 # The max. amount of characters the content of the message can contain before discord refuses to post it.
var debug_domain = "_d_loggie_discord"
var debug_enabled = false

func _init() -> void:
	self.ID = "discord"
	self.preprocess_flags = 0 # For this type of channel, this will be applied dynamically by Loggie after it loads LoggieSettings.

func send(msg : LoggieMsg, msg_type : LoggieEnums.MsgType):
	# Validate variables.
	var loggie = msg.get_logger()
	if loggie == null:
		push_error("Attempt to send a message that's coming from an invalid logger.")
		return
	
	# Wait until loggie is inside tree so that we can use add_child(http) on it without errors.
	if !loggie.is_inside_tree():
		loggie.tree_entered.connect(func():
			send(msg, msg_type)
		, CONNECT_ONE_SHOT)
		return

	var webhook_url = loggie.settings.discord_webhook_url_live if loggie.is_in_production() else loggie.settings.discord_webhook_url_dev
	if webhook_url == null or (webhook_url is String and webhook_url.is_empty()):
		push_error("Attempt to send a message to the Discord channel with an invalid webhook_url.")
		return

	var output_text = LoggieTools.convert_string_to_format_mode(msg.last_preprocess_result, LoggieEnums.MsgFormatMode.MARKDOWN)

	# Chunk the given string into chunks of maximum supported size by Discord, so we don't end up hitting the character limit
	# which would prevent the message from getting posted.
	var chunks = LoggieTools.chunk_string(output_text, discord_msg_character_limit)
	if chunks.size() > 1:
		loggie.debug("Chunking a long (", output_text.length(), "length ) message while sending to Discord into:", chunks.size(), "chunks.")
	for chunk : String in chunks:
		call_deferred("send_post_request", loggie, chunk, webhook_url)

func send_post_request(logger : Variant, output_text : String, webhook_url : String):
	# Enable debug messages if configured.
	logger.set_domain_enabled(debug_domain, debug_enabled)

	# Create a new HTTPRequest POST request that will be sent to Discord and add it into the scenetree.
	var http = HTTPRequest.new()
	logger.add_child(http)

	# When the request is completed, destroy it.
	http.request_completed.connect(func(result, response_code, headers, body):
		var debug_msg = logger.msg("HTTP Request Completed:").color(Color.ORANGE).header().domain(debug_domain).channel("terminal")
		debug_msg.nl().msg("Result:").color(Color.ORANGE).bold().space().msg(result).nl()
		debug_msg.msg("Response Code:").color(Color.ORANGE).bold().space().msg(response_code).nl()
		debug_msg.msg("Headers:").color(Color.ORANGE).bold().space().msg(headers).nl()
		debug_msg.msg("Body:").color(Color.ORANGE).bold().space().msg(body)
		debug_msg.debug()
		
		## Inform the user about a received non-success response code.
		if response_code < 200 or response_code > 299:
			logger.msg("Discord responded with a non-success code: ").bold().msg(response_code, " - This is an indicator that something about the message you tried to send to Discord does not comply with their request body standards (e.g. content is too long, invalid format, etc.)").channel("terminal").warn()
		
		http.queue_free()
	)
	
	# Convert the [LoggieMsg]'s contents into markdown and post that to the target webhook url.
	var json = JSON.stringify({"content": output_text})
	var header = ["Content-Type: application/json"]

	# Construct debug message.
	if debug_enabled:
		var debug_msg_post = logger.msg("Sending POST Request:").color(Color.CORNFLOWER_BLUE).header().channel("terminal").domain(debug_domain).nl()
		debug_msg_post.msg("JSON stringified (length {size}):".format({"size": output_text.length()})).color(Color.LIGHT_SLATE_GRAY).bold().space().msg(json).color(Color.SLATE_GRAY)
		debug_msg_post.debug()
	
	# Send the request.
	http.request(webhook_url, header, HTTPClient.METHOD_POST, json)

--- SCRIPT: res://addons/loggie/channels/slack.gd ---
class_name SlackLoggieMsgChannel extends LoggieMsgChannel

var debug_domain = "_d_loggie_slack"
var debug_enabled = false

func _init() -> void:
	self.ID = "slack"
	self.preprocess_flags = 0 # For this type of channel, this will be applied dynamically by Loggie after it loads LoggieSettings.

func send(msg : LoggieMsg, msg_type : LoggieEnums.MsgType):
	# Validate variables.
	var loggie = msg.get_logger()
	if loggie == null:
		push_error("Attempt to send a message that's coming from an invalid logger.")
		return
	
	# Wait until loggie is inside tree so that we can use add_child(http) on it without errors.
	if !loggie.is_inside_tree():
		loggie.tree_entered.connect(func():
			send(msg, msg_type)
		, CONNECT_ONE_SHOT)
		return
		
	var webhook = loggie.settings.slack_webhook_url_live if loggie.is_in_production() else loggie.settings.slack_webhook_url_dev
	if webhook == null or (webhook is String and webhook.is_empty()):
		push_error("Attempt to send a message to the Slack channel with an invalid webhook.")
		return

	# Enable debug messages if configured.
	loggie.set_domain_enabled(debug_domain, debug_enabled)

	# Create a new HTTPRequest POST request that will be sent to Slack and add it into the scenetree.
	var http = HTTPRequest.new()
	loggie.add_child(http)

	# When the request is completed, destroy it.
	http.request_completed.connect(func(result, response_code, headers, body):
		var debug_msg = loggie.msg("HTTP Request Completed:").color(Color.ORANGE).header().domain(debug_domain)
		debug_msg.nl().msg("Result:").color(Color.ORANGE).bold().space().msg(result).nl()
		debug_msg.msg("Response Code:").color(Color.ORANGE).bold().space().msg(response_code).nl()
		debug_msg.msg("Headers:").color(Color.ORANGE).bold().space().msg(headers).nl()
		debug_msg.msg("Body:").color(Color.ORANGE).bold().space().msg(body)
		debug_msg.debug()

		## Inform the user about a received non-success response code.
		if response_code < 200 or response_code > 299:
			loggie.msg("Slack responded with a non-success code: ").bold().msg(response_code, " - This is an indicator that something about the message you tried to send to Slack does not comply with their request body standards (e.g. content is too long, invalid format, etc.)").channel("terminal").warn()
	
		http.queue_free()
	)
	
	# Convert the [LoggieMsg]'s contents into markdown and post that to the target webhook url.
	var md_text = LoggieTools.convert_string_to_format_mode(msg.last_preprocess_result, LoggieEnums.MsgFormatMode.PLAIN)
	var json = JSON.stringify({"text": md_text})
	var header = ["Content-Type: application/json"]
	
	# Construct debug message.
	if debug_enabled:
		var debug_msg_post = loggie.msg("Sending POST Request:").color(Color.ORANGE).header().domain(debug_domain).nl()
		debug_msg_post.msg("Preprocessed message:").color(Color.ORANGE).bold().space().msg(msg.last_preprocess_result).nl()
		debug_msg_post.msg("JSON stringified:").color(Color.ORANGE).bold().space().msg(json)
		debug_msg_post.debug()
	
	# Send the request.
	http.request(webhook, header, HTTPClient.METHOD_POST, json)

--- SCRIPT: res://addons/loggie/channels/terminal.gd ---
class_name TerminalLoggieMsgChannel extends LoggieMsgChannel

func _init() -> void:
	self.ID = "terminal"
	self.preprocess_flags = 0 # For this type of channel, this will be applied dynamically by Loggie after it loads LoggieSettings.

func send(msg : LoggieMsg, msg_type : LoggieEnums.MsgType):
	var loggie = msg.get_logger()
	var text = LoggieTools.convert_string_to_format_mode(msg.last_preprocess_result, loggie.settings.msg_format_mode)

	match loggie.settings.msg_format_mode:
		LoggieEnums.MsgFormatMode.ANSI, LoggieEnums.MsgFormatMode.BBCODE:
			print_rich(text)
		LoggieEnums.MsgFormatMode.PLAIN, _:
			print(text)

	# Dump a non-preprocessed terminal-ready version of the message in additional ways if that has been configured.
	if msg_type == LoggieEnums.MsgType.ERROR and loggie.settings.print_errors_to_console:
		push_error(LoggieTools.convert_string_to_format_mode(msg.string(), LoggieEnums.MsgFormatMode.PLAIN))
	if msg_type == LoggieEnums.MsgType.WARNING and loggie.settings.print_warnings_to_console:
		push_warning(LoggieTools.convert_string_to_format_mode(msg.string(), LoggieEnums.MsgFormatMode.PLAIN))

--- SCRIPT: res://addons/loggie/loggie.gd ---
@tool

## Loggie is a basic logging utility for those who need common minor improvements and helpers around the basic [method print], [method print_rich]
## and other default Godot printing functions. Loggie creates instances of [LoggieMsg], which are a wrapper around a string that needs to manipulated,
## then uses them to properly format, arrange and present them in the console and .log files. Loggie uses the default Godot logging mechanism under the hood.
extends Node

## The current version of Loggie.
## Needs to be updated manually when changing the version.
var version : LoggieVersion = LoggieVersion.new(2,0)

## Emitted any time Loggie attempts to log a message.
## Useful for capturing the messages that pass through Loggie.
## [br][param msg] is the message Loggie attempted to log (before any preprocessing).
## [br][param preprocessed_content] is what the string content of that message contained after the preprocessing step, 
## which is what ultimately gets logged.
## [br][param result] describes the final result of the attempt to log that message.
signal log_attempted(msg : LoggieMsg, preprocessed_content : String, result : LoggieEnums.LogAttemptResult)

## A reference to the settings of this Loggie. Read more about [LoggieSettings].
var settings : LoggieSettings

## Holds a mapping between all registered domains (string keys) and bool values representing whether
## those domains are currently enabled. Enable domains with [method set_domain_enabled].
## You can then place [LoggieMsg] messages into a domain by calling [method LoggieMsg.domain].
## Messages belonging to a disabled domain will never be outputted.
var domains : Dictionary = {}

## Holds a mapping between script paths and the names of the classes defined in those scripts.
var class_names : Dictionary = {}

## Holds a mapping between channel IDs (string) and the
## [LoggieMsgChannel] objects those IDs are representing.
var available_channels = {}

## Stores a reference to a [LoggieVersionManager] that will be used to manage the
## version of this instance.
var version_manager : LoggieVersionManager = LoggieVersionManager.new()

func _init() -> void:
	# Connect the version manager to this logger.
	version_manager.connect_logger(self)

	# Load and initialize the settings.
	var uses_original_settings_file = true
	var default_settings_path = get_script().get_path().get_base_dir().path_join("loggie_settings.gd")
	var custom_settings_path = get_script().get_path().get_base_dir().path_join("custom_settings.gd")
	
	if self.settings == null:
		if custom_settings_path != null and custom_settings_path != "" and ResourceLoader.exists(custom_settings_path):
			var loaded_successfully = load_settings_from_path(custom_settings_path)
			if loaded_successfully:
				uses_original_settings_file = false

	if uses_original_settings_file:
		var _settings = ResourceLoader.load(default_settings_path)
		if _settings != null:
			self.settings = _settings.new()
			self.settings.load()
		else:
			push_error("Loggie loaded neither a custom nor a default settings file. This will break the plugin. Make sure that a valid loggie_settings.gd is in the same directory where loggie.gd is.")
			return

	# Enforce certain settings if configured to do so.
	if self.settings.enforce_optimal_settings_in_release_build == true and is_in_production():
		self.settings.msg_format_mode = LoggieEnums.MsgFormatMode.PLAIN
		self.settings.box_characters_mode = LoggieEnums.BoxCharactersMode.COMPATIBLE

	# Set the default custom string converter.
	self.settings.custom_string_converter = LoggieTools.convert_to_string

	# Install all the built-in channels.
	var terminal_channel : TerminalLoggieMsgChannel = load("res://addons/loggie/channels/terminal.gd").new()
	terminal_channel.preprocess_flags = self.settings.preprocess_flags_terminal_channel
	add_channel(terminal_channel)
	var discord_channel : DiscordLoggieMsgChannel = load("res://addons/loggie/channels/discord.gd").new()
	discord_channel.preprocess_flags = self.settings.preprocess_flags_discord_channel
	add_channel(discord_channel)
	var slack_channel : SlackLoggieMsgChannel = load("res://addons/loggie/channels/slack.gd").new()
	slack_channel.preprocess_flags = self.settings.preprocess_flags_slack_channel
	add_channel(slack_channel)

	# Already cache the name of the singleton found at loggie's script path.
	class_names[self.get_script().resource_path] = LoggieSettings.loggie_singleton_name

	# Prepopulate class data from ProjectSettings to avoid needing to read files.
	if OS.has_feature("debug"):
		for class_data: Dictionary in ProjectSettings.get_global_class_list():
			class_names[class_data.path] = class_data.class
	  
		for autoload_setting: String in ProjectSettings.get_property_list().map(func(prop): return prop.name).filter(func(prop): return prop.begins_with("autoload/") and ProjectSettings.has_setting(prop)):
			var autoload_class: String = autoload_setting.trim_prefix("autoload/")
			var class_path: String = ProjectSettings.get_setting(autoload_setting)
			class_path = class_path.trim_prefix("*")      
			if not class_names.has(class_path):
				class_names[class_path] = autoload_class

	# And don't proceed further if we're in Editor mode, since we don't need to show loggie boot messages in that case.
	if Engine.is_editor_hint():
		return 
	
	# Print the Loggie boot messages.
	if self.settings.show_loggie_specs != LoggieEnums.ShowLoggieSpecsMode.DISABLED:
		msg(" Loggie {version}{isproxy} booted.".format({
			"version" : self.version_manager.version,
			"isproxy" : " (proxy for {original})".format({"original": self.version_manager.version.proxy_for}) if self.version_manager.version.proxy_for != null else ""
		})).color(Color.ORANGE).header().nl().info()
		var loggie_specs_msg = LoggieSystemSpecsMsg.new().use_logger(self)
		loggie_specs_msg.add(msg("|\t Using Custom Settings File: ").bold(), !uses_original_settings_file).nl().add("|\t ").hseparator(35).nl()
		
		match self.settings.show_loggie_specs:
			LoggieEnums.ShowLoggieSpecsMode.ESSENTIAL:
				loggie_specs_msg.embed_essential_logger_specs()
			LoggieEnums.ShowLoggieSpecsMode.ADVANCED:
				loggie_specs_msg.embed_advanced_logger_specs()

		loggie_specs_msg.preprocessed(false).info()

	if self.settings.show_system_specs:
		var system_specs_msg = LoggieSystemSpecsMsg.new().use_logger(self)
		system_specs_msg.embed_specs().preprocessed(false).info()

## Attempts to instantiate and use a LoggieSettings object from the script at the given [param path].
## Returns true if successful, otherwise false and prints an error.
func load_settings_from_path(path : String) -> bool:
	var settings_resource = ResourceLoader.load(path)
	var settings_instance

	if settings_resource != null:
		settings_instance = settings_resource.new()

	if (settings_instance is LoggieSettings):
		self.settings = settings_instance
		self.settings.load()
		return true
	else:
		push_error("Unable to instantiate a LoggieSettings object from the script at path {path}. Check that loggie.gd -> custom_settings_path is pointing to a valid .gd script that contains the class definition of a class that either extends LoggieSettings, or is LoggieSettings.".format({"path": path}))
		return false

## Checks if Loggie is running in production (release) mode of the game.
## While it is, every [LoggieMsg] will have plain output.
## Uses a sensible default check for most projects, but
## you can rewrite this function to your needs if necessary.
## TODO: Port this out of Loggie into LoggieSettings so users can override it easier.
func is_in_production() -> bool:
	return OS.has_feature("release")

## Returns a custom list of channels that messages from the given [param domain_name] will be sent to.
## This list can be set through the [method set_domain_enabled] method.
## If the list is empty, default channels will be used.
func get_domain_custom_target_channels(domain_name : String) -> Array:
	if domains.has(domain_name):
		return domains[domain_name].custom_target_channels
	return []

## Sets whether the domain with the given name is enabled.
## If [param custom_target_channels] is provided, it will be used as the list of channels that messages from the given domain will be sent to.
## It can be provided as a string (if only one channel is used), or an array of strings (if multiple channels are used).
## Otherwise, the default channels will be used.
func set_domain_enabled(domain_name : String, enabled : bool, custom_target_channels : Variant = []) -> void:
	var pruned_target_channels = []

	if custom_target_channels is String:
		custom_target_channels = [custom_target_channels]

	# Prune the array to ensure only string content is used.
	if custom_target_channels is Array:
		for entry in custom_target_channels:
			if entry is String or entry is StringName:
				pruned_target_channels.push_back(entry)
	else:
		push_error("Attempt to set a custom target channel for domain {domain_name} with an invalid value: {custom_target_channels}. The value must be a string or an array of strings. Default channels will be used instead.".format({
			"domain_name": domain_name,
			"custom_target_channels": custom_target_channels
		}))

	domains[domain_name] = {"enabled": enabled, "custom_target_channels": pruned_target_channels}

## Checks whether the domain with the given name is enabled.
## The domain name "" (empty string) is the default one for all newly created messages,
## and is designed to always be enabled.
func is_domain_enabled(domain_name : String) -> bool:
	if domain_name == "":
		return true
	
	if domains.has(domain_name) and domains[domain_name].enabled == true:
		return true
	
	return false

## Returns an available channel with the given ID (if one exists), otherwise null.
func get_channel(channel_id : String) -> LoggieMsgChannel:
	if available_channels.has(channel_id):
		return available_channels[channel_id]
	return null

## Adds a new channel for sending messages to.
## Multiple channels with the same ID can not be added, so make sure your ID
## does not clash with one of the existing channels' IDs, which are:
## [param terminal], [param discord], [param slack].
func add_channel(channel : LoggieMsgChannel):
	if not available_channels.has(channel.ID):
		available_channels[channel.ID] = channel
	else:
		push_error("Attempt to add a channel with ID {ID} failed, a channel with that ID already exists in Loggie.".format({
			"ID": channel.ID
		}))

## Creates a new [LoggieMsg] out of the given [param msg] and extra arguments (by converting them to strings and concatenating them to the msg).
## You may continue to modify the [LoggieMsg] with additional functions from that class, then when you are ready to output it, use methods like:
## [method LoggieMsg.info], [method LoggieMsg.warn], etc.
func msg(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	var loggieMsg = LoggieMsg.new(message, arg1, arg2, arg3, arg4, arg5)
	loggieMsg.use_logger(self)
	return loggieMsg

## A shortcut method that instantly creates a [LoggieMsg] with the given arguments and outputs it at the info level.
## Can be used when you have no intention of customizing a LoggieMsg in any way using helper methods.
## For customization, use [method msg] instead.
func info(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	return msg(message, arg1, arg2, arg3, arg4, arg5).info()

## A shortcut method that instantly creates a [LoggieMsg] with the given arguments and outputs it at the warn level.
## Can be used when you have no intention of customizing a LoggieMsg in any way using helper methods.
## For customization, use [method msg] instead.
func warn(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	return msg(message, arg1, arg2, arg3, arg4, arg5).warn()

## A shortcut method that instantly creates a [LoggieMsg] with the given arguments and outputs it at the error level.
## Can be used when you have no intention of customizing a LoggieMsg in any way using helper methods.
## For customization, use [method msg] instead.
func error(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	return msg(message, arg1, arg2, arg3, arg4, arg5).error()

## A shortcut method that instantly creates a [LoggieMsg] with the given arguments and outputs it at the debug level.
## Can be used when you have no intention of customizing a LoggieMsg in any way using helper methods.
## For customization, use [method msg] instead.
func debug(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	return msg(message, arg1, arg2, arg3, arg4, arg5).debug()

## A shortcut method that instantly creates a [LoggieMsg] with the given arguments and outputs it at the notice level.
## Can be used when you have no intention of customizing a LoggieMsg in any way using helper methods.
## For customization, use [method msg] instead.
func notice(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	return msg(message, arg1, arg2, arg3, arg4, arg5).notice()

## Returns the path to the directory from which within this script is running.
func get_directory_path() -> String:
	return get_script().resource_path.get_base_dir()

## Returns a [LoggieMsg] that comes inserted with stylized content describing the stack trace obtained via [method get_stack].
## This function only works in debug builds, and on the main thread, because it uses [method get_stack].
## Read more about why in that function's documentation.
func stack() -> LoggieMsg:
	if !OS.has_feature("debug"):
		return msg()

	const FALLBACK_TXT_TO_FORMAT = "{index}: {fn_name}:{line} (in {source_path})"
	var stack = get_stack()
	var stack_msg = msg()
	
	var text_to_format = settings.format_stacktrace_entry if is_instance_valid(settings) else FALLBACK_TXT_TO_FORMAT
	
	stack.reverse()
	
	for index in stack.size():
		var file_name = stack[index].source.get_file().get_basename()

		if settings.skipped_filenames_in_stack_trace.has(file_name):
			continue

		var entry_msg = LoggieMsg.new()
		entry_msg.add(text_to_format.format({
			"index": index,
			"source_path": stack[index].source,
			"fn_name": stack[index].function,
			"line": stack[index].line
		}))

		if index == 0 or index < stack.size():
			entry_msg.prefix("\n  ")
			entry_msg.endseg()

		stack_msg.add(entry_msg)

	return stack_msg

--- SCRIPT: res://addons/loggie/loggie_message.gd ---
@tool

## LoggieMsg represents a mutable object that holds an array of strings ([member content]) [i](referred to as 'content segments')[/i], and
## a bunch of helper methods that make it easy to manipulate these segments and chain together additions and changes to them.
## [br][br]For example:
## [codeblock]
### Prints: "Hello world!" at the INFO debug level.
##var msg = LoggieMsg.new("Hello world").color(Color.RED).suffix("!").info() 
##[/codeblock]
## [br] You can also use [method Loggie.msg] to quickly construct a message.
## [br] Example of usage:
## [codeblock]Loggie.msg("Hello world").color(Color("#ffffff")).suffix("!").info()[/codeblock]
class_name LoggieMsg extends RefCounted

## The full content of this message. By calling various helper methods in this class, this content is further altered.
## The content is an array of strings which represents segments of the message which are ultimately appended together 
## to form the final message. You can start a new segment by calling [method msg] on this class.
## You can then output the whole message with methods like [method info], [method debug], etc.
var content : Array = [""]

## The segment of [member content] that is currently being edited.
var current_segment_index : int = 0

## The (key string) domain this message belongs to.
## "" is the default domain which is always enabled.
## If this message attempts to be outputted, but belongs to a disabled domain, it will not be outputted.
## You can change which domains are enabled in Loggie at any time with [Loggie.set_domain_enabled].
## This is useful for creating blocks of debugging output that you can simply turn off/on with a boolean when you actually need them.
var domain_name : String = ""

## Stores a reference to the logger that generated this message, from which we need to read settings and other data.
## This variable should be set with [method use_logger] before an attempt is made to log this message out.
var _logger : Variant

## Stores an array of IDs of all channels this message should be sent to when being outputted.
var used_channels : Array = ["terminal"]

## Whether this message should be preprocessed and modified during [method output].
var preprocess : bool = true

## Usually, the [LoggieMsgChannel] this message gets outputted on sets the preprocessing steps this message should use.
## But sometimes we may want to use a specific set of preprocessing steps on this message,
## overriding the channel's set of rules.
## In that case, set this variable to the value of the [LoggieEnums.PreprocessStep] flags you want this message to use with
## [method preprocess].
var custom_preprocess_flags : int = -1

## Stores the string which was obtained the last time the [method get_preprocessed] was called on this message.
## You need to call it at least once for this to have any results.
var last_preprocess_result : String = ""

## Whether this message should append the stack trace during preprocessing.
var appends_stack : bool = false

func _init(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> void:
	var args = [message, arg1, arg2, arg3, arg4, arg5]
	self.content[0] = LoggieTools.concatenate_args(args)
	self.set_meta("initial_args", args)

## Returns a reference to the logger object that created this message.
func get_logger() -> Variant:
	return self._logger

## Sets this message to use the given [param logger] as the logger from which it will be reading
## settings. The given logger should be of class [Loggie] or an extension of it.
func use_logger(logger_to_use : Variant) -> LoggieMsg:
	self._logger = logger_to_use
	self.used_channels = self._logger.settings.default_channels
	
	# Now that a logger is connected, we can re-format the first segment
	# using that Logger's converter function if it has a custom one defined.
	if self.has_meta("initial_args"):
		var initial_args = self.get_meta("initial_args")
		if initial_args is Array:
			var converter_fn = self._logger.settings.custom_string_converter if is_instance_valid(self._logger) and is_instance_valid(self._logger.settings) else null
			self.content[0] = LoggieTools.concatenate_args(initial_args, converter_fn)

	return self

## Sets the list of channels this message should be sent to when outputted.
## [param channels] should either be provided as a single channel ID (String), or
## as an array of channel IDs (Array of strings).
func channel(channels : Variant):
	if typeof(channels) != TYPE_ARRAY and typeof(channels) != TYPE_PACKED_STRING_ARRAY:
		channels = [str(channels)]
	self.used_channels = channels
	return self

## Returns a processed version of the content of this message, which has modifications applied to
## it based on the requested [param level] and other settings defined by the provided preprocess [param flags].
## Available preprocess flags are found in [enum LoggieEnums.PreprocessStep].
func get_preprocessed(flags : int, level : LoggieEnums.LogLevel) -> String:
	var loggie = get_logger()
	var message = self.string()

	match level:
		LoggieEnums.LogLevel.ERROR:
			message = loggie.settings.format_error_msg.format({"msg": message})
		LoggieEnums.LogLevel.WARN:
			message = loggie.settings.format_warning_msg.format({"msg": message})
		LoggieEnums.LogLevel.NOTICE:
			message = loggie.settings.format_notice_msg.format({"msg": message})
		LoggieEnums.LogLevel.INFO:
			message = loggie.settings.format_info_msg.format({"msg": message})
		LoggieEnums.LogLevel.DEBUG:
			message = loggie.settings.format_debug_msg.format({"msg": message})

	if (flags & LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME != 0) and !self.domain_name.is_empty():
		message = _apply_format_domain(message)

	if (flags & LoggieEnums.PreprocessStep.APPEND_CLASS_NAME != 0) and OS.has_feature("debug"):
		message = _apply_format_class_name(message)

	if (flags & LoggieEnums.PreprocessStep.APPEND_TIMESTAMPS != 0):
		message = _apply_format_timestamp(message)

	if self.appends_stack or (loggie.settings.debug_msgs_print_stack_trace and level == LoggieEnums.LogLevel.DEBUG):
		message = _apply_format_stack(message)

	return message

## Outputs the given string [param message] at the given output [param level] to the standard output using either [method print_rich] or [method print].
## The domain from which the message is considered to be coming can be provided via [param target_domain].
## The classification of the message can be provided via [param msg_type], as certain types need extra handling and treatment.
## It also does a number of changes to the given [param msg] based on various Loggie settings.
## Designed to be called internally. You should consider using [method info], [method error], [method warn], [method notice], [method debug] instead.
func output(level : LoggieEnums.LogLevel, msg_type : LoggieEnums.MsgType = LoggieEnums.MsgType.STANDARD) -> void:
	var loggie = get_logger()
	var message = self.string()
	var target_domain = self.domain_name
	var target_channels = self.used_channels
	
	if loggie == null:
		push_error("Attempt to log output with an invalid _logger. Make sure to call LoggieMsg.use_logger to set the appropriate logger before working with the message.")
		return
		
	if loggie.settings == null:
		push_error("Attempt to use a _logger with invalid settings to print: {msg}".format({"msg": message}))
		return

	# We don't output the message if the settings dictate that messages of that level shouldn't be outputted.
	if level > loggie.settings.log_level:
		loggie.log_attempted.emit(self, message, LoggieEnums.LogAttemptResult.LOG_LEVEL_INSUFFICIENT)
		return

	# We don't output the message if the domain from which it comes is not enabled.
	if not loggie.is_domain_enabled(target_domain):
		loggie.log_attempted.emit(self, message, LoggieEnums.LogAttemptResult.DOMAIN_DISABLED)
		return

	# Send the message on all configured channels.
	var custom_target_channels = loggie.get_domain_custom_target_channels(target_domain)
	if custom_target_channels.size() > 0:
		target_channels = custom_target_channels

	for channel_id : String in target_channels:
		var channel : LoggieMsgChannel = loggie.get_channel(channel_id)

		if channel == null:
			loggie.log_attempted.emit(self, message, LoggieEnums.LogAttemptResult.INVALID_CHANNEL)
			continue

		# Preprocessing Stage:
		#   Apply full preprocessing only if explicitly enabled.
		#   Otherwise, simply concatenate together all the [member content].
		if self.preprocess:
			var flags = self.custom_preprocess_flags if self.custom_preprocess_flags != -1 else channel.preprocess_flags
			self.last_preprocess_result = get_preprocessed(flags, level)
		else:
			self.last_preprocess_result = self.string()

		channel.send(self, msg_type)
		
		# Emit signal deferred so if this is called from a thread, it doesn't cry about it.
		loggie.call_deferred("emit_signal", "log_attempted", self, message, LoggieEnums.LogAttemptResult.SUCCESS)

## Outputs this message from Loggie as an Error type message.
## The [Loggie.settings.log_level] must be equal to or higher to the ERROR level for this to work.
func error() -> LoggieMsg:
	output(LoggieEnums.LogLevel.ERROR, LoggieEnums.MsgType.ERROR)
	return self

## Outputs this message from Loggie as an Warning type message.
## The [Loggie.settings.log_level] must be equal to or higher to the WARN level for this to work.
func warn() -> LoggieMsg:
	output(LoggieEnums.LogLevel.WARN, LoggieEnums.MsgType.WARNING)
	return self

## Outputs this message from Loggie as an Notice type message.
## The [Loggie.settings.log_level] must be equal to or higher to the NOTICE level for this to work.
func notice() -> LoggieMsg:
	output(LoggieEnums.LogLevel.NOTICE)
	return self

## Outputs this message from Loggie as an Info type message.
## The [Loggie.settings.log_level] must be equal to or higher to the INFO level for this to work.
func info() -> LoggieMsg:
	output(LoggieEnums.LogLevel.INFO)
	return self

## Outputs this message from Loggie as a Debug type message.
## The [Loggie.settings.log_level] must be equal to or higher to the DEBUG level for this to work.
func debug() -> LoggieMsg:
	output(LoggieEnums.LogLevel.DEBUG, LoggieEnums.MsgType.DEBUG)
	return self

## Returns the string content of this message.
## If [param segment] is provided, it should be an integer indicating which segment of the message to return.
## If its value is -1, all segments are concatenated together and returned.
func string(segment : int = -1) -> String:
	if segment == -1:
		return "".join(self.content)
	else:
		if segment < self.content.size():
			return self.content[segment]
		else:
			push_error("Attempt to access a non-existent segment of a LoggieMsg. Make sure to use a valid segment index.")
			return ""

## Converts the current content of this message to an ANSI compatible form.
func to_ANSI() -> LoggieMsg:
	var new_content : Array = []
	for segment in self.content:
		new_content.append(LoggieTools.rich_to_ANSI(segment))
	self.content = new_content
	return self

## Strips all the BBCode in the current content of this message.
func strip_BBCode() -> LoggieMsg:
	var new_content : Array = []
	for segment in self.content:
		new_content.append(LoggieTools.remove_BBCode(segment))
	self.content = new_content
	return self

## Wraps the content of the current segment of this message in the given color.
## The [param color] can be provided as a [Color], a recognized Godot color name (String, e.g. "red"), or a color hex code (String, e.g. "#ff0000").
func color(_color : Variant) -> LoggieMsg:
	if _color is Color:
		_color = _color.to_html()
	
	self.content[current_segment_index] = "[color={colorstr}]{msg}[/color]".format({
		"colorstr": _color, 
		"msg": self.content[current_segment_index]
	})

	return self

## Stylizes the current segment of this message to be bold.
func bold() -> LoggieMsg:
	self.content[current_segment_index] = "[b]{msg}[/b]".format({"msg": self.content[current_segment_index]})
	return self

## Stylizes the current segment of this message to be italic.
func italic() -> LoggieMsg:
	self.content[current_segment_index] = "[i]{msg}[/i]".format({"msg": self.content[current_segment_index]})
	return self

## Stylizes the current segment of this message as a header.
func header() -> LoggieMsg:
	var loggie = get_logger()
	self.content[current_segment_index] = loggie.settings.format_header.format({"msg": self.content[current_segment_index]})
	return self

## Sets whether this message should append the stack trace during preprocessing.
## If used in a different thread, it doesn't work, because it relies on [method get_stack] and
## that method doesn't work within threads.
func stack(enabled : bool = true) -> LoggieMsg:
	self.appends_stack = enabled
	return self

## Constructs a decorative box with the given horizontal padding around the current segment
## of this message. Messages containing a box are not going to be preprocessed, so they are best
## used only as a special header or decoration.
func box(h_padding : int = 4):
	var loggie = get_logger()
	var stripped_content = LoggieTools.remove_BBCode(self.content[current_segment_index]).strip_edges(true, true)
	var content_length = stripped_content.length()
	var h_fill_length = content_length + (h_padding * 2)
	var box_character_source = loggie.settings.box_symbols_compatible if loggie.settings.box_characters_mode == LoggieEnums.BoxCharactersMode.COMPATIBLE else loggie.settings.box_symbols_pretty

	var top_row_design = "{top_left_corner}{h_fill}{top_right_corner}".format({
		"top_left_corner" : box_character_source.top_left,
		"h_fill" : box_character_source.h_line.repeat(h_fill_length),
		"top_right_corner" : box_character_source.top_right
	})

	var middle_row_design = "{vert_line}{padding}{content}{space_fill}{padding}{vert_line}".format({
		"vert_line" : box_character_source.v_line,
		"content" : self.content[current_segment_index],
		"padding" : " ".repeat(h_padding),
		"space_fill" : " ".repeat(h_fill_length - stripped_content.length() - h_padding*2)
	})
	
	var bottom_row_design = "{bottom_left_corner}{h_fill}{bottom_right_corner}".format({
		"bottom_left_corner" : box_character_source.bottom_left,
		"h_fill" : box_character_source.h_line.repeat(h_fill_length),
		"bottom_right_corner" : box_character_source.bottom_right
	})
	
	self.content[current_segment_index] = "{top_row}\n{middle_row}\n{bottom_row}\n".format({
		"top_row" : top_row_design,
		"middle_row" : middle_row_design,
		"bottom_row" : bottom_row_design
	})
	
	self.preprocessed(false)
	return self
	
## Appends additional content to this message at the end of the current content and its stylings.
## This does not create a new message segment, just appends to the current one.
func add(message : Variant = null, arg1 : Variant = null, arg2 : Variant = null, arg3 : Variant = null, arg4 : Variant = null, arg5 : Variant = null) -> LoggieMsg:
	var converter_fn = self._logger.settings.custom_string_converter if is_instance_valid(self._logger) and is_instance_valid(self._logger.settings) else null
	self.content[current_segment_index] = self.content[current_segment_index] + LoggieTools.concatenate_args([message, arg1, arg2, arg3, arg4, arg5], converter_fn)
	return self

## Adds a specified amount of newlines to the end of the current segment of this message.
func nl(amount : int = 1) -> LoggieMsg:
	self.content[current_segment_index] += "\n".repeat(amount)
	return self

## Adds a specified amount of spaces to the end of the current segment of this message.
func space(amount : int = 1) -> LoggieMsg:
	self.content[current_segment_index] += " ".repeat(amount)
	return self

## Adds a specified amount of tabs to the end of the current segment of this message.
func tab(amount : int = 1) -> LoggieMsg:
	self.content[current_segment_index] += "\t".repeat(amount)
	return self

## Sets this message to belong to the domain with the given name.
## If it attempts to be outputted, but the domain is disabled, it won't be outputted.
func domain(_domain_name : String) -> LoggieMsg:
	self.domain_name = _domain_name
	return self

## Prepends the given prefix string to the start of the message (first segment) with the provided separator.
func prefix(str_prefix : String, separator : String = "") -> LoggieMsg:
	self.content[0] = "{prefix}{separator}{content}".format({
		"prefix" : str_prefix,
		"separator" : separator,
		"content" : self.content[0]
	})
	return self

## Appends the given suffix string to the end of the message (last segment) with the provided separator.
func suffix(str_suffix : String, separator : String = "") -> LoggieMsg:
	self.content[self.content.size() - 1] = "{content}{separator}{suffix}".format({
		"suffix" : str_suffix,
		"separator" : separator,
		"content" : self.content[self.content.size() - 1]
	})
	return self

## Appends a horizontal separator with the given length to the current segment of this message.
## If [param alternative_symbol] is provided, it should be a String, and it will be used as the symbol for the separator instead of the default one.
func hseparator(size : int = 16, alternative_symbol : Variant = null) -> LoggieMsg:
	var loggie = get_logger()
	var symbol = loggie.settings.h_separator_symbol if alternative_symbol == null else str(alternative_symbol)
	self.content[current_segment_index] = self.content[current_segment_index] + (symbol.repeat(size))
	return self

## Ends the current segment of the message and starts a new one.
func endseg() -> LoggieMsg:
	self.content.push_back("")
	self.current_segment_index = self.content.size() - 1
	return self

## Creates a new segment in this message and sets its content to the given message.
## Acts as a shortcut for calling [method endseg] + [method add].
func msg(message = "", arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null) -> LoggieMsg:
	self.endseg()
	var converter_fn = self._logger.settings.custom_string_converter if is_instance_valid(self._logger) and is_instance_valid(self._logger.settings) else null
	self.content[current_segment_index] = LoggieTools.concatenate_args([message, arg1, arg2, arg3, arg4, arg5], converter_fn)
	return self

## Sets whether this message should be preprocessed and potentially modified with prefixes and suffixes during [method output].
## If turned off, while outputting this message, Loggie will skip the steps where it appends the messaage domain, class name, timestamp, etc.
## Whether preprocess is set to true doesn't affect the final conversion from RICH to ANSI or PLAIN, which always happens 
## under some circumstances that are based on other settings.
func preprocessed(shouldPreprocess : bool) -> LoggieMsg:
	self.preprocess = shouldPreprocess
	return self

## Adds this message's configured domain to the start of the given [param message] and returns the modifier version of it.
func _apply_format_domain(message : String) -> String:
	var loggie = get_logger()
	message = loggie.settings.format_domain_prefix.format({"domain" : self.domain_name, "msg" : message})
	return message

## Adds a formatted class name to the given [param message] and returns the modified version of it.
func _apply_format_class_name(message : String) -> String:
	var loggie = get_logger()
	var stack_frame : Dictionary = LoggieTools.get_current_stack_frame_data()
	var _class_name : String

	var scriptPath = stack_frame.source
	if loggie.class_names.has(scriptPath):
		_class_name = loggie.class_names[scriptPath]
	else:
		_class_name = LoggieTools.get_class_name_from_script(scriptPath, loggie.settings.nameless_class_name_proxy)
		loggie.class_names[scriptPath] = _class_name
	
	if _class_name != "":
		message = "[b]({class_name})[/b] {msg}".format({
			"class_name" : _class_name,
			"msg" : message
		})
	return message

## Adds a formatted timestamp to the given [param message] and returns the modified version of it.
func _apply_format_timestamp(message : String) -> String:
	var loggie = get_logger()
	var format_dict : Dictionary = Time.get_datetime_dict_from_system(loggie.settings.timestamps_use_utc)
	for field in ["month", "day", "hour", "minute", "second"]:
		format_dict[field] = "%02d" % format_dict[field]
	message = "{formatted_time} {msg}".format({
		"formatted_time" : loggie.settings.format_timestamp.format(format_dict),
		"msg" : message
	})
	return message

## Adds the stack trace to the given [param message] and returns the modified version of it.
func _apply_format_stack(message : String) -> String:
	var loggie = get_logger()
	var stack_msg = loggie.stack()
	message = message + stack_msg.string()
	return message

--- SCRIPT: res://addons/loggie/loggie_message_channel.gd ---
@tool

## A class that describes a channel that can be used to output Loggie Messages.
class_name LoggieMsgChannel extends RefCounted

## The ID of the channel.
var ID : String = ""

## The preprocessing steps a [method LoggieMsg] that's about to be
## sent to this channel has to go through. See: [LoggieEnums.PreprocessStep] for
## the list of flags that can be used.
var preprocess_flags : int = 0

## Defines what happens when some [LoggieMsg] wants to be sent with this channel.
## [br]If you're implementing your own channel, override this function to define
## how your channel outputs the message. 
##
## You can access the last known preprocessed version of the message 
## in [LoggieMsg.last_preprocess_result].
##
## If your channel requires extra data, the data can be embedded into a message
## with [method LoggieMsg.set_meta] and read here with [method LoggieMsg.get_meta].
func send(msg : LoggieMsg, type : LoggieEnums.MsgType):
	pass

--- SCRIPT: res://addons/loggie/loggie_settings.gd ---
@tool

## Defines a set of variables through which all the relevant settings of Loggie can have their
## values set, read and documented. An instance of this class is found in [member Loggie.settings], and that's where Loggie
## ultimately reads from when it's asking for the value of a setting. For user convenience, settings are (by default) exported
## as custom Godot project settings and are loaded from there into these variables during [method load], however,
## you can extend or overwrite this class' [method load] method to define a different way of loading these settings if you prefer.
## [i](e.g. loading from a config.ini file, or a .json file, etc.)[/i].[br][br]
## 
## Loggie calls [method load] on this class during its [method _ready] function.
class_name LoggieSettings extends Resource

## The name that will be used for the singleton referring to Loggie.
## [br][br][i][b]Note:[/b] You may change this to something you're more used to, such as "log" or "logger".[/i]
## When doing so, make sure to either do it while the Plugin is enabled, then disable and re-enable the plugin,
## or that you manually clear out the previously created autoload (should be called "Loggie") in Project Settings -> Autoloads.
static var loggie_singleton_name = "Loggie"

# ----------------------------------------------- #
#region Project Settings
# ----------------------------------------------- #
## The dictionary which is used to grab the defaults and other values associated with each setting
## relevant to Loggie, particularly important for the default way of loading [LoggieSettings] and
## setting up Godot Project Settings related to Loggie.
const project_settings = {
	"update_check_mode" = {
		"path": "loggie/general/check_for_updates",
		"default_value" : LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_UPDATER_WINDOW,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Never:0,Only print notice if available:1,Print notice and auto-install:2,Yes and show updater window:3",
		"doc" : "Sets which behavior Loggie should use when checking for updates.",
	},
	"remove_settings_if_plugin_disabled" = {
		"path": "loggie/general/remove_settings_if_plugin_disabled",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "Choose whether you want Loggie project settings to be wiped from ProjectSettings if the Loggie plugin is disabled.",
	},
	"msg_format_mode" = {
		"path": "loggie/general/msg_format_mode",
		"default_value" : LoggieEnums.MsgFormatMode.BBCODE,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Plain:0,ANSI:1,BBCode:2,Markdown:3",
		"doc" : "Choose the format for which loggie should preprocess the output so that it displays correctly on the intended output medium.[br][br]Use BBCode for Godot console.[br]Use ANSI for Powershell, Bash, etc.[br]Use MARKDOWN for Discord.[br]Use PLAIN for log files.",
	},
	"log_level" = {
		"path": "loggie/general/log_level",
		"default_value" : LoggieEnums.LogLevel.INFO,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Error:0,Warn:1,Notice:2,Info:3,Debug:4",
		"doc" : "Choose the level of messages which should be displayed. Loggie displays all messages that are outputted at the currently set level (or any lower level).",
	},
	"show_system_specs" = {
		"path": "loggie/general/show_system_specs",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "Should Loggie log the system and device specs of the user as soon as it is booted?",
	},
	"show_loggie_specs" = {
		"path": "loggie/general/show_loggie_specs",
		"default_value" : LoggieEnums.ShowLoggieSpecsMode.ESSENTIAL,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Disabled:0,Essential:1,Advanced:2",
		"doc" : "Defines which way Loggie should print its own specs when it is booted.",
	},
	"enforce_optimal_settings_in_release_build" = {
		"path": "loggie/general/enforce_optimal_settings_in_release_build",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "Should Loggie enforce certain settings to automatically change to optimal values in production/release builds?",
	},
	"default_channels" = {
		"path": "loggie/general/default_channels",
		"default_value" : ["terminal"],
		"type" : TYPE_PACKED_STRING_ARRAY,
		"hint" : PROPERTY_HINT_TYPE_STRING,
		"hint_string" : "",
		"doc" : "The channels messages outputted from Loggie will be sent to by default (if not modified with LoggieMsg.channel method).",
	},
	"skipped_filenames_in_stack_trace" = {
		"path": "loggie/general/skipped_filenames_in_stack_trace",
		"default_value" : ["loggie", "loggie_message"],
		"type" : TYPE_PACKED_STRING_ARRAY,
		"hint" : PROPERTY_HINT_TYPE_STRING,
		"hint_string" : "",
		"doc" : "The file names, which, when appearing in a stack trace, should be omitted from the output.",
	},
	"discord_webhook_url_live" = {
		"path": "loggie/general/discord/live_webhook",
		"default_value" : "",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_MULTILINE_TEXT,
		"hint_string" : "",
		"doc" : "The endpoint URL for the Discord webhook used when Loggie is running in a production build.",
	},
	"discord_webhook_url_dev" = {
		"path": "loggie/general/discord/dev_webhook",
		"default_value" : "",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_MULTILINE_TEXT,
		"hint_string" : "",
		"doc" : "The endpoint URL for the Discord webhook used when Loggie is not running in a production build.",
	},
	"slack_webhook_url_live" = {
		"path": "loggie/general/slack/live_webhook",
		"default_value" : "",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_MULTILINE_TEXT,
		"hint_string" : "",
		"doc" : "The endpoint URL for the Slack webhook used when Loggie is running in a production build.",
	},
	"slack_webhook_url_dev" = {
		"path": "loggie/general/slack/dev_webhook",
		"default_value" : "",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_MULTILINE_TEXT,
		"hint_string" : "",
		"doc" : "The endpoint URL for the Slack webhook used when Loggie is not running in a production build.",
	},
	"timestamps_use_utc" = {
		"path": "loggie/preprocessing/timestamps_use_utc",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "If 'Output Timestamps' is true, should those timestamps use the UTC time. If not, local system time is used instead.",
	},
	"output_errors_to_console" = {
		"path": "loggie/preprocessing/terminal/output_errors_also_to_console",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "If true, errors printed by Loggie will also be visible through an additional print in the main output.",
	},
	"output_warnings_to_console" = {
		"path": "loggie/preprocessing/terminal/output_warnings_also_to_console",
		"default_value" : true,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "If true, warnings printed by Loggie will also be visible through an additional print in the main output.",
	},
	"debug_msgs_print_stack_trace" = {
		"path": "loggie/preprocessing/terminal/debug_msgs_print_stack_trace",
		"default_value" : false,
		"type" : TYPE_BOOL,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "If true, 'debug' level messages outputted by Loggie will also print the stack trace.",
	},
	"nameless_class_name_proxy" = {
		"path": "loggie/preprocessing/nameless_class_name_proxy",
		"default_value" : LoggieEnums.NamelessClassExtensionNameProxy.BASE_TYPE,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Nothing:0,ScriptName:1,BaseType:2",
		"doc" : "If 'Derive and Display Class Names From Scripts' is enabled, and a script doesn't have a 'class_name', which text should we use as a substitute?",
	},
	"preprocess_flags_terminal_channel" = {
		"path": "loggie/preprocessing/terminal/preprocess_flags",
		"default_value" : LoggieEnums.PreprocessStep.APPEND_TIMESTAMPS | LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_FLAGS,
		"hint_string" : "Append Timestamp:1,Append Domain Name:2,Append Class Name:4",
		"doc" : "Defines the flags which LoggieMessages sent to the terminal channel will use during preprocessing.",
	},
	"preprocess_flags_discord_channel" = {
		"path": "loggie/preprocessing/discord/preprocess_flags",
		"default_value" : LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_FLAGS,
		"hint_string" : "Append Timestamp:1,Append Domain Name:2,Append Class Name:4",
		"doc" : "Defines the flags which LoggieMessages sent to the Discord channel will use during preprocessing.",
	},
	"preprocess_flags_slack_channel" = {
		"path": "loggie/preprocessing/slack/preprocess_flags",
		"default_value" : LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_FLAGS,
		"hint_string" : "Append Timestamp:1,Append Domain Name:2,Append Class Name:4",
		"doc" : "Defines the flags which LoggieMessages sent to the Slack channel will use during preprocessing.",
	},
	"format_timestamp" = {
		"path": "loggie/formats/timestamp",
		"default_value" : "[{day}.{month}.{year} {hour}:{minute}:{second}]",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for timestamps which are prepended to the message when the appending of timestamps is enabled.",
	},
	"format_stacktrace_entry" = {
		"path": "loggie/formats/stacktrace_entry",
		"default_value" : "{index}: [color=#ff7085]func[/color] [color=#53b1c3][b]{fn_name}[/b]:{line}[/color] [color=slate_gray][i](in {source_path})[/i][/color]",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for stack trace entries when trace logging is enabled.",
	},
	"format_debug_msg" = {
		"path": "loggie/formats/debug_message",
		"default_value" : "[b][color=pink][DEBUG]:[/color][/b] {msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for debug messages.",
	},
	"format_info_msg" = {
		"path": "loggie/formats/info_message",
		"default_value" : "{msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for info messages.",
	},
	"format_notice_msg" = {
		"path": "loggie/formats/notice_message",
		"default_value" : "[b][color=cyan][NOTICE]:[/color][/b] {msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for notice messages.",
	},
	"format_warning_msg" = {
		"path": "loggie/formats/warning_message",
		"default_value" : "[b][color=orange][WARN]:[/color][/b] {msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for warning messages.",
	},
	"format_error_msg" = {
		"path": "loggie/formats/error_message",
		"default_value" : "[b][color=red][ERROR]:[/color][/b] {msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for error messages.",
	},
	"format_domain_prefix" = {
		"path": "loggie/formats/domain_prefix",
		"default_value" : "[b]({domain})[/b] {msg}",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for domain prefixes.",
	},
	"format_header" = {
		"path": "loggie/formats/header",
		"default_value" : "[b][i]{msg}[/i][/b]",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The format used for headers.",
	},
	"h_separator_symbol" = {
		"path": "loggie/formats/h_separator_symbol",
		"default_value" : "-",
		"type" : TYPE_STRING,
		"hint" : PROPERTY_HINT_NONE,
		"hint_string" : "",
		"doc" : "The symbol used for the horizontal separator.",
	},
	"box_characters_mode" = {
		"path": "loggie/formats/box_characters_mode",
		"default_value" : LoggieEnums.BoxCharactersMode.COMPATIBLE,
		"type" : TYPE_INT,
		"hint" : PROPERTY_HINT_ENUM,
		"hint_string" : "Compatible:0,Pretty:1",
		"doc" : "There are two sets of box characters defined in LoggieSettings - one set contains prettier characters that produce a nicer looking box, but may not render correctly in the context of various terminals. The other set contains characters that produce a less pretty box, but are compatible with being shown in most terminals.",
	}
}

#endregion
# ----------------------------------------------- #
#region Variables
# ----------------------------------------------- #

## The current behavior Loggie uses to check for updates.
var update_check_mode : LoggieEnums.UpdateCheckType = LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_UPDATER_WINDOW

## The current Message Format Mode of Loggie.
## Message Format Mode determines whether BBCode, ANSI or some other type of
## formatting is used to convey text effects, such as bold, italic, colors, etc.
## [br][br]BBCode is compatible with the Godot console.
## [br]ANSI is compatible with consoles like Powershell and Windows CMD.
## [br]PLAIN is used to strip any effects and use plain text instead, which is good for saving raw logs into log files.
var msg_format_mode : LoggieEnums.MsgFormatMode = LoggieEnums.MsgFormatMode.BBCODE

## The current log level of Loggie.
## It determines which types of messages are allowed to be logged.
## Set this using [method setLogLevel].
var log_level : LoggieEnums.LogLevel = LoggieEnums.LogLevel.INFO

## Whether or not Loggie should log the loggie specs on ready.
var show_loggie_specs : LoggieEnums.ShowLoggieSpecsMode = LoggieEnums.ShowLoggieSpecsMode.ESSENTIAL

## Whether or not Loggie should log the system specs on ready.
var show_system_specs : bool = true

## Whether to, in addition to logging errors with [method push_error], 
## Loggie should also print the error as a message in the standard output.
var print_errors_to_console : bool = true

## Whether to, in addition to logging errors with [method push_warning], 
## Loggie should also print the error as a message in the standard output.
var print_warnings_to_console : bool = true

## Defines which text will be used as a substitute for the 'class_name' of scripts that do not have a 'class_name'.
## Relevant only during the [member LoggieEnums.PreprocessStep.APPEND_CLASS_NAME] step of preprocessing.
var nameless_class_name_proxy : LoggieEnums.NamelessClassExtensionNameProxy

## Whether the outputted timestamps use UTC or local machine time.
var timestamps_use_utc : bool = true

## If true, when outputting Debug level messages, the stack trace will also be appended.
var debug_msgs_print_stack_trace : bool = false

## Whether Loggie should enforce optimal values for certain settings when in a Release/Production build.
## [br]If true, Loggie will enforce:
## [br]  * [member msg_format_mode] to [member LoggieEnums.MsgFormatMode.PLAIN]
## [br]  * [member box_characters_mode] to [member LoggieEnums.BoxCharactersMode.COMPATIBLE]
var enforce_optimal_settings_in_release_build : bool = true

## Endpoint URL for the Discord webhook (used in dev environment)
## [br][b]NEVER[/b] distribute your webhook in your project's repository, source code, or built game, where it can be accessed by other people.
## This is meant to be used only in controlled circumstances.
var discord_webhook_url_dev : String = "" 

## Endpoint URL for the Discord webhook (used in production/release environment)
## [br][b]NEVER[/b] distribute your webhook in your project's repository, source code, or built game, where it can be accessed by other people.
## This is meant to be used only in controlled circumstances.
var discord_webhook_url_live : String = "" 

## Endpoint URL for the Slack webhook (used in dev environment)
## [br][b]NEVER[/b] distribute your webhook in your project's repository, source code, or built game, where it can be accessed by other people.
## This is meant to be used only in controlled circumstances.
var slack_webhook_url_dev : String = "" 

## Endpoint URL for the Slack webhook (used in production/release environment)
## [br][b]NEVER[/b] distribute your webhook in your project's repository, source code, or built game, where it can be accessed by other people.
## This is meant to be used only in controlled circumstances.
var slack_webhook_url_live : String = "" 

## Defines the flags which LoggieMessages sent to the terminal channel will use during preprocessing.
var preprocess_flags_terminal_channel = LoggieEnums.PreprocessStep.APPEND_TIMESTAMPS | LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME

## Defines the flags which LoggieMessages sent to the Discord channel output will use during preprocessing.
var preprocess_flags_discord_channel = LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME

## Defines the flags which LoggieMessages sent to the Slack channel output will use during preprocessing.
var preprocess_flags_slack_channel = LoggieEnums.PreprocessStep.APPEND_DOMAIN_NAME | LoggieEnums.PreprocessStep.APPEND_CLASS_NAME

## The list of channels a message outputted from Loggie should be sent to by default.
var default_channels : PackedStringArray = ["terminal"]

## The list of file names, which, when appearing in a stack trace, should be omitted from the output..
var skipped_filenames_in_stack_trace : PackedStringArray = ["loggie", "loggie_message"]

#endregion
# ----------------------------------------------- #
#region Formats for prints
# ----------------------------------------------- #
# As per the `print_rich` documentation, supported colors are: black, red, green, yellow, blue, magenta, pink, purple, cyan, white, orange, gray.
# Any other color will be displayed in the Godot console or an ANSI based console, but the color tag (in case of BBCode) won't be properly stripped
# when written to the .log file, resulting in BBCode visible in .log files.

## The format used to decorate a message as a header when using [method LoggieMsg.header].[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
var format_header = "[b][i]{msg}[/i][/b]"

## The format used when appending a domain to a message.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## The [param {domain}] is a variable that will be replaced with the domain key.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_domain_prefix = "[b]({domain})[/b] {msg}"

## The format used when outputting error messages.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_error_msg = "[b][color=red][ERROR]:[/color][/b] {msg}"

## The format used when outputting warning messages.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_warning_msg = "[b][color=orange][WARN]:[/color][/b] {msg}"

## The format used when outputting notice messages.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_notice_msg = "[b][color=cyan][NOTICE]:[/color][/b] {msg}"

## The format used when outputting info messages.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_info_msg = "{msg}"

## The format used when outputting debug messages.[br]
## The [param {msg}] is a variable that will be replaced with the contents of the message.[br]
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_debug_msg = "[b][color=pink][DEBUG]:[/color][/b] {msg}"

## The format used for timestamps when they are prepended to the output.[br]
## The variables [param {day}], [param {month}], [param {year}], [param {hour}], [param {minute}], [param {second}], [param {weekday}], and [param {dst}] are supported.
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_timestamp = "[{day}.{month}.{year} {hour}:{minute}:{second}]"

## The format used for each entry in a stack trace that is obtained through [method Loggie.stack].
## The variables [param {fn_name}], [param {index}], [param {source_path}], [param {line}] are supported.
## You can customize this in your ProjectSettings, or custom_settings.gd (if using it).[br]
var format_stacktrace_entry = "{index}: [color=#ff7085]func[/color] [color=#53b1c3][b]{fn_name}[/b]:{line}[/color] [color=slate_gray][i](in {source_path})[/i][/color]"

## The symbol which will be used for the HSeparator.
var h_separator_symbol = "-"

## The mode used for drawing boxes.
var box_characters_mode : LoggieEnums.BoxCharactersMode

## The symbols which will be used to construct a box decoration that will properly
## display on any kind of terminal or text reader.
## For a prettier but potentially incompatible box, use [member box_symbols_pretty] instead.
var box_symbols_compatible = {
	# ANSI and .log compatible box characters:
	"top_left" : "-",
	"top_right" : "-",
	"bottom_left" : "-",
	"bottom_right" : "-",
	"h_line" : "-",
	"v_line" : ":",
}

## The symbols which will be used to construct pretty box decoration.
## These may not be compatible with some terminals or text readers.
## Use the [member box_symbols_compatible] instead as an alternative.
var box_symbols_pretty = {
	"top_left" : "",
	"top_right" : "",
	"bottom_left" : "",
	"bottom_right" : "",
	"h_line" : "",
	"v_line" : "",
}

#endregion
# ----------------------------------------------- #

## A [Callable] function that takes 1 parameter [param something] (Variant),
## and returns a [String] which represents the given [param something] in text.
## By default, Loggie sets this to `LoggieTools.convert_to_string` when initialized.
## [br][br]
## You can, however, override that by changing this value to a valid replacement [Callable], 
## after Loggie has initialized.
var custom_string_converter : Callable

## Loads the initial (default) values for all of the LoggieSettings variables.
## (By default, loads them from ProjectSettings (if any modifications there exist), 
## or looks in [LoggieEditorPlugin..project_settings] for default values).
## [br][br]Extend this class and override this function to write your own logic for 
## how loggie should obtain these settings if you have a need for a different approach.
func load():
	update_check_mode = ProjectSettings.get_setting(project_settings.update_check_mode.path, project_settings.update_check_mode.default_value)
	msg_format_mode = ProjectSettings.get_setting(project_settings.msg_format_mode.path, project_settings.msg_format_mode.default_value)
	log_level = ProjectSettings.get_setting(project_settings.log_level.path, project_settings.log_level.default_value)
	show_loggie_specs = ProjectSettings.get_setting(project_settings.show_loggie_specs.path, project_settings.show_loggie_specs.default_value)
	show_system_specs = ProjectSettings.get_setting(project_settings.show_system_specs.path, project_settings.show_system_specs.default_value)
	timestamps_use_utc = ProjectSettings.get_setting(project_settings.timestamps_use_utc.path, project_settings.timestamps_use_utc.default_value)
	enforce_optimal_settings_in_release_build = ProjectSettings.get_setting(project_settings.enforce_optimal_settings_in_release_build.path, project_settings.enforce_optimal_settings_in_release_build.default_value)
	default_channels = ProjectSettings.get_setting(project_settings.default_channels.path, project_settings.default_channels.default_value)
	skipped_filenames_in_stack_trace = ProjectSettings.get_setting(project_settings.skipped_filenames_in_stack_trace.path, project_settings.skipped_filenames_in_stack_trace.default_value)

	print_errors_to_console = ProjectSettings.get_setting(project_settings.output_errors_to_console.path, project_settings.output_errors_to_console.default_value)
	print_warnings_to_console = ProjectSettings.get_setting(project_settings.output_warnings_to_console.path, project_settings.output_warnings_to_console.default_value)
	debug_msgs_print_stack_trace = ProjectSettings.get_setting(project_settings.debug_msgs_print_stack_trace.path, project_settings.debug_msgs_print_stack_trace.default_value)

	nameless_class_name_proxy = ProjectSettings.get_setting(project_settings.nameless_class_name_proxy.path, project_settings.nameless_class_name_proxy.default_value)
	box_characters_mode = ProjectSettings.get_setting(project_settings.box_characters_mode.path, project_settings.box_characters_mode.default_value)

	format_timestamp = ProjectSettings.get_setting(project_settings.format_timestamp.path, project_settings.format_timestamp.default_value)
	format_stacktrace_entry = ProjectSettings.get_setting(project_settings.format_stacktrace_entry.path, project_settings.format_stacktrace_entry.default_value)
	format_info_msg = ProjectSettings.get_setting(project_settings.format_info_msg.path, project_settings.format_info_msg.default_value)
	format_notice_msg = ProjectSettings.get_setting(project_settings.format_notice_msg.path, project_settings.format_notice_msg.default_value)
	format_warning_msg = ProjectSettings.get_setting(project_settings.format_warning_msg.path, project_settings.format_warning_msg.default_value)
	format_error_msg = ProjectSettings.get_setting(project_settings.format_error_msg.path, project_settings.format_error_msg.default_value)
	format_debug_msg = ProjectSettings.get_setting(project_settings.format_debug_msg.path, project_settings.format_debug_msg.default_value)
	h_separator_symbol = ProjectSettings.get_setting(project_settings.h_separator_symbol.path, project_settings.h_separator_symbol.default_value)
	
	discord_webhook_url_live = ProjectSettings.get_setting(project_settings.discord_webhook_url_live.path, project_settings.discord_webhook_url_live.default_value)
	discord_webhook_url_dev = ProjectSettings.get_setting(project_settings.discord_webhook_url_dev.path, project_settings.discord_webhook_url_dev.default_value)
	preprocess_flags_discord_channel = ProjectSettings.get_setting(project_settings.preprocess_flags_discord_channel.path, project_settings.preprocess_flags_discord_channel.default_value)
	slack_webhook_url_live = ProjectSettings.get_setting(project_settings.slack_webhook_url_live.path, project_settings.slack_webhook_url_live.default_value)
	slack_webhook_url_dev = ProjectSettings.get_setting(project_settings.slack_webhook_url_dev.path, project_settings.slack_webhook_url_dev.default_value)
	preprocess_flags_slack_channel = ProjectSettings.get_setting(project_settings.preprocess_flags_slack_channel.path, project_settings.preprocess_flags_slack_channel.default_value)
	preprocess_flags_terminal_channel = ProjectSettings.get_setting(project_settings.preprocess_flags_terminal_channel.path, project_settings.preprocess_flags_terminal_channel.default_value)

## Returns a dictionary where the indices are names of relevant variables in the LoggieSettings class,
## and the values are their current values.
func to_dict() -> Dictionary:
	var dict = {}
	var included = [
		"preprocess_flags_discord_channel", "preprocess_flags_slack_channel", "preprocess_flags_terminal_channel",
		"default_channels", "skipped_filenames_in_stack_trace", "msg_format_mode", "log_level", "show_loggie_specs", "show_system_specs", "enforce_optimal_settings_in_release_build",
		"print_errors_to_console", "print_warnings_to_console",
		"debug_msgs_print_stack_trace", "nameless_class_name_proxy",
		"timestamps_use_utc", "format_header", "format_domain_prefix", "format_error_msg",
		"format_warning_msg", "format_notice_msg", "format_info_msg", "format_debug_msg", "format_timestamp",
		"h_separator_symbol", "box_characters_mode", "box_symbols_compatible", "box_symbols_pretty",
	]
	
	for var_name in included:
		dict[var_name] = get(var_name)
	return dict

--- SCRIPT: res://addons/loggie/plugin.gd ---
@tool
class_name LoggieEditorPlugin extends EditorPlugin

func _enter_tree():
	add_autoload_singleton(LoggieSettings.loggie_singleton_name, "res://addons/loggie/loggie.gd")
	add_loggie_project_settings()
	Engine.set_meta("LoggieEditorPlugin", self)
	if Engine.is_editor_hint():
		Engine.set_meta("LoggieEditorInterfaceBaseControl", EditorInterface.get_base_control())
	
func _enable_plugin() -> void:
	add_loggie_project_settings()

func _disable_plugin() -> void:
	var wipe_setting_exists = ProjectSettings.has_setting(LoggieSettings.project_settings.remove_settings_if_plugin_disabled.path)
	if (not wipe_setting_exists) or (wipe_setting_exists and ProjectSettings.get_setting(LoggieSettings.project_settings.remove_settings_if_plugin_disabled.path, true)):
		push_warning("The Loggie plugin is being disabled, and all of its ProjectSettings are erased from Godot. If you wish to prevent this behavior, look for the 'Project Settings -> Loggie -> General -> Remove Settings if Plugin Disabled' option while the plugin is enabled.")
		remove_loggie_project_setings()
	else:
		push_warning("The Loggie plugin is being disabled, but its ProjectSettings have been prevented from being removed from Godot. If you wish to allow that behavior, look for the 'Project Settings -> Loggie -> General -> Remove Settings if Plugin Disabled' option while the plugin is enabled.")
	remove_autoload_singleton(LoggieSettings.loggie_singleton_name)

## Adds new Loggie related ProjectSettings to Godot.
func add_loggie_project_settings():
	for setting in LoggieSettings.project_settings.values():
		add_project_setting(setting["path"], setting["default_value"], setting["type"], setting["hint"], setting["hint_string"], setting["doc"])

## Removes Loggie related ProjectSettings from Godot.
func remove_loggie_project_setings():
	for setting in LoggieSettings.project_settings.values():
		ProjectSettings.set_setting(setting["path"], null)
	
	var error: int = ProjectSettings.save()
	if error != OK: 
		push_error("Loggie - Encountered error %d while saving project settings." % error)

## Adds a new project setting to Godot.
## (WARNING): Unfortunately, as of Godot 4.3, it has been confirmed that it is not possible to set the
## popup tooltip text for a project setting. This should be implemented here as soon as that becomes possible.
func add_project_setting(setting_name: String, default_value : Variant, value_type: int, type_hint: int = PROPERTY_HINT_NONE, hint_string: String = "", documentation : String = ""):
	if !ProjectSettings.has_setting(setting_name):
		ProjectSettings.set_setting(setting_name, default_value)
		
	ProjectSettings.set_initial_value(setting_name, default_value)
	ProjectSettings.add_property_info({	"name": setting_name, "type": value_type, "hint": type_hint, "hint_string": hint_string})
	ProjectSettings.set_as_basic(setting_name, true)

	var error: int = ProjectSettings.save()
	if error: 
		push_error("Loggie - Encountered error %d while saving project settings." % error)

--- SCRIPT: res://addons/loggie/tools/loggie_enums.gd ---
@tool
class_name LoggieEnums extends Node

## Based on which log level is currently set to be used by the Loggie., attempting to log a message that's on
## a higher-than-configured log level will result in nothing happening.
enum LogLevel {
	ERROR, 	## Log level which includes only the logging of Error type messages.
	WARN, 	## Log level which includes the logging of Error and Warning type messages.
	NOTICE, ## Log level which includes the logging of Error, Warning and Notice type messages.
	INFO,	## Log level which includes the logging of Error, Warning, Notice and Info type messages.
	DEBUG	## Log level which includes the logging of Error, Warning, Notice, Info and Debug type messages.
}

## The classification of message types that can be used to distinguish two identical strings in nature
## of their origin. This is different from [enum LogLevel].
enum MsgType {
	STANDARD, ## A message that is considered a standard text that is not special in any way.
	ERROR, ## A message that is considered to be an error message.
	WARNING, ## A message that is considered to be a warning message.
	DEBUG ## A message that is considered to be a message used for debugging.
}

enum MsgFormatMode {
	PLAIN, ## Prints will be plain text.
	ANSI,  ## Prints will be styled using the ANSI standard. Compatible with Powershell, Win CMD, etc.
	BBCODE, ## Prints will be styled using the Godot BBCode rules. Compatible with the Godot console.
	MARKDOWN, ## Prints will be styled using the Markdown standard. Compatible with most Markdown readers.
}

## Classifies various steps that can happen during preprocessing.
enum PreprocessStep {
	## A timestamp will be added to the message.
	APPEND_TIMESTAMPS = 1 << 0, 
	
	## The name of the domain from which the message is coming will be added to the message.
	APPEND_DOMAIN_NAME = 1 << 1, 

	## Whether Loggie should use the scripts from which it is being called to 
	## figure out a class name for the class that called a loggie function,
	## and append it to the outputted message.
	## This only works in debug builds because it uses [method @GDScript.get_stack]. 
	## See that method's documentation to see why that can't be used in release builds.
	APPEND_CLASS_NAME = 1 << 2,
}

enum BoxCharactersMode {
	COMPATIBLE, ## Boxes are drawn using characters that compatible with any kind of terminal or text reader.
	PRETTY ## Boxes are drawn using special unicode characters that create a prettier looking box which may not display properly in some terminals or text readers.
}

## Defines a list of possible approaches that can be taken to derive some kind of a class name proxy from a script that doesn't have a 'class_name' clause.
enum NamelessClassExtensionNameProxy {
	NOTHING, ## If there is no class_name, nothing will be displayed.
	SCRIPT_NAME, ## Use the name of the script whose class_name we tried to read. (e.g. "my_script.gd").
	BASE_TYPE, ## Use the name of the base type which the script extends (e.g. 'Node2D', 'Control', etc.)
}

## Defines a list of possible behaviors for the 'show_loggie_specs' setting.
enum ShowLoggieSpecsMode {
	DISABLED, ## Loggie specs won't be shown.
	ESSENTIAL, ## Show only the essentials.
	ADVANCED ## Show all loggie specs.
}

## Defines a list of possible outcomes that can happen when attempting to log a message.
enum LogAttemptResult {
	SUCCESS, ## Message will be logged successfully.
	LOG_LEVEL_INSUFFICIENT, ## Message won't be logged because it was output at a log level higher than what Loggie is currently set to.
	DOMAIN_DISABLED, ## Message won't be logged because it was outputted from a disabled domain.
	INVALID_CHANNEL, ## Message won't be logged because the channel which was supposed to send it doesn't exist.
}

## Defines a list of possible ways to configure Loggie to check for updates.
enum UpdateCheckType {
	DONT_CHECK, ## If the user doesn't want Loggie to check for updates at all.
	CHECK_AND_SHOW_MSG, ## If the user wants Loggie to check for updates, and display info in a terminal message.
	CHECK_DOWNLOAD_AND_SHOW_MSG, ## If the user wants Loggie to check for updates, download the update, and display info in a terminal message.
	CHECK_AND_SHOW_UPDATER_WINDOW, ## If the user wants Loggie to check for updats, and display the updater window.
}

--- SCRIPT: res://addons/loggie/tools/loggie_system_specs.gd ---
@tool

## LoggieSystemSpecs is a helper class that defines various functions on how to access data about the local machine and its specs
## and creates displayable strings out of them.
class_name LoggieSystemSpecsMsg extends LoggieMsg

## Embeds various system specs into the content of this message.
func embed_specs() -> LoggieSystemSpecsMsg:
	self.embed_system_specs()
	self.embed_localization_specs()
	self.embed_date_data().nl()
	self.embed_hardware_specs().nl()
	self.embed_video_specs().nl()
	self.embed_display_specs().nl()
	self.embed_audio_specs().nl()
	self.embed_engine_specs().nl()
	self.embed_input_specs()
	return self

## Embeds essential data about the logger into the content of this message.
func embed_essential_logger_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	self.add(loggie.msg("|\t Is in Production:").bold(), loggie.is_in_production()).nl()
	self.add(loggie.msg("|\t Default Channel(s):").bold(),loggie.settings.default_channels).nl()
	self.add(loggie.msg("|\t Msg Format Mode:").bold(), LoggieEnums.MsgFormatMode.keys()[loggie.settings.msg_format_mode]).nl()
	self.add(loggie.msg("|\t Log Level:").bold(), LoggieEnums.LogLevel.keys()[loggie.settings.log_level]).nl()
	return self

## Embeds advanced data about the logger into the content of this message.
func embed_advanced_logger_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	
	self.add(loggie.msg("|\t Is in Production:").bold(), loggie.is_in_production()).nl()
	
	var settings_dict = loggie.settings.to_dict()
	for setting_var_name : String in settings_dict.keys():
		var setting_value = settings_dict[setting_var_name]
		var content_to_print = setting_value
		
		match setting_var_name:
			"msg_format_mode":
				content_to_print = LoggieEnums.MsgFormatMode.keys()[setting_value]
			"log_level":
				content_to_print = LoggieEnums.LogLevel.keys()[setting_value]
			"box_characters_mode":
				content_to_print = LoggieEnums.BoxCharactersMode.keys()[setting_value]

		self.add(loggie.msg("|\t", setting_var_name.capitalize(), ":").bold(), content_to_print).nl()
	
	return self

## Adds data about the user's software to the content of this message.
func embed_system_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Operating System: ").color(Color.ORANGE).add(OS.get_name()).box(4)
	self.add(header)
	return self
	
## Adds data about localization to the content of this message.
func embed_localization_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Localization: ").color(Color.ORANGE).add(OS.get_locale()).box(7)
	self.add(header)
	return self

## Adds data about the current date/time to the content of this message.
func embed_date_data() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Date").color(Color.ORANGE).box(15)
	self.add(header)
	self.add(loggie.msg("Date and time (local):").bold(), Time.get_datetime_string_from_system(false, true)).nl()
	self.add(loggie.msg("Date and time (UTC):").bold(), Time.get_datetime_string_from_system(true, true)).nl()
	self.add(loggie.msg("Date (local):").bold(), Time.get_date_string_from_system(false)).nl()
	self.add(loggie.msg("Date (UTC):").bold(), Time.get_date_string_from_system(true)).nl()
	self.add(loggie.msg("Time (local):").bold(), Time.get_time_string_from_system(false)).nl()
	self.add(loggie.msg("Time (UTC):").bold(), Time.get_time_string_from_system(true)).nl()
	self.add(loggie.msg("Timezone:").bold(), Time.get_time_zone_from_system()).nl()
	self.add(loggie.msg("UNIX time:").bold(), Time.get_unix_time_from_system()).nl()
	return self

## Adds data about the user's hardware to the content of this message.
func embed_hardware_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Hardware").color(Color.ORANGE).box(13)
	self.add(header)
	self.add(loggie.msg("Model name:").bold(), OS.get_model_name()).nl()
	self.add(loggie.msg("Processor name:").bold(), OS.get_processor_name()).nl()
	return self

## Adds data about the video system to the content of this message.
func embed_video_specs() -> LoggieSystemSpecsMsg:
	const adapter_type_to_string = ["Other (Unknown)", "Integrated", "Discrete", "Virtual", "CPU"]
	var adapter_type_string = adapter_type_to_string[RenderingServer.get_video_adapter_type()]
	var video_adapter_driver_info = OS.get_video_adapter_driver_info()
	var loggie = get_logger()

	var header = loggie.msg("Video").color(Color.ORANGE).box(15)
	self.add(header)
	self.add(loggie.msg("Adapter name:").bold(), RenderingServer.get_video_adapter_name()).nl()
	self.add(loggie.msg("Adapter vendor:").bold(), RenderingServer.get_video_adapter_vendor()).nl()
	self.add(loggie.msg("Adapter type:").bold(), adapter_type_string).nl()
	self.add(loggie.msg("Adapter graphics API version:").bold(), RenderingServer.get_video_adapter_api_version()).nl()

	if video_adapter_driver_info.size() > 0:
		self.add(loggie.msg("Adapter driver name:").bold(), video_adapter_driver_info[0]).nl()
	if video_adapter_driver_info.size() > 1:
		self.add(loggie.msg("Adapter driver version:").bold(), video_adapter_driver_info[1]).nl()

	return self

## Adds data about the display to the content of this message.
func embed_display_specs() -> LoggieSystemSpecsMsg:
	const screen_orientation_to_string = [
		"Landscape",
		"Portrait",
		"Landscape (reverse)",
		"Portrait (reverse)",
		"Landscape (defined by sensor)",
		"Portrait (defined by sensor)",
		"Defined by sensor",
	]
	var screen_orientation_string = screen_orientation_to_string[DisplayServer.screen_get_orientation()]
	var loggie = get_logger()

	var header = loggie.msg("Display").color(Color.ORANGE).box(13)
	self.add(header)
	self.add(loggie.msg("Screen count:").bold(), DisplayServer.get_screen_count()).nl()
	self.add(loggie.msg("DPI:").bold(), DisplayServer.screen_get_dpi()).nl()
	self.add(loggie.msg("Scale factor:").bold(), DisplayServer.screen_get_scale()).nl()
	self.add(loggie.msg("Maximum scale factor:").bold(), DisplayServer.screen_get_max_scale()).nl()
	self.add(loggie.msg("Startup screen position:").bold(), DisplayServer.screen_get_position()).nl()
	self.add(loggie.msg("Startup screen size:").bold(), DisplayServer.screen_get_size()).nl()
	self.add(loggie.msg("Startup screen refresh rate:").bold(), ("%f Hz" % DisplayServer.screen_get_refresh_rate()) if DisplayServer.screen_get_refresh_rate() > 0.0 else "").nl()
	self.add(loggie.msg("Usable (safe) area rectangle:").bold(), DisplayServer.get_display_safe_area()).nl()
	self.add(loggie.msg("Screen orientation:").bold(), screen_orientation_string).nl()
	return self

## Adds data about the audio system to the content of this message.
func embed_audio_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Audio").color(Color.ORANGE).box(14)
	self.add(header)
	self.add(loggie.msg("Mix rate:").bold(), "%d Hz" % AudioServer.get_mix_rate()).nl()
	self.add(loggie.msg("Output latency:").bold(), "%f ms" % (AudioServer.get_output_latency() * 1000)).nl()
	self.add(loggie.msg("Output device list:").bold(), ", ".join(AudioServer.get_output_device_list())).nl()
	self.add(loggie.msg("Capture device list:").bold(), ", ".join(AudioServer.get_input_device_list())).nl()
	return self

## Adds data about the godot engine to the content of this message.
func embed_engine_specs() -> LoggieSystemSpecsMsg:
	var loggie = get_logger()
	var header = loggie.msg("Engine").color(Color.ORANGE).box(14)
	self.add(header)
	self.add(loggie.msg("Version:").bold(), Engine.get_version_info()["string"]).nl()
	self.add(loggie.msg("Command-line arguments:").bold(), str(OS.get_cmdline_args())).nl()
	self.add(loggie.msg("Is debug build:").bold(), OS.is_debug_build()).nl()
	self.add(loggie.msg("Filesystem is persistent:").bold(), OS.is_userfs_persistent()).nl()
	return self

## Adds data about the input device to the content of this message.
func embed_input_specs() -> LoggieSystemSpecsMsg:
	var has_virtual_keyboard = DisplayServer.has_feature(DisplayServer.FEATURE_VIRTUAL_KEYBOARD)
	var loggie = get_logger()

	var header = loggie.msg("Input").color(Color.ORANGE).box(14)
	self.add(header)
	self.add(loggie.msg("Device has touch screen:").bold(), DisplayServer.is_touchscreen_available()).nl()
	self.add(loggie.msg("Device has virtual keyboard:").bold(), has_virtual_keyboard).nl()

	if has_virtual_keyboard:
		self.add(loggie.msg("Virtual keyboard height:").bold(), DisplayServer.virtual_keyboard_get_height())

	return self

## Prints out a bunch of useful data about a given script.
## Useful for debugging.
func embed_script_data(script : Script):
	var loggie = get_logger()
	self.add("Script Data for:", script.get_path()).color("pink")
	self.add(":").nl()
	self.add(loggie.msg("get_class(): ").color("slate_blue").bold()).add(script.get_class()).nl()
	self.add(loggie.msg("get_global_name(): ").color("slate_blue").bold()).add(script.get_global_name()).nl()
	self.add(loggie.msg("get_base_script(): ").color("slate_blue").bold()).add(script.get_base_script().resource_path if script.get_base_script() != null else "No base script.").nl()
	self.add(loggie.msg("get_instance_base_type(): ").color("slate_blue").bold()).add(script.get_instance_base_type()).nl()
	self.add(loggie.msg("get_script_property_list(): ").color("slate_blue").bold()).add(script.get_script_property_list()).nl()
	return self

--- SCRIPT: res://addons/loggie/tools/loggie_tools.gd ---
@tool
class_name LoggieTools extends Node

## Removes BBCode from the given text.
## If [param specific_tags] is an array, it removes only the tags found in that array.
## Otherwise, it removes the tags found in the default_tags array:[br]
## [param ["b", "i", "u", "s", "indent", "code", "url", "center", "right", "color", "bgcolor", "fgcolor"]]
static func remove_BBCode(text: String, specific_tags = null) -> String:
	# The bbcode tags to remove.
	var default_tags = ["b", "i", "u", "s", "indent", "code", "url", "center", "right", "color", "bgcolor", "fgcolor"]
	var tags = specific_tags if specific_tags is Array else default_tags

	var regex = RegEx.new()
	var tags_pattern = "|".join(tags)
	regex.compile("\\[/?(" + tags_pattern + ")(=[^\\]]*)?\\]")

	var stripped_text = regex.sub(text, "", true)
	return stripped_text

## Concatenates all elements of the given [param args] array into one single string, in consecutive order.
## If [param custom_converter_fn] is provided, and is a [Callable], that function will be used to convert each element of the array into a string
## instead of using [method convert_to_string]. That function will receive 1 argument, which will be a 'Variant', and it has to return a 'String'.
static func concatenate_args(args : Array, custom_converter_fn : Variant = null) -> String:
	if args.size() == 0:
		return ""

	var converter_fn : Callable = LoggieTools.convert_to_string
	if custom_converter_fn is Callable and custom_converter_fn.is_valid() and !custom_converter_fn.is_null():
		converter_fn = custom_converter_fn

	# Start with first element without modifying array
	var final_msg : String = converter_fn.call(args[0])

	# Start from index 1 since we already handled index 0
	for i in range(1, args.size()):
		var arg = args[i]
		var is_not_followed_by_a_null_arg = true if (i + 1 <= args.size() - 1) and (args[i + 1] != null) else false
		if (arg != null) or (arg == null and is_not_followed_by_a_null_arg):
			var converted_arg : String = converter_fn.call(arg)
			final_msg += (" " + converted_arg)

	return final_msg

## Converts a text with BBCode in it to markdown.
## A limited set of BBCode tags are supported for this conversion, because standard Markdown can't handle everything
## that BBCode can. For example, colors will be entirely stripped.
static func convert_BBCode_to_markdown(text: String) -> String:
	# Purge the unsupported tags.
	var unsupported_tags = ["indent", "url", "center", "right", "color", "bgcolor", "fgcolor"]
	text = LoggieTools.remove_BBCode(text, unsupported_tags)

	# Space out all instances where "*" characters from multiple tags are strung together,
	# since that would break them from rendering with the proper effect in markdown.
	# This is only an issue with [b] and [i] tags because they both use the same "*" character
	# in markdown to be represented.
	text = text.replace("[/b][i]", "** *")
	text = text.replace("[/b][/i]", "** *")
	text = text.replace("[/i][b]", "* **")
	text = text.replace("[/i][/b]", "* **")
	text = text.replace("[/i][i]", "* *")
	text = text.replace("[/i][/i]", "* *")
	text = text.replace("[/b][b]", "** **")
	text = text.replace("[/b][/b]", "** **")

	# Perform all supported conversion.
	var supported_conversions = {
		"[b]" : "**", "[/b]" : "**",
		"[i]" : "*",  "[/i]" : "*",
		"[u]" : "__", "[/u]" : "__",
		"[s]" : "~~", "[/s]" : "~~",
	}
	for bbcodetag in supported_conversions.keys():
		text = text.replace(bbcodetag, supported_conversions[bbcodetag])

	return text

## Converts [param something] into a string, with custom handling for
## certain native and custom classes.
static func convert_to_string(something : Variant) -> String:
	var result : String
	if something is Dictionary:
		result = JSON.new().stringify(something, "  ", false, true)
	elif something is LoggieMsg:
		result = something.string()
	else:
		result = str(something)
	return result

## Takes the given [param str] and returns a terminal-ready version of it by converting its content
## to the appropriate format required to display the string correctly in the provided [param mode]
## msg format mode.
## [b]The provided [param str] is expected to be either in Plain or BBCode format.[/b]
static func convert_string_to_format_mode(str : String, mode : LoggieEnums.MsgFormatMode) -> String:
	match mode:
		LoggieEnums.MsgFormatMode.ANSI:
			# We put the message through the rich_to_ANSI converter which takes care of converting BBCode
			# to appropriate ANSI. (Only if the MsgFormatMode is set to ANSI).
			# Godot claims to be already preparing BBCode output for ANSI, but it only works with a small
			# predefined set of colors, and I think it totally strips stuff like [b], [i], etc.
			# It is possible to display those stylings in ANSI, but we have to do our own conversion here
			# to support these features instead of having them stripped.
			str = LoggieTools.rich_to_ANSI(str)
		LoggieEnums.MsgFormatMode.BBCODE:
			# No need to do anything for BBCODE mode, because we already expect all strings to
			# start out with this format in mind.
			pass
		LoggieEnums.MsgFormatMode.MARKDOWN:
			str = LoggieTools.convert_BBCode_to_markdown(str)
		LoggieEnums.MsgFormatMode.PLAIN, _:
			str = LoggieTools.remove_BBCode(str)
	return str

## Converts a given [Color] to an ANSI compatible representation of it in code.
static func color_to_ANSI(color: Color) -> String:
	var r = int(color.r * 255)
	var g = int(color.g * 255)
	var b = int(color.b * 255)
	return "\u001b[38;2;%d;%d;%dm" % [r, g, b]

## Strips the BBCode from the given text, and converts all [b], [i] and [color] tags to appropriate ANSI representable codes,
## then returns the converted string. The result of this conversion becomes an ANSI compatible representation of the given [param text].
static func rich_to_ANSI(text: String) -> String:
	var regex_color = RegEx.new()
	regex_color.compile("\\[color=(.*?)\\](.*?)\\[/color\\]")
	
	# Process color tags first.
	while regex_color.search(text):
		var match = regex_color.search(text)
		var color_str = match.get_string(1).to_upper()
		var color: Color
		var color_code: String
		var reset_code = "\u001b[0m"
		
		# Try to parse the color string
		if LoggieTools.NamedColors.has(color_str):
			color = LoggieTools.NamedColors[color_str]
		else:
			color = Color(color_str)
		
		if color:
			color_code = color_to_ANSI(color)
		else:
			color_code = ""
			reset_code = ""
		
		var replacement = color_code + match.get_string(2) + reset_code
		text = text.replace(match.get_string(0), replacement)
	
	# Process bold and italic tags.
	var bold_on = "\u001b[1m"
	var bold_off = "\u001b[22m"
	var italic_on = "\u001b[3m"
	var italic_off = "\u001b[23m"

	text = text.replace("[b]", bold_on).replace("[/b]", bold_off)
	text = text.replace("[i]", italic_on).replace("[/i]", italic_off)

	# Remove any other BBCode tags but retain the text between them.
	var regex_bbcode = RegEx.new()
	regex_bbcode.compile("\\[(b|/b|i|/i|color=[^\\]]+|/color)\\]")
	text = regex_bbcode.sub(text, "", true)

	return text

## Returns a dictionary of call stack data related to the stack the call to this function is a part of.
## This function only works in debug builds, and on the main thread, because it uses [method get_stack].
## Read more about why in that function's documentation.
static func get_current_stack_frame_data() -> Dictionary:
	var stack = get_stack()
	if stack.size() > 0:
		stack.reverse()
		# Prune the frames starting from the first one that comes from loggie_message and onwards.
		var pruned_stack = []
		for index in stack.size():
			var source : String = stack[index].source
			var prune_breakpoint_files = ["loggie", "loggie_message"]
			if prune_breakpoint_files.has(source.get_file().get_basename()):
				break
			pruned_stack.push_back(stack[index])
		
		# The back-most remaining entry in the pruned stack is the first non-Loggie caller.
		if pruned_stack.size() >= 1:
			return pruned_stack.back()

	return {
		"source" : "UnknownStackFrameSource",
		"line" : 0,
		"function" : "UnknownFunction"
	}

## Returns the `class_name` of a script.
## [br][param path_or_script] should be either an absolute path to the script 
## (String, e.g. "res://my_script.gd"), or a [Script] object.
## [br][param proxy] defines which kind of text will be used as a replacement
## for the class name if the script has no 'class_name'.
static func get_class_name_from_script(path_or_script : Variant, proxy : LoggieEnums.NamelessClassExtensionNameProxy) -> String:
	var script
	var _class_name = ""

	if path_or_script is String or path_or_script is StringName:
		if !ResourceLoader.exists(path_or_script, "Script"):
			return _class_name
		script = load(path_or_script)
	elif path_or_script is Script:
		script = path_or_script

	if not (script is Script):
		push_error("Invalid 'path_or_script' param provided to get_class_name_from_script: {path}".format({"path" : path_or_script}))
	else:
		if not script.has_method("get_global_name"):
			# User is using a pre-4.3 version of Godot that doesn't have Script.get_global_name.
			# We must use a different method to achieve this then.
			return extract_class_name_from_gd_script(path_or_script, proxy)

		# Try to get the class name directly.
		_class_name = script.get_global_name()

		if _class_name != "":
			return _class_name

		# If that's empty, the script is either a base class, or a class without a name.
		# Check if this script has a base script, and if so, use that one as the target whose name to obtain.
		# If it doesn't have it, use what the [param proxy] demands.
		var base_script = script.get_base_script()
		if base_script != null:
			return get_class_name_from_script(base_script, proxy)
		else:
			match proxy:
				LoggieEnums.NamelessClassExtensionNameProxy.BASE_TYPE:
					_class_name = script.get_instance_base_type()
				LoggieEnums.NamelessClassExtensionNameProxy.SCRIPT_NAME:
					_class_name = script.get_script_property_list().front()["name"]

	return _class_name

## Opens and reads a .gd script file to find out its 'class_name' or what it 'extends'.
## [param path_or_script] should be either an absolute path to the script 
## (String, e.g. "res://my_script.gd"), or a [Script] object.
## [br][param proxy] defines which kind of text will be used as a replacement
## for the class name if the script has no 'class_name'.
## [br][br][b]Note:[/b] This is a compatibility method that will be used on older versions of Godot which
## don't support [method Script.get_global_name].
static func extract_class_name_from_gd_script(path_or_script : Variant, proxy : LoggieEnums.NamelessClassExtensionNameProxy) -> String:
	var path : String

	if path_or_script is String:
		path = path_or_script
	elif path_or_script is Script:
		path = path_or_script.resource_path
	else:
		push_error("Invalid 'path_or_script' param provided to extract_class_name_from_gd_script: {path}".format({"path" : path_or_script}))
		return ""

	var file = FileAccess.open(path, FileAccess.READ)
	if not file:
		return "File Open Error {filepath}".format({"filepath" : path})

	var _class_name: String = ""

	for line_num in 40:  # Loop only up to 40 lines
		if file.eof_reached():
			break

		var line = file.get_line().strip_edges()

		if line.begins_with("class_name"):
			_class_name = line.split(" ")[1]
			break

	if _class_name == "":
		var script = load(path)
		if script is Script:
			match proxy:
				LoggieEnums.NamelessClassExtensionNameProxy.BASE_TYPE:
					_class_name = script.get_instance_base_type()
				LoggieEnums.NamelessClassExtensionNameProxy.SCRIPT_NAME:
					_class_name = script.get_script_property_list().front()["name"]

	file.close()
	return _class_name

## Takes the given [param string] and returns an array made out of chunks of the given size.
## The string is chunked from start to end.
static func chunk_string(string : String, chunk_size : int) -> Array:
	var message_chunks = []
	if string.length() >= chunk_size:
		# Cut chunk_size pieces from the left side of the string and push them to message_chunks.
		while string.length() >= chunk_size:
			message_chunks.append(string.left(chunk_size))
			string = string.substr(chunk_size, -1)
			
		# Append the remaining slice as the final chunk.
		if string.length() > 0:
			message_chunks.append(string)
		return message_chunks
	else:
		return [string]

## Copies the directory at the given [param path_dir_to_copy] path and places the copy at the given [param path_dir_to_copy_into] path.
## Returns a dictionary with 2 keys:
##[codeblock]
##`errors` : Array[Error] # An array of all errors that occured during the process. ('Error.OK' is an exception and won't be included here)
##`messages` : Array[LoggieMsg] # An array of messages describing the process, including informational or error related content.
##[/codeblock]
static func copy_dir_absolute(path_dir_to_copy: String, path_dir_to_copy_into: String, overwrite_existing_files_with_same_name : bool = false) -> Dictionary:
	const debug_enabled = false
	var result = {
		"errors" : [],
		"messages" : []
	}
	
	# Ensure source directory is openable.
	var source_dir = DirAccess.open(path_dir_to_copy)
	if source_dir == null:
		var open_error = DirAccess.get_open_error()
		result.errors.push_back(open_error)
		result.messages.push_back(LoggieMsg.new("Failed to open source directory: ", path_dir_to_copy, " with error: ", error_string(open_error)))
		return result

	# Ensure target directory is openable.
	var target_dir = DirAccess.open(path_dir_to_copy_into)
	var target_dir_path_abs = ProjectSettings.globalize_path(path_dir_to_copy_into)
	if target_dir == null:
		var msg = LoggieMsg.new(" Target directory not found - creating it at:").msg(path_dir_to_copy_into).color(Color.CADET_BLUE)
		result.messages.push_back(msg)
		DirAccess.make_dir_recursive_absolute(path_dir_to_copy_into)
		target_dir = DirAccess.open(path_dir_to_copy_into)

	# Copy all files from the current source directory into the target directory.
	for file_name : String in source_dir.get_files():
		var file_path_abs = ProjectSettings.globalize_path(path_dir_to_copy.path_join(file_name))
		var target_file_path_abs = target_dir_path_abs.path_join(file_name)
		var copying_msg = LoggieMsg.new(" Copying file...")
		copying_msg.msg(file_path_abs).italic().color(Color.CORNFLOWER_BLUE).add(" -> ")
		copying_msg.msg(target_file_path_abs).bold().color(Color.CORNFLOWER_BLUE)
		
		var is_overwrite_required = false
		if FileAccess.file_exists(target_file_path_abs):
			is_overwrite_required = true
			if overwrite_existing_files_with_same_name:
				copying_msg.nl().msg("\t[!] Target file already exists and will be overwritten.").bold().color(Color.DARK_KHAKI)
			else:
				copying_msg.nl().msg("\t File will not be copied as overwriting existing files is disabled.").bold().color(Color.SALMON)

		result.messages.push_back(copying_msg)
		
		if (not is_overwrite_required) or (is_overwrite_required and overwrite_existing_files_with_same_name):
			var copy_error = DirAccess.copy_absolute(file_path_abs, target_file_path_abs)
			if copy_error != OK:
				result.errors.push_back(copy_error)
				result.messages.push_back(LoggieMsg.new("Attempt to copy file failed with error: '", error_string(copy_error)))

	# Create all of source directory's subdirectories in the target directory and copy their contents.
	for dir_name : String in source_dir.get_directories():
		var source_subdir_path = path_dir_to_copy.path_join(dir_name)
		var source_subdir_path_abs = ProjectSettings.globalize_path(source_subdir_path)
		var target_subdir_path = path_dir_to_copy_into.path_join(dir_name)
		var dir_path_abs = ProjectSettings.globalize_path(target_subdir_path)

		result.messages.push_back(LoggieMsg.new(" Creating directory: ").msg("{dir}".format({"dir": dir_path_abs})).color(Color.CADET_BLUE))
		var make_dir_error = DirAccess.make_dir_recursive_absolute(dir_path_abs)
		if make_dir_error != OK:
			result.errors.push_back(make_dir_error)
			var error_msg = LoggieMsg.new("Attempt to create directory at absolute path recursively failed with error: '", error_string(make_dir_error))
			result.messages.push_back(error_msg)
			continue

		# Recursively copy the contents of the subdirectory
		var subdir_copy_result = copy_dir_absolute(source_subdir_path_abs, target_subdir_path, overwrite_existing_files_with_same_name)
		result.errors = result.errors + subdir_copy_result.errors
		result.messages = result.messages + subdir_copy_result.messages
	
	if debug_enabled:
		for msg : LoggieMsg in result.messages:
			print_rich(msg.string())
			
	return result

## A dictionary of named colors matching the constants from [Color] used to help with rich text coloring.
## There may be a way to obtain these Color values without this dictionary if one can somehow check for the 
## existence and value of a constant on the Color class (since they're already there),
## but I can't seem to find a way, so this will have to do for now.
static var NamedColors = {
	"ALICE_BLUE": Color(0.941176, 0.972549, 1, 1),
	"ANTIQUE_WHITE": Color(0.980392, 0.921569, 0.843137, 1),
	"AQUA": Color(0, 1, 1, 1),
	"AQUAMARINE": Color(0.498039, 1, 0.831373, 1),
	"AZURE": Color(0.941176, 1, 1, 1),
	"BEIGE": Color(0.960784, 0.960784, 0.862745, 1),
	"BISQUE": Color(1, 0.894118, 0.768627, 1),
	"BLACK": Color(0, 0, 0, 1),
	"BLANCHED_ALMOND": Color(1, 0.921569, 0.803922, 1),
	"BLUE": Color(0, 0, 1, 1),
	"BLUE_VIOLET": Color(0.541176, 0.168627, 0.886275, 1),
	"BROWN": Color(0.647059, 0.164706, 0.164706, 1),
	"BURLYWOOD": Color(0.870588, 0.721569, 0.529412, 1),
	"CADET_BLUE": Color(0.372549, 0.619608, 0.627451, 1),
	"CHARTREUSE": Color(0.498039, 1, 0, 1),
	"CHOCOLATE": Color(0.823529, 0.411765, 0.117647, 1),
	"CORAL": Color(1, 0.498039, 0.313726, 1),
	"CORNFLOWER_BLUE": Color(0.392157, 0.584314, 0.929412, 1),
	"CORNSILK": Color(1, 0.972549, 0.862745, 1),
	"CRIMSON": Color(0.862745, 0.0784314, 0.235294, 1),
	"CYAN": Color(0, 1, 1, 1),
	"DARK_BLUE": Color(0, 0, 0.545098, 1),
	"DARK_CYAN": Color(0, 0.545098, 0.545098, 1),
	"DARK_GOLDENROD": Color(0.721569, 0.52549, 0.0431373, 1),
	"DARK_GRAY": Color(0.662745, 0.662745, 0.662745, 1),
	"DARK_GREEN": Color(0, 0.392157, 0, 1),
	"DARK_KHAKI": Color(0.741176, 0.717647, 0.419608, 1),
	"DARK_MAGENTA": Color(0.545098, 0, 0.545098, 1),
	"DARK_OLIVE_GREEN": Color(0.333333, 0.419608, 0.184314, 1),
	"DARK_ORANGE": Color(1, 0.54902, 0, 1),
	"DARK_ORCHID": Color(0.6, 0.196078, 0.8, 1),
	"DARK_RED": Color(0.545098, 0, 0, 1),
	"DARK_SALMON": Color(0.913725, 0.588235, 0.478431, 1),
	"DARK_SEA_GREEN": Color(0.560784, 0.737255, 0.560784, 1),
	"DARK_SLATE_BLUE": Color(0.282353, 0.239216, 0.545098, 1),
	"DARK_SLATE_GRAY": Color(0.184314, 0.309804, 0.309804, 1),
	"DARK_TURQUOISE": Color(0, 0.807843, 0.819608, 1),
	"DARK_VIOLET": Color(0.580392, 0, 0.827451, 1),
	"DEEP_PINK": Color(1, 0.0784314, 0.576471, 1),
	"DEEP_SKY_BLUE": Color(0, 0.74902, 1, 1),
	"DIM_GRAY": Color(0.411765, 0.411765, 0.411765, 1),
	"DODGER_BLUE": Color(0.117647, 0.564706, 1, 1),
	"FIREBRICK": Color(0.698039, 0.133333, 0.133333, 1),
	"FLORAL_WHITE": Color(1, 0.980392, 0.941176, 1),
	"FOREST_GREEN": Color(0.133333, 0.545098, 0.133333, 1),
	"FUCHSIA": Color(1, 0, 1, 1),
	"GAINSBORO": Color(0.862745, 0.862745, 0.862745, 1),
	"GHOST_WHITE": Color(0.972549, 0.972549, 1, 1),
	"GOLD": Color(1, 0.843137, 0, 1),
	"GOLDENROD": Color(0.854902, 0.647059, 0.12549, 1),
	"GRAY": Color(0.745098, 0.745098, 0.745098, 1),
	"GREEN": Color(0, 1, 0, 1),
	"GREEN_YELLOW": Color(0.678431, 1, 0.184314, 1),
	"HONEYDEW": Color(0.941176, 1, 0.941176, 1),
	"HOT_PINK": Color(1, 0.411765, 0.705882, 1),
	"INDIAN_RED": Color(0.803922, 0.360784, 0.360784, 1),
	"INDIGO": Color(0.294118, 0, 804, 1),
	"IVORY": Color(1, 1, 0.941176, 1),
	"KHAKI": Color(0.941176, 0.901961, 0.54902, 1),
	"LAVENDER": Color(0.901961, 0.901961, 0.980392, 1),
	"LAVENDER_BLUSH": Color(1, 0.941176, 0.960784, 1),
	"LAWN_GREEN": Color(0.486275, 0.988235, 0, 1),
	"LEMON_CHIFFON": Color(1, 0.980392, 0.803922, 1),
	"LIGHT_BLUE": Color(0.678431, 0.847059, 0.901961, 1),
	"LIGHT_CORAL": Color(0.941176, 0.501961, 0.501961, 1),
	"LIGHT_CYAN": Color(0.878431, 1, 1, 1),
	"LIGHT_GOLDENROD": Color(0.980392, 0.980392, 0.823529, 1),
	"LIGHT_GRAY": Color(0.827451, 0.827451, 0.827451, 1),
	"LIGHT_GREEN": Color(0.564706, 0.933333, 0.564706, 1),
	"LIGHT_PINK": Color(1, 0.713726, 0.756863, 1),
	"LIGHT_SALMON": Color(1, 0.627451, 0.478431, 1),
	"LIGHT_SEA_GREEN": Color(0.12549, 0.698039, 0.666667, 1),
	"LIGHT_SKY_BLUE": Color(0.529412, 0.807843, 0.980392, 1),
	"LIGHT_SLATE_GRAY": Color(0.466667, 0.533333, 0.6, 1),
	"LIGHT_STEEL_BLUE": Color(0.690196, 0.768627, 0.870588, 1),
	"LIGHT_YELLOW": Color(1, 1, 0.878431, 1),
	"LIME": Color(0, 1, 0, 1),
	"LIME_GREEN": Color(0.196078, 0.803922, 0.196078, 1),
	"LINEN": Color(0.980392, 0.941176, 0.901961, 1),
	"MAGENTA": Color(1, 0, 1, 1),
	"MAROON": Color(0.690196, 0.188235, 0.376471, 1),
	"MEDIUM_AQUAMARINE": Color(0.4, 0.803922, 0.666667, 1),
	"MEDIUM_BLUE": Color(0, 0, 0.803922, 1),
	"MEDIUM_ORCHID": Color(0.729412, 0.333333, 0.827451, 1),
	"MEDIUM_PURPLE": Color(0.576471, 0.439216, 0.858824, 1),
	"MEDIUM_SEA_GREEN": Color(0.235294, 0.701961, 0.443137, 1),
	"MEDIUM_SLATE_BLUE": Color(0.482353, 0.407843, 0.933333, 1),
	"MEDIUM_SPRING_GREEN": Color(0, 0.980392, 0.603922, 1),
	"MEDIUM_TURQUOISE": Color(0.282353, 0.819608, 0.8, 1),
	"MEDIUM_VIOLET_RED": Color(0.780392, 0.0823529, 0.521569, 1),
	"MIDNIGHT_BLUE": Color(0.0980392, 0.0980392, 0.439216, 1),
	"MINT_CREAM": Color(0.960784, 1, 0.980392, 1),
	"MISTY_ROSE": Color(1, 0.894118, 0.882353, 1),
	"MOCCASIN": Color(1, 0.894118, 0.709804, 1),
	"NAVAJO_WHITE": Color(1, 0.870588, 0.678431, 1),
	"NAVY_BLUE": Color(0, 0, 0.501961, 1),
	"OLD_LACE": Color(0.992157, 0.960784, 0.901961, 1),
	"OLIVE": Color(0.501961, 0.501961, 0, 1),
	"OLIVE_DRAB": Color(0.419608, 0.556863, 0.137255, 1),
	"ORANGE": Color(1, 0.647059, 0, 1),
	"ORANGE_RED": Color(1, 0.270588, 0, 1),
	"ORCHID": Color(0.854902, 0.439216, 0.839216, 1),
	"PALE_GOLDENROD": Color(0.933333, 0.909804, 0.666667, 1),
	"PALE_GREEN": Color(0.596078, 0.984314, 0.596078, 1),
	"PALE_TURQUOISE": Color(0.686275, 0.933333, 0.933333, 1),
	"PALE_VIOLET_RED": Color(0.858824, 0.439216, 0.576471, 1),
	"PAPAYA_WHIP": Color(1, 0.937255, 0.835294, 1),
	"PEACH_PUFF": Color(1, 0.854902, 0.72549, 1),
	"PERU": Color(0.803922, 0.521569, 0.247059, 1),
	"PINK": Color(1, 0.752941, 0.796078, 1),
	"PLUM": Color(0.866667, 0.627451, 0.866667, 1),
	"POWDER_BLUE": Color(0.690196, 0.878431, 0.901961, 1),
	"PURPLE": Color(0.627451, 0.12549, 0.941176, 1),
	"REBECCA_PURPLE": Color(0.4, 0.2, 0.6, 1),
	"RED": Color(1, 0, 0, 1),
	"ROSY_BROWN": Color(0.737255, 0.560784, 0.560784, 1),
	"ROYAL_BLUE": Color(0.254902, 0.411765, 0.882353, 1),
	"SADDLE_BROWN": Color(0.545098, 0.270588, 0.0745098, 1),
	"SALMON": Color(0.980392, 0.501961, 0.447059, 1),
	"SANDY_BROWN": Color(0.956863, 0.643137, 0.376471, 1),
	"SEA_GREEN": Color(0.180392, 0.545098, 0.341176, 1),
	"SEASHELL": Color(1, 0.960784, 0.933333, 1),
	"SIENNA": Color(0.627451, 0.321569, 0.176471, 1),
	"SILVER": Color(0.752941, 0.752941, 0.752941, 1),
	"SKY_BLUE": Color(0.529412, 0.807843, 0.921569, 1),
	"SLATE_BLUE": Color(0.415686, 0.352941, 0.803922, 1),
	"SLATE_GRAY": Color(0.439216, 0.501961, 0.564706, 1),
	"SNOW": Color(1, 0.980392, 0.980392, 1),
	"SPRING_GREEN": Color(0, 1, 0.498039, 1),
	"STEEL_BLUE": Color(0.27451, 0.509804, 0.705882, 1),
	"TAN": Color(0.823529, 0.705882, 0.54902, 1),
	"TEAL": Color(0, 0.501961, 0.501961, 1),
	"THISTLE": Color(0.847059, 0.74902, 0.847059, 1),
	"TOMATO": Color(1, 0.388235, 0.278431, 1),
	"TRANSPARENT": Color(1, 1, 1, 0),
	"TURQUOISE": Color(0.25098, 0.878431, 0.815686, 1),
	"VIOLET": Color(0.933333, 0.509804, 0.933333, 1),
	"WEB_GRAY": Color(0.501961, 0.501961, 0.501961, 1),
	"WEB_GREEN": Color(0, 0.501961, 0, 1),
	"WEB_MAROON": Color(0.501961, 0, 0, 1),
	"WEB_PURPLE": Color(0.501961, 0, 0.501961, 1),
	"WHEAT": Color(0.960784, 0.870588, 0.701961, 1),
	"WHITE": Color(1, 1, 1, 1),
	"WHITE_SMOKE": Color(0.960784, 0.960784, 0.960784, 1),
	"YELLOW": Color(1, 1, 0, 1),
	"YELLOW_GREEN": Color(0.603922, 0.803922, 0.196078, 1)
}

--- SCRIPT: res://addons/loggie/version_management/loggie_update.gd ---
@tool
class_name LoggieUpdate extends Node

## Emitted when this update fails.
signal failed()

## Emitted when this update succeeds.
signal succeeded()

## Emitted when this declares that it has made some progress.
signal progress(value : float)

## Emitted when this declares that it wants a new status/substatus message to be used.
signal status_changed(status_msg : Variant, substatus_msg : Variant)

## Emitted when this update is starting.
signal starting()

## Emitted when the 'is_in_progress' status of this update changes.
signal is_in_progress_changed(new_value : bool)

## The path to the directory that should have a temporary file created and filled with the patch zipball buffer.
const TEMP_FILES_DIR = "user://"

## If this is set to a non-empty string, it will be used as the directory into which the new update will be
## installed. Used for testing/debugging. When set to empty string, Loggie will automatically figure out
## where it is being updated from and use that directory instead.
const ALT_LOGGIE_PLUGIN_CONTAINER_DIR = ""

## The domain from which status report [LoggieMsg]s from this update will be logged from.
const REPORTS_DOMAIN : String = "loggie_update_status_reports"

## Stores a reference to the logger that's requesting this update.
var _logger : Variant

## The URL used to visit a page that contains the release notes for this update.
var release_notes_url = ""

## Stores a reference to the previous version the connected [member _logger] is/was using.
var prev_version : LoggieVersion = null

## Stores a reference to the new version the connected [member _logger] should be using after the update.
var new_version : LoggieVersion = null

## Indicates whether this update is currently in progress.
var is_in_progress : bool = false

## Whether the update should retain or purge the backup it makes of the previous version files once it is done
## installing and applying the new update.
var _clean_up_backup_files : bool = true

func _init(_prev_version : LoggieVersion, _new_version : LoggieVersion) -> void:
	self.prev_version = _prev_version
	self.new_version = _new_version

## Returns a reference to the logger that's requesting this update.
func get_logger() -> Variant:
	return self._logger
	
## Sets the URL used to visit a page that contains the release notes for this update.
func set_release_notes_url(url : String) -> void:
	self.release_notes_url = url

## Sets whether this window is currently performing the update.
func set_is_in_progress(value : bool) -> void:
	self.is_in_progress = value
	self.is_in_progress_changed.emit(value)

## Tries to start the version update. Prevents the update from starting
## if something is not configured correctly and pushes a warning/error.
func try_start():
	if Engine.has_meta("LoggieUpdateSuccessful") and Engine.get_meta("LoggieUpdateSuccessful"):
		# No plan to allow multiple updates to run during a single Engine session anyway so no need to start another one.
		# Also, this helps with internal testing of the updater and prevents an updated plugin from auto-starting another update
		# when dealing with proxy versions.
		return

	if self._logger == null:
		push_warning("Attempt to start Loggie update failed - member '_logger' on the LoggieUpdate object is null.")
		return

	if self.is_in_progress:
		push_warning("Attempt to start Loggie update failed - the update is already in progress.")
		return

	if self.new_version == null or self.prev_version == null:
		push_warning("Attempt to start Loggie update failed - the updater prompt has the 'new_version' or 'prev_version' variable at null value.")
		return
	elif !self.new_version.is_higher_than(self.prev_version):
		push_warning("Attempt to start Loggie update failed - the 'new_version' is not higher than 'prev_version'.")
		return

	if self.new_version.has_meta("github_data"):
		var github_data = self.new_version.get_meta("github_data")
		if !github_data.has("zipball_url"):
			push_error("Attempt to start Loggie update failed - the meta key 'github_data' on the 'new_version' is a dictionary that does not contain the required 'zipball_url' key/value pair.")
			return
	else:
		push_error("Attempt to start Loggie update failed - the meta key 'github_data' on the 'new_version' was not found.")
		return
	
	_start()
	
## Internal function. Starts the updating of the [param _logger] to the [param new_version].
## Do not run without verification that configuration is correct.
## Use [method try_start] to call this safely.
func _start():
	var loggie = self.get_logger()

	loggie.msg("Loggie is updating from version {v_prev} to {v_new}.".format({
		"v_prev" : self.prev_version,
		"v_new" : self.new_version
	})).domain(REPORTS_DOMAIN).color(Color.ORANGE).box(12).info()
	
	set_is_in_progress(true)
	starting.emit()

	# Make request to configured endpoint.
	var update_data = self.new_version.get_meta("github_data")
	var http_request = HTTPRequest.new()
	loggie.add_child(http_request)
	http_request.request_completed.connect(_on_download_request_completed)
	http_request.request(update_data.zipball_url)

## Internal callback function. 
## Defines what happens when new update content is successfully downloaded from GitHub.
## Called automatically during [method _start] if everything is going according to plan.
func _on_download_request_completed(result: int, response_code: int, headers: PackedStringArray, body: PackedByteArray) -> void:
	var loggie = self.get_logger()

	if loggie == null:
		_failure("The _logger used by the updater window is null.")
		return

	if result != HTTPRequest.RESULT_SUCCESS:
		_failure("Download request returned non-zero code: " + str(result))
		return

	#region || Prepare: Define variables and callbacks that will be used throughout.
	# The path to the directory which is supposed to contain the plugin directory.
	# This will usually be 'res://addons/', but could be anything else too. We'll read it dynamically
	# from the connected logger to guarantee correctness.
	var LOGGIE_PLUGIN_CONTAINER_DIR = ALT_LOGGIE_PLUGIN_CONTAINER_DIR if !ALT_LOGGIE_PLUGIN_CONTAINER_DIR.is_empty() else loggie.get_directory_path().get_base_dir() + "/"
	
	# The path to the `loggie` plugin directory.
	var LOGGIE_PLUGIN_DIR = ProjectSettings.globalize_path(LOGGIE_PLUGIN_CONTAINER_DIR.path_join("loggie/"))
	
	# The full path filename of the temporary .zip archive that will be created to store the downloaded data.
	var TEMP_ZIP_FILE_PATH = ProjectSettings.globalize_path(TEMP_FILES_DIR.path_join("_temp_loggie_{ver}.zip".format({"ver": str(new_version)})))
	
	# The path to the directory where a temporary backup of current loggie plugin files will be copied to.
	# (will be created if doesn't exist).
	var TEMP_PREV_VER_FILES_DIR_PATH = ProjectSettings.globalize_path(TEMP_FILES_DIR.path_join("_temp_loggie_{ver}_backup".format({"ver": str(prev_version)})))
	
	# A callable that can be reused within this function that cleans up the temporary and unused directories,
	# once this function comes to a conclusion.
	var clean_up : Callable = func():
		if FileAccess.file_exists(TEMP_ZIP_FILE_PATH):
			OS.move_to_trash(TEMP_ZIP_FILE_PATH)
		if DirAccess.dir_exists_absolute(TEMP_PREV_VER_FILES_DIR_PATH) and self._clean_up_backup_files:
			OS.move_to_trash(TEMP_PREV_VER_FILES_DIR_PATH)

	# A callable that can be used to replace the currently existing Loggie plugin directory
	# with whatever is currently (temporarily) stored as its backup.
	var revert_to_backup = func():
		if FileAccess.file_exists(LOGGIE_PLUGIN_DIR):
			OS.move_to_trash(LOGGIE_PLUGIN_DIR)
		if DirAccess.dir_exists_absolute(TEMP_PREV_VER_FILES_DIR_PATH):
			DirAccess.rename_absolute(TEMP_PREV_VER_FILES_DIR_PATH, LOGGIE_PLUGIN_DIR)
			
	#endregion

	#region || Step 1: Store the downloaded content into a temporary zip file.
	send_progress_update(20, "Processing Files", "Storing patch locally...")

	var zip_file: FileAccess = FileAccess.open(TEMP_ZIP_FILE_PATH, FileAccess.WRITE)
	if zip_file == null:
		_failure("Failed to open temp. file for writing: {path}".format({"path": TEMP_ZIP_FILE_PATH}))
		clean_up.call()
		return

	zip_file.store_buffer(body)
	zip_file.close()
	#endregion

	#region || Step 2: Make a temporary backup of the currently used Loggie plugin directory.
	send_progress_update(30, "Processing Files", "Backing up previous version files...")
	
	if !DirAccess.dir_exists_absolute(LOGGIE_PLUGIN_DIR):
		_failure("The Loggie plugin directory ({path}) could not be found.".format({
			"path" : LOGGIE_PLUGIN_DIR
		}))
		clean_up.call()
		return

	var copy_prev_ver_result = LoggieTools.copy_dir_absolute(LOGGIE_PLUGIN_DIR, TEMP_PREV_VER_FILES_DIR_PATH, true)
	if copy_prev_ver_result.errors.size() > 0:
		var copy_prev_var_result_errors_msg = LoggieMsg.new("Errors encountered:")
		for error in copy_prev_ver_result.errors:
			copy_prev_var_result_errors_msg.nl().add(error_string(error))
		_failure(copy_prev_var_result_errors_msg.string())
		clean_up.call()
		return
	#endregion

	#region || Step 3: Remove currently used Loggie plugin directory and create a new one in its place populated with new version files.
	send_progress_update(50, "Processing Files", "Copying new version files...")
	var zip_reader: ZIPReader = ZIPReader.new()
	var zip_reader_open_error = zip_reader.open(TEMP_ZIP_FILE_PATH)
	if zip_reader_open_error != OK:
		_failure("Attempt to open temp. file(s) archive at {path} failed with error: {err_str}".format({
			"path": LOGGIE_PLUGIN_DIR,
			"err_str" : error_string(zip_reader_open_error)
		}))
		clean_up.call()
		return
	
	# Trash the previously existing loggie plugin dir entirely.
	# A new one will be created in a moment.
	OS.move_to_trash(LOGGIE_PLUGIN_DIR)
	
	# Get a list of all files and dirs in the zip.
	var files : PackedStringArray = zip_reader.get_files() 

	# This will always be the "addons" directory in the zip archive in which we expect
	# to find the "loggie" directory containing the plugin.
	var base_path_in_zip = files[1] 

	# Remove the first 2 parts of the path that we won't be needing at all.
	files.remove_at(0)
	files.remove_at(0)

	# Create all needed files and directories.
	for path in files:
		var new_file_path: String = path.replace(base_path_in_zip, "")
		if path.ends_with("/"):
			DirAccess.make_dir_recursive_absolute(LOGGIE_PLUGIN_CONTAINER_DIR + new_file_path)
		else:
			var abs_path = LOGGIE_PLUGIN_CONTAINER_DIR + new_file_path
			var file : FileAccess = FileAccess.open(abs_path, FileAccess.WRITE)
			if file == null:
				_failure("Error while storing buffer data into temporary files - write target directory or file {target} gave the error: {error}".format({
					"error" : error_string(FileAccess.get_open_error()), 
					"target" : abs_path
				}))
				revert_to_backup.call()
				clean_up.call()
				return
			else:
				var file_content = zip_reader.read_file(path)
				file.store_buffer(file_content)
				file.close()

	zip_reader.close()
	#endregion

	#region || Step 4: Move the user's 'custom_settings.gd' to the new version directory if it existed in prev version.
	send_progress_update(70, "Processing Files", "Reapplying custom settings...")
	var CUSTOM_SETTINGS_IN_PREV_VER_PATH = TEMP_PREV_VER_FILES_DIR_PATH.path_join("custom_settings.gd")
	if FileAccess.file_exists(CUSTOM_SETTINGS_IN_PREV_VER_PATH):
		var CUSTOM_SETTINGS_IN_NEW_VER_PATH = ProjectSettings.globalize_path(LOGGIE_PLUGIN_DIR.path_join("custom_settings.gd"))
		var custom_settings_copy_error = DirAccess.copy_absolute(CUSTOM_SETTINGS_IN_PREV_VER_PATH, CUSTOM_SETTINGS_IN_NEW_VER_PATH)
		if custom_settings_copy_error != OK:
			push_error("Attempt to copy the 'custom_settings.gd' file from {p1} to {p2} failed with error: {error}".format({
				"p1" : CUSTOM_SETTINGS_IN_PREV_VER_PATH,
				"p2" : CUSTOM_SETTINGS_IN_NEW_VER_PATH,
				"error" : error_string(custom_settings_copy_error)
			}))
	#endregion

	#region || Step 5: Move the user's 'channels/custom_channels' directory to the new version if it existed in prev version.
	send_progress_update(80, "Processing Files", "Reapplying custom channels...")
	var CUSTOM_CHANNELS_IN_PREV_VER_PATH = ProjectSettings.globalize_path(TEMP_PREV_VER_FILES_DIR_PATH.path_join("channels/custom_channels/"))
	if DirAccess.dir_exists_absolute(CUSTOM_CHANNELS_IN_PREV_VER_PATH):
		var CUSTOM_CHANNELS_IN_NEW_VER_PATH = ProjectSettings.globalize_path(LOGGIE_PLUGIN_DIR.path_join("channels/custom_channels/"))
		var copy_prev_ver_custom_channels_result = LoggieTools.copy_dir_absolute(CUSTOM_CHANNELS_IN_PREV_VER_PATH, CUSTOM_CHANNELS_IN_NEW_VER_PATH, true)
		if copy_prev_ver_custom_channels_result.errors.size() > 0:
			var copy_prev_var_result_errors_msg = LoggieMsg.new("Errors encountered:")
			for error in copy_prev_ver_result.errors:
				copy_prev_var_result_errors_msg.nl().add(error_string(error))
			push_error("Attempt to copy the 'channels/custom_channels' directory from {p1} to {p2} failed with error: {error}".format({
				"p1" : CUSTOM_CHANNELS_IN_PREV_VER_PATH,
				"p2" : CUSTOM_CHANNELS_IN_NEW_VER_PATH,
				"error" : copy_prev_var_result_errors_msg.string()
			}))
	else:
		print("The {path} directory doesn't exist.".format({"path": CUSTOM_CHANNELS_IN_PREV_VER_PATH}))
	#endregion

	#region || Step 6: Clean up temporarily created files and close filewrite.
	send_progress_update(90, "Processing Files", "Cleaning up...")
	clean_up.call()
	#endregion
	
	#region || Step 7: Declare successful. Wrap up.
	send_progress_update(100, "Finishing up", "")
	_success()
	#endregion

## Internal function used at the end of the updating process if it is successfully completed.
func _success():
	set_is_in_progress(false)

	var msg = " You may see temporary errors in the console due to Loggie files being re-scanned and reloaded on the spot.\nIt should be safe to dismiss them, but for the best experience, reload the Godot editor (and the plugin, if something seems wrong).\n\n If you see a 'Files have been modified on disk' window pop up, choose 'Discard local changes and reload' to accept incoming changes."
	status_changed.emit(null, msg)
	succeeded.emit()

	print_rich(LoggieMsg.new(" Loggie updated to version {new_ver}!".format({"new_ver": self.new_version})).bold().color(Color.ORANGE).string())
	print_rich(LoggieMsg.new("\t Release Notes: ").bold().msg("[url={url}]{url}[/url]".format({"url": release_notes_url})).color(Color.CORNFLOWER_BLUE).string())
	print_rich(LoggieMsg.new("\t Support, Development & Feature Requests: ").bold().msg("[url=https://discord.gg/XPdxpMqmcs]https://discord.gg/XPdxpMqmcs[/url]").color(Color.CORNFLOWER_BLUE).string())

	if Engine.is_editor_hint():
		var editor_plugin = Engine.get_meta("LoggieEditorPlugin")
		editor_plugin.get_editor_interface().get_resource_filesystem().scan()
		editor_plugin.get_editor_interface().call_deferred("set_plugin_enabled", "loggie", true)
		editor_plugin.get_editor_interface().set_plugin_enabled("loggie", false)
		Engine.set_meta("LoggieUpdateSuccessful", true)
		print_rich("[b]Updater:[/b] ", msg)

## Internal function used to interrupt an ongoing update and cause it to fail.
func _failure(status_msg : String):
	var loggie = self.get_logger()
	loggie.msg(status_msg).color(Color.SALMON).preprocessed(false).error()
	loggie.msg("\t If this issue persists, consider reporting: ").bold().msg("https://github.com/Shiva-Shadowsong/loggie/issues").color(Color.CORNFLOWER_BLUE).preprocessed(false).info()
	set_is_in_progress(false)
	failed.emit()
	status_changed.emit(null, status_msg)

## Informs the listeners of the [signal progress] / [signal status_changed] signals about a change in the progress of the update.
func send_progress_update(progress_amount : float, status_msg : String, substatus_msg : String):
	var loggie = self.get_logger()
	if !substatus_msg.is_empty():
		loggie.msg(" ").msg(substatus_msg).domain(REPORTS_DOMAIN).preprocessed(false).info()
	progress.emit(progress_amount)
	status_changed.emit(status_msg, substatus_msg)

--- SCRIPT: res://addons/loggie/version_management/loggie_version.gd ---
## A utility class that helps with storing data about a Loggie Version and converting and comparing version strings.
class_name LoggieVersion extends Resource

var minor : int = -1 ## The minor component of the version.
var major : int = -1 ## The major component of the version.
var proxy_for : LoggieVersion = null ## The version that this version is a proxy for. (Internal use only)

func _init(_major : int = -1, _minor : int = -1) -> void:
	self.minor = _minor
	self.major = _major
	
func _to_string() -> String:
	return str(self.major) + "." + str(self.minor)

## Checks if this version is valid.
## (neither minor nor major component can be less than 0).
func is_valid() -> bool:
	return (minor >= 0 and major >= 0)

## Checks if the given [param version] if higher than this version.
func is_higher_than(version : LoggieVersion):
	if self.major > version.major:
		return true
	if self.minor > version.minor:
		return true
	return false

## Given a string that has 2 sets of digits separated by a ".", breaks that down
## into a version with a major and minor version component (ints).
static func from_string(version_string : String) -> LoggieVersion:
	var version : LoggieVersion = LoggieVersion.new()
	var regex = RegEx.new()
	regex.compile("(\\d+)\\.(\\d+)")
	
	var result = regex.search(version_string)
	if result:
		version.major = result.get_string(1).to_int()
		version.minor = result.get_string(2).to_int()
	return version

--- SCRIPT: res://addons/loggie/version_management/loggie_version_manager.gd ---
@tool
## A class that can be used to inquire about, generate, and operate on [LoggieVersion]s. 
## It is also responsible for notifying about an available update, and starting it, if configured to do so.
class_name LoggieVersionManager extends RefCounted

## Emitted when this version manager updates the known [member latest_version].
signal latest_version_updated()

## Emitted when this version manager has created a valid [LoggieUpdate] and is ready to use it.
signal update_ready()

## The URL where loggie releases on GitHub can be found.
const REMOTE_RELEASES_URL = "https://api.github.com/repos/Shiva-Shadowsong/loggie/releases"

## The domain from which [LoggieMsg]s from this version manager will be logged from.
const REPORTS_DOMAIN : String = "loggie_version_check_reports"

## Stores the result of reading the Loggie version with [method get_current_Version].
var version : LoggieVersion = null

## Stores the result of reading the latest Loggie version with [method get_latest_version].
var latest_version : LoggieVersion = null

## Stores a reference to a ConfigFile which will be loaded from [member CONFIG_PATH] during [method find_and_store_current_version].
var config : ConfigFile = ConfigFile.new()

## Stores a reference to the logger that's using this version manager.
var _logger : Variant = null

## Stores a reference to the [LoggieUpdate] that has been created to handle an available update.
var _update : LoggieUpdate = null

## Internal debug variable.
## If not null, this version manager will treat the [LoggieVersion] provided under this variable to be the current [param version].
## Useful for debugging this module when you want to simulate that the current version is something different than it actually is.
var _version_proxy : LoggieVersion = null

## Initializes this version manager, connecting it to the logger that's using it and updating the version cache based on that logger,
## which will further prompt the emission of signals in this class, and so on.
func connect_logger(logger : Variant) -> void:
	self.latest_version_updated.connect(on_latest_version_updated)
	self._logger = logger

	# Set to true during development to enable debug prints related to version management.
	self._logger.set_domain_enabled(self.REPORTS_DOMAIN, false)

	update_version_cache()

## Returns a reference to the logger object that is using this version manager.
func get_logger() -> Variant:
	return self._logger

## Reads the current version of Loggie from plugin.cfg and stores it in [member version].
func find_and_store_current_version():
	var detected_version = self._logger.version
	if self._version_proxy != null:
		self.version = self._version_proxy
		self.version.proxy_for = detected_version
	else:
		self.version = detected_version

## Reads the latest version of Loggie from a GitHub API response and stores it in [member latest_version].
func find_and_store_latest_version():
	var loggie = self.get_logger()
	var http_request = HTTPRequest.new()
	loggie.add_child(http_request)
	loggie.msg("Retrieving version(s) info from endpoint:", REMOTE_RELEASES_URL).domain(REPORTS_DOMAIN).debug()
	http_request.request_completed.connect(_on_get_latest_version_request_completed, CONNECT_ONE_SHOT)
	http_request.request(REMOTE_RELEASES_URL)

## Defines what happens once this version manager emits the signal saying that an update is available.
func on_update_available_detected() -> void:
	var loggie = self.get_logger()
	if loggie.settings.update_check_mode == LoggieEnums.UpdateCheckType.DONT_CHECK:
		return
	
	self._update = LoggieUpdate.new(self.version, self.latest_version)
	self._update._logger = loggie

	var github_data = self.latest_version.get_meta("github_data")
	var latest_release_notes_url = github_data.html_url
	self._update.set_release_notes_url(latest_release_notes_url)
	loggie.add_child(self._update)
	update_ready.emit()

	# No plan to allow multiple updates to run during a single Engine session anyway so no need to start another one.
	# Also, this helps with internal testing of the updater and prevents an updated plugin from auto-starting another update
	# when dealing with proxy versions.
	var hasUpdatedAlready = Engine.has_meta("LoggieUpdateSuccessful") and Engine.get_meta("LoggieUpdateSuccessful")

	match loggie.settings.update_check_mode:
		LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_UPDATER_WINDOW:
			if hasUpdatedAlready:
				loggie.info("Update already performed. ")
				return
			create_and_show_updater_widget(self._update)
		LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_MSG:
			loggie.msg(" Loggie update available!").color(Color.ORANGE).header().msg(" > Current version: {version}, Latest version: {latest}".format({
				"version" : self.version,
				"latest" : self.latest_version
			})).info()
		LoggieEnums.UpdateCheckType.CHECK_DOWNLOAD_AND_SHOW_MSG:
			if hasUpdatedAlready:
				loggie.info("Update already performed. ")
				return
			loggie.set_domain_enabled("loggie_update_status_reports", true)
			self._update.try_start()

## Defines what happens when the request to GitHub API which grabs all the Loggie releases is completed.
func _on_get_latest_version_request_completed(result : int, response_code : int, headers : PackedStringArray, body: PackedByteArray):
	var loggie = self.get_logger()
	loggie.msg("Response for request received:", response_code).domain(REPORTS_DOMAIN).debug()

	if result != HTTPRequest.RESULT_SUCCESS: 
		return

	var response = JSON.parse_string(body.get_string_from_utf8())

	if typeof(response) != TYPE_ARRAY:
		loggie.error("The response parsed from GitHub was not an array. Response received in an unsupported format.")
		return
	
	var latest_version_data = response[0] # GitHub releases are in order of creation, so grab the first one from the response, that's the latest one.
	self.latest_version = LoggieVersion.from_string(latest_version_data.tag_name)
	self.latest_version.set_meta("github_data", latest_version_data)

	loggie.msg("Current version of Loggie:", self.version).msg(" (proxy for: {value})".format({"value": self.version.proxy_for})).domain(REPORTS_DOMAIN).debug()
	loggie.msg("Latest version of Loggie:", self.latest_version).domain(REPORTS_DOMAIN).debug()
	latest_version_updated.emit()

## Executes every time this version manager updates the known latest_version.
func on_latest_version_updated() -> void:
	var loggie = self.get_logger()
	if loggie == null:
		return

	# Check if update is available.
	if loggie.settings.update_check_mode != LoggieEnums.UpdateCheckType.DONT_CHECK:
		loggie.msg(" Loggie:").bold().color("orange").msg(" Checking for updates...").info()
		if is_update_available():
			on_update_available_detected()
		else:
			loggie.msg(" Loggie:").bold().color("orange").msg(" Up to date. ").color(Color.LIGHT_GREEN).info()
		
## Displays the widget which informs the user of the available update and offers actions that they can take next.
func create_and_show_updater_widget(update : LoggieUpdate) -> Window:
	const PATH_TO_WIDGET_SCENE = "addons/loggie/version_management/update_prompt_window.tscn"
	var WIDGET_SCENE = load(PATH_TO_WIDGET_SCENE)
	if !is_instance_valid(WIDGET_SCENE):
		push_error("Loggie Update Prompt Window scene not found on expected path: {path}".format({"path": PATH_TO_WIDGET_SCENE}))
		return

	var loggie = self.get_logger()
	if loggie == null:
		return
	
	var popup_parent = null
	if Engine.is_editor_hint() and Engine.has_meta("LoggieEditorInterfaceBaseControl"):
		popup_parent = Engine.get_meta("LoggieEditorInterfaceBaseControl")
	else:
		popup_parent = SceneTree.current_scene

	# Configure popup window.
	var _popup = Window.new()
	update.succeeded.connect(func():
		_popup.queue_free()
		var success_dialog = AcceptDialog.new()
		var msg = " You may see temporary errors in the console due to Loggie files being re-scanned and reloaded on the spot.\nIt should be safe to dismiss them, but for the best experience, reload the Godot editor (and the plugin, if something seems wrong).\n\n If you see a 'Files have been modified on disk' window pop up, choose 'Discard local changes and reload' to accept incoming changes."
		success_dialog.dialog_text = msg
		success_dialog.title = "Loggie Updater"
		if is_instance_valid(popup_parent):
			popup_parent.add_child(success_dialog)
			success_dialog.popup_centered()
	)
	var on_close_requested = func():
		_popup.queue_free()

	_popup.close_requested.connect(on_close_requested, CONNECT_ONE_SHOT)
	_popup.borderless = false
	_popup.unresizable = true
	_popup.transient = true
	_popup.title = "Update Available"
	
	# Configure window widget and add it as a child of the popup window.
	var widget : LoggieUpdatePrompt = WIDGET_SCENE.instantiate()
	widget.connect_to_update(update)
	widget.set_anchors_preset(Control.PRESET_FULL_RECT)
	widget._logger = loggie
	widget.close_requested.connect(on_close_requested, CONNECT_ONE_SHOT)
	
	if is_instance_valid(popup_parent):
		popup_parent.add_child(_popup)
		_popup.popup_centered(widget.host_window_size)
	_popup.add_child(widget)

	return _popup

## Updates the local variables which point to the current and latest version of Loggie.
func update_version_cache():
	# Read and cache the current version of Loggie from plugin.cfg.
	find_and_store_current_version()

	# Read and cache the latest version of Loggie from GitHub.
	# (Do it only if running in editor, no need for this if running in a game).
	var logger = self.get_logger()
	if logger is Node:
		if !Engine.is_editor_hint():
			return
		if logger.is_node_ready():
			find_and_store_latest_version()
		else:
			logger.ready.connect(func():
				find_and_store_latest_version()
			, CONNECT_ONE_SHOT)

## Checks if an update for Loggie is available. Run only after running [method update_version_cache].
func is_update_available() -> bool:
	var loggie = self.get_logger()
	if !(self.version is LoggieVersion and self.version.is_valid()):
		loggie.error("The current version of Loggie is not valid. Run `find_and_store_current_version` once to obtain this value first.")
		return false
	if !(self.latest_version is LoggieVersion and self.latest_version.is_valid()):
		loggie.error("The latest version of Loggie is not valid. Run `find_and_store_latest_version` once to obtain this value first.")
		return false
	return self.latest_version.is_higher_than(self.version)

--- SCRIPT: res://addons/loggie/version_management/update_prompt_window.gd ---
@tool
## The Loggie Update Prompt is a control node that is meant to be created and added as a child of some other node, most commonly a [Window].
## It connects to a [LoggieUpdate] via its [method connect_to_update] method, then displays data about that update depending on what kind of
## data that [LoggieUpdate] provides with its signals.
class_name LoggieUpdatePrompt extends Panel

## Emitted when the user requests to close the update prompt.
signal close_requested()

## The animation player that will be used to animate the appearance of this window.
@export var animator : AnimationPlayer

## The size the window that's hosting this panel will be forced to assume when
## it's ready to pop this up on the screen.
@export var host_window_size : Vector2 = Vector2(1063, 672)

## Stores a reference to the logger that's using this window.
var _logger : Variant

## The update this window is visually representing.
var _update : LoggieUpdate

## Stores a boolean which indicates whether the update is currently in progress.
var is_currently_updating : bool = false

func _ready() -> void:
	connect_control_effects()
	%UpdateNowBtn.grab_focus()
	refresh_remind_later_btn()
	animator.play("RESET")

## Connects this window to an instance of [LoggieUpdate] whose progress and properties this window is supposed to track.
func connect_to_update(p_update : LoggieUpdate) -> void:
	self._update = p_update
	_update.is_in_progress_changed.connect(is_update_in_progress_changed)
	_update.starting.connect(on_update_starting)
	_update.succeeded.connect(on_update_succeeded)
	_update.failed.connect(on_update_failed)
	_update.progress.connect(on_update_progress)
	_update.status_changed.connect(on_update_status_changed)

## Returns a reference to the logger object that is using this widget.
func get_logger() -> Variant:
	return self._logger
	
## Defines what happens when the update this window is representing updates its "is in progress" status.
func is_update_in_progress_changed(is_in_progress : bool) -> void:
	self.is_currently_updating = is_in_progress
	
	# The first time we enter the UpdateMonitor view and start an update,
	# the %Notice node and its children should no longer (ever) be interactive or processing,
	# since there is no way to get back to that view anymore.
	if is_in_progress and %Notice.process_mode != Node.PROCESS_MODE_DISABLED:
		%Notice.process_mode = Node.PROCESS_MODE_DISABLED
		for child in %NoticeButtons.get_children():
			if child is Button:
				child.focus_mode = Button.FOCUS_NONE
	
## Connects the effects and functionalities of various controls in this window.
func connect_control_effects():
	if !is_instance_valid(self._update):
		return

	# Configure version(s) labels.
	%LabelCurrentVersion.text = str(self._update.prev_version)
	%LabelLatestVersion.text = str(self._update.new_version)
	%LabelOldVersion.text = str(self._update.prev_version)
	%LabelNewVersion.text = str(self._update.new_version)
	
	# Configure onhover/focused effects.
	var buttons_with_on_focushover_effect = [%OptionExitBtn, %OptionRestartGodotBtn, %OptionRetryUpdateBtn, %ReleaseNotesBtn, %RemindLaterBtn, %UpdateNowBtn]
	for button : Button in buttons_with_on_focushover_effect:
		button.focus_entered.connect(_on_button_focus_entered.bind(button))
		button.focus_exited.connect(_on_button_focus_exited.bind(button))
		button.mouse_entered.connect(_on_button_focus_entered.bind(button))
		button.mouse_exited.connect(_on_button_focus_exited.bind(button))
		button.pivot_offset = button.size * 0.5
		
	# Connect behavior which executes when "Update Now" is pressed.
	%UpdateNowBtn.pressed.connect(func():
		self._update.try_start()
	)
	
	# Configure Release Notes button.
	%ReleaseNotesBtn.visible = !self._update.release_notes_url.is_empty()
	%ReleaseNotesBtn.tooltip_text = "Opens {url} in browser.".format({"url": self._update.release_notes_url})
	%ReleaseNotesBtn.pressed.connect(func():
		if !self._update.release_notes_url.is_empty():
			OS.shell_open(self._update.release_notes_url)
	)
	
	# Connect behavior which executes when the "Remind Me Later / Close" is pressed.
	%RemindLaterBtn.pressed.connect(func(): close_requested.emit())
	%OptionExitBtn.pressed.connect(func(): close_requested.emit())
	
	# Connect behavior which executes when the "Retry" button is pressed.
	%OptionRetryUpdateBtn.pressed.connect(self._update.try_start)
	
	# Connect behavior which executes when the "Restart Godot" button is pressed.
	%OptionRestartGodotBtn.pressed.connect(func():
		close_requested.emit()
		if Engine.is_editor_hint():
			var editor_plugin = Engine.get_meta("LoggieEditorPlugin")
			editor_plugin.get_editor_interface().restart_editor(true)
	)

	# The "Don't show again checkbox" updates project settings whenever it is toggled.
	%DontShowAgainCheckbox.toggled.connect(func(toggled_on : bool):
		var loggie = self.get_logger()
		if Engine.is_editor_hint() and loggie != null:
			if toggled_on:
				loggie.settings.update_check_mode = LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_MSG
				ProjectSettings.set_setting(loggie.settings.project_settings.update_check_mode.path, LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_MSG)
			else:
				loggie.settings.update_check_mode = LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_UPDATER_WINDOW
				ProjectSettings.set_setting(loggie.settings.project_settings.update_check_mode.path, LoggieEnums.UpdateCheckType.CHECK_AND_SHOW_UPDATER_WINDOW)
		refresh_remind_later_btn()
	)

## Updates the content of the "Remind Later Btn" to show text appropriate to the current state of the "Don't show again" checkbox.
func refresh_remind_later_btn():
	if %DontShowAgainCheckbox.button_pressed:
		%RemindLaterBtn.text = "close"
	else:
		%RemindLaterBtn.text = "remind later"

## Defines what happens when the [member _update] is detected to be starting.
func on_update_starting():
	if animator.current_animation != "show_update_overview":
		animator.queue("show_update_overview")
	%ProgressBar.value = 0
	%LabelMainStatus.text = "Downloading"
	%LabelUpdateStatus.text = "Waiting for server response."
	%OptionExitBtn.disabled = true
	%OptionExitBtn.visible = false
	%OptionRetryUpdateBtn.disabled = true
	%OptionRetryUpdateBtn.visible = false
	%OptionRestartGodotBtn.disabled = true
	%OptionRestartGodotBtn.visible = false

## Defines what happens when the [member _update] declares it has made progress.
func on_update_progress(value : float):
	%ProgressBar.value = value

## Defines what happens when the [member _update] declares it has succeeded.
func on_update_succeeded():
	%LabelMainStatus.text = "Updated"
	%OptionExitBtn.disabled = false
	%OptionExitBtn.visible = true
	%OptionRestartGodotBtn.disabled = false
	%OptionRestartGodotBtn.visible = true
	if animator.is_playing():
		animator.stop()
	animator.play("finish_success")

## Defines what happens when the [member _update] declares it wants the status message to change.
func on_update_status_changed(status_msg : Variant, substatus_msg : Variant):
	if status_msg is String:
		%LabelMainStatus.text = status_msg
	if substatus_msg is String:
		%LabelUpdateStatus.text = substatus_msg

## Defines what happens when the [member _update] declares it has failed.
func on_update_failed():
	%ProgressBar.value = 0
	%LabelMainStatus.text = "Failed"
	%OptionExitBtn.disabled = false
	%OptionExitBtn.visible = true
	%OptionRetryUpdateBtn.disabled = false
	%OptionRetryUpdateBtn.visible = true
	%OptionRestartGodotBtn.disabled = true
	%OptionRestartGodotBtn.visible = false

func _on_button_focus_entered(button : Button):
	if button.has_meta("scale_tween"):
		var old_tween = button.get_meta("scale_tween")
		old_tween.kill()
		button.set_meta("scale_tween", null)

	var tween : Tween = button.create_tween()
	tween.tween_property(button, "scale", Vector2(1.2, 1.2), 0.1)
	button.set_meta("scale_tween", tween)

func _on_button_focus_exited(button : Button):
	if button.has_meta("scale_tween"):
		var old_tween = button.get_meta("scale_tween")
		old_tween.kill()
		button.set_meta("scale_tween", null)

	var tween : Tween = button.create_tween()
	tween.tween_property(button, "scale", Vector2(1.0, 1.0), 0.1).from_current()
	button.set_meta("scale_tween", tween)

--- SCRIPT: res://addons/phantom_camera/examples/scripts/2D/2d_room_limit_tween.gd ---
extends Node2D

@onready var pcam_room_left: PhantomCamera2D = %RoomLeftPhantomCamera2D
@onready var pcam_room_centre: PhantomCamera2D = %RoomCentrePhantomCamera2D
@onready var pcam_room_right: PhantomCamera2D = %RoomRightPhantomCamera2D

@onready var player: Node2D = %CharacterBody2D/%PlayerVisuals

@onready var area_2d_room_left: Area2D = %RoomLeftArea2D
@onready var area_2d_room_centre: Area2D = %RoomCentreArea2D
@onready var area_2d_room_right: Area2D = %RoomRightArea2D


func _ready():
	pcam_room_left.set_follow_offset(Vector2(0, -80))
	pcam_room_right.set_follow_offset(Vector2(0, -80))

	area_2d_room_left.body_entered.connect(_on_body_entered.bind(pcam_room_left))
	area_2d_room_centre.body_entered.connect(_on_body_entered.bind(pcam_room_centre))
	area_2d_room_right.body_entered.connect(_on_body_entered.bind(pcam_room_right))

	area_2d_room_left.body_exited.connect(_on_body_exited.bind(pcam_room_left))
	area_2d_room_centre.body_exited.connect(_on_body_exited.bind(pcam_room_centre))
	area_2d_room_right.body_exited.connect(_on_body_exited.bind(pcam_room_right))


func _on_body_entered(body: Node2D, pcam: PhantomCamera2D) -> void:
	if body == player.get_parent():
		pcam.set_follow_target(player)
		pcam.set_priority(20)


func _on_body_exited(body: Node2D, pcam: PhantomCamera2D) -> void:
	if body == player.get_parent():
		pcam.set_priority(0)
		pcam.set_follow_target(null)

--- SCRIPT: res://addons/phantom_camera/examples/scripts/2D/2d_room_limit_tween_4.3.gd ---
extends Node2D

@onready var pcam_room_left: PhantomCamera2D = %RoomLeftPhantomCamera2D
@onready var pcam_room_centre: PhantomCamera2D = %RoomCentrePhantomCamera2D
@onready var pcam_room_right: PhantomCamera2D = %RoomRightPhantomCamera2D

@onready var player: Node2D = %CharacterBody2D

@onready var area_2d_room_left: Area2D = %RoomLeftArea2D
@onready var area_2d_room_centre: Area2D = %RoomCentreArea2D
@onready var area_2d_room_right: Area2D = %RoomRightArea2D


func _ready():
	pcam_room_left.set_follow_offset(Vector2(0, -80))
	pcam_room_right.set_follow_offset(Vector2(0, -80))

	area_2d_room_left.body_entered.connect(_on_body_entered.bind(pcam_room_left))
	area_2d_room_centre.body_entered.connect(_on_body_entered.bind(pcam_room_centre))
	area_2d_room_right.body_entered.connect(_on_body_entered.bind(pcam_room_right))

	area_2d_room_left.body_exited.connect(_on_body_exited.bind(pcam_room_left))
	area_2d_room_centre.body_exited.connect(_on_body_exited.bind(pcam_room_centre))
	area_2d_room_right.body_exited.connect(_on_body_exited.bind(pcam_room_right))


func _on_body_entered(body: Node2D, pcam: PhantomCamera2D) -> void:
	if body == player:
		pcam.set_follow_target(player)
		pcam.set_priority(20)


func _on_body_exited(body: Node2D, pcam: PhantomCamera2D) -> void:
	if body == player:
		pcam.set_priority(0)
		pcam.set_follow_target(null)

--- SCRIPT: res://addons/phantom_camera/examples/scripts/2D/2d_trigger_area.gd ---
extends Area2D

@export var area_pcam: PhantomCamera2D

func _ready() -> void:
	connect("area_entered", _entered_area)
	connect("area_exited", _exited_area)

func _entered_area(area_2d: Area2D) -> void:
	if area_2d.get_parent() is CharacterBody2D:
		area_pcam.set_priority(20)

func _exited_area(area_2d: Area2D) -> void:
	if area_2d.get_parent() is CharacterBody2D:
		area_pcam.set_priority(0)

--- SCRIPT: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d.gd ---
extends CharacterBody2D

@onready var _player_area2d = %PlayerArea2D
@onready var _player_visuals: Node2D = %PlayerVisuals
@onready var _player_sprite: Sprite2D = %PlayerSprite
@onready var _interaction_prompt: Panel = %InteractionPrompt
@onready var _ui_sign: Control
@onready var _dark_overlay: ColorRect = %DarkOverlay

const KEY_STRINGNAME: StringName = "Key"
const ACTION_STRINGNAME: StringName = "Action"
const INPUT_MOVE_LEFT_STRINGNAME: StringName = "move_left"
const INPUT_MOVE_RIGHT_STRINGNAME: StringName = "move_right"

const SPEED = 350.0
const JUMP_VELOCITY = -750.0

# Get the gravity from the project settings to be synced with RigidBody nodes.
var gravity: int = 2400
var _is_interactive: bool
var _can_open_inventory: bool
var _movement_disabled: bool
var tween: Tween
var _interactive_UI: Control
var _active_pcam: PhantomCamera2D

var _physics_body_trans_last: Transform2D
var _physics_body_trans_current: Transform2D

enum InteractiveType {
	NONE = 0,
	ITEM = 1,
	INVENTORY = 2,
}
var _interactive_object: InteractiveType = InteractiveType.NONE

var InputMovementDic: Dictionary = {
	INPUT_MOVE_LEFT_STRINGNAME: {
		KEY_STRINGNAME: KEY_A,
		ACTION_STRINGNAME: INPUT_MOVE_LEFT_STRINGNAME
	},
	INPUT_MOVE_RIGHT_STRINGNAME: {
		KEY_STRINGNAME: KEY_D,
		ACTION_STRINGNAME: INPUT_MOVE_RIGHT_STRINGNAME
	},
}


func _ready() -> void:
	_player_area2d.body_shape_entered.connect(_show_prompt)
	_player_area2d.body_shape_exited.connect(_hide_prompt)

	_ui_sign = owner.get_node("%UISign")

	for input in InputMovementDic:
		var key_val = InputMovementDic[input].get(KEY_STRINGNAME)
		var action_val = InputMovementDic[input].get(ACTION_STRINGNAME)

		var movement_input = InputEventKey.new()
		movement_input.physical_keycode = key_val
		InputMap.add_action(action_val)
		InputMap.action_add_event(action_val, movement_input)

	_player_visuals.top_level = true

	if Engine.get_version_info().major == 4 and \
		Engine.get_version_info().minor >= 3:
		printerr("Please run the other 2D example scenes, in the 2D-4.3 directory, for more up-to-date example setups.")


func _unhandled_input(event: InputEvent) -> void:
	if _is_interactive:
		if Input.is_physical_key_pressed(KEY_F):
			if tween:
				tween.kill()

			if not _movement_disabled:
				tween = get_tree().create_tween()

				_movement_disabled = true
				_active_pcam.set_priority(10)

				_show_interactive_node(_interactive_UI)
				_interactive_node_logic()

			else:
				_hide_interactive_node(_interactive_UI)
				_interactive_node_logic()


		if Input.is_physical_key_pressed(KEY_ESCAPE) and _movement_disabled:
			_hide_interactive_node(_interactive_UI)
			_interactive_node_logic()


func _show_interactive_node(UI: Control) -> void:
	UI.modulate.a = 0
	UI.visible = true
	tween.tween_property(UI, "modulate", Color.WHITE, 1).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_CIRC)


func _hide_interactive_node(UI: Control) -> void:
	_movement_disabled = false
	_active_pcam.set_priority(0)
	UI.visible = false


func _interactive_node_logic() -> void:
	match _interactive_object:
		2:
			if _movement_disabled:
				_dark_overlay.set_visible(true)
			else:
				_dark_overlay.set_visible(false)


func _physics_process(delta: float) -> void:
	_physics_body_trans_last = _physics_body_trans_current
	_physics_body_trans_current = global_transform

	if not is_on_floor():
		velocity.y += gravity * delta

	if Input.is_action_just_pressed("ui_accept") and is_on_floor():
		velocity.y = JUMP_VELOCITY

	if _movement_disabled: return

	var input_dir: = Input.get_axis(
		INPUT_MOVE_LEFT_STRINGNAME,
		INPUT_MOVE_RIGHT_STRINGNAME
	)

	if input_dir:
		velocity.x = input_dir * SPEED
		if input_dir > 0:
			_player_sprite.set_flip_h(false)
		elif input_dir < 0:
			_player_sprite.set_flip_h(true)
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)

	move_and_slide()


func _process(delta) -> void:
	_player_visuals.global_position = _physics_body_trans_last.interpolate_with(
		_physics_body_trans_current,
		Engine.get_physics_interpolation_fraction()
	).origin


func _show_prompt(body_rid: RID, body: Node2D, body_shape_index: int, local_shape: int) -> void:
	if body is TileMap:
		var tile_map: TileMap = body

		var tile_coords: Vector2i = tile_map.get_coords_for_body_rid(body_rid)
		var cell_data: TileData = tile_map.get_cell_tile_data(1, tile_coords)

		if cell_data:
			var cell_data_type: StringName = cell_data.get_custom_data("Type")
#			var cell_global_pos: Vector2 = tile_map.to_global(tile_map.map_to_local(tile_coords))
			_is_interactive = true
			_interaction_prompt.set_visible(true)

			match cell_data_type:
				"Sign":
					_interactive_UI = owner.get_node("%UISign")
					_active_pcam = %ItemFocusPhantomCamera2D
					_interactive_object = InteractiveType.ITEM
				"Inventory":
					_interactive_UI = owner.get_node("%UIInventory")
					_interactive_object = InteractiveType.INVENTORY
					_active_pcam = %InventoryPhantomCamera2D


func _hide_prompt(body_rid: RID, body: Node2D, body_shape_index: int, local_shape: int) -> void:
	if body is TileMap:
		var tile_map: TileMap = body

		var tile_coords: Vector2i = tile_map.get_coords_for_body_rid(body_rid)
		var cell_data: TileData = tile_map.get_cell_tile_data(1, tile_coords)

		if cell_data:
			_interaction_prompt.set_visible(false)
			_is_interactive = false
			_interactive_UI = null
			_interactive_object = InteractiveType.NONE
			_active_pcam = null

--- SCRIPT: res://addons/phantom_camera/examples/scripts/2D/player_character_body_2d_4.3.gd ---
extends CharacterBody2D

@onready var _player_area2d = %PlayerArea2D
@onready var _player_visuals: Node2D = %PlayerVisuals
@onready var _player_sprite: Sprite2D = %PlayerSprite
@onready var _interaction_prompt: Panel = %InteractionPrompt
@onready var _ui_sign: Control
@onready var _dark_overlay: ColorRect = %DarkOverlay
@onready var _noise_emitter: PhantomCameraNoiseEmitter2D

const KEY_STRINGNAME: StringName = "Key"
const ACTION_STRINGNAME: StringName = "Action"
const INPUT_MOVE_LEFT_STRINGNAME: StringName = "move_left"
const INPUT_MOVE_RIGHT_STRINGNAME: StringName = "move_right"

const SPEED = 350.0
const JUMP_VELOCITY = -750.0

# Get the gravity from the project settings to be synced with RigidBody nodes.
var gravity: int = 2400
var _is_interactive: bool
var _can_open_inventory: bool
var _movement_disabled: bool
var tween: Tween
var _interactive_UI: Control
var _active_pcam: PhantomCamera2D

enum InteractiveType {
	NONE = 0,
	ITEM = 1,
	INVENTORY = 2,
}
var _interactive_object: InteractiveType = InteractiveType.NONE

var InputMovementDic: Dictionary = {
	INPUT_MOVE_LEFT_STRINGNAME: {
		KEY_STRINGNAME: KEY_A,
		ACTION_STRINGNAME: INPUT_MOVE_LEFT_STRINGNAME
	},
	INPUT_MOVE_RIGHT_STRINGNAME: {
		KEY_STRINGNAME: KEY_D,
		ACTION_STRINGNAME: INPUT_MOVE_RIGHT_STRINGNAME
	},
}


func _ready() -> void:
	_player_area2d.body_shape_entered.connect(_show_prompt)
	_player_area2d.body_shape_exited.connect(_hide_prompt)

	_ui_sign = owner.get_node("%UISign")

	for input in InputMovementDic:
		var key_val = InputMovementDic[input].get(KEY_STRINGNAME)
		var action_val = InputMovementDic[input].get(ACTION_STRINGNAME)

		var movement_input = InputEventKey.new()
		movement_input.physical_keycode = key_val
		InputMap.add_action(action_val)
		InputMap.action_add_event(action_val, movement_input)

	if Engine.get_version_info().major == 4 and \
		Engine.get_version_info().minor < 3:
			printerr("This scene is designed to only work properly in Godot 4.3 or later that supports 2D Physics Interpolation.")
			printerr("Please run the other 2D example scenes in the other directory.")


func _unhandled_input(event: InputEvent) -> void:
	if _is_interactive:
		if Input.is_physical_key_pressed(KEY_F):
			if tween:
				tween.kill()

			if not _movement_disabled:
				tween = get_tree().create_tween()

				_movement_disabled = true
				_active_pcam.set_priority(10)

				_show_interactive_node(_interactive_UI)
				_interactive_node_logic()

			else:
				_hide_interactive_node(_interactive_UI)
				_interactive_node_logic()


		if Input.is_physical_key_pressed(KEY_ESCAPE) and _movement_disabled:
			_hide_interactive_node(_interactive_UI)
			_interactive_node_logic()

	if Input.is_physical_key_pressed(KEY_Q):
		if get_node_or_null("%PlayerPhantomCameraNoiseEmitter2D"):
			%PlayerPhantomCameraNoiseEmitter2D.emit()


func _show_interactive_node(UI: Control) -> void:
	UI.modulate.a = 0
	UI.visible = true
	tween.tween_property(UI, "modulate", Color.WHITE, 1).set_ease(Tween.EASE_OUT).set_trans(Tween.TRANS_CIRC)


func _hide_interactive_node(UI: Control) -> void:
	_movement_disabled = false
	_active_pcam.set_priority(0)
	UI.visible = false


func _interactive_node_logic() -> void:
	match _interactive_object:
		2:
			if _movement_disabled:
				_dark_overlay.set_visible(true)
			else:
				_dark_overlay.set_visible(false)


func _physics_process(delta: float) -> void:
	if not is_on_floor():
		velocity.y += gravity * delta

	if Input.is_action_just_pressed("ui_accept") and is_on_floor():
		velocity.y = JUMP_VELOCITY

	if _movement_disabled: return

	var input_dir: = Input.get_axis(
		INPUT_MOVE_LEFT_STRINGNAME,
		INPUT_MOVE_RIGHT_STRINGNAME
	)

	if input_dir:
		velocity.x = input_dir * SPEED
		if input_dir > 0:
			_player_sprite.set_flip_h(false)
		elif input_dir < 0:
			_player_sprite.set_flip_h(true)
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)

	move_and_slide()


func _show_prompt(body_rid: RID, body: Node2D, body_shape_index: int, local_shape: int) -> void:
	if body.is_class("TileMapLayer"): # TODO - Using string reference to support Godot 4.2
		var tile_map := body
		var tile_coords: Vector2i = tile_map.get_coords_for_body_rid(body_rid)
		var cell_data: TileData = tile_map.get_cell_tile_data(tile_coords)

		if cell_data:
			var cell_data_type: StringName = cell_data.get_custom_data("Type")
#			var cell_global_pos: Vector2 = tile_map.to_global(tile_map.map_to_local(tile_coords))
			_is_interactive = true
			_interaction_prompt.set_visible(true)

			match cell_data_type:
				"Sign":
					_interactive_UI = owner.get_node("%UISign")
					_active_pcam = %ItemFocusPhantomCamera2D
					_interactive_object = InteractiveType.ITEM
				"Inventory":
					_interactive_UI = owner.get_node("%UIInventory")
					_interactive_object = InteractiveType.INVENTORY
					_active_pcam = %InventoryPhantomCamera2D


func _hide_prompt(body_rid: RID, body: Node2D, body_shape_index: int, local_shape: int) -> void:
	if body.is_class("TileMapLayer"): # TODO - Using string reference to support Godot 4.2
		var tile_map := body

		var tile_coords: Vector2i = tile_map.get_coords_for_body_rid(body_rid)
		var cell_data: TileData = tile_map.get_cell_tile_data(tile_coords)

		if cell_data:
			_interaction_prompt.set_visible(false)
			_is_interactive = false
			_interactive_UI = null
			_interactive_object = InteractiveType.NONE
			_active_pcam = null

--- SCRIPT: res://addons/phantom_camera/examples/scripts/3D/3d_trigger_area.gd ---
extends Area3D

@export var area_pcam: PhantomCamera3D

var initial_camera_position: Vector3
var initial_camera_rotation: Vector3

var tween: Tween
var tween_duration: float = 0.9


func _ready() -> void:
	connect("area_entered", _entered_area)
	connect("area_exited", _exited_area)


func _entered_area(area_3D: Area3D) -> void:
	if area_3D.get_parent() is CharacterBody3D:
		area_pcam.set_priority(20)


func _exited_area(area_3D: Area3D) -> void:
	if area_3D.get_parent() is CharacterBody3D:
		area_pcam.set_priority(0)

--- SCRIPT: res://addons/phantom_camera/examples/scripts/3D/npc.gd ---
extends Node3D

@onready var npc_pcam: PhantomCamera3D = %NPCPhantomCamera3D
@onready var dialogueArea: Area3D = %NPCInteractionArea3D
@onready var dialogueLabel3D: Label3D = %NPCDialogueExampleLabel

@onready var player: CharacterBody3D = %PlayerCharacterBody3D

@onready var move_to_location: Vector3 = %MoveToLocation.get_global_position()

var dialogue_label_initial_position: Vector3
var dialogue_label_initial_rotation: Vector3

var tween: Tween
var tween_duration: float = 0.9
var tween_transition: Tween.TransitionType = Tween.TRANS_QUAD

var interactable: bool
var is_interacting: bool

func _ready() -> void:
	dialogueArea.connect("area_entered", _interactable)
	dialogueArea.connect("area_exited", _not_interactable)

	dialogueLabel3D.set_visible(false)

	dialogue_label_initial_position = dialogueLabel3D.get_global_position()
	dialogue_label_initial_rotation = dialogueLabel3D.get_global_rotation()

	npc_pcam.tween_completed.connect(_on_tween_started)



func _on_tween_started() -> void:
	player.movement_enabled = false


func _interactable(area_3D: Area3D) -> void:
	if area_3D.get_parent() is CharacterBody3D:
		dialogueLabel3D.set_visible(true)
		interactable = true

		var tween: Tween = get_tree().create_tween().set_trans(tween_transition).set_ease(Tween.EASE_IN_OUT).set_loops()
		tween.tween_property(dialogueLabel3D, "global_position", dialogue_label_initial_position - Vector3(0, -0.2, 0), tween_duration)
		tween.tween_property(dialogueLabel3D, "position", dialogue_label_initial_position, tween_duration)


func _not_interactable(area_3D: Area3D) -> void:
	if area_3D.get_parent() is CharacterBody3D:
		dialogueLabel3D.set_visible(false)
		interactable = false


func _input(event) -> void:
	if not interactable: return

	if event is InputEventKey and event.pressed:
		if event.keycode == KEY_F:
			var tween: Tween = get_tree().create_tween() \
				.set_parallel(true) \
				.set_trans(Tween.TRANS_QUART) \
				.set_ease(Tween.EASE_IN_OUT)
			if not is_interacting:
				npc_pcam.priority = 20
				tween.tween_property(player, "global_position", move_to_location, 0.6).set_trans(tween_transition)
				tween.tween_property(dialogueLabel3D, "rotation", Vector3(deg_to_rad(-20), deg_to_rad(53), 0), 0.6).set_trans(tween_transition)
			else:
				npc_pcam.priority = 0
				tween.tween_property(dialogueLabel3D, "rotation", dialogue_label_initial_rotation, 0.9)
				player.movement_enabled = true
			is_interacting = !is_interacting

--- SCRIPT: res://addons/phantom_camera/examples/scripts/3D/path_follow.gd ---
extends Node

@export var path_pcam: PhantomCamera3D

func _ready() -> void:
	connect("area_entered", _entered_area)
	connect("area_exited", _exited_area)


func _entered_area(area_3D: Area3D) -> void:
	if area_3D.get_parent() is CharacterBody3D:
		path_pcam.set_priority(20)


func _exited_area(area_3D: Area3D) -> void:
	if area_3D.get_parent() is CharacterBody3D:
		path_pcam.set_priority(0)

--- SCRIPT: res://addons/phantom_camera/examples/scripts/3D/player_controller.gd ---
extends CharacterBody3D

@export var SPEED: float = 5.0
@export var JUMP_VELOCITY: float = 4.5
@export var enable_gravity = true

@onready var _camera: Camera3D

@onready var _player_visual: Node3D = %PlayerVisual

# Get the gravity from the project settings to be synced with RigidBody nodes.
var gravity: float = 9.8

var movement_enabled: bool = true

var _physics_body_trans_last: Transform3D
var _physics_body_trans_current: Transform3D

const KEY_STRINGNAME: StringName = "Key"
const ACTION_STRINGNAME: StringName = "Action"

const INPUT_MOVE_UP_STRINGNAME: StringName = "move_up"
const INPUT_MOVE_DOWM_STRINGNAME: StringName = "move_down"
const INPUT_MOVE_LEFT_STRINGNAME: StringName = "move_left"
const INPUT_MOVE_RIGHT_STRINGNAME: StringName = "move_right"

var InputMovementDic: Dictionary = {
	INPUT_MOVE_UP_STRINGNAME: {
		KEY_STRINGNAME: KEY_W,
		ACTION_STRINGNAME: INPUT_MOVE_UP_STRINGNAME
	},
	INPUT_MOVE_DOWM_STRINGNAME: {
		KEY_STRINGNAME: KEY_S,
		ACTION_STRINGNAME: INPUT_MOVE_DOWM_STRINGNAME
	},
	INPUT_MOVE_LEFT_STRINGNAME: {
		KEY_STRINGNAME: KEY_A,
		ACTION_STRINGNAME: INPUT_MOVE_LEFT_STRINGNAME
	},
	INPUT_MOVE_RIGHT_STRINGNAME: {
		KEY_STRINGNAME: KEY_D,
		ACTION_STRINGNAME: INPUT_MOVE_RIGHT_STRINGNAME
	},
}


func _ready() -> void:
	for input in InputMovementDic:
		var key_val = InputMovementDic[input].get(KEY_STRINGNAME)
		var action_val = InputMovementDic[input].get(ACTION_STRINGNAME)

		_camera = owner.get_node("%MainCamera3D")

		var movement_input = InputEventKey.new()
		movement_input.physical_keycode = key_val
		InputMap.add_action(action_val)
		InputMap.action_add_event(action_val, movement_input)

		_player_visual.top_level = true


func _physics_process(delta: float) -> void:
	_physics_body_trans_last = _physics_body_trans_current
	_physics_body_trans_current = global_transform

	# Add the gravity.
	if enable_gravity and not is_on_floor():
		velocity.y -= gravity * delta

	if not movement_enabled: return

	# Get the input direction and handle the movement/deceleration.
	# As good practice, you should replace UI actions with custom gameplay actions.
	var input_dir: Vector2 = Input.get_vector(
		INPUT_MOVE_LEFT_STRINGNAME,
		INPUT_MOVE_RIGHT_STRINGNAME,
		INPUT_MOVE_UP_STRINGNAME,
		INPUT_MOVE_DOWM_STRINGNAME
	)

	var cam_dir: Vector3 = -_camera.global_transform.basis.z

	var direction: Vector3 = (transform.basis * Vector3(input_dir.x, 0, input_dir.y)).normalized()
	if direction:
		var move_dir: Vector3 = Vector3.ZERO
		move_dir.x = direction.x
		move_dir.z = direction.z

		move_dir = move_dir.rotated(Vector3.UP, _camera.rotation.y).normalized()
		velocity.x = move_dir.x * SPEED
		velocity.z = move_dir.z * SPEED
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)
		velocity.z = move_toward(velocity.z, 0, SPEED)

	move_and_slide()


func _process(_delta: float) -> void:
	_player_visual.global_transform = _physics_body_trans_last.interpolate_with(
		_physics_body_trans_current,
		Engine.get_physics_interpolation_fraction()
	)

--- SCRIPT: res://addons/phantom_camera/examples/scripts/3D/player_controller_4.4.gd ---
extends CharacterBody3D

@export var SPEED: float = 5.0
@export var JUMP_VELOCITY: float = 4.5
@export var enable_gravity = true

@onready var _camera: Camera3D

# Get the gravity from the project settings to be synced with RigidBody nodes.
var gravity: float = 9.8

var movement_enabled: bool = true

const KEY_STRINGNAME: StringName = "Key"
const ACTION_STRINGNAME: StringName = "Action"

const INPUT_MOVE_UP_STRINGNAME: StringName = "move_up"
const INPUT_MOVE_DOWM_STRINGNAME: StringName = "move_down"
const INPUT_MOVE_LEFT_STRINGNAME: StringName = "move_left"
const INPUT_MOVE_RIGHT_STRINGNAME: StringName = "move_right"

var InputMovementDic: Dictionary = {
	INPUT_MOVE_UP_STRINGNAME: {
		KEY_STRINGNAME: KEY_W,
		ACTION_STRINGNAME: INPUT_MOVE_UP_STRINGNAME
	},
	INPUT_MOVE_DOWM_STRINGNAME: {
		KEY_STRINGNAME: KEY_S,
		ACTION_STRINGNAME: INPUT_MOVE_DOWM_STRINGNAME
	},
	INPUT_MOVE_LEFT_STRINGNAME: {
		KEY_STRINGNAME: KEY_A,
		ACTION_STRINGNAME: INPUT_MOVE_LEFT_STRINGNAME
	},
	INPUT_MOVE_RIGHT_STRINGNAME: {
		KEY_STRINGNAME: KEY_D,
		ACTION_STRINGNAME: INPUT_MOVE_RIGHT_STRINGNAME
	},
}


func _ready() -> void:
	for input in InputMovementDic:
		var key_val = InputMovementDic[input].get(KEY_STRINGNAME)
		var action_val = InputMovementDic[input].get(ACTION_STRINGNAME)

		_camera = owner.get_node("%MainCamera3D")

		var movement_input = InputEventKey.new()
		movement_input.physical_keycode = key_val
		InputMap.add_action(action_val)
		InputMap.action_add_event(action_val, movement_input)


func _physics_process(delta: float) -> void:
	# Add the gravity.
	if enable_gravity and not is_on_floor():
		velocity.y -= gravity * delta

	if not movement_enabled: return

	# Get the input direction and handle the movement/deceleration.
	# As good practice, you should replace UI actions with custom gameplay actions.
	var input_dir: Vector2 = Input.get_vector(
		INPUT_MOVE_LEFT_STRINGNAME,
		INPUT_MOVE_RIGHT_STRINGNAME,
		INPUT_MOVE_UP_STRINGNAME,
		INPUT_MOVE_DOWM_STRINGNAME
	)

	var direction: Vector3 = (transform.basis * Vector3(input_dir.x, 0, input_dir.y)).normalized()
	if direction:
		var move_dir: Vector3 = Vector3.ZERO
		move_dir.x = direction.x
		move_dir.z = direction.z

		move_dir = move_dir.rotated(Vector3.UP, _camera.rotation.y).normalized()
		velocity.x = move_dir.x * SPEED
		velocity.z = move_dir.z * SPEED
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)
		velocity.z = move_toward(velocity.z, 0, SPEED)

	move_and_slide()

--- SCRIPT: res://addons/phantom_camera/examples/scripts/3D/player_controller_first_person.gd ---
extends "player_controller.gd"

@onready var _player_pcam: PhantomCamera3D = %PlayerPhantomCamera3D

@onready var _player_character: CharacterBody3D = %PlayerCharacterBody3D

@export var mouse_sensitivity: float = 0.05

@export var min_pitch: float = -89.9
@export var max_pitch: float = 50

@export var min_yaw: float = 0
@export var max_yaw: float = 360

@export var run_noise: PhantomCameraNoise3D

func _ready() -> void:
	super()
	Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)

	if get_node_or_null("%PlayerPhantomCameraNoiseEmitter3D"):
		%EmitterTip.visible = true


func _physics_process(delta: float) -> void:
	super(delta)


func _unhandled_input(event: InputEvent) -> void:
	if event is InputEventKey:
		if get_node_or_null("%PlayerPhantomCameraNoiseEmitter3D"):
			if event.keycode == KEY_Q and event.is_pressed():
				%PlayerPhantomCameraNoiseEmitter3D.emit()

	if event is InputEventMouseMotion:
		var pcam_rotation_degrees: Vector3

		# Assigns the current 3D rotation of the SpringArm3D node - so it starts off where it is in the editor
		pcam_rotation_degrees = _player_pcam.rotation_degrees

		# Change the X rotation
		pcam_rotation_degrees.x -= event.relative.y * mouse_sensitivity

		# Clamp the rotation in the X axis so it go over or under the target
		pcam_rotation_degrees.x = clampf(pcam_rotation_degrees.x, min_pitch, max_pitch)

		# Change the Y rotation value
		pcam_rotation_degrees.y -= event.relative.x * mouse_sensitivity

		# Sets the rotation to fully loop around its target, but witout going below or exceeding 0 and 360 degrees respectively
		pcam_rotation_degrees.y = wrapf(pcam_rotation_degrees.y, min_yaw, max_yaw)

		# Change the SpringArm3D node's rotation and rotate around its target
		_player_pcam.rotation_degrees = pcam_rotation_degrees

--- SCRIPT: res://addons/phantom_camera/examples/scripts/3D/player_controller_first_person_4.4.gd ---
extends "player_controller_4.4.gd"

@onready var _player_pcam: PhantomCamera3D = %PlayerPhantomCamera3D

@onready var _player_character: CharacterBody3D = %PlayerCharacterBody3D

@export var mouse_sensitivity: float = 0.05

@export var min_pitch: float = -89.9
@export var max_pitch: float = 50

@export var min_yaw: float = 0
@export var max_yaw: float = 360

@export var run_noise: PhantomCameraNoise3D

func _ready() -> void:
	super()
	Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)

	if get_node_or_null("%PlayerPhantomCameraNoiseEmitter3D"):
		%EmitterTip.visible = true


func _physics_process(delta: float) -> void:
	super(delta)


func _unhandled_input(event: InputEvent) -> void:
	if event is InputEventKey:
		if get_node_or_null("%PlayerPhantomCameraNoiseEmitter3D"):
			if event.keycode == KEY_Q and event.is_pressed():
				%PlayerPhantomCameraNoiseEmitter3D.emit()

	if event is InputEventMouseMotion:
		var pcam_rotation_degrees: Vector3

		# Assigns the current 3D rotation of the SpringArm3D node - so it starts off where it is in the editor
		pcam_rotation_degrees = _player_pcam.rotation_degrees

		# Change the X rotation
		pcam_rotation_degrees.x -= event.relative.y * mouse_sensitivity

		# Clamp the rotation in the X axis so it go over or under the target
		pcam_rotation_degrees.x = clampf(pcam_rotation_degrees.x, min_pitch, max_pitch)

		# Change the Y rotation value
		pcam_rotation_degrees.y -= event.relative.x * mouse_sensitivity

		# Sets the rotation to fully loop around its target, but witout going below or exceeding 0 and 360 degrees respectively
		pcam_rotation_degrees.y = wrapf(pcam_rotation_degrees.y, min_yaw, max_yaw)

		# Change the SpringArm3D node's rotation and rotate around its target
		_player_pcam.rotation_degrees = pcam_rotation_degrees

--- SCRIPT: res://addons/phantom_camera/examples/scripts/3D/player_controller_third_person.gd ---
extends "player_controller.gd"

@onready var _player_pcam: PhantomCamera3D
@onready var _aim_pcam: PhantomCamera3D
@onready var _player_direction: Node3D = %PlayerDirection
@onready var _ceiling_pcam: PhantomCamera3D

@export var mouse_sensitivity: float = 0.05

@export var min_pitch: float = -89.9
@export var max_pitch: float = 50

@export var min_yaw: float = 0
@export var max_yaw: float = 360



func _ready() -> void:
	super()

	_player_pcam = owner.get_node("%PlayerPhantomCamera3D")
	_aim_pcam = owner.get_node("%PlayerAimPhantomCamera3D")
	_ceiling_pcam = owner.get_node("%CeilingPhantomCamera3D")

	if _player_pcam.get_follow_mode() == _player_pcam.FollowMode.THIRD_PERSON:
		Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)


func _physics_process(delta: float) -> void:
	super(delta)

	if velocity.length() > 0.2:
		var look_direction: Vector2 = Vector2(velocity.z, velocity.x)
		_player_direction.rotation.y = look_direction.angle()


func _unhandled_input(event: InputEvent) -> void:
	if _player_pcam.get_follow_mode() == _player_pcam.FollowMode.THIRD_PERSON:
		var active_pcam: PhantomCamera3D

		_set_pcam_rotation(_player_pcam, event)
		_set_pcam_rotation(_aim_pcam, event)
		if _player_pcam.get_priority() > _aim_pcam.get_priority():
			_toggle_aim_pcam(event)
		else:
			_toggle_aim_pcam(event)

		if event is InputEventKey and event.pressed:
			if event.keycode == KEY_SPACE:
				if _ceiling_pcam.get_priority() < 30 and _player_pcam.is_active():
					_ceiling_pcam.set_priority(30)
				else:
					_ceiling_pcam.set_priority(1)


func _set_pcam_rotation(pcam: PhantomCamera3D, event: InputEvent) -> void:
	if event is InputEventMouseMotion:
		var pcam_rotation_degrees: Vector3

		# Assigns the current 3D rotation of the SpringArm3D node - so it starts off where it is in the editor
		pcam_rotation_degrees = pcam.get_third_person_rotation_degrees()

		# Change the X rotation
		pcam_rotation_degrees.x -= event.relative.y * mouse_sensitivity

		# Clamp the rotation in the X axis so it go over or under the target
		pcam_rotation_degrees.x = clampf(pcam_rotation_degrees.x, min_pitch, max_pitch)

		# Change the Y rotation value
		pcam_rotation_degrees.y -= event.relative.x * mouse_sensitivity

		# Sets the rotation to fully loop around its target, but witout going below or exceeding 0 and 360 degrees respectively
		pcam_rotation_degrees.y = wrapf(pcam_rotation_degrees.y, min_yaw, max_yaw)

		# Change the SpringArm3D node's rotation and rotate around its target
		pcam.set_third_person_rotation_degrees(pcam_rotation_degrees)


func _toggle_aim_pcam(event: InputEvent) -> void:
	if event is InputEventMouseButton \
		and event.is_pressed() \
		and event.button_index == 2 \
		and (_player_pcam.is_active() or _aim_pcam.is_active()):
		if _player_pcam.get_priority() > _aim_pcam.get_priority():
			_aim_pcam.set_priority(30)
		else:
			_aim_pcam.set_priority(0)

--- SCRIPT: res://addons/phantom_camera/examples/scripts/3D/player_controller_third_person_4.4.gd ---
extends "player_controller_4.4.gd"

@onready var _player_pcam: PhantomCamera3D
@onready var _aim_pcam: PhantomCamera3D
@onready var _player_direction: Node3D = %PlayerDirection
@onready var _ceiling_pcam: PhantomCamera3D

@export var mouse_sensitivity: float = 0.05

@export var min_pitch: float = -89.9
@export var max_pitch: float = 50

@export var min_yaw: float = 0
@export var max_yaw: float = 360


func _ready() -> void:
	super()

	_player_pcam = owner.get_node("%PlayerPhantomCamera3D")
	_aim_pcam = owner.get_node("%PlayerAimPhantomCamera3D")
	_ceiling_pcam = owner.get_node("%CeilingPhantomCamera3D")

	if _player_pcam.get_follow_mode() == _player_pcam.FollowMode.THIRD_PERSON:
		Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)


func _physics_process(delta: float) -> void:
	super(delta)

	if velocity.length() > 0.2:
		var look_direction: Vector2 = Vector2(velocity.z, velocity.x)
		_player_direction.rotation.y = look_direction.angle()


func _unhandled_input(event: InputEvent) -> void:
	if _player_pcam.get_follow_mode() == _player_pcam.FollowMode.THIRD_PERSON:
		var active_pcam: PhantomCamera3D

		_set_pcam_rotation(_player_pcam, event)
		_set_pcam_rotation(_aim_pcam, event)
		if _player_pcam.get_priority() > _aim_pcam.get_priority():
			_toggle_aim_pcam(event)
		else:
			_toggle_aim_pcam(event)

		if event is InputEventKey and event.pressed:
			if event.keycode == KEY_SPACE:
				if _ceiling_pcam.get_priority() < 30 and _player_pcam.is_active():
					_ceiling_pcam.set_priority(30)
				else:
					_ceiling_pcam.set_priority(1)


func _set_pcam_rotation(pcam: PhantomCamera3D, event: InputEvent) -> void:
	if event is InputEventMouseMotion:
		var pcam_rotation_degrees: Vector3

		# Assigns the current 3D rotation of the SpringArm3D node - so it starts off where it is in the editor
		pcam_rotation_degrees = pcam.get_third_person_rotation_degrees()

		# Change the X rotation
		pcam_rotation_degrees.x -= event.relative.y * mouse_sensitivity

		# Clamp the rotation in the X axis so it go over or under the target
		pcam_rotation_degrees.x = clampf(pcam_rotation_degrees.x, min_pitch, max_pitch)

		# Change the Y rotation value
		pcam_rotation_degrees.y -= event.relative.x * mouse_sensitivity

		# Sets the rotation to fully loop around its target, but witout going below or exceeding 0 and 360 degrees respectively
		pcam_rotation_degrees.y = wrapf(pcam_rotation_degrees.y, min_yaw, max_yaw)

		# Change the SpringArm3D node's rotation and rotate around its target
		pcam.set_third_person_rotation_degrees(pcam_rotation_degrees)


func _toggle_aim_pcam(event: InputEvent) -> void:
	if event is InputEventMouseButton \
		and event.is_pressed() \
		and event.button_index == 2 \
		and (_player_pcam.is_active() or _aim_pcam.is_active()):
		if _player_pcam.get_priority() > _aim_pcam.get_priority():
			_aim_pcam.set_priority(30)
		else:
			_aim_pcam.set_priority(0)

--- SCRIPT: res://addons/phantom_camera/inspector/phantom_camera_inspector_plugin.gd ---
@tool
extends EditorInspectorPlugin

#var _phantom_camera_script: Script = preload("res://addons/phantom_camera/scripts/phantom_camera.gd")


# 	TODO - Enable again once work is resumed for inspector based tasks

#func _can_handle(object) -> bool:
#	return object is _phantom_camera_script


func _parse_category(object: Object, category: String) -> void:

	var _margin_container: MarginContainer = MarginContainer.new()
	var _margin_v: float = 20
	_margin_container.add_theme_constant_override("margin_left", 10)
	_margin_container.add_theme_constant_override("margin_top", _margin_v)
	_margin_container.add_theme_constant_override("margin_right", 10)
	_margin_container.add_theme_constant_override("margin_bottom", _margin_v)
	add_custom_control(_margin_container)

	var _vbox_container: VBoxContainer = VBoxContainer.new()
	_margin_container.add_child(_vbox_container)

	var align_with_view_button = Button.new()
	align_with_view_button.connect("pressed", _align_camera_with_view.bind(object))
	align_with_view_button.set_custom_minimum_size(Vector2(0, 60))
	align_with_view_button.set_text("Align with view")
	_vbox_container.add_child(align_with_view_button)

	var preview_camera_button = Button.new()
	preview_camera_button.connect("pressed", _preview_camera.bind(object))
	preview_camera_button.set_custom_minimum_size(Vector2(0, 60))
	preview_camera_button.set_text("Preview Camera")
	_vbox_container.add_child(preview_camera_button)



func _align_camera_with_view(object: Object) -> void:
	print("Aligning camera with view")
	print(object)

func _preview_camera(object: Object) -> void:
	print("Previewing camera")
	print(object)

--- SCRIPT: res://addons/phantom_camera/plugin.gd ---
@tool
extends EditorPlugin

#region Constants

const PCAM_HOST: String = "PhantomCameraHost"
const PCAM_2D: String = "PhantomCamera2D"
const PCAM_3D: String = "PhantomCamera3D"
const PCAM_NOISE_EMITTER_2D: String = "PhantomCameraNoiseEmitter2D"
const PCAM_NOISE_EMITTER_3D: String = "PhantomCameraNoiseEmitter3D"

const PCam3DPlugin: Script = preload("res://addons/phantom_camera/scripts/gizmos/phantom_camera_3d_gizmo_plugin.gd")
const PCam3DNoiseEmitterPlugin: Script = preload("res://addons/phantom_camera/scripts/gizmos/phantom_camera_noise_emitter_gizmo_plugin_3d.gd")
const EditorPanel: PackedScene = preload("res://addons/phantom_camera/panel/editor.tscn")
const updater_constants: Script = preload("res://addons/phantom_camera/scripts/panel/updater/updater_constants.gd")
const PHANTOM_CAMERA_MANAGER: StringName = "PhantomCameraManager"

#endregion

#region Private Variables

var _settings_show_jitter_tips: String = "phantom_camera/tips/show_jitter_tips"
var _settings_enable_editor_shortcut: String = "phantom_camera/general/enable_editor_shortcut"
var _settings_editor_shortcut: String = "phantom_camera/general/editor_shortcut"

# 	TODO - Pending merge of https://github.com/godotengine/godot/pull/102889 - Should only support Godot version after the release that is featured in
#var _editor_shortcut: Shortcut = Shortcut.new()
#var _editor_shortcut_input: InputEventKey
#endregion

#region Public Variables

var pcam_3d_gizmo_plugin = PCam3DPlugin.new()
var pcam_3d_noise_emitter_gizmo_plugin = PCam3DNoiseEmitterPlugin.new()

var editor_panel_instance: Control
var panel_button: Button
#var viewfinder_panel_instance


#endregion

#region Private Functions

func _enable_plugin() -> void:
	print_rich("Phantom Camera documentation can be found at: [url=https://phantom-camera.dev]https://phantom-camera.dev[/url]")
	if not Engine.has_singleton(PHANTOM_CAMERA_MANAGER):
		add_autoload_singleton(PHANTOM_CAMERA_MANAGER, "res://addons/phantom_camera/scripts/managers/phantom_camera_manager.gd")


func _disable_plugin() -> void:
	remove_autoload_singleton(PHANTOM_CAMERA_MANAGER)


func _enter_tree() -> void:
	add_autoload_singleton(PHANTOM_CAMERA_MANAGER, "res://addons/phantom_camera/scripts/managers/phantom_camera_manager.gd")

	# Phantom Camera Nodes
	add_custom_type(PCAM_2D, "Node2D", preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd"), preload("res://addons/phantom_camera/icons/phantom_camera_2d.svg"))
	add_custom_type(PCAM_3D, "Node3D", preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd"), preload("res://addons/phantom_camera/icons/phantom_camera_2d.svg"))
	add_custom_type(PCAM_HOST, "Node", preload("res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd"), preload("res://addons/phantom_camera/icons/phantom_camera_2d.svg"))
	add_custom_type(PCAM_NOISE_EMITTER_2D, "Node2D", preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_noise_emitter_2d.gd"),  preload("res://addons/phantom_camera/icons/phantom_camera_noise_emitter_2d.svg"))
	add_custom_type(PCAM_NOISE_EMITTER_3D, "Node3D", preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_noise_emitter_3d.gd"),  preload("res://addons/phantom_camera/icons/phantom_camera_noise_emitter_3d.svg"))

	# Phantom Camera 3D Gizmo
	add_node_3d_gizmo_plugin(pcam_3d_gizmo_plugin)
	add_node_3d_gizmo_plugin(pcam_3d_noise_emitter_gizmo_plugin)

	var setting_updater_mode: String
	var setting_updater_mode_default: int
	if FileAccess.file_exists("res://dev_scenes/3d/dev_scene_3d.tscn"): # For forks
		setting_updater_mode = "Off, Console Output"
		setting_updater_mode_default = 1
	else: # For end-users
		setting_updater_mode = "Off, Console Output, Updater Window"
		setting_updater_mode_default = 2

	if not ProjectSettings.has_setting(updater_constants.setting_updater_mode):
		ProjectSettings.set_setting(updater_constants.setting_updater_mode, setting_updater_mode_default)
	ProjectSettings.add_property_info({
		"name": updater_constants.setting_updater_mode,
		"type": TYPE_INT,
		"hint": PROPERTY_HINT_ENUM,
		"hint_string": setting_updater_mode,
	})
	ProjectSettings.set_initial_value(updater_constants.setting_updater_mode, setting_updater_mode_default)
	ProjectSettings.set_as_basic(updater_constants.setting_updater_mode, true)


	## Setting for enabling / disabling Jitter tips in the Output
	if not ProjectSettings.has_setting(_settings_show_jitter_tips):
		ProjectSettings.set_setting(_settings_show_jitter_tips, true)
	ProjectSettings.add_property_info({
		"name": _settings_show_jitter_tips,
		"type": TYPE_BOOL,
	})
	ProjectSettings.set_initial_value(_settings_show_jitter_tips, true)
	ProjectSettings.set_as_basic(_settings_show_jitter_tips, true)


# 	TODO - Pending merge of https://github.com/godotengine/godot/pull/102889 - Should only support Godot version after this release
#	if not ProjectSettings.has_setting(_settings_enable_editor_shortcut):
#		ProjectSettings.set_setting(_settings_enable_editor_shortcut, false)
#	ProjectSettings.set_initial_value(_settings_enable_editor_shortcut, false)

# 	TODO - Pending merge of https://github.com/godotengine/godot/pull/102889 - Should only support Godot version after this release
#	_viewfinder_shortcut_default.events = [editor_shortcut]
#	if ProjectSettings.get_setting(_settings_enable_editor_shortcut):
#	if not ProjectSettings.has_setting(_settings_editor_shortcut):
#		ProjectSettings.set_setting(_settings_editor_shortcut, _editor_shortcut)
#	ProjectSettings.set_initial_value(_settings_editor_shortcut, _editor_shortcut)


	# TODO - Should be disabled unless in editor
	# Viewfinder
	editor_panel_instance = EditorPanel.instantiate()
	editor_panel_instance.editor_plugin = self
	panel_button = add_control_to_bottom_panel(editor_panel_instance, "Phantom Camera")
	panel_button.toggled.connect(_btn_toggled)
	if panel_button.toggle_mode: _btn_toggled(true)

	scene_changed.connect(editor_panel_instance.viewfinder.scene_changed)
	scene_changed.connect(_scene_changed)


func _exit_tree() -> void:
	panel_button.toggled.disconnect(_btn_toggled)
	scene_changed.disconnect(editor_panel_instance.viewfinder.scene_changed)
	scene_changed.disconnect(_scene_changed)

	remove_control_from_bottom_panel(editor_panel_instance)
	editor_panel_instance.queue_free()

	remove_node_3d_gizmo_plugin(pcam_3d_gizmo_plugin)
	remove_node_3d_gizmo_plugin(pcam_3d_noise_emitter_gizmo_plugin)

	remove_custom_type(PCAM_2D)
	remove_custom_type(PCAM_3D)
	remove_custom_type(PCAM_HOST)
	remove_custom_type(PCAM_NOISE_EMITTER_2D)
	remove_custom_type(PCAM_NOISE_EMITTER_3D)

	remove_autoload_singleton(PHANTOM_CAMERA_MANAGER)
#	if get_tree().root.get_node_or_null(String(PHANTOM_CAMERA_MANAGER)):
#		remove_autoload_singleton(PHANTOM_CAMERA_MANAGER)


func _btn_toggled(toggled_on: bool):
	editor_panel_instance.viewfinder.set_visibility(toggled_on)
#	if toggled_on:
#		editor_panel_instance.viewfinder.viewfinder_visible = true
#		editor_panel_instance.viewfinder.visibility_check()
#	else:
#		editor_panel_instance.viewfinder.viewfinder_visible = false

func _make_visible(visible):
	if editor_panel_instance:
		editor_panel_instance.set_visible(visible)

## TODO - Signal can be added directly to the editor_panel with the changes in Godot 4.5 (https://github.com/godotengine/godot/pull/102986)
func _scene_changed(scene_root: Node) -> void:
	editor_panel_instance.viewfinder.scene_changed(scene_root)

#	TODO - Pending merge of https://github.com/godotengine/godot/pull/102889 - Should only support Godot version after this release
#func _set_editor_shortcut() -> InputEventKey:
#	var shortcut: InputEventKey = InputEventKey.new()
#	shortcut.keycode = 67 # Key =  C
#	shortcut.alt_pressed = true
#	return shortcut

#endregion


#region Public Functions

func get_version() -> String:
	var config: ConfigFile = ConfigFile.new()
	config.load(get_script().resource_path.get_base_dir() + "/plugin.cfg")
	return config.get_value("plugin", "version")

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/gizmos/phantom_camera_3d_gizmo.gd ---
@tool
extends EditorNode3DGizmo

#var pcam_3d: PhantomCamera3D

func _redraw() -> void:
	clear()

	var icon: Material = get_plugin().get_material(get_plugin().get_name(), self)
	add_unscaled_billboard(icon, 0.035)

	var pcam_3d: PhantomCamera3D = get_node_3d()

#	if pcam_3d.is_following():
#		_draw_target(pcam_3d, pcam_3d.get_follow_target_position(), "follow_target")
#	if pcam_3d.is_looking_at():
#		_draw_target(pcam_3d, pcam_3d.get_look_at_target_position(), "look_at_target")

	if pcam_3d.is_active(): return

	var frustum_lines: PackedVector3Array = PackedVector3Array()
	var height: float                     = 0.25
	var width: float                      = height * 1.25
	var forward: float                    = height * -1.5

	# Trapezoid
	frustum_lines.push_back(Vector3.ZERO)
	frustum_lines.push_back(Vector3(-width, height, forward))

	frustum_lines.push_back(Vector3.ZERO)
	frustum_lines.push_back(Vector3(width, height, forward))

	frustum_lines.push_back(Vector3.ZERO)
	frustum_lines.push_back(Vector3(-width, -height, forward))

	frustum_lines.push_back(Vector3.ZERO)
	frustum_lines.push_back(Vector3(width, -height, forward))

	#######
	# Frame
	#######
	## Left
	frustum_lines.push_back(Vector3(-width, height, forward))
	frustum_lines.push_back(Vector3(-width, -height, forward))

	## Bottom
	frustum_lines.push_back(Vector3(-width, -height, forward))
	frustum_lines.push_back(Vector3(width, -height, forward))

	## Right
	frustum_lines.push_back(Vector3(width, -height, forward))
	frustum_lines.push_back(Vector3(width, height, forward))

	## Top
	frustum_lines.push_back(Vector3(width, height, forward))
	frustum_lines.push_back(Vector3(-width, height, forward))

	##############
	# Up Direction
	##############
	var up_height: float = height + 0.15
	var up_width: float = width / 3

	## Left
	frustum_lines.push_back(Vector3(0, up_height, forward))
	frustum_lines.push_back(Vector3(-up_width, height, forward))

	## Right
	frustum_lines.push_back(Vector3(0, up_height, forward))
	frustum_lines.push_back(Vector3(up_width, height, forward))

	var frustum_material: StandardMaterial3D = get_plugin().get_material("frustum", self)
	add_lines(frustum_lines, frustum_material, false)


func _draw_target(pcam_3d: Node3D, target_position: Vector3, type: String) -> void:
	var target_lines: PackedVector3Array = PackedVector3Array()
	var direction: Vector3 = target_position - pcam_3d.global_position
	var end_position: Vector3 = pcam_3d.global_basis.z * direction

	target_lines.push_back(Vector3.ZERO)
	target_lines.push_back(end_position)
	var target_material: StandardMaterial3D = get_plugin().get_material(type, self)
	add_lines(target_lines, target_material, false)

--- SCRIPT: res://addons/phantom_camera/scripts/gizmos/phantom_camera_3d_gizmo_plugin.gd ---
@tool
extends EditorNode3DGizmoPlugin

const PhantomCamera3DNode: Script = preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd")
const PhantomCamera3DGizmo: Script = preload("res://addons/phantom_camera/scripts/gizmos/phantom_camera_3d_gizmo.gd")
const _icon_texture: Texture2D = preload("res://addons/phantom_camera/icons/phantom_camera_gizmo.svg")
var _gizmo_name: String = "PhantomCamera3D"

var gizmo_name: String: set = set_gizmo_name
var _gizmo_icon: Texture2D
var _gizmo_spatial_script: Script = PhantomCamera3DNode


func set_gizmo_name(name: String) -> void:
	_gizmo_name = name


func _get_gizmo_name() -> String:
	return _gizmo_name


func _has_gizmo(spatial: Node3D) -> bool:
	return spatial is PhantomCamera3D


func _init() -> void:
	create_icon_material(gizmo_name, _icon_texture, false, Color.WHITE)
	create_material("frustum", Color8(252, 127, 127, 255))
	create_material("follow_target", Color8(185, 58, 89))
	create_material("look_at_target", Color8(61, 207, 225))


func _create_gizmo(for_node_3d: Node3D) -> EditorNode3DGizmo:
	if for_node_3d is PhantomCamera3DNode:
		return PhantomCamera3DGizmo.new()
	else:
		return null

--- SCRIPT: res://addons/phantom_camera/scripts/gizmos/phantom_camera_noise_emitter_gizmo_plugin_3d.gd ---
extends EditorNode3DGizmoPlugin

var _spatial_script: Script = preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_noise_emitter_3d.gd")
var _gizmo_icon: Texture2D = preload("res://addons/phantom_camera/icons/phantom_camera_noise_emitter_gizmo.svg")

var _gizmo_name: StringName = "PhantomCameraNoiseEmitter"

func _init() -> void:
	create_material("main", Color8(252, 127, 127, 255))
	create_handle_material("handles")
	create_icon_material(_gizmo_name, _gizmo_icon, false, Color.WHITE)


func _has_gizmo(node: Node3D):
	return node.get_script() == _spatial_script


func _get_gizmo_name() -> String:
	return _gizmo_name


func _redraw(gizmo: EditorNode3DGizmo):
	gizmo.clear()

	var icon: Material = get_material(_gizmo_name, gizmo)
	gizmo.add_unscaled_billboard(icon, 0.035)

	#var material = get_material("main", gizmo)
	#gizmo.add_lines(_draw_frustum(), material)

--- SCRIPT: res://addons/phantom_camera/scripts/managers/PhantomCameraManager.cs ---
using System.Linq;
using Godot;

#nullable enable

namespace PhantomCamera.Manager;

public static class PhantomCameraManager
{
    private static GodotObject? _instance;

    public static GodotObject Instance => _instance ??= Engine.GetSingleton("PhantomCameraManager");

    public static PhantomCamera2D[] PhantomCamera2Ds =>
        Instance.Call(MethodName.GetPhantomCamera2Ds).AsGodotArray<Node2D>()
            .Select(node => new PhantomCamera2D(node)).ToArray();

    public static PhantomCamera3D[] PhantomCamera3Ds =>
        Instance.Call(MethodName.GetPhantomCamera3Ds).AsGodotArray<Node3D>()
            .Select(node => new PhantomCamera3D(node)).ToArray();

    public static PhantomCameraHost[] PhantomCameraHosts =>
        Instance.Call(MethodName.GetPhantomCameraHosts).AsGodotArray<Node>()
            .Select(node => new PhantomCameraHost(node)).ToArray();

    public static PhantomCamera2D[] GetPhantomCamera2Ds() => PhantomCamera2Ds;
    public static PhantomCamera3D[] GetPhantomCamera3Ds() => PhantomCamera3Ds;
    public static PhantomCameraHost[] GetPhantomCameraHosts() => PhantomCameraHosts;

    public static class MethodName
    {
        public const string GetPhantomCamera2Ds = "get_phantom_camera_2ds";
        public const string GetPhantomCamera3Ds = "get_phantom_camera_3ds";
        public const string GetPhantomCameraHosts = "get_phantom_camera_hosts";
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/managers/phantom_camera_manager.gd ---
@tool
extends Node

const _CONSTANTS = preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd")

#region Signals

# Noise
signal noise_2d_emitted(noise_output: Transform2D, emitter_layer: int)
signal noise_3d_emitted(noise_output: Transform3D, emitter_layer: int)

# PCam Host
signal pcam_host_added_to_scene(pcam_host: PhantomCameraHost)
signal pcam_host_removed_from_scene(pcam_host: PhantomCameraHost)

# PCam
signal pcam_added_to_scene(pcam: Node)
signal pcam_removed_from_scene(pcam: Node)

# Priority
signal pcam_priority_changed(pcam: Node)
signal pcam_visibility_changed(pcam: Node)

signal pcam_teleport(pcam: Node)

# Limit (2D)
signal limit_2d_changed(side: int, limit: int)
signal draw_limit_2d(enabled: bool)

# Camera3DResource (3D)
signal camera_3d_resource_changed(property: String, value: Variant)

# Viewfinder Signals
signal viewfinder_pcam_host_switch(pcam_host: PhantomCameraHost)
signal pcam_priority_override(pcam: Node, shouldOverride: bool)
signal pcam_dead_zone_changed(pcam: Node)
signal pcam_host_layer_changed(pcam: Node)

#endregion

#region Private Variables

var _phantom_camera_host_list: Array[PhantomCameraHost]
var _phantom_camera_2d_list: Array[PhantomCamera2D]
var _phantom_camera_3d_list: Array[Node] ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.

#endregion

#region Public Variables

var phantom_camera_hosts: Array[PhantomCameraHost]:
	get:
		return _phantom_camera_host_list

var phantom_camera_2ds: Array[PhantomCamera2D]:
	get:
		return _phantom_camera_2d_list

var phantom_camera_3ds: Array[Node]: ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
	get:
		return _phantom_camera_3d_list

var screen_size: Vector2i

#endregion

#region Private Functions

func _enter_tree() -> void:
	if not Engine.has_singleton(_CONSTANTS.PCAM_MANAGER_NODE_NAME):
		Engine.register_singleton(_CONSTANTS.PCAM_MANAGER_NODE_NAME, self)
	Engine.physics_jitter_fix = 0


func _ready() -> void:
	# Setting default screensize
	screen_size = Vector2i(
		ProjectSettings.get_setting("display/window/size/viewport_width"),
		ProjectSettings.get_setting("display/window/size/viewport_height")
	)

	# For editor
	if Engine.is_editor_hint():
		ProjectSettings.settings_changed.connect(func():
			screen_size = Vector2i(
				ProjectSettings.get_setting("display/window/size/viewport_width"),
				ProjectSettings.get_setting("display/window/size/viewport_height")
			)
		)
	# For runtime
	else:
		get_tree().get_root().size_changed.connect(func():
			screen_size = get_viewport().get_visible_rect().size
		)

#endregion

#region Public Functions

func pcam_host_added(caller: Node) -> void:
	if is_instance_of(caller, PhantomCameraHost):
		_phantom_camera_host_list.append(caller)
		pcam_host_added_to_scene.emit(caller)
	else:
		printerr("This method can only be called from a PhantomCameraHost node")

func pcam_host_removed(caller: Node) -> void:
	if is_instance_of(caller, PhantomCameraHost):
		_phantom_camera_host_list.erase(caller)
		pcam_host_removed_from_scene.emit(caller)
	else:
		printerr("This method can only be called from a PhantomCameraHost node")


func pcam_added(caller) -> void:
	if is_instance_of(caller, PhantomCamera2D):
		_phantom_camera_2d_list.append(caller)
		pcam_added_to_scene.emit(caller)
	elif caller.is_class("PhantomCamera3D"): ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
		_phantom_camera_3d_list.append(caller)
		pcam_added_to_scene.emit(caller)

func pcam_removed(caller) -> void:
	if is_instance_of(caller, PhantomCamera2D):
		_phantom_camera_2d_list.erase(caller)
		pcam_removed_from_scene.emit(caller)
	elif caller.is_class("PhantomCamera3D"): ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
		_phantom_camera_3d_list.erase(caller)
		pcam_removed_from_scene.emit(caller)
	else:
		printerr("This method can only be called from a PhantomCamera node")


func get_phantom_camera_hosts() -> Array[PhantomCameraHost]:
	return _phantom_camera_host_list

func get_phantom_camera_2ds() -> Array[PhantomCamera2D]:
	return _phantom_camera_2d_list

func get_phantom_camera_3ds() -> Array: ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
	return _phantom_camera_3d_list


func scene_changed() -> void:
	_phantom_camera_2d_list.clear()
	_phantom_camera_3d_list.clear()
	_phantom_camera_host_list.clear()

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/panel/editor.gd ---
@tool
extends VBoxContainer

#region Onready

@onready var updater: Control = %UpdateButton
@onready var viewfinder: Control = %ViewfinderPanel

#endregion

#region Public Variables

var editor_plugin: EditorPlugin

#endregion


#region Private Functions

func _ready():
	updater.editor_plugin = editor_plugin

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/panel/updater/download_update_panel.gd ---
#######################################################################
# Credit goes to the Dialogue Manager plugin for this script
# Check it out at: https://github.com/nathanhoad/godot_dialogue_manager
#######################################################################

@tool
extends Control

#region Constants

const TEMP_FILE_NAME = "user://temp.zip"

#endregion


#region Signals

signal failed()
signal updated(updated_to_version: String)

#endregion


#region @onready

#@onready var logo: TextureRect = %Logo
@onready var _download_verion: Label = %DownloadVersionLabel
@onready var _download_http_request: HTTPRequest = %DownloadHTTPRequest
@onready var _download_button: Button = %DownloadButton
@onready var _download_button_bg: NinePatchRect = %DownloadButtonBG
@onready var _download_label: Label = %UpdateLabel

@onready var _breaking_label: Label = %BreakingLabel
@onready var _breaking_margin_container: MarginContainer = %BreakingMarginContainer
@onready var _breaking_options_button: OptionButton = %BreakingOptionButton
#@onready var current_version_label: Label = %CurrentVersionLabel

#endregion


#region Variables

# Todo - For 4.2 upgrade - Shows current version
var _download_dialogue: AcceptDialog
var _button_texture_default: Texture2D = load("res://addons/phantom_camera/assets/PhantomCameraBtnPrimaryDefault.png")
var _button_texture_hover: Texture2D = load("res://addons/phantom_camera/assets/PhantomCameraBtnPrimaryHover.png")

var next_version_release: Dictionary:
	set(value):
		next_version_release = value
		_download_verion.text = "%s update is available for download" % value.tag_name.substr(1)
		# Todo - For 4.2 upgrade
		#current_version_label.text = "Current version is " + editor_plugin.get_version()
	get:
		return next_version_release

var _breaking_window_height: float = 520
var _breaking_window_height_update: float = 600

#endregion


#region Private Functions

func _ready() -> void:
	_download_http_request.request_completed.connect(_on_http_request_request_completed)
	_download_button.pressed.connect(_on_download_button_pressed)
	_download_button.mouse_entered.connect(_on_mouse_entered)
	_download_button.mouse_exited.connect(_on_mouse_exited)

	_breaking_label.hide()
	_breaking_margin_container.hide()
	_breaking_options_button.hide()

	_breaking_options_button.item_selected.connect(_on_item_selected)


func _on_item_selected(index: int) -> void:
	if index == 1:
		_download_button.show()
		_download_dialogue.size = Vector2(_download_dialogue.size.x, _breaking_window_height_update)
	else:
		_download_button.hide()
		_download_dialogue.size = Vector2(_download_dialogue.size.x, _breaking_window_height)


func _on_download_button_pressed() -> void:
	_download_http_request.request(next_version_release.zipball_url)
	_download_button.disabled = true
	_download_label.text = "Downloading..."
	_download_button_bg.hide()


func _on_mouse_entered() -> void:
	_download_button_bg.set_texture(_button_texture_hover)


func _on_mouse_exited() -> void:
	_download_button_bg.set_texture(_button_texture_default)


func _on_http_request_request_completed(result: int, response_code: int, headers: PackedStringArray, body: PackedByteArray) -> void:
	if result != HTTPRequest.RESULT_SUCCESS:
		failed.emit()
		return

	# Save the downloaded zip
	var zip_file: FileAccess = FileAccess.open(TEMP_FILE_NAME, FileAccess.WRITE)
	zip_file.store_buffer(body)
	zip_file.close()

	OS.move_to_trash(ProjectSettings.globalize_path("res://addons/phantom_camera"))

	var zip_reader: ZIPReader = ZIPReader.new()
	zip_reader.open(TEMP_FILE_NAME)
	var files: PackedStringArray = zip_reader.get_files()

	var base_path = files[1]
	# Remove archive folder
	files.remove_at(0)
	# Remove assets folder
	files.remove_at(0)

	for path in files:
		var new_file_path: String = path.replace(base_path, "")
		if path.ends_with("/"):
			DirAccess.make_dir_recursive_absolute("res://addons/%s" % new_file_path)
		else:
			var file: FileAccess = FileAccess.open("res://addons/%s" % new_file_path, FileAccess.WRITE)
			file.store_buffer(zip_reader.read_file(path))

	zip_reader.close()
	DirAccess.remove_absolute(TEMP_FILE_NAME)

	updated.emit(next_version_release.tag_name.substr(1))


func _on_notes_button_pressed() -> void:
	OS.shell_open(next_version_release.html_url)

#endregion

#region Public Functions

func show_updater_warning(next_version_number: Array, current_version_number: Array) -> void:
	var current_version_number_0: int = current_version_number[0] as int
	var current_version_number_1: int = current_version_number[1] as int

	var next_version_number_0: int = next_version_number[0] as int # Major release number in the new release
	var next_version_number_1: int = next_version_number[1] as int # Minor release number in the new release

	if next_version_number_0 > current_version_number_0 or \
	next_version_number_1 > current_version_number_1:
		_breaking_label.show()
		_breaking_margin_container.show()
		_breaking_options_button.show()
		_download_button.hide()

		_download_dialogue = get_parent()
		_download_dialogue.size = Vector2(_download_dialogue.size.x, _breaking_window_height)

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/panel/updater/updater_constants.gd ---
extends RefCounted

# Plugin Project Settings Sections
const setting_phantom_camera: StringName = "phantom_camera/"
const setting_updater_name: StringName = setting_phantom_camera + "updater/"

# Updater Settings
const setting_updater_mode: StringName = setting_updater_name + "updater_mode"

--- SCRIPT: res://addons/phantom_camera/scripts/panel/updater/update_button.gd ---
#######################################################################
# Credit goes to the Dialogue Manager plugin for this script
# Check it out at: https://github.com/nathanhoad/godot_dialogue_manager
#######################################################################

@tool
extends Button

#region Constants

const REMOTE_RELEASE_URL: StringName = "https://api.github.com/repos/ramokz/phantom-camera/releases"
const UPDATER_CONSTANTS := preload("res://addons/phantom_camera/scripts/panel/updater/updater_constants.gd")

#endregion


#region @onready

@onready var http_request: HTTPRequest = %HTTPRequest
@onready var download_dialog: AcceptDialog = %DownloadDialog
@onready var download_update_panel: Control = %DownloadUpdatePanel
@onready var needs_reload_dialog: AcceptDialog = %NeedsReloadDialog
@onready var update_failed_dialog: AcceptDialog = %UpdateFailedDialog

#endregion


#region Variables

# The main editor plugin
var editor_plugin: EditorPlugin

var needs_reload: bool = false

# A lambda that gets called just before refreshing the plugin. Return false to stop the reload.
var on_before_refresh: Callable = func(): return true

#endregion


#region Private Functions

func _ready() -> void:
	hide()

	# Check for updates on GitHub Releases
	check_for_update()

	pressed.connect(_on_update_button_pressed)
	http_request.request_completed.connect(_request_request_completed)
	download_update_panel.updated.connect(_on_download_update_panel_updated)
	needs_reload_dialog.confirmed.connect(_on_needs_reload_dialog_confirmed)


func _request_request_completed(result: int, response_code: int, headers: PackedStringArray, body: PackedByteArray) -> void:
	if result != HTTPRequest.RESULT_SUCCESS: return

	if not editor_plugin: return
	var current_version: String = editor_plugin.get_version()

	# Work out the next version from the releases information on GitHub
	var response: Array = JSON.parse_string(body.get_string_from_utf8())
	if typeof(response) != TYPE_ARRAY: return

	# GitHub releases are in order of creation, not order of version
	var versions: Array = response.filter(func(release):
		var version: String = release.tag_name.substr(1)
		return version_to_number(version) > version_to_number(current_version)
	)

	if versions.size() > 0:
		if ProjectSettings.get_setting(UPDATER_CONSTANTS.setting_updater_mode) == 1: ## For console output mode

			print_rich("
[color=#3AB99A]   ********[/color]
[color=#3AB99A] ************[/color]
[color=#3AB99A]**************[/color]
[color=#3AB99A]******  ***  *[/color]
[color=#3AB99A]******  ***[/color]
[color=#3AB99A]**********      *****[/color]
[color=#3AB99A]********   ***********[/color]
[color=#3AB99A]********  ***********  **[/color]
[color=#3AB99A]*********  **************[/color]
[color=#3AB99A]**********  *************[/color]
[color=#3AB99A]**  **  **   *******   **[/color]
[font_size=18][b]New Phantom Camera version is available[/b][/font_size]")

			if FileAccess.file_exists("res://dev_scenes/3d/dev_scene_3d.tscn"):
				print_rich("[font_size=14][color=#EAA15E][b]As you're using a fork of the project, you will need to update it manually[/b][/color][/font_size]")

			print_rich("[font_size=12]If you don't want to see this message, then it can be disabled inside:\n[code]Project Settings/Phantom Camera/Updater/Show New Release Info on Editor Launch in Output[/code]")

			return

		download_update_panel.next_version_release = versions[0]
		download_update_panel.show_updater_warning(
			versions[0].tag_name.substr(1).split("."),
			current_version.split(".")
		)
		_set_scale()
		editor_plugin.panel_button.add_theme_color_override("font_color", Color("#3AB99A"))
		editor_plugin.panel_button.icon = load("res://addons/phantom_camera/icons/phantom_camera_updater_panel_icon.svg")
		editor_plugin.panel_button.add_theme_color_override("icon_normal_color", Color("#3AB99A"))
		show()


func _on_update_button_pressed() -> void:
	if needs_reload:
		var will_refresh = on_before_refresh.call()
		if will_refresh:
			EditorInterface.restart_editor(true)
	else:
		_set_scale()
		download_dialog.popup_centered()


func _set_scale() -> void:
	var scale: float = EditorInterface.get_editor_scale()
	download_dialog.min_size = Vector2(300, 250) * scale


func _on_download_dialog_close_requested() -> void:
	download_dialog.hide()


func _on_download_update_panel_updated(updated_to_version: String) -> void:
	download_dialog.hide()

	needs_reload_dialog.dialog_text = "Reload to finish update"
	needs_reload_dialog.ok_button_text = "Reload"
	needs_reload_dialog.cancel_button_text = "Cancel"
	needs_reload_dialog.popup_centered()

	needs_reload = true
	text = "Reload Project"


func _on_download_update_panel_failed() -> void:
	download_dialog.hide()
	update_failed_dialog.dialog_text = "Updated Failed"
	update_failed_dialog.popup_centered()


func _on_needs_reload_dialog_confirmed() -> void:
	EditorInterface.restart_editor(true)


func _on_timer_timeout() -> void:
	if not needs_reload:
		check_for_update()

#endregion


#region Public Functions

# Convert a version number to an actually comparable number
func version_to_number(version: String) -> int:
	var regex = RegEx.new()
	regex.compile("[a-zA-Z]+")
	if regex.search(str(version)): return 0

	var bits = version.split(".")
	var version_bit: int
	var multiplier: int = 10000
	for i in bits.size():
		version_bit += bits[i].to_int() * multiplier / (10 ** (i))

	return version_bit


func check_for_update() -> void:
	if ProjectSettings.get_setting(UPDATER_CONSTANTS.setting_updater_mode) == 0:  return

	http_request.request(REMOTE_RELEASE_URL)

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/panel/viewfinder/host_list.gd ---
@tool
extends VBoxContainer

#region Constants

const _constants := preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd")
const _host_list_item: PackedScene = preload("res://addons/phantom_camera/panel/viewfinder/host_list/host_list_item.tscn")

#endregion

signal pcam_host_removed(pcam_host: PhantomCameraHost)

@onready var _host_list_button: Button = %HostListButton
@onready var _host_list_scroll_container: ScrollContainer = %ScrollContainer
@onready var _host_list_item_container: VBoxContainer = %HostListContainer

var _host_list_open: bool = false

var _bottom_offset_value: float

var _pcam_host_list: Array[PhantomCameraHost]
var _pcam_manager: Node

var _viewfinder_panel: Control

#region Private Functions

func _ready() -> void:
	_host_list_button.pressed.connect(_host_list_button_pressed)
	if Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME):
		_pcam_manager = Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME)
		_pcam_manager.pcam_host_removed_from_scene.connect(_remove_pcam_host)

	if not get_parent() is Control: return # To prevent errors when opening the scene on its own
	_viewfinder_panel = get_parent()
	_viewfinder_panel.resized.connect(_set_offset_top)

	_host_list_item_container.resized.connect(_set_offset_top)


func _set_offset_top() -> void:
	offset_top = _set_host_list_size()


func _host_list_button_pressed() -> void:
	_host_list_open = !_host_list_open

	var tween: Tween = create_tween()
	var max_duration: float = 0.6

	# 300 being the minimum size of the viewfinder's height
	var duration: float = clampf(
		max_duration / (300 / _host_list_item_container.size.y),
		0.3,
		max_duration)

	tween.tween_property(self, "offset_top", _set_host_list_size(), duration)\
	.set_ease(Tween.EASE_OUT)\
	.set_trans(Tween.TRANS_QUINT)


func _set_host_list_size() -> float:
	if not _host_list_open:
		return clampf(
			_viewfinder_panel.size.y - \
			_host_list_item_container.size.y - \
			_host_list_button.size.y - 20,
			0,
			INF
		)
	else:
		return (_viewfinder_panel.size.y - _host_list_button.size.y / 2)


func _remove_pcam_host(pcam_host: PhantomCameraHost) -> void:
	if _pcam_host_list.has(pcam_host):
		_pcam_host_list.erase(pcam_host)

	var freed_pcam_host: Control
	for host_list_item_instance in _host_list_item_container.get_children():
		if not host_list_item_instance.pcam_host == pcam_host: continue
		freed_pcam_host = host_list_item_instance
		host_list_item_instance.queue_free()

#endregion

#region Public Functions

func add_pcam_host(pcam_host: PhantomCameraHost, is_default: bool) -> void:
	if _pcam_host_list.has(pcam_host): return

	_pcam_host_list.append(pcam_host)

	var host_list_item_instance: PanelContainer = _host_list_item.instantiate()
	var switch_pcam_host_button: Button = host_list_item_instance.get_node("%SwitchPCamHost")
	if is_default: switch_pcam_host_button.button_pressed = true

	if not pcam_host.tree_exiting.is_connected(_remove_pcam_host):
		pcam_host.tree_exiting.connect(_remove_pcam_host.bind(pcam_host))

	host_list_item_instance.pcam_host = pcam_host

	_host_list_item_container.add_child(host_list_item_instance)


func clear_pcam_host_list() -> void:
	_pcam_host_list.clear()

	for host_list_item_instance in _host_list_item_container.get_children():
		host_list_item_instance.queue_free()

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/panel/viewfinder/host_list_item.gd ---
@tool
extends Control

const button_group_resource: ButtonGroup = preload("res://addons/phantom_camera/panel/viewfinder/host_list/host_list_item_group.tres")
const _constants = preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd")

@onready var select_pcam_host: Button = %SelectPCamHost
@onready var switch_pcam_host: Button = %SwitchPCamHost

var pcam_host: PhantomCameraHost:
	set(value):
		pcam_host = value
		if not is_instance_valid(value): return
		if not pcam_host.renamed.is_connected(_rename_pcam_host):
			pcam_host.renamed.connect(_rename_pcam_host)
			pcam_host.has_error.connect(_pcam_host_has_error)
	get:
		return pcam_host

var _pcam_manager: Node

#region Private fucntions

func _ready() -> void:
	switch_pcam_host.button_group = button_group_resource
	select_pcam_host.pressed.connect(_select_pcam)
	switch_pcam_host.pressed.connect(_switch_pcam_host)

	if not is_instance_valid(pcam_host): return
	switch_pcam_host.text = pcam_host.name

	_pcam_host_has_error()


func _pcam_host_has_error() -> void:
	if pcam_host.show_warning:
		%ErrorPCamHost.visible = true
	else:
		%ErrorPCamHost.visible = false


func _rename_pcam_host() -> void:
	switch_pcam_host.text = pcam_host.name


func _select_pcam() -> void:
	EditorInterface.get_selection().clear()
	EditorInterface.get_selection().add_node(pcam_host)


func _switch_pcam_host() -> void:
	if not Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME): return
	if not is_instance_valid(_pcam_manager):
		_pcam_manager = Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME)

	_pcam_manager.viewfinder_pcam_host_switch.emit(pcam_host)

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/panel/viewfinder/viewfinder.gd ---
@tool
extends Control

#region Constants

const _constants = preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd")

# TODO - Should be in a central location
const _camera_2d_icon: CompressedTexture2D = preload("res://addons/phantom_camera/icons/viewfinder/Camera2DIcon.svg")
const _camera_3d_icon: CompressedTexture2D = preload("res://addons/phantom_camera/icons/viewfinder/Camera3DIcon.svg")
const _pcam_host_icon: CompressedTexture2D = preload("res://addons/phantom_camera/icons/phantom_camera_host.svg")
const _pcam_2D_icon: CompressedTexture2D = preload("res://addons/phantom_camera/icons/phantom_camera_2d.svg")
const _pcam_3D_icon: CompressedTexture2D = preload("res://addons/phantom_camera/icons/phantom_camera_3d.svg")

const _overlay_color_alpha: float = 0.3

#endregion

#region @onready

@onready var dead_zone_center_hbox: VBoxContainer = %DeadZoneCenterHBoxContainer
@onready var dead_zone_center_center_panel: Panel = %DeadZoneCenterCenterPanel
@onready var dead_zone_left_center_panel: Panel = %DeadZoneLeftCenterPanel
@onready var dead_zone_right_center_panel: Panel = %DeadZoneRightCenterPanel
@onready var target_point: Panel = %TargetPoint

@onready var aspect_ratio_container: AspectRatioContainer = %AspectRatioContainer
@onready var camera_viewport_panel: Panel = aspect_ratio_container.get_child(0)
@onready var _viewfinder: Control = %Viewfinder
@onready var _dead_zone_h_box_container: Control = %DeadZoneHBoxContainer
@onready var sub_viewport: SubViewport = %SubViewport

@onready var _empty_state_control: Control = %EmptyStateControl
@onready var _empty_state_icon: TextureRect = %EmptyStateIcon
@onready var _empty_state_text: RichTextLabel = %EmptyStateText
@onready var _add_node_button: Button = %AddNodeButton
@onready var _add_node_button_text: RichTextLabel = %AddNodeTypeText

@onready var _priority_override_button: Button = %PriorityOverrideButton
@onready var _priority_override_name_label: Label = %PriorityOverrideNameLabel

@onready var _camera_2d: Camera2D = %Camera2D

@onready var _pcam_host_list: VBoxContainer = %PCamHostList

#endregion

#region Private Variables

var _no_open_scene_icon: CompressedTexture2D = preload("res://addons/phantom_camera/icons/viewfinder/SceneTypesIcon.svg")
var _no_open_scene_string: String = "[b]2D[/b] or [b]3D[/b] scene open"

var _selected_camera: Node
var _active_pcam: Node

var _is_2d: bool

var _pcam_manager: Node

var _root_node: Node

#endregion

#region Public Variables

var pcam_host_group: Array[PhantomCameraHost]

var is_scene: bool

var viewfinder_visible: bool

var min_horizontal: float
var max_horizontal: float
var min_vertical: float
var max_vertical: float

var pcam_host: PhantomCameraHost

#endregion


#region Private Functions

func _ready() -> void:
	if not Engine.is_editor_hint():
		set_process(true)
		camera_viewport_panel.self_modulate.a = 0

	_root_node = get_tree().current_scene

	if _root_node is Node2D || _root_node is Node3D:
		%SubViewportContainer.visible = false
		if _root_node is Node2D:
			_is_2d = true
		else:
			_is_2d = false

		_set_viewfinder(_root_node, false)

	if not Engine.is_editor_hint():
		_empty_state_control.visible = false

	_priority_override_button.visible = false

	# Triggered when viewport size is changed in Project Settings
	ProjectSettings.settings_changed.connect(_settings_changed)

	# PCam Host List
	_pcam_host_list.visible = false
	_assign_manager()
	_visibility_check()


func _pcam_host_switch(new_pcam_host: PhantomCameraHost) -> void:
	_set_viewfinder_camera(new_pcam_host, true)


func _exit_tree() -> void:
	if aspect_ratio_container.resized.is_connected(_resized):
		aspect_ratio_container.resized.disconnect(_resized)

	if _add_node_button.pressed.is_connected(_visibility_check):
		_add_node_button.pressed.disconnect(_visibility_check)

	if is_instance_valid(_active_pcam):
		if _active_pcam.dead_zone_changed.is_connected(_on_dead_zone_changed):
			_active_pcam.dead_zone_changed.disconnect(_on_dead_zone_changed)

	if _priority_override_button.pressed.is_connected(_select_override_pcam):
		_priority_override_button.pressed.disconnect(_select_override_pcam)


func _process(_delta: float) -> void:
	if Engine.is_editor_hint() and not viewfinder_visible: return
	if not is_instance_valid(_active_pcam): return

	var unprojected_position_clamped: Vector2 = Vector2(
		clamp(_active_pcam.viewport_position.x, min_horizontal, max_horizontal),
		clamp(_active_pcam.viewport_position.y, min_vertical, max_vertical)
	)

	if not Engine.is_editor_hint():
		target_point.position = camera_viewport_panel.size * unprojected_position_clamped - target_point.size / 2

	if not _is_2d: return
	if not is_instance_valid(pcam_host): return
	if not is_instance_valid(pcam_host.camera_2d): return

	var window_size_height: float = ProjectSettings.get_setting("display/window/size/viewport_height")
	sub_viewport.size_2d_override = sub_viewport.size * (window_size_height / sub_viewport.size.y)

	_camera_2d.global_transform = pcam_host.camera_2d.global_transform
	_camera_2d.offset = pcam_host.camera_2d.offset
	_camera_2d.zoom = pcam_host.camera_2d.zoom
	_camera_2d.ignore_rotation = pcam_host.camera_2d.ignore_rotation
	_camera_2d.anchor_mode = pcam_host.camera_2d.anchor_mode
	_camera_2d.limit_left = pcam_host.camera_2d.limit_left
	_camera_2d.limit_top = pcam_host.camera_2d.limit_top
	_camera_2d.limit_right = pcam_host.camera_2d.limit_right
	_camera_2d.limit_bottom = pcam_host.camera_2d.limit_bottom


func _settings_changed() -> void:
	var viewport_width: float = ProjectSettings.get_setting("display/window/size/viewport_width")
	var viewport_height: float = ProjectSettings.get_setting("display/window/size/viewport_height")
	var ratio: float = viewport_width / viewport_height
	aspect_ratio_container.set_ratio(ratio)
	camera_viewport_panel.size.x = viewport_width / (viewport_height / sub_viewport.size.y)

	# Applies Project Settings to Viewport
	sub_viewport.canvas_item_default_texture_filter = ProjectSettings.get_setting("rendering/textures/canvas_textures/default_texture_filter")

	# TODO - Add resizer for Framed Viewfinder


func _visibility_check() -> void:
	if not viewfinder_visible: return

	var pcam_host: PhantomCameraHost
	var has_camera: bool = false
	if not Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME): return

	if not Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME).get_phantom_camera_hosts().is_empty():
		has_camera = true
		pcam_host = Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME).get_phantom_camera_hosts()[0]

	var root: Node = EditorInterface.get_edited_scene_root()
	if root is Node2D:
		var camera_2d: Camera2D

		if has_camera:
			camera_2d = pcam_host.camera_2d
		else:
			camera_2d = _get_camera_2d()

		_is_2d = true
		is_scene = true
		_add_node_button.visible = true
		_check_camera(root, camera_2d)
	elif root is Node3D:
		var camera_3d: Camera3D
		if has_camera:
			camera_3d = pcam_host.camera_3d
		elif root.get_viewport() != null:
			if root.get_viewport().get_camera_3d() != null:
				camera_3d = root.get_viewport().get_camera_3d()

		_is_2d = false
		is_scene = true
		_add_node_button.visible = true
		_check_camera(root, camera_3d)
	else:
		# Is not a 2D or 3D scene
		is_scene = false
		_set_empty_viewfinder_state(_no_open_scene_string, _no_open_scene_icon)
		_add_node_button.visible = false

		# Checks if a new scene is created and changes viewfinder accordingly
		if not get_tree().node_added.is_connected(_node_added_to_scene):
			get_tree().node_added.connect(_node_added_to_scene)

	if not _priority_override_button.pressed.is_connected(_select_override_pcam):
		_priority_override_button.pressed.connect(_select_override_pcam)


func _node_added_to_scene(node: Node) -> void:
	if node is Node2D or node is Node3D:
		get_tree().node_added.disconnect(_node_added_to_scene)
		_visibility_check()


func _get_camera_2d() -> Camera2D:
	var edited_scene_root: Node = EditorInterface.get_edited_scene_root()

	if edited_scene_root == null: return null

	var viewport: Viewport = edited_scene_root.get_viewport()
	if viewport == null: return null

	var viewport_rid: RID = viewport.get_viewport_rid()
	if viewport_rid == null: return null

	var camerasGroupName: String = "__cameras_%d" % viewport_rid.get_id()
	var cameras: Array[Node] = get_tree().get_nodes_in_group(camerasGroupName)

	for camera in cameras:
		if camera is Camera2D and camera.is_current:
			return camera

	return null


func _check_camera(root: Node, camera: Node) -> void:
	var camera_string: String
	var pcam_string: String
	var color: Color
	var camera_icon: CompressedTexture2D
	var pcam_icon: CompressedTexture2D

	if _is_2d:
		camera_string = _constants.CAMERA_2D_NODE_NAME
		pcam_string = _constants.PCAM_2D_NODE_NAME
		color = _constants.COLOR_2D
		camera_icon = _camera_2d_icon
		pcam_icon = _pcam_2D_icon
	else:
		camera_string = _constants.CAMERA_3D_NODE_NAME
		pcam_string = _constants.PCAM_3D_NODE_NAME
		color = _constants.COLOR_3D
		camera_icon = _camera_3d_icon
		pcam_icon = _pcam_3D_icon

	if camera:
#		Has Camera
		if camera.get_children().size() > 0:
			for cam_child in camera.get_children():
				if cam_child is PhantomCameraHost:
					pcam_host = cam_child

				if pcam_host:
					if get_tree().root.get_node(_constants.PCAM_MANAGER_NODE_NAME).get_phantom_camera_2ds() or \
					get_tree().root.get_node(_constants.PCAM_MANAGER_NODE_NAME).get_phantom_camera_3ds():
						# Pcam exists in tree
						_set_viewfinder(root, true)
						_set_viewfinder_state()
						%NoSupportMsg.visible = false
					else:
#						No PCam in scene
						_update_button(pcam_string, pcam_icon, color)
						_set_empty_viewfinder_state(pcam_string, pcam_icon)
				else:
#					No PCamHost in scene
					_update_button(_constants.PCAM_HOST_NODE_NAME, _pcam_host_icon, _constants.PCAM_HOST_COLOR)
					_set_empty_viewfinder_state(_constants.PCAM_HOST_NODE_NAME, _pcam_host_icon)
		else:
#			No PCamHost in scene
			_update_button(_constants.PCAM_HOST_NODE_NAME, _pcam_host_icon, _constants.PCAM_HOST_COLOR)
			_set_empty_viewfinder_state(_constants.PCAM_HOST_NODE_NAME, _pcam_host_icon)
	else:
#		No Camera
		_update_button(camera_string, camera_icon, color)
		_set_empty_viewfinder_state(camera_string, camera_icon)


func _update_button(text: String, icon: CompressedTexture2D, color: Color) -> void:
	_add_node_button_text.set_text("[center]Add [img=32]" + icon.resource_path + "[/img] [b]"+ text + "[/b][/center]");
	var button_theme_hover: StyleBoxFlat = _add_node_button.get_theme_stylebox("hover")
	button_theme_hover.border_color = color
	_add_node_button.add_theme_stylebox_override("hover", button_theme_hover)


func _set_viewfinder_state() -> void:
	_empty_state_control.visible = false
	_viewfinder.visible = true

	if is_instance_valid(_active_pcam):
		if _active_pcam.get_follow_mode() == _active_pcam.FollowMode.FRAMED:
			_dead_zone_h_box_container.visible = true
			target_point.visible = true
		else:
			_dead_zone_h_box_container.visible = false
			target_point.visible = false


func _set_empty_viewfinder_state(text: String, icon: CompressedTexture2D) -> void:
	_viewfinder.visible = false
	_framed_view_visible(false)

	_empty_state_control.visible = true
	_empty_state_icon.texture = icon
	if icon == _no_open_scene_icon:
		_empty_state_text.set_text("[center]No " + text + "[/center]")
	else:
		_empty_state_text.set_text("[center]No [b]" + text + "[/b] in scene[/center]")

	if _add_node_button.pressed.is_connected(_add_node):
		_add_node_button.pressed.disconnect(_add_node)

	_add_node_button.pressed.connect(_add_node.bind(text))


func _add_node(node_type: String) -> void:
	var scene_root: Node = EditorInterface.get_edited_scene_root()

	match node_type:
		_no_open_scene_string:
			pass
		_constants.CAMERA_2D_NODE_NAME:
			var camera: Camera2D = Camera2D.new()
			_instantiate_node(scene_root, camera, _constants.CAMERA_2D_NODE_NAME)
		_constants.CAMERA_3D_NODE_NAME:
			var camera: Camera3D = Camera3D.new()
			_instantiate_node(scene_root, camera, _constants.CAMERA_3D_NODE_NAME)
		_constants.PCAM_HOST_NODE_NAME:
			var pcam_host: PhantomCameraHost = PhantomCameraHost.new()
			var camera_owner: Node
			if _is_2d:
				camera_owner = _get_camera_2d()
			else:
				camera_owner = get_tree().get_edited_scene_root().get_viewport().get_camera_3d()
			_instantiate_node(
				scene_root,
				pcam_host,
				_constants.PCAM_HOST_NODE_NAME,
				camera_owner
			)
		_constants.PCAM_2D_NODE_NAME:
			var pcam_2D: PhantomCamera2D = PhantomCamera2D.new()
			_instantiate_node(scene_root, pcam_2D, _constants.PCAM_2D_NODE_NAME)
		_constants.PCAM_3D_NODE_NAME:
			var pcam_3D: PhantomCamera3D = PhantomCamera3D.new()
			_instantiate_node(scene_root, pcam_3D, _constants.PCAM_3D_NODE_NAME)

	_visibility_check()


func _instantiate_node(scene_root: Node, node: Node, name: String, parent: Node = scene_root) -> void:
	node.set_name(name)
	parent.add_child(node)
	node.owner = scene_root


func _set_viewfinder(root: Node, editor: bool) -> void:
	pcam_host_group = get_tree().root.get_node(_constants.PCAM_MANAGER_NODE_NAME).get_phantom_camera_hosts()
	if pcam_host_group.size() != 0:
		if pcam_host_group.size() == 1:
			_pcam_host_list.visible = false
			_set_viewfinder_camera(pcam_host_group[0], editor)
		else:
			_pcam_host_list.visible = true
			_set_viewfinder_camera(pcam_host_group[0], editor)
			for i in pcam_host_group.size():
				var is_default: bool = false
				if i == 0:
					is_default = true
				_pcam_host_list.add_pcam_host(pcam_host_group[i], is_default)


func _set_viewfinder_camera(new_pcam_host: PhantomCameraHost, editor: bool) -> void:
	pcam_host = new_pcam_host

	if _is_2d:
		_selected_camera = pcam_host.camera_2d

		if editor:
			sub_viewport.disable_3d = true
			pcam_host = pcam_host
			_camera_2d.zoom = pcam_host.camera_2d.zoom
			_camera_2d.offset = pcam_host.camera_2d.offset
			_camera_2d.ignore_rotation = pcam_host.camera_2d.ignore_rotation

			sub_viewport.world_2d = pcam_host.camera_2d.get_world_2d()
			sub_viewport.render_target_update_mode = SubViewport.UPDATE_ALWAYS
			sub_viewport.render_target_clear_mode = SubViewport.CLEAR_MODE_ALWAYS
			sub_viewport.size_2d_override_stretch = true
	else:
		_selected_camera = pcam_host.camera_3d
		if editor:
			var camera_3d_rid: RID = _selected_camera.get_camera_rid()
			sub_viewport.disable_3d = false
			sub_viewport.world_3d = pcam_host.camera_3d.get_world_3d()
			RenderingServer.viewport_attach_camera(sub_viewport.get_viewport_rid(), camera_3d_rid)

		if _selected_camera.keep_aspect == Camera3D.KeepAspect.KEEP_HEIGHT:
			aspect_ratio_container.set_stretch_mode(AspectRatioContainer.STRETCH_HEIGHT_CONTROLS_WIDTH)
		else:
			aspect_ratio_container.set_stretch_mode(AspectRatioContainer.STRETCH_WIDTH_CONTROLS_HEIGHT)

	set_process(true)

	if not pcam_host.viewfinder_update.is_connected(_on_update_editor_viewfinder):
		pcam_host.viewfinder_update.connect(_on_update_editor_viewfinder)

	if not pcam_host.viewfinder_disable_dead_zone.is_connected(_disconnect_dead_zone):
		pcam_host.viewfinder_disable_dead_zone.connect(_disconnect_dead_zone)

	if not aspect_ratio_container.resized.is_connected(_resized):
		aspect_ratio_container.resized.connect(_resized)

	if is_instance_valid(pcam_host.get_active_pcam()):
		_active_pcam = pcam_host.get_active_pcam()
	else:
		_framed_view_visible(false)
		_active_pcam = null
		return

	if not _active_pcam.follow_mode == PhantomCamera2D.FollowMode.FRAMED: return

	_framed_view_visible(true)
	_on_dead_zone_changed()
	_connect_dead_zone()


func _connect_dead_zone() -> void:
	if not _active_pcam and is_instance_valid(pcam_host.get_active_pcam()):
		_active_pcam = pcam_host.get_active_pcam()

	if not _active_pcam.dead_zone_changed.is_connected(_on_dead_zone_changed):
		_active_pcam.dead_zone_changed.connect(_on_dead_zone_changed)

		_framed_view_visible(true)
		_viewfinder.visible = true
		_on_dead_zone_changed()

func _disconnect_dead_zone() -> void:
	if not is_instance_valid(_active_pcam): return
	_framed_view_visible(_is_framed_pcam())

	if _active_pcam.follow_mode_changed.is_connected(_check_follow_mode):
		_active_pcam.follow_mode_changed.disconnect(_check_follow_mode)

	if _active_pcam.dead_zone_changed.is_connected(_on_dead_zone_changed):
		_active_pcam.dead_zone_changed.disconnect(_on_dead_zone_changed)


func _resized() -> void:
	_on_dead_zone_changed()


func _is_framed_pcam() -> bool:
	if not is_instance_valid(pcam_host): return false
	_active_pcam = pcam_host.get_active_pcam()
	if not is_instance_valid(_active_pcam): return false
	if not _active_pcam.follow_mode == PhantomCamera2D.FollowMode.FRAMED: return false

	return true


func _framed_view_visible(should_show: bool) -> void:
	if should_show:
		target_point.visible = true
		_dead_zone_h_box_container.visible = true
	else:
		target_point.visible = false
		_dead_zone_h_box_container.visible = false


func _on_dead_zone_changed() -> void:
	if not is_instance_valid(_active_pcam): return
	if not _active_pcam.follow_mode == _active_pcam.FollowMode.FRAMED: return

	# Waits until the camera_viewport_panel has been resized when launching the game
	if camera_viewport_panel.size.x == 0:
		await camera_viewport_panel.resized

	if not _active_pcam == pcam_host.get_active_pcam():
		_active_pcam == pcam_host.get_active_pcam()

	var dead_zone_width: float = _active_pcam.dead_zone_width * camera_viewport_panel.size.x
	var dead_zone_height: float = _active_pcam.dead_zone_height * camera_viewport_panel.size.y
	dead_zone_center_hbox.set_custom_minimum_size(Vector2(dead_zone_width, 0))
	dead_zone_center_center_panel.set_custom_minimum_size(Vector2(0, dead_zone_height))
	dead_zone_left_center_panel.set_custom_minimum_size(Vector2(0, dead_zone_height))
	dead_zone_right_center_panel.set_custom_minimum_size(Vector2(0, dead_zone_height))

	min_horizontal = 0.5 - _active_pcam.dead_zone_width / 2
	max_horizontal = 0.5 + _active_pcam.dead_zone_width / 2
	min_vertical = 0.5 - _active_pcam.dead_zone_height / 2
	max_vertical = 0.5 + _active_pcam.dead_zone_height / 2


func _check_follow_mode() -> void:
	_framed_view_visible(_is_framed_pcam())


func _on_update_editor_viewfinder(check_framed_view: bool = false) -> void:
	_active_pcam = pcam_host.get_active_pcam()

	if not is_instance_valid(_active_pcam): return

	if not _active_pcam.follow_mode_changed.is_connected(_check_follow_mode):
		_active_pcam.follow_mode_changed.connect(_check_follow_mode)

	if _active_pcam.priority_override:
		_priority_override_button.visible = true
		_priority_override_name_label.set_text(_active_pcam.name)
		_priority_override_button.set_tooltip_text(_active_pcam.name)
	else:
		_priority_override_button.visible = false

	_framed_view_visible(false)
	if not check_framed_view: return
	if _is_framed_pcam(): _connect_dead_zone()


func _select_override_pcam() -> void:
	EditorInterface.get_selection().clear()
	EditorInterface.get_selection().add_node(_active_pcam)


func _assign_manager() -> void:
	if not is_instance_valid(_pcam_manager):
		if Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME):
			_pcam_manager = Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME)
			_pcam_manager.pcam_host_added_to_scene.connect(_pcam_changed)
			_pcam_manager.pcam_host_removed_from_scene.connect(_pcam_host_removed_from_scene)

			_pcam_manager.pcam_added_to_scene.connect(_pcam_changed)
			_pcam_manager.pcam_removed_from_scene.connect(_pcam_changed)

			_pcam_manager.viewfinder_pcam_host_switch.connect(_pcam_host_switch)


func _pcam_host_removed_from_scene(pcam_host: PhantomCameraHost) -> void:
	if _pcam_manager.phantom_camera_hosts.size() < 2:
		_pcam_host_list.visible = false

	_visibility_check()


func _pcam_changed(pcam: Node) -> void:
	_visibility_check()

#endregion


#region Public Functions

func set_visibility(visible: bool) -> void:
	if visible:
		viewfinder_visible = true
		_visibility_check()
	else:
		viewfinder_visible = false


func update_dead_zone() -> void:
	_set_viewfinder(_root_node, true)


## TODO - Signal can be added directly to this file with the changes in Godot 4.5 (https://github.com/godotengine/godot/pull/102986)
func scene_changed(scene_root: Node) -> void:
	_assign_manager()
	_priority_override_button.visible = false
	_pcam_host_list.clear_pcam_host_list()

	if not scene_root is Node2D and not scene_root is Node3D:
		is_scene = false
		_pcam_host_list.visible = false
		_set_empty_viewfinder_state(_no_open_scene_string, _no_open_scene_icon)
		_add_node_button.visible = false
	else:
		_visibility_check()

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera/PhantomCamera.cs ---
using Godot;
using PhantomCamera.Noise;

#nullable enable

namespace PhantomCamera;

public enum InactiveUpdateMode
{
    Always,
    Never
}

public abstract class PhantomCamera
{
    protected readonly GodotObject Node;

    public delegate void BecameActiveEventHandler();
    public delegate void BecameInactiveEventHandler();
    public delegate void FollowTargetChangedEventHandler();
    public delegate void DeadZoneChangedEventHandler();
    public delegate void TweenStartedEventHandler();
    public delegate void IsTweeningEventHandler();
    public delegate void TweenCompletedEventHandler();

    public event BecameActiveEventHandler? BecameActive;
    public event BecameInactiveEventHandler? BecameInactive;
    public event FollowTargetChangedEventHandler? FollowTargetChanged;
    public event DeadZoneChangedEventHandler? DeadZoneChanged;
    public event TweenStartedEventHandler? TweenStarted;
    public event IsTweeningEventHandler? IsTweening;
    public event TweenCompletedEventHandler? TweenCompleted;

    private readonly Callable _callableBecameActive;
    private readonly Callable _callableBecameInactive;
    private readonly Callable _callableFollowTargetChanged;
    private readonly Callable _callableDeadZoneChanged;
    private readonly Callable _callableTweenStarted;
    private readonly Callable _callableIsTweening;
    private readonly Callable _callableTweenCompleted;

    public int Priority
    {
        get => (int)Node.Call(MethodName.GetPriority);
        set => Node.Call(MethodName.SetPriority, value);
    }

    public bool IsActive => (bool)Node.Call(MethodName.IsActive);

    public bool FollowDamping
    {
        get => (bool)Node.Call(MethodName.GetFollowDamping);
        set => Node.Call(MethodName.SetFollowDamping, value);
    }

    public bool IsFollowing => (bool)Node.Call(PhantomCamera.MethodName.IsFollowing);

    public float DeadZoneWidth
    {
        get => (float)Node.Get(PropertyName.DeadZoneWidth);
        set => Node.Set(PropertyName.DeadZoneWidth, value);
    }

    public float DeadZoneHeight
    {
        get => (float)Node.Get(PropertyName.DeadZoneHeight);
        set => Node.Set(PropertyName.DeadZoneHeight, value);
    }

    public PhantomCameraTween TweenResource
    {
        get => new((Resource)Node.Call(MethodName.GetTweenResource));
        set => Node.Call(MethodName.SetTweenResource, (GodotObject)value.Resource);
    }

    public bool TweenSkip
    {
        get => (bool)Node.Call(MethodName.GetTweenSkip);
        set => Node.Call(MethodName.SetTweenSkip, value);
    }

    public float TweenDuration
    {
        get => (float)Node.Call(MethodName.GetTweenDuration);
        set => Node.Call(MethodName.SetTweenDuration, value);
    }

    public TransitionType TweenTransition
    {
        get => (TransitionType)(int)Node.Call(MethodName.GetTweenTransition);
        set => Node.Call(MethodName.SetTweenTransition, (int)value);
    }

    public EaseType TweenEase
    {
        get => (EaseType)(int)Node.Call(MethodName.GetTweenEase);
        set => Node.Call(MethodName.SetTweenEase, (int)value);
    }

    public bool TweenOnLoad
    {
        get => (bool)Node.Call(MethodName.GetTweenOnLoad);
        set => Node.Call(MethodName.SetTweenOnLoad, value);
    }

    public InactiveUpdateMode InactiveUpdateMode
    {
        get => (InactiveUpdateMode)(int)Node.Call(MethodName.GetInactiveUpdateMode);
        set => Node.Call(MethodName.SetInactiveUpdateMode, (int)value);
    }

    public int HostLayers
    {
        get => (int)Node.Call(MethodName.GetHostLayers);
        set => Node.Call(MethodName.SetHostLayers, value);
    }

    public int NoiseEmitterLayer
    {
        get => (int)Node.Call(MethodName.GetNoiseEmitterLayer);
        set => Node.Call(MethodName.SetNoiseEmitterLayer, value);
    }

    public void TeleportPosition()
    {
        Node.Call(MethodName.TeleportPosition);
    }

    public void SetHostLayersValue(int layer, bool enabled)
    {
        Node.Call(MethodName.SetHostLayersValue, layer, enabled);
    }

    protected PhantomCamera(GodotObject phantomCameraNode)
    {
        Node = phantomCameraNode;

        _callableBecameActive = Callable.From(() => BecameActive?.Invoke());
        _callableBecameInactive = Callable.From(() => BecameInactive?.Invoke());
        _callableFollowTargetChanged = Callable.From(() => FollowTargetChanged?.Invoke());
        _callableDeadZoneChanged = Callable.From(() => DeadZoneChanged?.Invoke());
        _callableTweenStarted = Callable.From(() => TweenStarted?.Invoke());
        _callableIsTweening = Callable.From(() => IsTweening?.Invoke());
        _callableTweenCompleted = Callable.From(() => TweenCompleted?.Invoke());

        Node.Connect(SignalName.BecameActive, _callableBecameActive);
        Node.Connect(SignalName.BecameInactive, _callableBecameInactive);
        Node.Connect(SignalName.FollowTargetChanged, _callableFollowTargetChanged);
        Node.Connect(SignalName.DeadZoneChanged, _callableDeadZoneChanged);
        Node.Connect(SignalName.TweenStarted, _callableTweenStarted);
        Node.Connect(SignalName.IsTweening, _callableIsTweening);
        Node.Connect(SignalName.TweenCompleted, _callableTweenCompleted);
    }

    ~PhantomCamera()
    {
        Node.Disconnect(SignalName.BecameActive, _callableBecameActive);
        Node.Disconnect(SignalName.BecameInactive, _callableBecameInactive);
        Node.Disconnect(SignalName.FollowTargetChanged, _callableFollowTargetChanged);
        Node.Disconnect(SignalName.DeadZoneChanged, _callableDeadZoneChanged);
        Node.Disconnect(SignalName.TweenStarted, _callableTweenStarted);
        Node.Disconnect(SignalName.IsTweening, _callableIsTweening);
        Node.Disconnect(SignalName.TweenCompleted, _callableTweenCompleted);
    }

    public static class MethodName
    {
        public const string GetFollowMode = "get_follow_mode";
        public const string IsActive = "is_active";

        public const string GetPriority = "get_priority";
        public const string SetPriority = "set_priority";

        public const string IsFollowing = "is_following";

        public const string GetFollowTarget = "get_follow_target";
        public const string SetFollowTarget = "set_follow_target";

        public const string GetFollowTargets = "get_follow_targets";
        public const string SetFollowTargets = "set_follow_targets";

        public const string TeleportPosition = "teleport_position";

        public const string AppendFollowTargets = "append_follow_targets";
        public const string AppendFollowTargetsArray = "append_follow_targets_array";
        public const string EraseFollowTargets = "erase_follow_targets";

        public const string GetFollowPath = "get_follow_path";
        public const string SetFollowPath = "set_follow_path";

        public const string GetFollowOffset = "get_follow_offset";
        public const string SetFollowOffset = "set_follow_offset";

        public const string GetFollowDamping = "get_follow_damping";
        public const string SetFollowDamping = "set_follow_damping";

        public const string GetFollowDampingValue = "get_follow_damping_value";
        public const string SetFollowDampingValue = "set_follow_damping_value";

        public const string GetFollowAxisLock = "get_follow_axis_lock";
        public const string SetFollowAxisLock = "set_follow_axis_lock";

        public const string GetTweenResource = "get_tween_resource";
        public const string SetTweenResource = "set_tween_resource";

        public const string GetTweenSkip = "get_tween_skip";
        public const string SetTweenSkip = "set_tween_skip";

        public const string GetTweenDuration = "get_tween_duration";
        public const string SetTweenDuration = "set_tween_duration";

        public const string GetTweenTransition = "get_tween_transition";
        public const string SetTweenTransition = "set_tween_transition";

        public const string GetTweenEase = "get_tween_ease";
        public const string SetTweenEase = "set_tween_ease";

        public const string GetTweenOnLoad = "get_tween_on_load";
        public const string SetTweenOnLoad = "set_tween_on_load";

        public const string GetInactiveUpdateMode = "get_inactive_update_mode";
        public const string SetInactiveUpdateMode = "set_inactive_update_mode";

        public const string GetHostLayers = "get_host_layers";
        public const string SetHostLayers = "set_host_layers";
        public const string SetHostLayersValue = "set_host_layers_value";

        public const string GetNoiseEmitterLayer = "get_noise_emitter_layer";
        public const string SetNoiseEmitterLayer = "set_noise_emitter_layer";

        public const string EmitNoise = "emit_noise";
    }

    public static class PropertyName
    {
        public const string DeadZoneWidth = "dead_zone_width";
        public const string DeadZoneHeight = "dead_zone_height";
    }

    public static class SignalName
    {
        public const string BecameActive = "became_active";
        public const string BecameInactive = "became_inactive";
        public const string FollowTargetChanged = "follow_target_changed";
        public const string DeadZoneChanged = "dead_zone_changed";
        public const string DeadZoneReached = "dead_zone_reached";
        public const string TweenStarted = "tween_started";
        public const string IsTweening = "is_tweening";
        public const string TweenCompleted = "tween_completed";
        public const string TweenInterrupted = "tween_interrupted";
        public const string NoiseEmitted = "noise_emitted";
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera/PhantomCamera2D.cs ---
using System.Linq;
using Godot;
using Godot.Collections;
using PhantomCamera.Noise;

#nullable enable

namespace PhantomCamera;

public enum FollowMode2D
{
    None,
    Glued,
    Simple,
    Group,
    Path,
    Framed
}

public enum FollowLockAxis2D
{
    None,
    X,
    Y,
    XY
}

public static class PhantomCamera2DExtensions
{
    public static PhantomCamera2D AsPhantomCamera2D(this Node2D node2D)
    {
        return new PhantomCamera2D(node2D);
    }

    public static PhantomCameraNoiseEmitter2D AsPhantomCameraNoiseEmitter2D(this Node2D node2D)
    {
        return new PhantomCameraNoiseEmitter2D(node2D);
    }

    public static PhantomCameraNoise2D AsPhantomCameraNoise2D(this Resource resource)
    {
        return new PhantomCameraNoise2D(resource);
    }
}

public class PhantomCamera2D : PhantomCamera
{
    public Node2D Node2D => (Node2D)Node;

    public delegate void TweenInterruptedEventHandler(Node2D pCam);
    public delegate void DeadZoneReachedEventHandler(Vector2 side);
    public delegate void NoiseEmittedEventHandler(Transform2D output);

    public event TweenInterruptedEventHandler? TweenInterrupted;
    public event DeadZoneReachedEventHandler? DeadZoneReached;
    public event NoiseEmittedEventHandler? NoiseEmitted;

    private readonly Callable _callableTweenInterrupted;
    private readonly Callable _callableDeadZoneReached;
    private readonly Callable _callableNoiseEmitted;

    public Node2D FollowTarget
    {
        get => (Node2D)Node2D.Call(PhantomCamera.MethodName.GetFollowTarget);
        set => Node2D.Call(PhantomCamera.MethodName.SetFollowTarget, value);
    }

    public Node2D[] FollowTargets
    {
        get => Node2D.Call(PhantomCamera.MethodName.GetFollowTargets).AsGodotArray<Node2D>().ToArray();
        set => Node2D.Call(PhantomCamera.MethodName.SetFollowTargets, new Array<Node2D>(value));
    }

    public void AppendFollowTargets(Node2D target) => Node2D.Call(PhantomCamera.MethodName.AppendFollowTargets, target);
    public void AppendFollowTargetsArray(Node2D[] targets) => Node2D.Call(PhantomCamera.MethodName.AppendFollowTargetsArray, targets);
    public void EraseFollowTargets(Node2D target) => Node2D.Call(PhantomCamera.MethodName.EraseFollowTargets, target);

    public FollowMode2D FollowMode => (FollowMode2D)(int)Node.Call(PhantomCamera.MethodName.GetFollowMode);

    public Path2D FollowPath
    {
        get => (Path2D)Node2D.Call(PhantomCamera.MethodName.GetFollowPath);
        set => Node2D.Call(PhantomCamera.MethodName.SetFollowPath, value);
    }

    public Vector2 FollowOffset
    {
        get => (Vector2)Node2D.Call(PhantomCamera.MethodName.GetFollowOffset);
        set => Node2D.Call(PhantomCamera.MethodName.SetFollowOffset, value);
    }

    public Vector2 FollowDampingValue
    {
        get => (Vector2)Node2D.Call(PhantomCamera.MethodName.GetFollowDampingValue);
        set => Node2D.Call(PhantomCamera.MethodName.SetFollowDampingValue, value);
    }

    public FollowLockAxis2D FollowAxisLock
    {
        get => (FollowLockAxis2D)(int)Node2D.Call(PhantomCamera.MethodName.GetFollowAxisLock);
        set => Node2D.Call(PhantomCamera.MethodName.SetFollowAxisLock, (int)value);
    }

    public Vector2 Zoom
    {
        get => (Vector2)Node2D.Call(MethodName.GetZoom);
        set => Node2D.Call(MethodName.SetZoom, value);
    }

    public bool SnapToPixel
    {
        get => (bool)Node2D.Call(MethodName.GetSnapToPixel);
        set => Node2D.Call(MethodName.SetSnapToPixel, value);
    }

    public bool RotateWithTarget
    {
        get => (bool)Node2D.Call(MethodName.GetRotateWithTarget);
        set => Node2D.Call(MethodName.SetRotateWithTarget, value);
    }

    public float RotationOffset
    {
        get => (float)Node2D.Call(MethodName.GetRotationOffset);
        set => Node2D.Call(MethodName.SetRotationOffset, value);
    }

    public bool RotationDamping
    {
        get => (bool)Node2D.Call(MethodName.GetRotationDamping);
        set  => Node2D.Call(MethodName.SetRotationDamping, value);
    }

    public float RotationDampingValue
    {
        get => (float)Node2D.Call(MethodName.GetRotationDampingValue);
        set => Node2D.Call(MethodName.SetRotationDampingValue, value);
    }

    public int LimitLeft
    {
        get => (int)Node2D.Call(MethodName.GetLimitLeft);
        set => Node2D.Call(MethodName.SetLimitLeft, value);
    }

    public int LimitTop
    {
        get => (int)Node2D.Call(MethodName.GetLimitTop);
        set => Node2D.Call(MethodName.SetLimitTop, value);
    }

    public int LimitRight
    {
        get => (int)Node2D.Call(MethodName.GetLimitRight);
        set => Node2D.Call(MethodName.SetLimitRight, value);
    }

    public int LimitBottom
    {
        get => (int)Node2D.Call(MethodName.GetLimitBottom);
        set => Node2D.Call(MethodName.SetLimitBottom, value);
    }

    public Vector4I LimitMargin
    {
        get => (Vector4I)Node2D.Call(MethodName.GetLimitMargin);
        set => Node2D.Call(MethodName.SetLimitMargin, value);
    }

    public bool AutoZoom
    {
        get => (bool)Node2D.Call(MethodName.GetAutoZoom);
        set => Node2D.Call(MethodName.SetAutoZoom, value);
    }

    public float AutoZoomMin
    {
        get => (float)Node2D.Call(MethodName.GetAutoZoomMin);
        set => Node2D.Call(MethodName.SetAutoZoomMin, value);
    }

    public float AutoZoomMax
    {
        get => (float)Node2D.Call(MethodName.GetAutoZoomMax);
        set => Node2D.Call(MethodName.SetAutoZoomMax, value);
    }

    public Vector4 AutoZoomMargin
    {
        get => (Vector4)Node2D.Call(MethodName.GetAutoZoomMargin);
        set => Node2D.Call(MethodName.SetAutoZoomMargin, value);
    }

    public bool DrawLimits
    {
        get => (bool)Node2D.Get(PropertyName.DrawLimits);
        set => Node2D.Set(PropertyName.DrawLimits, value);
    }

    public PhantomCameraNoise2D Noise
    {
        get => new((Resource)Node2D.Call(MethodName.GetNoise));
        set => Node2D.Call(MethodName.SetNoise, (GodotObject)value.Resource);
    }

    public void EmitNoise(Transform2D transform) => Node2D.Call(PhantomCamera.MethodName.EmitNoise, transform);

    public NodePath LimitTarget
    {
        get => (NodePath)Node2D.Call(MethodName.GetLimitTarget);
        set => Node2D.Call(MethodName.SetLimitTarget, value);
    }

    public static PhantomCamera2D FromScript(string path) => new(GD.Load<GDScript>(path).New().AsGodotObject());
    public static PhantomCamera2D FromScript(GDScript script) => new(script.New().AsGodotObject());

    public PhantomCamera2D(GodotObject phantomCameraNode) : base(phantomCameraNode)
    {
        _callableTweenInterrupted = Callable.From<Node2D>(pCam => TweenInterrupted?.Invoke(pCam));
        _callableDeadZoneReached = Callable.From((Vector2 side) => DeadZoneReached?.Invoke(side));
        _callableNoiseEmitted = Callable.From((Transform2D output) => NoiseEmitted?.Invoke(output));

        Node2D.Connect(SignalName.TweenInterrupted, _callableTweenInterrupted);
        Node2D.Connect(SignalName.DeadZoneReached, _callableDeadZoneReached);
        Node2D.Connect(SignalName.NoiseEmitted, _callableNoiseEmitted);
    }

    ~PhantomCamera2D()
    {
        Node2D.Disconnect(SignalName.TweenInterrupted, _callableTweenInterrupted);
        Node2D.Disconnect(SignalName.DeadZoneReached, _callableDeadZoneReached);
        Node2D.Disconnect(SignalName.NoiseEmitted, _callableNoiseEmitted);
    }

    public void SetLimitTarget(TileMap tileMap)
    {
        Node2D.Call(MethodName.SetLimitTarget, tileMap.GetPath());
    }

    public void SetLimitTarget(TileMapLayer tileMapLayer)
    {
        Node2D.Call(MethodName.SetLimitTarget, tileMapLayer.GetPath());
    }

    public void SetLimitTarget(CollisionShape2D shape2D)
    {
        Node2D.Call(MethodName.SetLimitTarget, shape2D.GetPath());
    }

    public LimitTargetQueryResult? GetLimitTarget()
    {
        var result = (NodePath)Node2D.Call(MethodName.GetLimitTarget);
        return result.IsEmpty ? null : new LimitTargetQueryResult(Node2D.GetNode(result));
    }

    public void SetLimit(Side side, int value)
    {
        Node2D.Call(MethodName.SetLimit, (int)side, value);
    }

    public int GetLimit(Side side)
    {
        return (int)Node2D.Call(MethodName.GetLimit, (int)side);
    }

    public new static class MethodName
    {
        public const string GetZoom = "get_zoom";
        public const string SetZoom = "set_zoom";

        public const string GetSnapToPixel = "get_snap_to_pixel";
        public const string SetSnapToPixel = "set_snap_to_pixel";

        public const string GetRotateWithTarget = "get_rotate_with_target";
        public const string SetRotateWithTarget = "set_rotate_with_target";

        public const string GetRotationOffset = "get_rotation_offset";
        public const string SetRotationOffset = "set_rotation_offset";

        public const string GetRotationDamping = "get_rotation_damping";
        public const string SetRotationDamping = "set_rotation_damping";

        public const string GetRotationDampingValue = "get_rotation_damping_value";
        public const string SetRotationDampingValue = "set_rotation_damping_value";

        public const string GetLimit = "get_limit";
        public const string SetLimit = "set_limit";

        public const string GetLimitLeft = "get_limit_left";
        public const string SetLimitLeft = "set_limit_left";

        public const string GetLimitTop = "get_limit_top";
        public const string SetLimitTop = "set_limit_top";

        public const string GetLimitRight = "get_limit_right";
        public const string SetLimitRight = "set_limit_right";

        public const string GetLimitBottom = "get_limit_bottom";
        public const string SetLimitBottom = "set_limit_bottom";

        public const string GetLimitTarget = "get_limit_target";
        public const string SetLimitTarget = "set_limit_target";

        public const string GetLimitMargin = "get_limit_margin";
        public const string SetLimitMargin = "set_limit_margin";

        public const string GetAutoZoom = "get_auto_zoom";
        public const string SetAutoZoom = "set_auto_zoom";

        public const string GetAutoZoomMin = "get_auto_zoom_min";
        public const string SetAutoZoomMin = "set_auto_zoom_min";

        public const string GetAutoZoomMax = "get_auto_zoom_max";
        public const string SetAutoZoomMax = "set_auto_zoom_max";

        public const string GetAutoZoomMargin = "get_auto_zoom_margin";
        public const string SetAutoZoomMargin = "set_auto_zoom_margin";

        public const string GetNoise = "get_noise";
        public const string SetNoise = "set_noise";
    }

    public new static class PropertyName
    {
        public const string DrawLimits = "draw_limits";
    }
}

public class LimitTargetQueryResult(GodotObject godotObject)
{
    public bool IsTileMap => godotObject.IsClass("TileMap");

    public bool IsTileMapLayer => godotObject.IsClass("TileMapLayer");

    public bool IsCollisionShape2D => godotObject.IsClass("CollisionShape2D");

    public TileMap? AsTileMap()
    {
        return IsTileMap ? (TileMap)godotObject : null;
    }

    public TileMapLayer? AsTileMapLayer()
    {
        return IsTileMapLayer ? (TileMapLayer)godotObject : null;
    }

    public CollisionShape2D? AsCollisionShape2D()
    {
        return IsCollisionShape2D ? (CollisionShape2D)godotObject : null;
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera/PhantomCamera3D.cs ---
using System.Linq;
using Godot;
using Godot.Collections;
using PhantomCamera.Noise;

#nullable enable

namespace PhantomCamera;

public enum LookAtMode
{
    None,
    Mimic,
    Simple,
    Group
}

public enum FollowMode3D
{
    None,
    Glued,
    Simple,
    Group,
    Path,
    Framed,
    ThirdPerson
}

public enum FollowLockAxis3D
{
    None,
    X,
    Y,
    Z,
    XY,
    XZ,
    YZ,
    XYZ
}

public static class PhantomCamera3DExtensions
{
    public static PhantomCamera3D AsPhantomCamera3D(this Node3D node3D)
    {
        return new PhantomCamera3D(node3D);
    }

    public static PhantomCameraNoiseEmitter3D AsPhantomCameraNoiseEmitter3D(this Node3D node3D)
    {
        return new PhantomCameraNoiseEmitter3D(node3D);
    }

    public static PhantomCameraNoise3D AsPhantomCameraNoise3D(this Resource resource)
    {
        return new PhantomCameraNoise3D(resource);
    }

    public static Camera3DResource AsCamera3DResource(this Resource resource)
    {
        return new Camera3DResource(resource);
    }

    public static Vector3 GetThirdPersonRotation(this PhantomCamera3D pCam3D) =>
        (Vector3)pCam3D.Node3D.Call(PhantomCamera3D.MethodName.GetThirdPersonRotation);

    public static void SetThirdPersonRotation(this PhantomCamera3D pCam3D, Vector3 rotation) =>
        pCam3D.Node3D.Call(PhantomCamera3D.MethodName.SetThirdPersonRotation, rotation);

    public static Vector3 GetThirdPersonRotationDegrees(this PhantomCamera3D pCam3D) =>
        (Vector3)pCam3D.Node3D.Call(PhantomCamera3D.MethodName.GetThirdPersonRotationDegrees);

    public static void SetThirdPersonDegrees(this PhantomCamera3D pCam3D, Vector3 rotation) =>
        pCam3D.Node3D.Call(PhantomCamera3D.MethodName.SetThirdPersonRotationDegrees, rotation);

    public static Quaternion GetThirdPersonQuaternion(this PhantomCamera3D pCam3D) =>
        (Quaternion)pCam3D.Node3D.Call(PhantomCamera3D.MethodName.GetThirdPersonQuaternion);

    public static void SetThirdPersonQuaternion(this PhantomCamera3D pCam3D, Quaternion quaternion) =>
        pCam3D.Node3D.Call(PhantomCamera3D.MethodName.SetThirdPersonQuaternion, quaternion);

}

public class PhantomCamera3D : PhantomCamera
{
    public Node3D Node3D => (Node3D)Node;

    public delegate void LookAtTargetChangedEventHandler();
    public delegate void DeadZoneReachedEventHandler();
    public delegate void Camera3DResourceChangedEventHandler();
    public delegate void Camera3DResourcePropertyChangedEventHandler(StringName property, Variant value);
    public delegate void TweenInterruptedEventHandler(Node3D pCam);
    public delegate void NoiseEmittedEventHandler(Transform3D output);

    public event LookAtTargetChangedEventHandler? LookAtTargetChanged;
    public event DeadZoneReachedEventHandler? DeadZoneReached;
    public event Camera3DResourceChangedEventHandler? Camera3DResourceChanged;
    public event Camera3DResourcePropertyChangedEventHandler? Camera3DResourcePropertyChanged;
    public event TweenInterruptedEventHandler? TweenInterrupted;
    public event NoiseEmittedEventHandler? NoiseEmitted;

    private readonly Callable _callableLookAtTargetChanged;
    private readonly Callable _callableDeadZoneReached;
    private readonly Callable _callableCamera3DResourceChanged;
    private readonly Callable _callableCamera3DResourcePropertyChanged;
    private readonly Callable _callableTweenInterrupted;
    private readonly Callable _callableNoiseEmitted;

    public Node3D FollowTarget
    {
        get => (Node3D)Node3D.Call(PhantomCamera.MethodName.GetFollowTarget);
        set => Node3D.Call(PhantomCamera.MethodName.SetFollowTarget, value);
    }

    public Node3D[] FollowTargets
    {
        get => Node3D.Call(PhantomCamera.MethodName.GetFollowTargets).AsGodotArray<Node3D>().ToArray();
        set => Node3D.Call(PhantomCamera.MethodName.SetFollowTargets, new Array<Node3D>(value));
    }

    public void AppendFollowTarget(Node3D target) => Node3D.Call(PhantomCamera.MethodName.AppendFollowTargets, target);
    public void AppendFollowTargetArray(Node3D[] targets) => Node3D.Call(PhantomCamera.MethodName.AppendFollowTargetsArray, targets);
    public void EraseFollowTarget(Node3D target) => Node3D.Call(PhantomCamera.MethodName.EraseFollowTargets, target);

    public FollowMode3D FollowMode => (FollowMode3D)(int)Node.Call(PhantomCamera.MethodName.GetFollowMode);

    public Path3D FollowPath
    {
        get => (Path3D)Node3D.Call(PhantomCamera.MethodName.GetFollowPath);
        set => Node3D.Call(PhantomCamera.MethodName.SetFollowPath, value);
    }

    public Vector3 FollowOffset
    {
        get => (Vector3)Node3D.Call(PhantomCamera.MethodName.GetFollowOffset);
        set => Node3D.Call(PhantomCamera.MethodName.SetFollowOffset, value);
    }

    public Vector3 FollowDampingValue
    {
        get => (Vector3)Node3D.Call(PhantomCamera.MethodName.GetFollowDampingValue);
        set => Node3D.Call(PhantomCamera.MethodName.SetFollowDampingValue, value);
    }

    public FollowLockAxis3D FollowAxisLock
    {
        get => (FollowLockAxis3D)(int)Node3D.Call(PhantomCamera.MethodName.GetFollowAxisLock);
        set => Node3D.Call(PhantomCamera.MethodName.SetFollowAxisLock, (int)value);
    }

    public LookAtMode LookAtMode => (LookAtMode)(int)Node3D.Call(MethodName.GetLookAtMode);

    public Camera3DResource Camera3DResource
    {
        get => new((Resource)Node3D.Call(MethodName.GetCamera3DResource));
        set => Node3D.Call(MethodName.SetCamera3DResource, value.Resource);
    }

    public float SpringLength
    {
        get => (float)Node3D.Call(MethodName.GetSpringLength);
        set => Node3D.Call(MethodName.SetSpringLength, value);
    }

    public float VerticalRotationOffset
    {
        get => (float)Node3D.Call(MethodName.GetVerticalRotationOffset);
        set => Node3D.Call(MethodName.SetVerticalRotationOffset, value);
    }

    public float HorizontalRotationOffset
    {
        get => (float)Node3D.Call(MethodName.GetHorizontalRotationOffset);
        set => Node3D.Call(MethodName.SetHorizontalRotationOffset, value);
    }

    public float FollowDistance
    {
        get => (float)Node3D.Call(MethodName.GetFollowDistance);
        set => Node3D.Call(MethodName.SetFollowDistance, value);
    }

    public bool AutoFollowDistance
    {
        get => (bool)Node3D.Call(MethodName.GetAutoFollowDistance);
        set => Node3D.Call(MethodName.SetAutoFollowDistance, value);
    }

    public float AutoFollowDistanceMin
    {
        get => (float)Node3D.Call(MethodName.GetAutoFollowDistanceMin);
        set => Node3D.Call(MethodName.SetAutoFollowDistanceMin, value);
    }

    public float AutoFollowDistanceMax
    {
        get => (float)Node3D.Call(MethodName.GetAutoFollowDistanceMax);
        set => Node3D.Call(MethodName.SetAutoFollowDistanceMax, value);
    }

    public float AutoFollowDistanceDivisor
    {
        get => (float)Node3D.Call(MethodName.GetAutoFollowDistanceDivisor);
        set => Node3D.Call(MethodName.SetAutoFollowDistanceDivisor, value);
    }

    public Node3D LookAtTarget
    {
        get => (Node3D)Node3D.Call(MethodName.GetLookAtTarget);
        set => Node3D.Call(MethodName.SetLookAtTarget, value);
    }

    public Node3D[] LookAtTargets
    {
        get => Node3D.Call(MethodName.GetLookAtTargets).AsGodotArray<Node3D>().ToArray();
        set => Node3D.Call(MethodName.SetLookAtTargets, new Array<Node3D>(value));
    }

    public bool IsLooking => (bool)Node3D.Call(MethodName.IsLooking);

    public int CollisionMask
    {
        get => (int)Node3D.Call(MethodName.GetCollisionMask);
        set => Node3D.Call(MethodName.SetCollisionMask, value);
    }

    public void SetCollisionMaskValue(int maskLayer, bool enable) =>
        Node3D.Call(MethodName.SetCollisionMaskValue, maskLayer, enable);

    public Shape3D Shape
    {
        get => (Shape3D)Node3D.Call(MethodName.GetShape);
        set => Node3D.Call(MethodName.SetShape, value);
    }

    public float Margin
    {
        get => (float)Node3D.Call(MethodName.GetMargin);
        set => Node3D.Call(MethodName.SetMargin, value);
    }

    public Vector3 LookAtOffset
    {
        get => (Vector3)Node3D.Call(MethodName.GetLookAtOffset);
        set => Node3D.Call(MethodName.SetLookAtOffset, value);
    }

    public bool LookAtDamping
    {
        get => (bool)Node3D.Call(MethodName.GetLookAtDamping);
        set => Node3D.Call(MethodName.SetLookAtDamping, value);
    }

    public float LookAtDampingValue
    {
        get => (float)Node3D.Call(MethodName.GetLookAtDampingValue);
        set => Node3D.Call(MethodName.SetLookAtDampingValue, value);
    }

    public Node3D Up
    {
        get => (Node3D)Node3D.Call(MethodName.GetUp);
        set => Node3D.Call(MethodName.SetUp, value);
    }

    public Vector3 UpTarget
    {
        get => (Vector3)Node3D.Call(MethodName.GetUpTarget);
        set => Node3D.Call(MethodName.SetUpTarget, value);
    }

    public int CullMask
    {
        get => (int)Node3D.Call(MethodName.GetCullMask);
        set => Node3D.Call(MethodName.SetCullMask, value);
    }

    public float HOffset
    {
        get => (float)Node3D.Call(MethodName.GetHOffset);
        set => Node3D.Call(MethodName.SetHOffset, value);
    }

    public float VOffset
    {
        get => (float)Node3D.Call(MethodName.GetVOffset);
        set => Node3D.Call(MethodName.SetVOffset, value);
    }

    public ProjectionType Projection
    {
        get => (ProjectionType)(int)Node3D.Call(MethodName.GetProjection);
        set => Node3D.Call(MethodName.SetProjection, (int)value);
    }

    public float Fov
    {
        get => (float)Node3D.Call(MethodName.GetFov);
        set => Node3D.Call(MethodName.SetFov, value);
    }

    public float Size
    {
        get => (float)Node3D.Call(MethodName.GetSize);
        set => Node3D.Call(MethodName.SetSize, value);
    }

    public Vector2 FrustumOffset
    {
        get => (Vector2)Node3D.Call(MethodName.GetFrustumOffset);
        set => Node3D.Call(MethodName.SetFrustumOffset, value);
    }

    public float Far
    {
        get => (float)Node3D.Call(MethodName.GetFar);
        set => Node3D.Call(MethodName.SetFar, value);
    }

    public float Near
    {
        get => (float)Node3D.Call(MethodName.GetNear);
        set => Node3D.Call(MethodName.SetNear, value);
    }

    public Environment Environment
    {
        get => (Environment)Node3D.Call(MethodName.GetEnvironment);
        set => Node3D.Call(MethodName.SetEnvironment, value);
    }

    public CameraAttributes Attributes
    {
        get => (CameraAttributes)Node3D.Call(MethodName.GetAttributes);
        set => Node3D.Call(MethodName.SetAttributes, value);
    }

    public PhantomCameraNoise3D Noise
    {
        get => new((Resource)Node3D.Call(MethodName.GetNoise));
        set => Node3D.Call(MethodName.SetNoise, (GodotObject)value.Resource);
    }

    public void EmitNoise(Transform3D transform) => Node3D.Call(PhantomCamera.MethodName.EmitNoise, transform);

    public static PhantomCamera3D FromScript(string path) => new(GD.Load<GDScript>(path).New().AsGodotObject());
    public static PhantomCamera3D FromScript(GDScript script) => new(script.New().AsGodotObject());

    public PhantomCamera3D(GodotObject phantomCamera3DNode) : base(phantomCamera3DNode)
    {
        _callableLookAtTargetChanged = Callable.From(() => LookAtTargetChanged?.Invoke());
        _callableDeadZoneReached = Callable.From(() => DeadZoneReached?.Invoke());
        _callableCamera3DResourceChanged = Callable.From(() => Camera3DResourceChanged?.Invoke());
        _callableCamera3DResourcePropertyChanged = Callable.From((StringName property, Variant value) =>
        Camera3DResourcePropertyChanged?.Invoke(property, value));
        _callableTweenInterrupted = Callable.From<Node3D>(pCam => TweenInterrupted?.Invoke(pCam));
        _callableNoiseEmitted = Callable.From((Transform3D output) => NoiseEmitted?.Invoke(output));

        Node3D.Connect(SignalName.LookAtTargetChanged, _callableLookAtTargetChanged);
        Node3D.Connect(PhantomCamera.SignalName.DeadZoneReached, _callableDeadZoneReached);
        Node3D.Connect(SignalName.Camera3DResourceChanged, _callableCamera3DResourceChanged);
        Node3D.Connect(SignalName.Camera3DResourcePropertyChanged, _callableCamera3DResourcePropertyChanged);
        Node3D.Connect(PhantomCamera.SignalName.TweenInterrupted, _callableTweenInterrupted);
        Node3D.Connect(PhantomCamera.SignalName.NoiseEmitted, _callableNoiseEmitted);
    }

    ~PhantomCamera3D()
    {
        Node3D.Disconnect(SignalName.LookAtTargetChanged, _callableLookAtTargetChanged);
        Node3D.Disconnect(PhantomCamera.SignalName.DeadZoneReached, _callableDeadZoneReached);
        Node3D.Disconnect(SignalName.Camera3DResourceChanged, _callableCamera3DResourceChanged);
        Node3D.Disconnect(SignalName.Camera3DResourcePropertyChanged, _callableCamera3DResourcePropertyChanged);
        Node3D.Disconnect(PhantomCamera.SignalName.TweenInterrupted, _callableTweenInterrupted);
        Node3D.Disconnect(PhantomCamera.SignalName.NoiseEmitted, _callableNoiseEmitted);
    }

    public new static class MethodName
    {
        public const string GetLookAtMode = "get_look_at_mode";

        public const string GetCamera3DResource = "get_camera_3d_resource";
        public const string SetCamera3DResource = "set_camera_3d_resource";

        public const string GetThirdPersonRotation = "get_third_person_rotation";
        public const string SetThirdPersonRotation = "set_third_person_rotation";

        public const string GetThirdPersonRotationDegrees = "get_third_person_rotation_degrees";
        public const string SetThirdPersonRotationDegrees = "set_third_person_rotation_degrees";

        public const string GetThirdPersonQuaternion = "get_third_person_quaternion";
        public const string SetThirdPersonQuaternion = "set_third_person_quaternion";

        public const string GetVerticalRotationOffset = "get_vertical_rotation_offset";
        public const string SetVerticalRotationOffset = "set_vertical_rotation_offset";

        public const string GetHorizontalRotationOffset = "get_horizontal_rotation_offset";
        public const string SetHorizontalRotationOffset = "set_horizontal_rotation_offset";

        public const string GetSpringLength = "get_spring_length";
        public const string SetSpringLength = "set_spring_length";

        public const string GetFollowDistance = "get_follow_distance";
        public const string SetFollowDistance = "set_follow_distance";

        public const string GetAutoFollowDistance = "get_auto_follow_distance";
        public const string SetAutoFollowDistance = "set_auto_follow_distance";

        public const string GetAutoFollowDistanceMin = "get_auto_follow_distance_min";
        public const string SetAutoFollowDistanceMin = "set_auto_follow_distance_min";

        public const string GetAutoFollowDistanceMax = "get_auto_follow_distance_max";
        public const string SetAutoFollowDistanceMax = "set_auto_follow_distance_max";

        public const string GetAutoFollowDistanceDivisor = "get_auto_follow_distance_divisor";
        public const string SetAutoFollowDistanceDivisor = "set_auto_follow_distance_divisor";

        public const string GetLookAtTarget = "get_look_at_target";
        public const string SetLookAtTarget = "set_look_at_target";

        public const string GetLookAtTargets = "get_look_at_targets";
        public const string SetLookAtTargets = "set_look_at_targets";

        public const string IsLooking = "is_looking";

        public const string GetUp = "get_up";
        public const string SetUp = "set_up";

        public const string GetUpTarget = "get_up_target";
        public const string SetUpTarget = "set_up_target";

        public const string GetCollisionMask = "get_collision_mask";
        public const string SetCollisionMask = "set_collision_mask";

        public const string SetCollisionMaskValue = "set_collision_mask_value";

        public const string GetShape = "get_shape";
        public const string SetShape = "set_shape";

        public const string GetMargin = "get_margin";
        public const string SetMargin = "set_margin";

        public const string GetLookAtOffset = "get_look_at_offset";
        public const string SetLookAtOffset = "set_look_at_offset";

        public const string GetLookAtDamping = "get_look_at_damping";
        public const string SetLookAtDamping = "set_look_at_damping";

        public const string GetLookAtDampingValue = "get_look_at_damping_value";
        public const string SetLookAtDampingValue = "set_look_at_damping_value";

        public const string GetCullMask = "get_cull_mask";
        public const string SetCullMask = "set_cull_mask";

        public const string GetHOffset = "get_h_offset";
        public const string SetHOffset = "set_h_offset";

        public const string GetVOffset = "get_v_offset";
        public const string SetVOffset = "set_v_offset";

        public const string GetProjection = "get_projection";
        public const string SetProjection = "set_projection";

        public const string GetFov = "get_fov";
        public const string SetFov = "set_fov";

        public const string GetSize = "get_size";
        public const string SetSize = "set_size";

        public const string GetFrustumOffset = "get_frustum_offset";
        public const string SetFrustumOffset = "set_frustum_offset";

        public const string GetFar = "get_far";
        public const string SetFar = "set_far";

        public const string GetNear = "get_near";
        public const string SetNear = "set_near";

        public const string GetEnvironment = "get_environment";
        public const string SetEnvironment = "set_environment";

        public const string GetAttributes = "get_attributes";
        public const string SetAttributes = "set_attributes";

        public const string GetNoise = "get_noise";
        public const string SetNoise = "set_noise";
    }

    public new static class SignalName
    {
        public const string LookAtTargetChanged = "look_at_target_changed";
        public const string Camera3DResourceChanged = "camera_3d_resource_changed";
        public const string Camera3DResourcePropertyChanged = "camera_3d_resource_property_changed";
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera/PhantomCameraNoiseEmitter2D.cs ---
using Godot;

namespace PhantomCamera.Noise;

public class PhantomCameraNoiseEmitter2D(GodotObject node)
{
    public Node2D Node2D = (Node2D)node;

    public PhantomCameraNoise2D Noise
    {
        get => new((Resource)Node2D.Call(MethodName.GetNoise));
        set => Node2D.Call(MethodName.SetNoise, (GodotObject)value.Resource);
    }

    public bool Continuous
    {
        get => (bool)Node2D.Call(MethodName.GetContinuous);
        set => Node2D.Call(MethodName.SetContinuous, value);
    }

    public float GrowthTime
    {
        get => (float)Node2D.Call(MethodName.GetGrowthTime);
        set => Node2D.Call(MethodName.SetGrowthTime, value);
    }

    public float Duration
    {
        get => (float)Node2D.Call(MethodName.GetDuration);
        set => Node2D.Call(MethodName.SetDuration, value);
    }

    public float DecayTime
    {
        get => (float)Node2D.Call(MethodName.GetDecayTime);
        set => Node2D.Call(MethodName.SetDecayTime, value);
    }

    public int NoiseEmitterLayer
    {
        get => (int)Node2D.Call(MethodName.GetNoiseEmitterLayer);
        set => Node2D.Call(MethodName.SetNoiseEmitterLayer, value);
    }

    public void SetNoiseEmitterLayerValue(int layer, bool value) =>
        Node2D.Call(MethodName.SetNoiseEmitterLayerValue, layer, value);

    public void Emit() => Node2D.Call(MethodName.Emit);

    public bool IsEmitting() => (bool)Node2D.Call(MethodName.IsEmitting);

    public void Stop() => Node2D.Call(MethodName.Stop);

    public void Toggle() => Node2D.Call(MethodName.Toggle);

    public static class MethodName
    {
        public const string GetNoise = "get_noise";
        public const string SetNoise = "set_noise";

        public const string GetContinuous = "get_continuous";
        public const string SetContinuous = "set_continuous";

        public const string GetGrowthTime = "get_growth_time";
        public const string SetGrowthTime = "set_growth_time";

        public const string GetDuration = "get_duration";
        public const string SetDuration = "set_duration";

        public const string GetDecayTime = "get_decay_time";
        public const string SetDecayTime = "set_decay_time";

        public const string GetNoiseEmitterLayer = "get_noise_emitter_layer";
        public const string SetNoiseEmitterLayer = "set_noise_emitter_layer";

        public const string SetNoiseEmitterLayerValue = "set_noise_emitter_layer_value";

        public const string Emit = "emit";
        public const string IsEmitting = "is_emitting";
        public const string Stop = "stop";
        public const string Toggle = "toggle";
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera/PhantomCameraNoiseEmitter3D.cs ---
using Godot;

namespace PhantomCamera.Noise;

public class PhantomCameraNoiseEmitter3D(GodotObject node)
{
    public Node3D Node3D = (Node3D)node;

    public PhantomCameraNoise3D Noise
    {
        get => new((Resource)Node3D.Call(MethodName.GetNoise));
        set => Node3D.Call(MethodName.SetNoise, (GodotObject)value.Resource);
    }

    public bool Continuous
    {
        get => (bool)Node3D.Call(MethodName.GetContinuous);
        set => Node3D.Call(MethodName.SetContinuous, value);
    }

    public float GrowthTime
    {
        get => (float)Node3D.Call(MethodName.GetGrowthTime);
        set => Node3D.Call(MethodName.SetGrowthTime, value);
    }

    public float Duration
    {
        get => (float)Node3D.Call(MethodName.GetDuration);
        set => Node3D.Call(MethodName.SetDuration, value);
    }

    public float DecayTime
    {
        get => (float)Node3D.Call(MethodName.GetDecayTime);
        set => Node3D.Call(MethodName.SetDecayTime, value);
    }

    public int NoiseEmitterLayer
    {
        get => (int)Node3D.Call(MethodName.GetNoiseEmitterLayer);
        set => Node3D.Call(MethodName.SetNoiseEmitterLayer, value);
    }

    public void SetNoiseEmitterLayerValue(int layer, bool value) =>
        Node3D.Call(MethodName.SetNoiseEmitterLayerValue, layer, value);

    public void Emit() => Node3D.Call(MethodName.Emit);

    public bool IsEmitting() => (bool)Node3D.Call(MethodName.IsEmitting);

    public void Stop() => Node3D.Call(MethodName.Stop);

    public void Toggle() => Node3D.Call(MethodName.Toggle);

    public static class MethodName
    {
        public const string GetNoise = "get_noise";
        public const string SetNoise = "set_noise";

        public const string GetContinuous = "get_continuous";
        public const string SetContinuous = "set_continuous";

        public const string GetGrowthTime = "get_growth_time";
        public const string SetGrowthTime = "set_growth_time";

        public const string GetDuration = "get_duration";
        public const string SetDuration = "set_duration";

        public const string GetDecayTime = "get_decay_time";
        public const string SetDecayTime = "set_decay_time";

        public const string GetNoiseEmitterLayer = "get_noise_emitter_layer";
        public const string SetNoiseEmitterLayer = "set_noise_emitter_layer";

        public const string SetNoiseEmitterLayerValue = "set_noise_emitter_layer_value";

        public const string Emit = "emit";
        public const string IsEmitting = "is_emitting";
        public const string Stop = "stop";
        public const string Toggle = "toggle";
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_2d.gd ---
@tool
@icon("res://addons/phantom_camera/icons/phantom_camera_2d.svg")
class_name PhantomCamera2D
extends Node2D

## Controls a scene's [Camera2D] and applies logic to it.
##
## The scene's [param Camera2D] will follow the position of the
## [param PhantomCamera2D] with the highest priority.
## Each instance can have different positional and rotational logic applied
## to them.

#region Constants

const _constants := preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd")

#endregion

#region Signals

## Emitted when the [param PhantomCamera2D] becomes active.
signal became_active

## Emitted when the [param PhantomCamera2D] becomes inactive.
signal became_inactive

## Emitted when the follow_mode changes.
## Note: This is for internal use only
signal follow_mode_changed

## Emitted when [member follow_target] changes.
signal follow_target_changed

## Emitted when dead zones changes.[br]
## [b]Note:[/b] Only applicable in [param Framed] [enum FollowMode].
signal dead_zone_changed

## Emitted when a target touches the edge of the dead zone in [param Framed] [enum FollowMode].
signal dead_zone_reached(side: Vector2)

## Emitted when the [param Camera2D] starts to tween to another [param PhantomCamera2D].
signal tween_started

## Emitted when the [param Camera2D] is to tweening towards another [param PhantomCamera2D].
signal is_tweening

## Emitted when the tween is interrupted due to another [param PhantomCamera2D]
## becoming active. The argument is the [param PhantomCamera2D] that interrupted
## the tween.
signal tween_interrupted(pcam_2d: PhantomCamera2D)

## Emitted when the [param Camera2D] completes its tween to the
## [param PhantomCamera2D].
signal tween_completed

## Emitted when Noise should be applied to the Camera2D.
signal noise_emitted(noise_output: Transform2D)

signal physics_target_changed

#endregion

#region Enums

## Determines the positional logic for a given [param PhantomCamera2D]
## [br][br]
## The different modes have different functionalities and purposes, so choosing
## the correct one depends on what each [param PhantomCamera2D] is meant to do.
enum FollowMode {
	NONE 			= 0, ## Default - No follow logic is applied.
	GLUED 			= 1, ## Sticks to its target.
	SIMPLE 			= 2, ## Follows its target with an optional offset.
	GROUP 			= 3, ## Follows multiple targets with option to dynamically reframe itself.
	PATH 			= 4, ## Follows a target while being positionally confined to a [Path2D] node.
	FRAMED 			= 5, ## Applies a dead zone on the frame and only follows its target when it tries to leave it.
}

## Determines how often an inactive [param PhantomCamera2D] should update
## its positional and rotational values. This is meant to reduce the amount
## of calculations inactive [param PhantomCamera2D] are doing when idling to
## improve performance.
enum InactiveUpdateMode {
	ALWAYS, ## Always updates the [param PhantomCamera2D], even when it's inactive.
	NEVER, ## Never updates the [param PhantomCamera2D] when it's inactive. Reduces the amount of computational resources when inactive.
#	EXPONENTIALLY,
}

enum FollowLockAxis {
	NONE    = 0,
	X 		= 1,
	Y 		= 2,
	XY		= 3,
}

#endregion

#region Exported Properties

## To quickly preview a [param PhantomCamera2D] without adjusting its
## [member priority], this property allows the selected PCam to ignore the
## Priority system altogether and forcefully become the active one. It's
## partly designed to work within the Viewfinder, and will be disabled when
## running a build export of the game.
@export var priority_override: bool = false:
	set(value):
		priority_override = value
		if Engine.is_editor_hint():
			if value:
				if not Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME): return
				Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME).pcam_priority_override.emit(self, true)
			else:
				if not Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME): return
				Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME).pcam_priority_override.emit(self, false)
	get:
		return priority_override


## It defines which [param PhantomCamera2D] a scene's [param Camera2D] should
## be corresponding with and be attached to. This is decided by the PCam with
## the highest [param Priority].
## [br][br]
## Changing [param Priority] will send an event to the scene's
## [PhantomCameraHost], which will then determine whether if the
## [param Priority] value is greater than or equal to the currently
## highest [param PhantomCamera2D]'s in the scene. The [param PhantomCamera2D]
## with the highest value will then reattach the [param Camera2D] accordingly.
@export var priority: int = 0:
	set = set_priority,
	get = get_priority


## Determines the positional logic for a given [param PhantomCamera2D].
## The different modes have different functionalities and purposes, so
## choosing the correct one depends on what each [param PhantomCamera2D]
## is meant to do.
@export var follow_mode: FollowMode = FollowMode.NONE:
	set(value):
		follow_mode = value

		if follow_mode == FollowMode.NONE:
			_should_follow = false
			top_level = false
			_is_parents_physics()
			notify_property_list_changed()
			return

		match follow_mode:
			FollowMode.PATH:
				if is_instance_valid(follow_path):
					_should_follow_checker()
				else:
					_should_follow = false
			FollowMode.GROUP:
				_follow_targets_size_check()
			_:
				_should_follow_checker()

		if follow_mode == FollowMode.FRAMED:
			if _follow_framed_initial_set and follow_target:
				_follow_framed_initial_set = false
				dead_zone_changed.connect(_on_dead_zone_changed)
		else:
			if dead_zone_changed.is_connected(_on_dead_zone_changed):
				dead_zone_changed.disconnect(_on_dead_zone_changed)

		top_level = true
		follow_mode_changed.emit()
		notify_property_list_changed()
	get:
		return follow_mode

## Determines which target should be followed.
## The [param Camera2D] will follow the position of the Follow Target
## based on the [member follow_mode] type and its parameters.
@export var follow_target: Node2D = null:
	set = set_follow_target,
	get = get_follow_target

### Defines the targets that the [param PhantomCamera2D] should be following.
@export var follow_targets: Array[Node2D] = []:
	set = set_follow_targets,
	get = get_follow_targets

## Determines the [Path2D] the [param PhantomCamera2D]
## should be bound to.
## The [param PhantomCamera2D] will follow the position of the
## [member follow_target] while sticking to the closest point on this path.
@export var follow_path: Path2D = null:
	set = set_follow_path,
	get = get_follow_path


## Applies a zoom level to the [param PhantomCamera2D], which effectively
## overrides the [param zoom] property of the [param Camera2D] node.
@export_custom(PROPERTY_HINT_LINK, "") var zoom: Vector2 = Vector2.ONE:
	set = set_zoom,
	get = get_zoom


## If enabled, will snap the [param Camera2D] to whole pixels as it moves.
## [br][br]
## This should be particularly useful in pixel art projects,
## where assets should always be aligned to the monitor's pixels to avoid
## unintended stretching.
@export var snap_to_pixel: bool = false:
	set = set_snap_to_pixel,
	get = get_snap_to_pixel


## Enables a preview of what the [PhantomCamera2D] will see in the
## scene. It works identically to how a [param Camera2D] shows which area
## will be visible during runtime. Likewise, this too will be affected by the
## [member zoom] property and the [param viewport_width] and
## [param Viewport Height] defined in the [param Project Settings].
@export var frame_preview: bool = true:
	set(value):
		frame_preview = value
		queue_redraw()
	get:
		return frame_preview


## Defines how the [param PhantomCamera2D] transition between one another.
## Changing the tween values for a given [param PhantomCamera2D]
## determines how transitioning to that instance will look like.
## This is a resource type that can be either used for one
## [param PhantomCamera] or reused across multiple - both 2D and 3D.
## By default, all [param PhantomCameras] will use a [param linear]
## transition, [param easeInOut] ease with a [param 1s] duration.
@export var tween_resource: PhantomCameraTween = PhantomCameraTween.new():
	set = set_tween_resource,
	get = get_tween_resource

## If enabled, the moment a [param PhantomCamera2D] is instantiated into
## a scene, and has the highest priority, it will perform its tween transition.
## This is most obvious if a [param PhantomCamera2D] has a long duration and
## is attached to a playable character that can be moved the moment a scene
## is loaded. Disabling the [param tween_on_load] property will
## disable this behaviour and skip the tweening entirely when instantiated.
@export var tween_on_load: bool = true:
	set = set_tween_on_load,
	get = get_tween_on_load


## Determines how often an inactive [param PhantomCamera2D] should update
## its positional and rotational values. This is meant to reduce the amount
## of calculations inactive [param PhantomCamera2Ds] are doing when idling
## to improve performance.
@export var inactive_update_mode: InactiveUpdateMode = InactiveUpdateMode.ALWAYS


## Determines which layers this [param PhantomCamera2D] should be able to communicate with [PhantomCameraHost] nodes.[br]
## A corresponding layer needs to be set on the [PhantomCameraHost] node.
@export_flags_2d_render var host_layers: int = 1:
	set = set_host_layers,
	get = get_host_layers


@export_group("Follow Parameters")
## Offsets the [member follow_target] position.
@export var follow_offset: Vector2 = Vector2.ZERO:
	set = set_follow_offset,
	get = get_follow_offset

## Applies a damping effect on the [param Camera2D]'s movement.
## Leading to heavier / slower camera movement as the targeted node moves around.
## This is useful to avoid sharp and rapid camera movement.
@export var follow_damping: bool = false:
	set = set_follow_damping,
	get = get_follow_damping

## Defines the damping amount. The ideal range should be somewhere between 0-1.[br][br]
## The damping amount can be specified in the individual axis.[br][br]
## [b]Lower value[/b] = faster / sharper camera movement.[br]
## [b]Higher value[/b] = slower / heavier camera movement.
@export_custom(PROPERTY_HINT_LINK, "")
var follow_damping_value: Vector2 = Vector2(0.1, 0.1):
	set = set_follow_damping_value,
	get = get_follow_damping_value

## Prevents the [param PhantomCamera2D] from moving in a designated axis.
## This can be enabled or disabled at runtime or from the editor directly.
@export var follow_axis_lock: FollowLockAxis = FollowLockAxis.NONE:
	set = set_lock_axis,
	get = get_lock_axis
var _follow_axis_is_locked: bool = false
var _follow_axis_lock_value: Vector2 = Vector2.ZERO

## Makes the [param PhantomCamera2D] copy the rotation of its [member follow_target][br]
## This behavior is only available when [member follow_mode] is set and only has one [member follow_target].[br][br]
## [b]Important:[/b] Be sure to disable [member Camera2D.ignore_rotation] on the [Camera2D] node to enable this feature.
@export var rotate_with_target: bool = false:
	set = set_rotate_with_target,
	get = get_rotate_with_target
var _should_rotate_with_target: bool = false

## Offsets the rotation when [member rotate_with_target] is enabled.
@export_range(-360, 360, 0.001, "radians_as_degrees") var rotation_offset: float = 0:
	set = set_rotation_offset,
	get = get_rotation_offset

## Enables rotational damping when [member rotate_with_target] is enabled.
@export var rotation_damping: bool = false:
	set = set_rotation_damping,
	get = get_rotation_damping

## Defines the damping amount for the [member rotate_with_target].
@export_range(0, 1) var rotation_damping_value: float = 0.1:
	set = set_rotation_damping_value,
	get = get_rotation_damping_value


@export_subgroup("Follow Group")
## Enables the [param PhantomCamera2D] to dynamically zoom in and out based on
## the targets' distances between each other.
## Once enabled, the [param Camera2D] will stay as zoomed in as possible,
## limited by the [member auto_zoom_max] and start zooming out as the targets
## move further apart, limited by the [member auto_zoom_min].
## Note: Enabling this property hides and disables the [member zoom] property
## as this effectively overrides that value.
@export var auto_zoom: bool = false:
	set = set_auto_zoom,
	get = get_auto_zoom

## Sets the param minimum zoom amount, in other words how far away the
## [param Camera2D] can be from scene.[br][br]
## This only works when [member auto_zoom] is enabled.
@export var auto_zoom_min: float = 1:
	set = set_auto_zoom_min,
	get = get_auto_zoom_min

## Sets the maximum zoom amount, in other words how close the [param Camera2D]
## can move towards the scene.[br][br]
## This only works when [member auto_zoom] is enabled.
@export var auto_zoom_max: float = 5:
	set = set_auto_zoom_max,
	get = get_auto_zoom_max

## Determines how close to the edges the targets are allowed to be.
## This is useful to avoid targets being cut off at the edges of the screen.
## [br][br]
## The Vector4 parameter order goes: [param Left] - [param Top] - [param Right]
## - [param Bottom].
@export var auto_zoom_margin: Vector4 = Vector4.ZERO:
	set = set_auto_zoom_margin,
	get = get_auto_zoom_margin


@export_subgroup("Dead Zones")
## Defines the horizontal dead zone area. While the target is within it, the
## [param PhantomCamera2D] will not move in the horizontal axis.
## If the targeted node leaves the horizontal bounds, the
## [param PhantomCamera2D] will follow the target horizontally to keep
## it within bounds.
@export_range(0, 1) var dead_zone_width: float = 0:
	set(value):
		dead_zone_width = value
		dead_zone_changed.emit()
	get:
		return dead_zone_width

## Defines the vertical dead zone area. While the target is within it, the
## [param PhantomCamera2D] will not move in the vertical axis.
## If the targeted node leaves the vertical bounds, the
## [param PhantomCamera2D] will follow the target horizontally to keep
## it within bounds.
@export_range(0, 1) var dead_zone_height: float = 0:
	set(value):
		dead_zone_height = value
		dead_zone_changed.emit()
	get:
		return dead_zone_height

## Enables the [param dead zones] to be visible when running the game from the editor.
## [br]
## [param dead zones] will never be visible in build exports.
@export var show_viewfinder_in_play: bool = false


@export_group("Limit")

## Shows the [param Camera2D]'s built-in limit border.[br]
## The [param PhantomCamera2D] and [param Camera2D] can move around anywhere within it.
@export var draw_limits: bool = false:
	set(value):
		_draw_limits = value
		if Engine.is_editor_hint():
			_draw_camera_2d_limit()
	get:
		return _draw_limits

## Defines the left side of the [param Camera2D] limit.
## The camera will not be able to move past this point.
@export var limit_left: int = -10000000:
	set = set_limit_left,
	get = get_limit_left
## Defines the top side of the [param Camera2D] limit.
## The camera will not be able to move past this point.
@export var limit_top: int = -10000000:
	set = set_limit_top,
	get = get_limit_top
## Defines the right side of the [param Camera2D] limit.
## The camera will not be able to move past this point.
@export var limit_right: int = 10000000:
	set = set_limit_right,
	get = get_limit_right
## Defines the bottom side of the [param Camera2D] limit.
## The camera will not be able to move past this point.
@export var limit_bottom: int = 10000000:
	set = set_limit_bottom,
	get = get_limit_bottom

## Allows for setting either a [TileMap], [TileMapLayer] or [CollisionShape2D] node to
## automatically apply a limit size instead of manually adjusting the Left,
## Top, Right and Left properties.[br][br]
## [b]TileMap / TileMapLayer[/b][br]
## The Limit will update after the [TileSet] of the [TileMap] / [TileMapLayer] has changed.[br]
## [b]Note:[/b] The limit size will only update after closing the TileMap editor
## bottom panel.
## [br][br]
## [b]CollisionShape2D[/b][br]
## The limit will update in realtime as the Shape2D changes its size.
## Note: For performance reasons, resizing the [Shape2D] during runtime will not change the Limits sides.
@export_node_path("TileMap", "Node2D", "CollisionShape2D") var limit_target: NodePath = NodePath(""):
	set = set_limit_target,
	get = get_limit_target

## Applies an offset to the [TileMap]/[TileMapLayer] Limit or [Shape2D] Limit.
## The values goes from [param Left], [param Top], [param Right]
## and [param Bottom].
@export var limit_margin: Vector4i = Vector4.ZERO:
	set = set_limit_margin,
	get = get_limit_margin
#@export var limit_smoothed: bool = false: # TODO - Needs proper support
	#set = set_limit_smoothing,
	#get = get_limit_smoothing

@export_group("Noise")
## Applies a noise, or shake, to a [Camera2D].[br]
## Once set, the noise will run continuously after the tween to the [PhantomCamera2D] is complete.
@export var noise: PhantomCameraNoise2D = null:
	set = set_noise,
	get = get_noise

## If true, will trigger the noise while in the editor.[br]
## Useful in cases where you want to temporarily disable the noise in the editor without removing
## the resource.[br][br]
## [b]Note:[/b] This property has no effect on runtime behaviour.
@export var _preview_noise: bool = true:
	set(value):
		_preview_noise = value
		if not value:
			_transform_noise = Transform2D()

## Enable a corresponding layer for a [member PhantomCameraNoiseEmitter2D.noise_emitter_layer]
## to make this [PhantomCamera2D] be affect by it.
@export_flags_2d_render var noise_emitter_layer: int = 0:
	set = set_noise_emitter_layer,
	get = get_noise_emitter_layer

#region Private Variables

var _is_active: bool = false

var _should_follow: bool = false
var _follow_framed_offset: Vector2 = Vector2.ZERO
var _follow_target_physics_based: bool = false
var _physics_interpolation_enabled: bool = false # NOTE - Enable for Godot 4.3 and when PhysicsInterpolationMode bug is resolved

var _has_multiple_follow_targets: bool = false
var _follow_targets_single_target_index: int = 0
var _follow_targets: Array[Node2D] = []

var _follow_velocity_ref: Vector2 = Vector2.ZERO # Stores and applies the velocity of the follow movement
var _rotation_velocity_ref: float = 0 # Stores and applies the velocity of the rotation movement

var _has_follow_path: bool = false

var _tween_skip: bool = false

## Defines the position of the [member follow_target] within the viewport.[br]
## This is only used for when [member follow_mode] is set to [param Framed].
var _follow_framed_initial_set: bool = false

static var _draw_limits: bool = false

var _limit_sides: Vector4i = _limit_sides_default
var _limit_sides_default: Vector4i = Vector4i(-10000000, -10000000, 10000000, 10000000)

var _limit_node: Node2D = null
var _tile_size_perspective_scaler: Vector2 = Vector2.ONE

var _limit_inactive_pcam: bool = false

var _follow_target_position: Vector2 = Vector2.ZERO

var _transform_output: Transform2D = Transform2D()
var _transform_noise: Transform2D = Transform2D()

var _has_noise_resource: bool = false

# NOTE - Temp solution until Godot has better plugin autoload recognition out-of-the-box.
var _phantom_camera_manager: Node = null

#endregion

#region Public Variables

var tween_duration: float:
	set = set_tween_duration,
	get = get_tween_duration
var tween_transition: PhantomCameraTween.TransitionType:
	set = set_tween_transition,
	get = get_tween_transition
var tween_ease: PhantomCameraTween.EaseType:
	set = set_tween_ease,
	get = get_tween_ease

var viewport_position: Vector2

#endregion

#region Private Functions

func _validate_property(property: Dictionary) -> void:
	################
	## Follow Target
	################
	if property.name == "follow_target":
		if follow_mode == FollowMode.NONE or \
		follow_mode == FollowMode.GROUP:
			property.usage = PROPERTY_USAGE_NO_EDITOR

	elif property.name == "follow_path" and \
	follow_mode != FollowMode.PATH:
		property.usage = PROPERTY_USAGE_NO_EDITOR


	####################
	## Follow Parameters
	####################
	if follow_mode == FollowMode.NONE:
		match property.name:
			"follow_offset", \
			"follow_damping", \
			"follow_damping_value", \
			"follow_axis_lock", \
			"rotate_with_target":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "follow_offset":
		if follow_mode == FollowMode.PATH or \
		follow_mode == FollowMode.GLUED:
			property.usage = PROPERTY_USAGE_NO_EDITOR


	###############
	## Follow Group
	###############
	if follow_mode != FollowMode.GROUP:
		match property.name:
			"follow_targets", \
			"auto_zoom":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	if not auto_zoom or follow_mode != FollowMode.GROUP:
		match property.name:
			"auto_zoom_min", \
			"auto_zoom_max", \
			"auto_zoom_margin":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	################
	## Follow Framed
	################
	if not follow_mode == FollowMode.FRAMED:
		match property.name:
			"dead_zone_width", \
			"dead_zone_height", \
			"show_viewfinder_in_play":
				property.usage = PROPERTY_USAGE_NO_EDITOR


	#####################
	## Rotate With Target
	#####################
	if property.name == "rotate_with_target" and follow_mode == FollowMode.GROUP:
		property.usage = PROPERTY_USAGE_NO_EDITOR


	if not rotate_with_target or follow_mode == FollowMode.GROUP:
		match property.name:
			"rotation_damping", \
			"rotation_offset", \
			"rotation_damping_value":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "rotation_damping_value":
		if not rotation_damping:
			property.usage = PROPERTY_USAGE_NO_EDITOR


	#######
	## Zoom
	#######
	if property.name == "zoom" and follow_mode == FollowMode.GROUP and auto_zoom:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	########
	## Limit
	########
	if is_instance_valid(_limit_node):
		match property.name:
			"limit_left", \
			"limit_top", \
			"limit_right", \
			"limit_bottom":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "limit_margin" and not _limit_node:
		property.usage = PROPERTY_USAGE_NO_EDITOR


func _enter_tree() -> void:
	_phantom_camera_manager = Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME)
	_tween_skip = !tween_on_load

	_phantom_camera_manager.pcam_added(self)

	priority_override = false

	match follow_mode:
		FollowMode.NONE:
			_is_parents_physics()
		FollowMode.PATH:
			if is_instance_valid(follow_path):
				_should_follow_checker()
			else:
				_should_follow = false
		FollowMode.GROUP:
			_follow_targets_size_check()
			_should_follow_checker()
		_:
			_should_follow_checker()

	if not visibility_changed.is_connected(_check_visibility):
		visibility_changed.connect(_check_visibility)

	update_limit_all_sides()



func _exit_tree() -> void:
	if not follow_mode == FollowMode.GROUP:
		follow_targets = []

	if not is_instance_valid(_phantom_camera_manager): return
	_phantom_camera_manager.pcam_removed(self)


func _ready() -> void:
	if is_instance_valid(follow_target):
		_transform_output.origin = _get_target_position_offset()
	else:
		_transform_output = global_transform

	_phantom_camera_manager.noise_2d_emitted.connect(_noise_emitted)

	if not Engine.is_editor_hint():
		_preview_noise = true

	if follow_mode == FollowMode.GROUP:
		_follow_targets_size_check()


func _process(delta: float) -> void:
	if _follow_target_physics_based or _is_active: return
	process_logic(delta)


func _physics_process(delta: float) -> void:
	if not _follow_target_physics_based or _is_active: return
	process_logic(delta)


func process_logic(delta: float) -> void:
	if _is_active:
		if _has_noise_resource and _preview_noise:
			_transform_noise = noise.get_noise_transform(delta)
	else:
		match inactive_update_mode:
			InactiveUpdateMode.NEVER: return
			InactiveUpdateMode.ALWAYS:
				# Only triggers if limit isn't default
				if _limit_inactive_pcam:
					global_position = _set_limit_clamp_position(global_position)
			# InactiveUpdateMode.EXPONENTIALLY:
			# TODO - Trigger positional updates less frequently as more PCams gets added

	_limit_checker()

	if _should_follow:
		_follow(delta)
	else:
		_transform_output = global_transform

	if _follow_axis_is_locked:
		match follow_axis_lock:
			FollowLockAxis.X:
				_transform_output.origin.x = _follow_axis_lock_value.x
			FollowLockAxis.Y:
				_transform_output.origin.y = _follow_axis_lock_value.y
			FollowLockAxis.XY:
				_transform_output.origin.x = _follow_axis_lock_value.x
				_transform_output.origin.y = _follow_axis_lock_value.y


func _limit_checker() -> void:
	## TODO - Needs to see if this can be triggerd only from CollisionShape2D Transform changes
	if not Engine.is_editor_hint(): return
	if draw_limits:
		update_limit_all_sides()


func _follow(delta: float) -> void:
	_set_follow_position()
	_interpolate_position(_follow_target_position, delta)


func _set_follow_position() -> void:
	match follow_mode:
		FollowMode.GLUED:
			_follow_target_position = follow_target.global_position

		FollowMode.SIMPLE:
			_follow_target_position = _get_target_position_offset()

		FollowMode.GROUP:
			if _has_multiple_follow_targets:
				var rect: Rect2 = Rect2(_follow_targets[0].global_position, Vector2.ZERO)
				for target in _follow_targets:
					rect = rect.expand(target.global_position)
				if auto_zoom:
					rect = rect.grow_individual(
						auto_zoom_margin.x,
						auto_zoom_margin.y,
						auto_zoom_margin.z,
						auto_zoom_margin.w
					)

					if rect.size.x > rect.size.y * _phantom_camera_manager.screen_size.aspect():
						zoom = clamp(_phantom_camera_manager.screen_size.x / rect.size.x, auto_zoom_min, auto_zoom_max) * Vector2.ONE
					else:
						zoom = clamp(_phantom_camera_manager.screen_size.y / rect.size.y, auto_zoom_min, auto_zoom_max) * Vector2.ONE
				_follow_target_position = rect.get_center() + follow_offset
			else:
				_follow_target_position = follow_targets[_follow_targets_single_target_index].global_position + follow_offset

		FollowMode.PATH:
			var path_position: Vector2 = follow_path.global_position

			_follow_target_position = \
			follow_path.curve.get_closest_point(
				_get_target_position_offset() - path_position
			) + path_position

		FollowMode.FRAMED:
			if not Engine.is_editor_hint():
				if not _is_active:
					_follow_target_position = _get_target_position_offset()
				else:
					viewport_position = (get_follow_target().get_global_transform_with_canvas().get_origin() + follow_offset) / get_viewport_rect().size
					var framed_side_offset: Vector2 = _get_framed_side_offset()

					if framed_side_offset != Vector2.ZERO:
						var glo_pos: Vector2
						var target_position: Vector2 = _get_target_position_offset() + _follow_framed_offset

						if dead_zone_width == 0 || dead_zone_height == 0:
							if dead_zone_width == 0 && dead_zone_height != 0:
								_follow_target_position = _get_target_position_offset()
							elif dead_zone_width != 0 && dead_zone_height == 0:
								glo_pos = _get_target_position_offset()
								glo_pos.x += target_position.x - global_position.x
								_follow_target_position = glo_pos
							else:
								_follow_target_position = _get_target_position_offset()

						# If a horizontal dead zone is reached
						if framed_side_offset.x != 0 and framed_side_offset.y == 0:
							_follow_target_position.y = _transform_output.origin.y
							_follow_target_position.x = target_position.x
							_follow_framed_offset.y = global_position.y - _get_target_position_offset().y
							dead_zone_reached.emit(Vector2(framed_side_offset.x, 0))
							# If a vertical dead zone is reached
						elif framed_side_offset.x == 0 and framed_side_offset.y != 0:
							_follow_target_position.x = _transform_output.origin.x
							_follow_target_position.y = target_position.y
							_follow_framed_offset.x = global_position.x - _get_target_position_offset().x
							dead_zone_reached.emit(Vector2(0, framed_side_offset.y))
						# If a deadzone corner is reached
						else:
							_follow_target_position = target_position
							dead_zone_reached.emit(Vector2(framed_side_offset.x, framed_side_offset.y))
					else:
						_follow_framed_offset = _transform_output.origin - _get_target_position_offset()
						return
			else:
				_follow_target_position = _get_target_position_offset()


func _set_follow_velocity(index: int, value: float):
	_follow_velocity_ref[index] = value

func _set_rotation_velocity(index: int, value: float):
	_rotation_velocity_ref = value

func _interpolate_position(target_position: Vector2, delta: float) -> void:
	var output_rotation: float = global_transform.get_rotation()
	if rotate_with_target:
		if rotation_damping and not Engine.is_editor_hint():
			output_rotation = _smooth_damp(
				follow_target.get_rotation() + rotation_offset,
				_transform_output.get_rotation(),
				0,
				_rotation_velocity_ref,
				_set_rotation_velocity,
				rotation_damping_value,
				delta
			)
		else:
			output_rotation = follow_target.get_rotation() + rotation_offset

	if _limit_inactive_pcam and not _tween_skip:
		target_position = _set_limit_clamp_position(target_position)

	global_position = target_position

	if follow_damping and not Engine.is_editor_hint():
		var output_position: Vector2
		for i in 2:
			output_position[i] = _smooth_damp(
				global_position[i],
				_transform_output.origin[i],
				i,
				_follow_velocity_ref[i],
				_set_follow_velocity,
				follow_damping_value[i],
				delta
			)
		_transform_output = Transform2D(output_rotation, output_position)
	else:
		_transform_output = Transform2D(output_rotation, target_position)


func _smooth_damp(target_axis: float, self_axis: float, index: int, current_velocity: float, set_velocity: Callable, damping_time: float, delta: float) -> float:
		damping_time = maxf(0.0001, damping_time)
		var omega: float = 2 / damping_time
		var x: float = omega * delta
		var exponential: float = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x)
		var diff: float = self_axis - target_axis
		var _target_axis: float = target_axis

		var max_change: float = INF * damping_time
		diff = clampf(diff, -max_change, max_change)
		target_axis = self_axis - diff

		var temp: float = (current_velocity + omega * diff) * delta
		set_velocity.call(index, (current_velocity - omega * temp) * exponential)
		var output: float = target_axis + (diff + temp) * exponential

		## To prevent overshooting
		if (_target_axis - self_axis > 0.0) == (output > _target_axis):
			output = _target_axis
			set_velocity.call(index, (output - _target_axis) / delta)

		return output


func _set_limit_clamp_position(value: Vector2) -> Vector2:
	var camera_frame_rect_size: Vector2 = _camera_frame_rect().size
	value.x = clampf(value.x, _limit_sides.x + camera_frame_rect_size.x / 2, _limit_sides.z - camera_frame_rect_size.x / 2)
	value.y = clampf(value.y, _limit_sides.y + camera_frame_rect_size.y / 2, _limit_sides.w - camera_frame_rect_size.y / 2)
	return value


func _draw() -> void:
	if not Engine.is_editor_hint(): return

	if frame_preview and not _is_active:
		draw_rect(_camera_frame_rect(), Color("3ab99a"), false, 2)


func _camera_frame_rect() -> Rect2:
	var screen_size_zoom: Vector2 = Vector2(_phantom_camera_manager.screen_size.x / get_zoom().x, _phantom_camera_manager.screen_size.y / get_zoom().y)

	return Rect2(-screen_size_zoom / 2, screen_size_zoom)


func _on_tile_map_changed() -> void:
	update_limit_all_sides()


func _get_target_position_offset() -> Vector2:
	return follow_target.global_position + follow_offset


func _on_dead_zone_changed() -> void:
	global_position = _get_target_position_offset()


func _get_framed_side_offset() -> Vector2:
	var frame_out_bounds: Vector2

	if viewport_position.x < 0.5 - dead_zone_width / 2:
		# Is outside left edge
		frame_out_bounds.x = -1

	if viewport_position.y < 0.5 - dead_zone_height / 2:
		# Is outside top edge
		frame_out_bounds.y = 1

	if viewport_position.x > 0.5 + dead_zone_width / 2:
		# Is outside right edge
		frame_out_bounds.x = 1

	if viewport_position.y > 0.5001 + dead_zone_height / 2: # 0.501 to resolve an issue where the bottom vertical Dead Zone never becoming 0 when the Dead Zone Vertical parameter is set to 0
		# Is outside bottom edge
		frame_out_bounds.y = -1

	return frame_out_bounds


func _draw_camera_2d_limit() -> void:
	if not is_instance_valid(_phantom_camera_manager): return
	_phantom_camera_manager.draw_limit_2d.emit(draw_limits)


func _check_limit_is_not_default() -> void:
	if _limit_sides == _limit_sides_default:
		_limit_inactive_pcam = false
	else:
		_limit_inactive_pcam = true


func _check_visibility() -> void:
	_phantom_camera_manager.pcam_visibility_changed.emit(self)


func _follow_target_tree_exiting(target: Node) -> void:
	if target == follow_target:
		_should_follow = false
	if _follow_targets.has(target):
		_follow_targets.erase(target)


func _should_follow_checker() -> void:
	if follow_mode == FollowMode.NONE:
		_should_follow = false
		return

	if not follow_mode == FollowMode.GROUP:
		if is_instance_valid(follow_target):
			_should_follow = true
		else:
			_should_follow = false


func _follow_targets_size_check() -> void:
	var targets_size: int = 0
	_follow_target_physics_based = false
	_follow_targets = []
	for i in follow_targets.size():
		if follow_targets[i] == null: continue
		if follow_targets[i].is_inside_tree():
			_follow_targets.append(follow_targets[i])
			targets_size += 1
			_follow_targets_single_target_index = i
			_check_physics_body(follow_targets[i])
			if not follow_targets[i].tree_exiting.is_connected(_follow_target_tree_exiting):
				follow_targets[i].tree_exiting.connect(_follow_target_tree_exiting.bind(follow_targets[i]))

	match targets_size:
		0:
			_should_follow = false
			_has_multiple_follow_targets = false
		1:
			_should_follow = true
			_has_multiple_follow_targets = false
		_:
			_should_follow = true
			_has_multiple_follow_targets = true


func _noise_emitted(emitter_noise_output: Transform2D, emitter_layer: int) -> void:
	if noise_emitter_layer & emitter_layer != 0:
		noise_emitted.emit(emitter_noise_output)


func _set_layer(current_layers: int, layer_number: int, value: bool) -> int:
	var mask: int = current_layers

	# From https://github.com/godotengine/godot/blob/51991e20143a39e9ef0107163eaf283ca0a761ea/scene/3d/camera_3d.cpp#L638
	if layer_number < 1 or layer_number > 20:
		printerr("Render layer must be between 1 and 20.")
	else:
		if value:
			mask |= 1 << (layer_number - 1)
		else:
			mask &= ~(1 << (layer_number - 1))

	return mask


func _check_physics_body(target: Node2D) -> void:
	if target is PhysicsBody2D:
		var show_jitter_tips := ProjectSettings.get_setting("phantom_camera/tips/show_jitter_tips")
		var physics_interpolation_enabled := ProjectSettings.get_setting("physics/common/physics_interpolation")

		## NOTE - Feature Toggle
		if Engine.get_version_info().major == 4 and \
		Engine.get_version_info().minor < 3:
			if show_jitter_tips == null: # Default value is null when referencing custom Project Setting
				print_rich("Following a [b]PhysicsBody2D[/b] node will likely result in jitter - on lower physics ticks in particular.")
				print_rich("If possible, will recommend upgrading to Godot 4.3, as it has built-in support for 2D Physics Interpolation, which will mitigate this issue.")
				print_rich("Otherwise, try following the guide on the [url=https://phantom-camera.dev/support/faq#i-m-seeing-jitter-what-can-i-do]documentation site[/url] for better results.")
				print_rich("This tip can be disabled from within [code]Project Settings / Phantom Camera / Tips / Show Jitter Tips[/code]")
			return
			## NOTE - Only supported in Godot 4.3 or above
		elif not physics_interpolation_enabled and show_jitter_tips == null: # Default value is null when referencing custom Project Setting
			printerr("Physics Interpolation is disabled in the Project Settings, recommend enabling it to smooth out physics-based camera movement")
			print_rich("This tip can be disabled from within [code]Project Settings / Phantom Camera / Tips / Show Jitter Tips[/code]")
		_follow_target_physics_based = true
	else:
		_is_parents_physics(target)
	physics_target_changed.emit()


func _is_parents_physics(target: Node = self) -> void:
	var current_node: Node = target
	while current_node:
		current_node = current_node.get_parent()
		if not current_node is PhysicsBody2D: continue
		_follow_target_physics_based = true

#endregion


#region Public Functions

## Updates the limit sides based what has been set to define it
## This should be automatic, but can be called manully if need be.
func update_limit_all_sides() -> void:
	var limit_rect: Rect2

	if not is_instance_valid(_limit_node):
		_limit_sides.x = limit_left
		_limit_sides.y = limit_top
		_limit_sides.z = limit_right
		_limit_sides.w = limit_bottom
	elif _limit_node is TileMap or _limit_node.is_class("TileMapLayer"):
		var tile_map := _limit_node

		if not tile_map.tile_set: return # TODO: This should be removed once https://github.com/godotengine/godot/issues/96898 is resolved

		var tile_map_size: Vector2 = Vector2(tile_map.get_used_rect().size) * Vector2(tile_map.tile_set.tile_size) * tile_map.get_scale()
		var tile_map_position: Vector2 = tile_map.global_position + Vector2(tile_map.get_used_rect().position) * Vector2(tile_map.tile_set.tile_size) * tile_map.get_scale()

		## Calculates the Rect2 based on the Tile Map position and size + margin
		limit_rect = Rect2(
			tile_map_position + Vector2(limit_margin.x, limit_margin.y),
			tile_map_size - Vector2(limit_margin.x, limit_margin.y) - Vector2(limit_margin.z, limit_margin.w)
		)

		# Left
		_limit_sides.x = roundi(limit_rect.position.x)
		# Top
		_limit_sides.y = roundi(limit_rect.position.y)
		# Right
		_limit_sides.z = roundi(limit_rect.position.x + limit_rect.size.x)
		# Bottom
		_limit_sides.w = roundi(limit_rect.position.y + limit_rect.size.y)
	elif _limit_node is CollisionShape2D:
		var collision_shape_2d: CollisionShape2D = _limit_node as CollisionShape2D

		if not collision_shape_2d.get_shape(): return

		var shape_2d: Shape2D = collision_shape_2d.get_shape()
		var shape_2d_size: Vector2 = shape_2d.get_rect().size
		var shape_2d_position: Vector2 = collision_shape_2d.global_position + Vector2(shape_2d.get_rect().position)

		## Calculates the Rect2 based on the Tile Map position and size
		limit_rect = Rect2(shape_2d_position, shape_2d_size)

		## Calculates the Rect2 based on the Tile Map position and size + margin
		limit_rect = Rect2(
			limit_rect.position + Vector2(limit_margin.x, limit_margin.y),
			limit_rect.size - Vector2(limit_margin.x, limit_margin.y) - Vector2(limit_margin.z, limit_margin.w)
		)

		# Left
		_limit_sides.x = roundi(limit_rect.position.x)
		# Top
		_limit_sides.y = roundi(limit_rect.position.y)
		# Right
		_limit_sides.z = roundi(limit_rect.position.x + limit_rect.size.x)
		# Bottom
		_limit_sides.w = roundi(limit_rect.position.y + limit_rect.size.y)

	_check_limit_is_not_default()
	if not _is_active: return
	if not is_instance_valid(_phantom_camera_manager): return
	_phantom_camera_manager.limit_2d_changed.emit(SIDE_LEFT, _limit_sides.x)
	_phantom_camera_manager.limit_2d_changed.emit(SIDE_TOP, _limit_sides.y)
	_phantom_camera_manager.limit_2d_changed.emit(SIDE_RIGHT, _limit_sides.z)
	_phantom_camera_manager.limit_2d_changed.emit(SIDE_BOTTOM, _limit_sides.w)
	_phantom_camera_manager.draw_limit_2d.emit(draw_limits)


func reset_limit() -> void:
	if not is_instance_valid(_phantom_camera_manager): return
	_phantom_camera_manager.limit_2d_changed.emit(SIDE_LEFT, _limit_sides_default.x)
	_phantom_camera_manager.limit_2d_changed.emit(SIDE_TOP, _limit_sides_default.y)
	_phantom_camera_manager.limit_2d_changed.emit(SIDE_RIGHT, _limit_sides_default.z)
	_phantom_camera_manager.limit_2d_changed.emit(SIDE_BOTTOM, _limit_sides_default.w)
	_phantom_camera_manager.draw_limit_2d.emit(draw_limits)


## Assigns the value of the [param has_tweened] property.
## [b][color=yellow]Important:[/color][/b] This value can only be changed
## from the [PhantomCameraHost] script.
func set_tween_skip(caller: Node, value: bool) -> void:
	if is_instance_of(caller, PhantomCameraHost):
		_tween_skip = value
	else:
		printerr("Can only be called PhantomCameraHost class")
## Returns the current [param has_tweened] value.
func get_tween_skip() -> bool:
	return _tween_skip

## Returns the [Transform3D] value based on the [member follow_mode] / [member look_at_mode] target value.
func get_transform_output() -> Transform2D:
	return _transform_output


## Returns the noise [Transform3D] value.
func get_noise_transform() -> Transform2D:
	return _transform_noise


## Emits a noise based on a custom [Transform2D] value.[br]
## Use this function if you wish to make use of external noise patterns from, for example, other addons.
func emit_noise(value: Transform2D) -> void:
	noise_emitted.emit(value)


## Teleports the [param PhantomCamera2D] and [Camera2D] to their designated position,
## bypassing the damping process.
func teleport_position() -> void:
	_follow_velocity_ref = Vector2.ZERO
	_set_follow_position()
	_transform_output.origin = _follow_target_position
	_phantom_camera_manager.pcam_teleport.emit(self)


# TODO: Enum link does link to anywhere is being tracked in: https://github.com/godotengine/godot/issues/106828
## Returns true if this [param PhantomCamera2D]'s [member follow_mode] is not set to [enum FollowMode]
## and has a valid [member follow_target].
func is_following() -> bool:
	return _should_follow

#endregion


#region Setter & Getter Functions

## Assigns new [member zoom] value.
func set_zoom(value: Vector2) -> void:
	zoom = value
	queue_redraw()

## Gets current [member zoom] value.
func get_zoom() -> Vector2:
	return zoom


## Assigns new [member priority] value.
func set_priority(value: int) -> void:
	priority = maxi(0, value)
	if not is_node_ready(): return
	if not Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME): return
	Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME).pcam_priority_changed.emit(self)

## Gets current [member priority] value.
func get_priority() -> int:
	return priority


## Assigns a new PhantomCameraTween resource to the PhantomCamera2D
func set_tween_resource(value: PhantomCameraTween) -> void:
	tween_resource = value

## Gets the PhantomCameraTween resource assigned to the PhantomCamera2D
## Returns null if there's nothing assigned to it.
func get_tween_resource() -> PhantomCameraTween:
	return tween_resource


## Assigns a new [param Tween Duration] to the [member tween_resource] value.[br]
## The duration value is in seconds.
func set_tween_duration(value: float) -> void:
	tween_resource.duration = value

## Gets the current [param Tween Duration] value inside the
## [member tween_resource].[br]
## The duration value is in seconds.
func get_tween_duration() -> float:
	return tween_resource.duration


## Assigns a new [param Tween Transition] value inside the
## [member tween_resource].
func set_tween_transition(value: int) -> void:
	tween_resource.transition = value

## Gets the current [param Tween Transition] value  inside the
## [member tween_resource].
func get_tween_transition() -> int:
	return tween_resource.transition


## Assigns a new [param Tween Ease] value inside the [member tween_resource].
func set_tween_ease(value: int) -> void:
	tween_resource.ease = value

## Gets the current [param Tween Ease] value inside the [member tween_resource].
func get_tween_ease() -> int:
	return tween_resource.ease


## Sets the [param PhantomCamera2D] active state.[br]
## [b][color=yellow]Important:[/color][/b] This value can only be changed
## from the [PhantomCameraHost] script.
func set_is_active(node, value) -> void:
	if node is PhantomCameraHost:
		_is_active = value
		if value:
			_should_follow_checker()
		queue_redraw()
	else:
		printerr("PCams can only be set from the PhantomCameraHost")

## Gets current active state of the [param PhantomCamera2D].
## If it returns true, it means the [param PhantomCamera2D] is what the
## [param Camera2D] is currently following.
func is_active() -> bool:
	return _is_active


## Enables or disables the [member tween_on_load].
func set_tween_on_load(value: bool) -> void:
	tween_on_load = value

## Gets the current [member tween_on_load] value.
func get_tween_on_load() -> bool:
	return tween_on_load

## Sets the [member host_layers] value.
func set_host_layers(value: int) -> void:
	host_layers = value
	if is_instance_valid(_phantom_camera_manager):
		_phantom_camera_manager.pcam_host_layer_changed.emit(self)

## Enables or disables a given layer of [member host_layers].
func set_host_layers_value(layer: int, value: bool) -> void:
	host_layers = _set_layer(host_layers, layer, value)

## Gets the current [member host_layers].
func get_host_layers() -> int:
	return host_layers


## Gets the current follow mode as an enum int based on [enum FollowMode].[br]
## [b]Note:[/b] Setting [enum FollowMode] purposely not added.
## A separate PCam should be used instead.
func get_follow_mode() -> int:
	return follow_mode


## Assigns a new [Node2D] as the [member follow_target].
func set_follow_target(value: Node2D) -> void:
	if follow_mode == FollowMode.NONE or follow_mode == FollowMode.GROUP: return
	if follow_target == value: return
	follow_target = value
	_follow_target_physics_based = false
	if is_instance_valid(value):
		if follow_mode == FollowMode.PATH:
			if is_instance_valid(follow_path):
				_should_follow = true
			else:
				_should_follow = false
		else:
			_should_follow = true
		_check_physics_body(value)
		if not follow_target.tree_exiting.is_connected(_follow_target_tree_exiting):
			follow_target.tree_exiting.connect(_follow_target_tree_exiting.bind(follow_target))
	else:
		_should_follow = false
	follow_target_changed.emit()
	notify_property_list_changed()

## Erases the current [member follow_target].
func erase_follow_target() -> void:
	if follow_target == null: return
	_should_follow = false
	follow_target = null
	_follow_target_physics_based = false
	follow_target_changed.emit()

## Gets the current [member follow_target].
func get_follow_target() -> Node2D:
	return follow_target


## Assigns a new [Path2D] to the [member follow_path].
func set_follow_path(value: Path2D) -> void:
	follow_path = value
	if is_instance_valid(follow_path):
		_should_follow_checker()
	else:
		_should_follow = false

## Erases the current [Path2D] from the [member follow_path] property.
func erase_follow_path() -> void:
	follow_path = null

## Gets the current [Path2D] from the [member follow_path].
func get_follow_path() -> Path2D:
	return follow_path


## Assigns a new [param follow_targets] array value.
func set_follow_targets(value: Array[Node2D]) -> void:
	if follow_mode != FollowMode.GROUP: return
	if follow_targets == value: return
	follow_targets = value
	_follow_targets_size_check()

## Appends a single [Node2D] to [member follow_targets].
func append_follow_targets(value: Node2D) -> void:
	if not is_instance_valid(value):
		printerr(value, " is not a valid Node2D instance")
		return

	if not follow_targets.has(value):
		follow_targets.append(value)
		_follow_targets_size_check()
	else:
		printerr(value, " is already part of Follow Group")

## Adds an Array of type [Node2D] to [member follow_targets].
func append_follow_targets_array(value: Array[Node2D]) -> void:
	for target in value:
		if not is_instance_valid(target): continue
		if not follow_targets.has(target):
			follow_targets.append(target)
			_follow_targets_size_check()
		else:
			printerr(value, " is already part of Follow Group")

## Removes a [Node2D] from [member follow_targets] array.
func erase_follow_targets(value: Node2D) -> void:
	follow_targets.erase(value)
	_follow_targets_size_check()

## Gets all [Node2D] from [member follow_targets] array.
func get_follow_targets() -> Array[Node2D]:
	return follow_targets


## Assigns a new Vector2 for the Follow Target Offset property.
func set_follow_offset(value: Vector2) -> void:
	var temp_offset: Vector2 = follow_offset

	follow_offset = value

	if follow_axis_lock != FollowLockAxis.NONE:
		temp_offset = temp_offset - value
		match value:
			FollowLockAxis.X:
				_follow_axis_lock_value.x = _transform_output.origin.x + temp_offset.x
			FollowLockAxis.Y:
				_follow_axis_lock_value.y = _transform_output.origin.y + temp_offset.y
			FollowLockAxis.XY:
				_follow_axis_lock_value.x = _transform_output.origin.x + temp_offset.x
				_follow_axis_lock_value.y = _transform_output.origin.y + temp_offset.y


## Gets the current Vector2 for the Follow Target Offset property.
func get_follow_offset() -> Vector2:
	return follow_offset


## Enables or disables Follow Damping.
func set_follow_damping(value: bool) -> void:
	follow_damping = value
	notify_property_list_changed()

## Gets the current Follow Damping property.
func get_follow_damping() -> bool:
	return follow_damping


## Assigns new Damping value.
func set_follow_damping_value(value: Vector2) -> void:
	## TODO - Should be using @export_range once minimum version support is Godot 4.3
	if value.x < 0: value.x = 0
	elif value.y < 0: value.y = 0
	follow_damping_value = value

## Gets the current Follow Damping value.
func get_follow_damping_value() -> Vector2:
	return follow_damping_value


## Assigns a new [member follow_axis] member. Value is based on [enum FollowLockAxis] enum.
func set_lock_axis(value: FollowLockAxis) -> void:
	follow_axis_lock = value

	# Wait for the node to be ready before setting lock
	if not is_node_ready(): await ready

	# Prevent axis lock from working in the editor
	if value != FollowLockAxis.NONE and not Engine.is_editor_hint():
		_follow_axis_is_locked = true
		match value:
			FollowLockAxis.X:
				_follow_axis_lock_value.x = _transform_output.origin.x
			FollowLockAxis.Y:
				_follow_axis_lock_value.y = _transform_output.origin.y
			FollowLockAxis.XY:
				_follow_axis_lock_value.x = _transform_output.origin.x
				_follow_axis_lock_value.y = _transform_output.origin.y
	else:
		_follow_axis_is_locked = false

## Gets the current [member follow_axis_lock] value. Value is based on [enum FollowLockAxis] enum.
func get_lock_axis() -> FollowLockAxis:
	return follow_axis_lock


## Enables or disables [member rotate_with_target].
func set_rotate_with_target(value: bool) -> void:
	rotate_with_target = value
	notify_property_list_changed()

## Gets the current [member rotate_with_target] value.
func get_rotate_with_target() -> bool:
	return rotate_with_target


## Sets the [member rotation_offset].
func set_rotation_offset(value: float) -> void:
	rotation_offset = value

## Gets the current [member rotation_offset] value.
func get_rotation_offset() -> float:
	return rotation_offset


## Enables or disables [member rotation_damping].
func set_rotation_damping(value: bool) -> void:
	rotation_damping = value
	notify_property_list_changed()

## Gets the [member rotation_damping] value.
func get_rotation_damping() -> bool:
	return rotation_damping


## Set the [member rotation_damping_value].
func set_rotation_damping_value(value: float) -> void:
	rotation_damping_value = value

## Gets the [member rotation_damping_value] value.
func get_rotation_damping_value() -> float:
	return rotation_damping_value


## Enables or disables [member snap_to_pixel].
func set_snap_to_pixel(value: bool) -> void:
	snap_to_pixel = value

## Gets the current [member snap_to_pixel] value.
func get_snap_to_pixel() -> bool:
	return snap_to_pixel


## Enables or disables Auto zoom when using Group Follow.
func set_auto_zoom(value: bool) -> void:
	auto_zoom = value
	notify_property_list_changed()

## Gets Auto Zoom state.
func get_auto_zoom() -> bool:
	return auto_zoom


## Assigns new Min Auto Zoom value.
func set_auto_zoom_min(value: float) -> void:
	auto_zoom_min = value

## Gets Min Auto Zoom value.
func get_auto_zoom_min() -> float:
	return auto_zoom_min


## Assigns new Max Auto Zoom value.
func set_auto_zoom_max(value: float) -> void:
	auto_zoom_max = value

## Gets Max Auto Zoom value.
func get_auto_zoom_max() -> float:
	return auto_zoom_max


## Assigns new Zoom Auto Margin value.
func set_auto_zoom_margin(value: Vector4) -> void:
	auto_zoom_margin = value

## Gets Zoom Auto Margin value.
func get_auto_zoom_margin() -> Vector4:
	return auto_zoom_margin


## Sets a limit side based on the side parameter.[br]
## It's recommended to pass the [enum Side] enum as the sid parameter.
func set_limit(side: int, value: int) -> void:
	match side:
		SIDE_LEFT: 		limit_left = value
		SIDE_TOP: 		limit_top = value
		SIDE_RIGHT: 	limit_right = value
		SIDE_BOTTOM: 	limit_bottom = value
		_:				printerr("Not a valid Side.")

## Gets the limit side
func get_limit(value: int) -> int:
	match value:
		SIDE_LEFT: 		return limit_left
		SIDE_TOP: 		return limit_top
		SIDE_RIGHT: 	return limit_right
		SIDE_BOTTOM: 	return limit_bottom
		_:
						printerr("Not a valid Side.")
						return -1


## Assign a the Camera2D Left Limit Side value.
func set_limit_left(value: int) -> void:
	_limit_target_exist_error()
	limit_left = value
	update_limit_all_sides()

## Gets the Camera2D Left Limit value.
func get_limit_left() -> int:
	return limit_left


## Assign a the Camera2D Top Limit Side value.
func set_limit_top(value: int) -> void:
	_limit_target_exist_error()
	limit_top = value
	update_limit_all_sides()

## Gets the Camera2D Top Limit value.
func get_limit_top() -> int:
	return limit_top


## Assign a the Camera2D Right Limit Side value.
func set_limit_right(value: int) -> void:
	_limit_target_exist_error()
	limit_right = value
	update_limit_all_sides()

## Gets the Camera2D Right Limit value.
func get_limit_right() -> int:
	return limit_right


## Assign a the Camera2D Bottom Limit Side value.
func set_limit_bottom(value: int) -> void:
	_limit_target_exist_error()
	limit_bottom = value
	update_limit_all_sides()

## Gets the Camera2D Bottom Limit value.
func get_limit_bottom() -> int:
	return limit_bottom


func _limit_target_exist_error() -> void:
	if not limit_target.is_empty():
		printerr("Unable to set Limit Side due to Limit Target ", _limit_node.name,  " being assigned")


# Sets a [memeber limit_target] node.
func set_limit_target(value: NodePath) -> void:
	limit_target = value

	# Waits for PCam2d's _ready() before trying to validate limit_node_path
	if not is_node_ready(): await ready

	# Removes signal from existing TileMap node
	if is_instance_valid(get_node_or_null(value)):
		var prev_limit_node: Node2D = _limit_node
		var new_limit_node: Node2D = get_node(value)

		if prev_limit_node:
			if prev_limit_node is TileMap or prev_limit_node.is_class("TileMapLayer"):
				if prev_limit_node.changed.is_connected(_on_tile_map_changed):
					prev_limit_node.changed.disconnect(_on_tile_map_changed)

		if new_limit_node is TileMap or new_limit_node.is_class("TileMapLayer"):
			if not new_limit_node.changed.is_connected(_on_tile_map_changed):
				new_limit_node.changed.connect(_on_tile_map_changed)
		elif new_limit_node is CollisionShape2D:
			var col_shape: CollisionShape2D = get_node(value)

			if col_shape.shape == null:
				printerr("No Shape2D in: ", col_shape.name)
				reset_limit()
				limit_target = ""
				return
		else:
			printerr("Limit Target is not a TileMap, TileMapLayer or CollisionShape2D node")
			return
	elif value == NodePath(""):
		reset_limit()
		limit_target = ""
	else:
		printerr("Limit Target cannot be found")
		return

	_limit_node = get_node_or_null(value)

	notify_property_list_changed()
	update_limit_all_sides()

## Get [member limit_target] node.
func get_limit_target() -> NodePath:
	if not limit_target: # TODO - Fixes an spam error if if limit_taret is empty
		return NodePath("")
	else:
		return limit_target


## Set Tile Map Limit Margin.
func set_limit_margin(value: Vector4i) -> void:
	limit_margin = value
	update_limit_all_sides()
## Get Tile Map Limit Margin.
func get_limit_margin() -> Vector4i:
	return limit_margin


### Enables or disables the Limit Smoothing beaviour.
#func set_limit_smoothing(value: bool) -> void:
	#limit_smoothed = value
### Returns the Limit Smoothing beaviour.
#func get_limit_smoothing() -> bool:
	#return limit_smoothed


## Sets a [PhantomCameraNoise2D] resource.
func set_noise(value: PhantomCameraNoise2D) -> void:
	noise = value
	if value != null:
		_has_noise_resource = true
		noise.set_trauma(1)
	else:
		_has_noise_resource = false
		_transform_noise = Transform2D()

## Returns the [PhantomCameraNoise2D] resource.
func get_noise() -> PhantomCameraNoise2D:
	return noise

func has_noise_resource() -> bool:
	return _has_noise_resource


## Sets the [member noise_emitter_layer] value.
func set_noise_emitter_layer(value: int) -> void:
	noise_emitter_layer = value

## Enables or disables a given layer of [member noise_emitter_layer].
func set_noise_emitter_layer_value(value: int, enabled: bool) -> void:
	noise_emitter_layer = _set_layer(noise_emitter_layer, value, enabled)

## Returns the [member noise_emitter_layer]
func get_noise_emitter_layer() -> int:
	return noise_emitter_layer


## Sets [member inactive_update_mode] property.
func set_inactive_update_mode(value: int) -> void:
	inactive_update_mode = value

## Gets [enum InactiveUpdateMode] value.
func get_inactive_update_mode() -> int:
	return inactive_update_mode


func get_follow_target_physics_based() -> bool:
	return _follow_target_physics_based


func get_class() -> String:
	return "PhantomCamera2D"


func is_class(value) -> bool:
	return value == "PhantomCamera2D"

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_3d.gd ---
@tool
@icon("res://addons/phantom_camera/icons/phantom_camera_3d.svg")
class_name PhantomCamera3D
extends Node3D

## Controls a scene's [Camera3D] and applies logic to it.
##
## The scene's [Camera3D] will follow the position of the
## [param PhantomCamera3D] with the highest priority.
## Each instance can have different positional and rotational logic applied
## to them.

#region Constants

const _constants = preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd")

#endregion

#region Signals

## Emitted when the [param PhantomCamera3D] becomes active.
signal became_active

## Emitted when the [param PhantomCamera3D] becomes inactive.
signal became_inactive

## Emitted when the follow_mode changes.
## Note: This is for internal use only
signal follow_mode_changed

## Emitted when [member follow_target] changes.
signal follow_target_changed

## Emitted when [member look_at_target] changes.
signal look_at_target_changed

## Emitted when dead zones changes.[br]
## [b]Note:[/b] Only applicable in [param Framed] [member FollowMode].
signal dead_zone_changed

## Emitted when a target touches the edge of the dead zone in [param Framed] [enum FollowMode].
signal dead_zone_reached

## Emitted when the [param Camera3D] starts to tween to another
## [param PhantomCamera3D].
signal tween_started

## Emitted when the [param Camera3D] is to tweening towards another
## [param PhantomCamera3D].
signal is_tweening

## Emitted when the tween is interrupted due to another [param PhantomCamera3D]
## becoming active. The argument is the [param PhantomCamera3D] that
## interrupted the tween.
signal tween_interrupted(pcam_3d: PhantomCamera3D)

## Emitted when the [param Camera3D] completes its tween to the
## [param PhantomCamera3D].
signal tween_completed

## Emitted when Noise should be applied to the [param Camera3D].
signal noise_emitted(noise_output: Transform3D)

signal physics_target_changed

signal camera_3d_resource_property_changed(property: StringName, value: Variant)
signal camera_3d_resource_changed

#endregion


#region Enums

## Determines the positional logic for a given [param PhantomCamera3D]
## [br][br]
## The different modes have different functionalities and purposes, so choosing
## the correct one depends on what each [param PhantomCamera3D] is meant to do.
enum FollowMode {
	NONE 			= 0, ## Default - No follow logic is applied.
	GLUED 			= 1, ## Sticks to its target.
	SIMPLE 			= 2, ## Follows its target with an optional offset.
	GROUP 			= 3, ## Follows multiple targets with option to dynamically reframe itself.
	PATH 			= 4, ## Follows a target while being positionally confined to a [Path3D] node.
	FRAMED 			= 5, ## Applies a dead zone on the frame and only follows its target when it tries to leave it.
	THIRD_PERSON 	= 6, ## Applies a [SpringArm3D] node to the target's position and allows for rotating around it.
}

## Determines the rotational logic for a given [param PhantomCamera3D].[br][br]
## The different modes has different functionalities and purposes, so
## choosing the correct mode depends on what each [param PhantomCamera3D]
## is meant to do.
enum LookAtMode {
	NONE 	= 0, ## Default - No Look At logic is applied.
	MIMIC 	= 1, ## Copies its target's rotational value.
	SIMPLE 	= 2, ## Looks at its target in a straight line.
	GROUP	= 3, ## Looks at the centre of its targets.
}

## Determines how often an inactive [param PhantomCamera3D] should update
## its positional and rotational values. This is meant to reduce the amount
## of calculations inactive [param PhantomCamera3D] are doing when idling
## to improve performance.
enum InactiveUpdateMode {
	ALWAYS, ## Always updates the [param PhantomCamera3D], even when it's inactive.
	NEVER, 	## Never updates the [param PhantomCamera3D] when it's inactive. Reduces the amount of computational resources when inactive.
#	EXPONENTIALLY,
}

enum FollowLockAxis {
	NONE	= 0,
	X 		= 1,
	Y 		= 2,
	Z 		= 3,
	XY		= 4,
	XZ		= 5,
	YZ		= 6,
	XYZ		= 7,
}

#endregion


#region Exported Properties

## To quickly preview a [param PhantomCamera3D] without adjusting its
## [member Priority], this property allows the selected [param PhantomCamera3D]
## to ignore the Priority system altogether and forcefully become the active
## one. It's partly designed to work within the [param viewfinder], and will be
## disabled when running a build export of the game.
@export var priority_override: bool = false:
	set(value):
		priority_override = value
		if Engine.is_editor_hint():
			if value:
				if not Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME): return
				Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME).pcam_priority_override.emit(self, priority_override)
			else:
				if not Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME): return
				Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME).pcam_priority_override.emit(self, priority_override)
	get:
		return priority_override


## It defines which [param PhantomCamera3D] a scene's [param Camera3D] should
## be corresponding with and be attached to. This is decided by the
## [param PhantomCamera3D] with the highest [param priority].
## [br][br]
## Changing [param priority] will send an event to the scene's
## [PhantomCameraHost], which will then determine whether if the
## [param priority] value is greater than or equal to the currently
## highest [param PhantomCamera3D]'s in the scene. The
## [param PhantomCamera3D] with the highest value will then reattach the
## Camera accordingly.
@export var priority: int = 0:
	set = set_priority,
	get = get_priority


## Determines the positional logic for a given [param PhantomCamera3D].
## The different modes have different functionalities and purposes, so
## choosing the correct one depends on what each [param PhantomCamera3D]
## is meant to do.
@export var follow_mode: FollowMode = FollowMode.NONE:
	set(value):
		follow_mode = value

		if follow_mode == FollowMode.NONE:
			_should_follow = false
			top_level = false
			_is_parents_physics()
			notify_property_list_changed()
			return

		match follow_mode:
			FollowMode.PATH:
				if is_instance_valid(follow_path):
					_should_follow_checker()
				else:
					_should_follow = false
			FollowMode.GROUP:
				_follow_targets_size_check()
			_:
				_should_follow_checker()

		if follow_mode == FollowMode.FRAMED:
			if _follow_framed_initial_set and follow_target:
				_follow_framed_initial_set = false
				dead_zone_changed.connect(_on_dead_zone_changed)
		else:
			if  dead_zone_changed.is_connected(_on_dead_zone_changed):
				dead_zone_changed.disconnect(_on_dead_zone_changed)

		if follow_mode == FollowMode.THIRD_PERSON:
			top_level = false
			_is_third_person_follow = true
		else:
			top_level = true
			_is_third_person_follow = false

		follow_mode_changed.emit()
		notify_property_list_changed()

		## NOTE - Warning that Look At + Follow Mode hasn't been fully tested together yet
		if look_at_mode != LookAtMode.NONE:
			print_rich("[color=#EAA15E]Warning: Using both Look At and Follow Mode on the same PCam3D has not been fully tested yet, proceed with caution![/color]")
	get:
		return follow_mode

## Determines which target should be followed.
## The [param Camera3D] will follow the position of the Follow Target based on
## the [member follow_mode] type and its parameters.
@export var follow_target: Node3D = null:
	set = set_follow_target,
	get = get_follow_target

## Defines the targets that the [param PhantomCamera3D] should be following.
@export var follow_targets: Array[Node3D] = []:
	set = set_follow_targets,
	get = get_follow_targets

## Determines the [Path3D] node the [param PhantomCamera3D]
## should be bound to.
## The [param PhantomCamera3D] will follow the position of the
## [member follow_target] while sticking to the closest point on this path.
@export var follow_path: Path3D = null:
	set = set_follow_path,
	get = get_follow_path


## Determines the rotational logic for a given [param PhantomCamera3D].
## The different modes has different functionalities and purposes,
## so choosing the correct mode depends on what each
## [param PhantomCamera3D] is meant to do.
@export var look_at_mode: LookAtMode = LookAtMode.NONE:
	set(value):
		look_at_mode = value

		if look_at_mode == LookAtMode.NONE:
			_should_look_at = false
			notify_property_list_changed()
			return

		if not look_at_mode == LookAtMode.GROUP:
			if look_at_target is Node3D:
				_should_look_at = true
		else: # If Look At Group
			_look_at_targets_size_check()
		notify_property_list_changed()

		## NOTE - Warning that Look At + Follow Mode hasn't been fully tested together yet
		if follow_mode != FollowMode.NONE:
			print_rich("[color=#EAA15E]Warning: Using both Look At and Follow Mode on the same PCam3D has not been fully tested yet, proceed with caution![/color]")
	get:
		return look_at_mode

## Determines which target should be looked at.
## The [param PhantomCamera3D] will update its rotational value as the
## target changes its position.
@export var look_at_target: Node3D = null:
	set = set_look_at_target,
	get = get_look_at_target

## Defines the targets that the camera should looking at.
## It will be looking at the centre of all the assigned targets.
@export var look_at_targets: Array[Node3D] = []:
	set = set_look_at_targets,
	get = get_look_at_targets


## Defines how [param ]PhantomCamera3Ds] transition between one another.
## Changing the tween values for a given [param PhantomCamera3D]
## determines how transitioning to that instance will look like.
## This is a resource type that can be either used for one
## [param PhantomCamera] or reused across multiple - both 2D and 3D.
## By default, all [param PhantomCameras] will use a [param linear]
## transition, [param easeInOut] ease with a [param 1s] duration.
@export var tween_resource: PhantomCameraTween = PhantomCameraTween.new():
	set = set_tween_resource,
	get = get_tween_resource

## If enabled, the moment a [param PhantomCamera3D] is instantiated into
## a scene, and has the highest priority, it will perform its tween transition.
## This is most obvious if a [param PhantomCamera3D] has a long duration and
## is attached to a playable character that can be moved the moment a scene
## is loaded. Disabling the [param tween_on_load] property will
## disable this behaviour and skip the tweening entirely when instantiated.
@export var tween_on_load: bool = true:
	set = set_tween_on_load,
	get = get_tween_on_load


## Determines how often an inactive [param PhantomCamera3D] should update
## its positional and rotational values. This is meant to reduce the amount
## of calculations inactive [param PhantomCamera3Ds] are doing when idling
## to improve performance.
@export var inactive_update_mode: InactiveUpdateMode = InactiveUpdateMode.ALWAYS:
	set = set_inactive_update_mode,
	get = get_inactive_update_mode


## Determines which layers this [param PhantomCamera3D] should be able to communicate with [PhantomCameraHost] nodes.[br]
## A corresponding layer needs to be set on the [PhantomCameraHost] node.
@export_flags_3d_render var host_layers: int = 1:
	set = set_host_layers,
	get = get_host_layers


## A resource type that allows for overriding the [param Camera3D] node's
## properties.
@export var camera_3d_resource: Camera3DResource = null:
	set = set_camera_3d_resource,
	get = get_camera_3d_resource


## Overrides the [member Camera3D.attribuets] resource property.
@export var attributes: CameraAttributes = null:
	set = set_attributes,
	get = get_attributes


## Overrides the [member Camera3D.environment] resource property.
@export var environment: Environment = null:
	set = set_environment,
	get = get_environment


@export_group("Follow Parameters")
## Offsets the [member follow_target] position.
@export var follow_offset: Vector3 = Vector3.ZERO:
	set = set_follow_offset,
	get = get_follow_offset

## Applies a damping effect on the camera's movement.
## Leading to heavier / slower camera movement as the targeted node moves around.
## This is useful to avoid sharp and rapid camera movement.
@export var follow_damping: bool = false:
	set = set_follow_damping,
	get = get_follow_damping

## Defines the damping amount. The ideal range should be somewhere between 0-1.[br][br]
## The damping amount can be specified in the individual axis.[br][br]
## [b]Lower value[/b] = faster / sharper camera movement.[br]
## [b]Higher value[/b] = slower / heavier camera movement.
@export_custom(PROPERTY_HINT_LINK, "")
var follow_damping_value: Vector3 = Vector3(0.1, 0.1, 0.1):
	set = set_follow_damping_value,
	get = get_follow_damping_value


## Prevents the [param PhantomCamera2D] from moving in a designated axis.
## This can be enabled or disabled at runtime or from the editor directly.
@export var follow_axis_lock: FollowLockAxis = FollowLockAxis.NONE:
	set = set_follow_axis_lock,
	get = get_follow_axis_lock
var _follow_axis_is_locked: bool = false
var _follow_axis_lock_value: Vector3 = Vector3.ZERO


## Sets a distance offset from the centre of the target's position.
## The distance is applied to the [param PhantomCamera3D]'s local z axis.
@export var follow_distance: float = 1:
	set = set_follow_distance,
	get = get_follow_distance

## Enables the [param PhantomCamera3D] to automatically distance
## itself as the [param follow targets] move further apart.[br]
## It looks at the longest axis between the different targets and interpolates
## the distance length between the [member auto_follow_distance_min] and
## [member follow_group_distance] properties.[br][br]
## Note: Enabling this property hides and disables the [member follow_distance]
## property as this effectively overrides that property.
@export var auto_follow_distance: bool = false:
	set = set_auto_follow_distance,
	get = get_auto_follow_distance

## Sets the minimum distance between the Camera and centre of [AABB].
## [br][br]
## Note: This distance will only ever be reached when all the targets are in
## the exact same [param Vector3] coordinate, which will very unlikely
## happen, so adjust the value here accordingly.
## [br][br]
## If only one follow target is assigned to [member follow_targets], this value will be used as the `follow_distance`.
@export var auto_follow_distance_min: float = 1:
	set = set_auto_follow_distance_min,
	get = get_auto_follow_distance_min

## Sets the maximum distance between the Camera and centre of [AABB].
@export var auto_follow_distance_max: float = 5:
	set = set_auto_follow_distance_max,
	get = get_auto_follow_distance_max

## Determines how fast the [member auto_follow_distance] moves between the
## maximum and minimum distance. The higher the value, the sooner the
## maximum distance is reached.[br][br]
## This value should be based on the sizes of the [member auto_follow_distance_min]
## and [member auto_follow_distance_max].[br]
## E.g. if the value between the [member auto_follow_distance_min] and
## [member auto_follow_distance_max] is small, consider keeping the number low
## and vice versa.
@export var auto_follow_distance_divisor: float = 10:
	set = set_auto_follow_distance_divisor,
	get = get_auto_follow_distance_divisor


@export_subgroup("Dead Zones")
## Defines the horizontal dead zone area. While the target is within it, the
## [param PhantomCamera3D] will not move in the horizontal axis.
## If the targeted node leaves the horizontal bounds, the
## [param PhantomCamera3D] will follow the target horizontally to keep
## it within bounds.
@export_range(0, 1) var dead_zone_width: float = 0:
	set(value):
		dead_zone_width = value
		dead_zone_changed.emit()
	get:
		return dead_zone_width

## Defines the vertical dead zone area. While the target is within it, the
## [param PhantomCamera3D] will not move in the vertical axis.
## If the targeted node leaves the vertical bounds, the
## [param PhantomCamera3D] will follow the target horizontally to keep
## it within bounds.
@export_range(0, 1) var dead_zone_height: float = 0:
	set(value):
		dead_zone_height = value
		dead_zone_changed.emit()
	get:
		return dead_zone_height

## Enables the dead zones to be visible when running the game from the editor.
## Dead zones will never be visible in build exports.
@export var show_viewfinder_in_play: bool = false

## Defines the position of the [member follow_target] within the viewport.[br]
## This is only used for when [member follow_mode] is set to [param Framed].
@export_subgroup("Spring Arm")

## Applies a rotational offset to the Third Person [member follow_mode] in the [code]X[/code] axis.
@export_range(-360, 360, 0.1,"or_greater", "or_less", "radians_as_degrees")
var vertical_rotation_offset: float = 0:
	set = set_vertical_rotation_offset,
	get = get_vertical_rotation_offset

## Applies a rotational offset to the Third Person [member follow_mode] in the [code]Y[/code] axis.
@export_range(-360, 360, 0.1, "or_greater", "or_less", "radians_as_degrees")
var horizontal_rotation_offset: float = 0:
	set = set_horizontal_rotation_offset,
	get = get_horizontal_rotation_offset

## Defines the [member SpringArm3D.spring_length].
@export var spring_length: float = 1:
	set = set_spring_length,
	get = get_spring_length

## Defines the [member SpringArm3D.collision_mask] node's Collision Mask.
@export_flags_3d_physics var collision_mask: int = 1:
	set = set_collision_mask,
	get = get_collision_mask

## Defines the [member SpringArm3D.shape] node's Shape3D.
@export var shape: Shape3D = null:
	set = set_shape,
	get = get_shape

## Defines the [member SpringArm3D.margin] node's Margin.
@export var margin: float = 0.01:
	set = set_margin,
	get = get_margin


@export_group("Look At Parameters")
## Offsets the target's [param Vector3] position that the
## [param PhantomCamera3D] is looking at.
@export var look_at_offset: Vector3 = Vector3.ZERO:
	set = set_look_at_offset,
	get = get_look_at_offset

## Applies a damping effect on the camera's rotation.
## Leading to heavier / slower camera movement as the targeted node moves around.
## This is useful to avoid sharp and rapid camera rotation.
@export var look_at_damping: bool = false:
	set = set_look_at_damping,
	get = get_look_at_damping

## Defines the Rotational damping amount. The ideal range is typically somewhere between 0-1.[br][br]
## The damping amount can be specified in the individual axis.[br][br]
## [b]Lower value[/b] = faster / sharper camera rotation.[br]
## [b]Higher value[/b] = slower / heavier camera rotation.
@export_range(0.0, 1.0, 0.001, "or_greater") var look_at_damping_value: float = 0.25:
	set = set_look_at_damping_value,
	get = get_look_at_damping_value

@export_subgroup("Up Direction")

## Defines the upward direction of the [param PhantomCamera3D] when [member look_at_mode] is set. [br]
## This value will be overriden if [member up_target] is defined.
@export var up: Vector3 = Vector3.UP:
	set = set_up,
	get = get_up

## Applies and continuously updates the [param up] direction of the [param PhantomCamera3D] based on this target when [member look_at_mode] is set.[br]
## Setting a value here will override the [member up] value.
@export var up_target: Node3D = null:
	set = set_up_target,
	get = get_up_target


@export_group("Noise")
## Applies a noise, or shake, to a [Camera3D].[br]
## Once set, the noise will run continuously after the tween to the [PhantomCamera3D] instance is complete.
@export var noise: PhantomCameraNoise3D = null:
	set = set_noise,
	get = get_noise

## If true, will trigger the noise while in the editor.[br]
## Useful in cases where you want to temporarily disalbe the noise in the editor without removing
## the resource.[br][br]
## [b]Note:[/b] This property has no effect on runtime behaviour.
@export var _preview_noise: bool = true:
	set(value):
		_preview_noise = value
		if not value:
			_transform_noise = Transform3D()

## Enable a corresponding layer for a [member PhantomCameraNoiseEmitter3D.noise_emitter_layer]
## to make this [PhantomCamera3D] be affect by it.
@export_flags_3d_render var noise_emitter_layer: int = 0:
	set = set_noise_emitter_layer,
	get = get_noise_emitter_layer

#endregion

#region Private Variables

var _is_active: bool = false

var _is_third_person_follow: bool = false
var _camera_target: Node3D = self # Calculates the position of the camera in the editor, uses instantiated SpringArm3D node when running the scene

var _should_follow: bool = false
var _follow_target_physics_based: bool = false
var _physics_interpolation_enabled: bool = false ## TOOD - Should be enbled once toggling physics_interpolation_mode ON, when previously OFF, works in 3D

var _has_multiple_follow_targets: bool = false
var _follow_targets_single_target_index: int = 0
var _follow_targets: Array[Node3D] = []

var _should_look_at: bool = false
var _look_at_target_physics_based: bool = false

var _has_multiple_look_at_targets: bool = false
var _look_at_targets_single_target_index: int = 0

var _current_rotation: Vector3 = Vector3.ZERO

var _up: Vector3 = Vector3.UP
var _has_up_target: bool = false

var _follow_target_position: Vector3 = Vector3.ZERO
var _look_at_target_position: Vector3 = Vector3.ZERO

var _transform_output: Transform3D = Transform3D()
var _transform_noise: Transform3D = Transform3D()

var _tween_skip: bool = false

var _follow_velocity_ref: Vector3 = Vector3.ZERO # Stores and applies the velocity of the movement

var _follow_framed_initial_set: bool = false
var _follow_framed_offset: Vector3 = Vector3.ZERO

var _follow_spring_arm: SpringArm3D = null
var _has_follow_spring_arm: bool = false

var _has_noise_resource: bool = false


# NOTE - Temp solution until Godot has better plugin autoload recognition out-of-the-box.
var _phantom_camera_manager: Node = null

#endregion

#region Public Variable

var tween_duration: float:
	set = set_tween_duration,
	get = get_tween_duration
var tween_transition: PhantomCameraTween.TransitionType:
	set = set_tween_transition,
	get = get_tween_transition
var tween_ease: PhantomCameraTween.EaseType:
	set = set_tween_ease,
	get = get_tween_ease

var keep_aspect: int:
	set = set_keep_aspect,
	get = get_keep_aspect
var cull_mask: int:
	set = set_cull_mask,
	get = get_cull_mask
var h_offset: float:
	set = set_h_offset,
	get = get_h_offset
var v_offset: float:
	set = set_v_offset,
	get = get_v_offset
var projection: Camera3DResource.ProjectionType:
	set = set_projection,
	get = get_projection
var fov: float:
	set = set_fov,
	get = get_fov
var size: float:
	set = set_size,
	get = get_size
var frustum_offset: Vector2:
	set = set_frustum_offset,
	get = get_frustum_offset
var far: float:
	set = set_far,
	get = get_far
var near: float:
	set = set_near,
	get = get_near

var viewport_position: Vector2

#endregion


#region Private Functions

func _validate_property(property: Dictionary) -> void:
	################
	## Follow Target
	################
	if property.name == "follow_target":
		if follow_mode == FollowMode.NONE or \
		follow_mode == FollowMode.GROUP:
			property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "follow_path" and \
	follow_mode != FollowMode.PATH:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	####################
	## Follow Parameters
	####################
	if follow_mode == FollowMode.NONE:
		match property.name:
			"follow_offset", \
			"follow_damping", \
			"follow_damping_value", \
			"follow_axis_lock":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "follow_offset":
		if follow_mode == FollowMode.PATH or \
		follow_mode == FollowMode.GLUED:
			property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "follow_damping_value" and not follow_damping:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "follow_offset":
		if follow_mode == FollowMode.PATH:
			property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "follow_distance":
		if not follow_mode == FollowMode.FRAMED:
			if not follow_mode == FollowMode.GROUP or \
			auto_follow_distance: \
				property.usage = PROPERTY_USAGE_NO_EDITOR

	###############
	## Group Follow
	###############
	if property.name == "follow_targets" and \
	not follow_mode == FollowMode.GROUP:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "auto_follow_distance" and \
	not follow_mode == FollowMode.GROUP:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	if not auto_follow_distance or not follow_mode == FollowMode.GROUP:
		match property.name:
			"auto_follow_distance_min", \
			"auto_follow_distance_max", \
			"auto_follow_distance_divisor":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	###############
	## Framed Follow
	###############
	if not follow_mode == FollowMode.FRAMED:
		match property.name:
			"dead_zone_width", \
			"dead_zone_height", \
			"show_viewfinder_in_play":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	######################
	## Third Person Follow
	######################
	if not follow_mode == FollowMode.THIRD_PERSON:
		match property.name:
			"vertical_rotation_offset", \
			"horizontal_rotation_offset", \
			"spring_length", \
			"collision_mask", \
			"shape", \
			"margin":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	##########
	## Look At
	##########
	if look_at_mode == LookAtMode.NONE:
		match property.name:
			"look_at_target", \
			"look_at_offset" , \
			"look_at_damping", \
			"look_at_damping_value", \
			"up", \
			"up_target":
				property.usage = PROPERTY_USAGE_NO_EDITOR
	elif look_at_mode == LookAtMode.GROUP:
		match property.name:
			"look_at_target":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "look_at_target":
		if look_at_mode == LookAtMode.NONE or \
		look_at_mode == LookAtMode.GROUP:
			property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "look_at_targets" and \
	not look_at_mode == LookAtMode.GROUP:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "look_at_damping_value" and \
	not look_at_damping:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "up" and _has_up_target:
		property.usage = PROPERTY_USAGE_NO_EDITOR


func _enter_tree() -> void:
	_phantom_camera_manager = Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME)
	_tween_skip = !tween_on_load

	_phantom_camera_manager.pcam_added(self)

	priority_override = false

	if not visibility_changed.is_connected(_check_visibility):
		visibility_changed.connect(_check_visibility)

	match follow_mode:
		FollowMode.NONE:
			_is_parents_physics()
		FollowMode.PATH:
			if is_instance_valid(follow_path):
				_should_follow_checker()
			else:
				_should_follow = false
		FollowMode.GROUP:
			_follow_targets_size_check()
			_should_follow_checker()
		_:
			_should_follow_checker()

	_should_look_at_checker()
	if look_at_mode == LookAtMode.GROUP:
		_look_at_targets_size_check()

	#if not get_parent() is SpringArm3D:
		#if look_at_target:
			#_look_at_target_node = look_at_target
		#elif look_at_targets:
			#_look_at_group_nodes.clear()
			#for path in look_at_targets:
				#if not path.is_empty() and path:
					#_should_look_at = true
					#_has_look_at_targets = true
					#_look_at_group_nodes.append(path)


func _exit_tree() -> void:
	if not follow_mode == FollowMode.GROUP:
		follow_targets = []

	if not is_instance_valid(_phantom_camera_manager): return
	_phantom_camera_manager.pcam_removed(self)


func _ready():
	match follow_mode:
		FollowMode.THIRD_PERSON:
			_is_third_person_follow = true
			if _should_follow: _transform_output.origin = _get_target_position_offset_distance()
			if not Engine.is_editor_hint():
				if not is_instance_valid(_follow_spring_arm):
					_follow_spring_arm = SpringArm3D.new()
					_follow_spring_arm.top_level = true
					_follow_spring_arm.spring_length = spring_length
					_follow_spring_arm.collision_mask = collision_mask
					_follow_spring_arm.shape = shape
					_follow_spring_arm.margin = margin
					# Stores the rotation value as the rotation gets skewed after
					# the SpringArm3D is instantiated for some reason...
					var initial_rotation: Vector3 = global_rotation
					if _should_follow: _follow_spring_arm.add_excluded_object(follow_target)
					get_parent().add_child.call_deferred(_follow_spring_arm)

					# Waits for the SpringArm3D to be ready and then apply rotation
					# Resolves an issue most prominent in Godot 4.4
					await _follow_spring_arm.ready
					reparent.call_deferred(_follow_spring_arm)
					_camera_target = _follow_spring_arm
					_follow_spring_arm.global_position = _get_target_position_offset() if is_instance_valid(follow_target) else global_position
					_follow_spring_arm.global_rotation = initial_rotation
					_has_follow_spring_arm = true
					top_level = false
		FollowMode.FRAMED:
			if not Engine.is_editor_hint():
				if is_instance_valid(follow_target):
					_follow_framed_offset = global_position - _get_target_position_offset()
				_current_rotation = global_rotation
		FollowMode.GROUP:
			_follow_targets_size_check()
		_:
			if is_instance_valid(follow_target):
				_transform_output.origin = _get_target_position_offset()
			else:
				_transform_output.origin = global_position

	if not Engine.is_editor_hint():
		_preview_noise = true

	## NOTE - Only here to set position for Framed View on startup.
	## Should be removed once https://github.com/ramokz/phantom-camera/issues/161 is complete
	_transform_output = global_transform

	_phantom_camera_manager.noise_3d_emitted.connect(_noise_emitted)


func _process(delta: float) -> void:
	if _follow_target_physics_based or _is_active: return
	process_logic(delta)


func _physics_process(delta: float) -> void:
	if not _follow_target_physics_based or _is_active: return
	process_logic(delta)


func process_logic(delta: float) -> void:
	if _is_active:
		if _has_noise_resource and _preview_noise:
			_transform_noise = noise.get_noise_transform(delta)
	else:
		match inactive_update_mode:
			InactiveUpdateMode.NEVER: return
			# InactiveUpdateMode.EXPONENTIALLY:
			# TODO - Trigger positional updates less frequently as more PCams gets added

	if _should_follow:
		_follow(delta)
	else:
		_transform_output.origin = global_position

	if _should_look_at:
		_look_at(delta)
	elif not _is_third_person_follow:
		_transform_output.basis = global_basis

	if _follow_axis_is_locked:
		match follow_axis_lock:
			FollowLockAxis.X:
				_transform_output.origin.x = _follow_axis_lock_value.x
			FollowLockAxis.Y:
				_transform_output.origin.y = _follow_axis_lock_value.y
			FollowLockAxis.Z:
				_transform_output.origin.z = _follow_axis_lock_value.z
			FollowLockAxis.XY:
				_transform_output.origin.x = _follow_axis_lock_value.x
				_transform_output.origin.y = _follow_axis_lock_value.y
			FollowLockAxis.XZ:
				_transform_output.origin.x = _follow_axis_lock_value.x
				_transform_output.origin.z = _follow_axis_lock_value.z
			FollowLockAxis.YZ:
				_transform_output.origin.y = _follow_axis_lock_value.y
				_transform_output.origin.z = _follow_axis_lock_value.z
			FollowLockAxis.XYZ:
				_transform_output.origin.x = _follow_axis_lock_value.x
				_transform_output.origin.y = _follow_axis_lock_value.y
				_transform_output.origin.z = _follow_axis_lock_value.z


func _follow(delta: float) -> void:
	_set_follow_position()
	_interpolate_position(delta)

func _look_at(delta: float) -> void:
	_set_look_at_position()
	_interpolate_rotation(delta)


func _set_follow_position() -> void:
	match follow_mode:
		FollowMode.GLUED:
			_follow_target_position = follow_target.global_position

		FollowMode.SIMPLE:
			_follow_target_position = _get_target_position_offset()

		FollowMode.GROUP:
			if _has_multiple_follow_targets:
				var bounds: AABB = AABB(_follow_targets[0].global_position, Vector3.ZERO)
				for target in _follow_targets:
					bounds = bounds.expand(target.global_position)
				var distance: float
				if auto_follow_distance:
					distance = lerpf(auto_follow_distance_min, auto_follow_distance_max, bounds.get_longest_axis_size() / auto_follow_distance_divisor)
					distance = clampf(distance, auto_follow_distance_min, auto_follow_distance_max)
				else:
					distance = follow_distance

				_follow_target_position = \
					bounds.get_center() + \
					follow_offset + \
					global_basis.z * \
					distance
			else:
				_follow_target_position = \
					follow_targets[_follow_targets_single_target_index].global_position + \
					follow_offset + \
					global_basis.z * \
					auto_follow_distance_min

		FollowMode.PATH:
			var path_position: Vector3 = follow_path.global_position
			_follow_target_position = \
				follow_path.curve.get_closest_point(
					follow_target.global_position - path_position
				) + path_position

		FollowMode.FRAMED:
			if not Engine.is_editor_hint():
				if not _is_active:
					_follow_target_position = _get_target_position_offset_distance()
				else:
					viewport_position = get_viewport().get_camera_3d().unproject_position(_get_target_position_offset())
					var visible_rect_size: Vector2 = get_viewport().get_visible_rect().size
					viewport_position = viewport_position / visible_rect_size
					_current_rotation = global_rotation

					if _current_rotation != global_rotation:
						_follow_target_position = _get_target_position_offset_distance()

					if _get_framed_side_offset() != Vector2.ZERO:
						var target_position: Vector3 = _get_target_position_offset() + _follow_framed_offset
						var glo_pos: Vector3

						if dead_zone_width == 0 || dead_zone_height == 0:
							if dead_zone_width == 0 && dead_zone_height != 0:
								glo_pos = _get_target_position_offset_distance()
								glo_pos.z = target_position.z
								_follow_target_position = glo_pos
							elif dead_zone_width != 0 && dead_zone_height == 0:
								glo_pos = _get_target_position_offset_distance()
								glo_pos.x = target_position.x
								_follow_target_position = glo_pos
							else:
								_follow_target_position = _get_target_position_offset_distance()
						else:
							if _current_rotation != global_rotation:
								var opposite: float = sin(-global_rotation.x) * follow_distance + _get_target_position_offset().y
								glo_pos.y = _get_target_position_offset().y + opposite
								glo_pos.z = sqrt(pow(follow_distance, 2) - pow(opposite, 2)) + _get_target_position_offset().z
								glo_pos.x = global_position.x

								_follow_target_position = glo_pos
								_current_rotation = global_rotation
							else:
								dead_zone_reached.emit()
								_follow_target_position = target_position
					else:
						_follow_framed_offset = global_position - _get_target_position_offset()
						_current_rotation = global_rotation
						return
			else:
				_follow_target_position = _get_target_position_offset_distance()
				var unprojected_position: Vector2 = _get_raw_unprojected_position()
				var viewport_width: float = get_viewport().size.x
				var viewport_height: float = get_viewport().size.y
				var camera_aspect: int = get_viewport().get_camera_3d().keep_aspect
				var visible_rect_size: Vector2 = get_viewport().get_visible_rect().size

				unprojected_position = unprojected_position - visible_rect_size / 2
				if camera_aspect == Camera3D.KEEP_HEIGHT:
					# Landscape View
					var aspect_ratio_scale: float = viewport_width / viewport_height
					unprojected_position.x = (unprojected_position.x / aspect_ratio_scale + 1) / 2
					unprojected_position.y = (unprojected_position.y + 1) / 2
				else:
					# Portrait View
					var aspect_ratio_scale: float = viewport_height / viewport_width
					unprojected_position.x = (unprojected_position.x + 1) / 2
					unprojected_position.y = (unprojected_position.y / aspect_ratio_scale + 1) / 2

				viewport_position = unprojected_position

		FollowMode.THIRD_PERSON:
			if not Engine.is_editor_hint():
				if not _has_follow_spring_arm: return
				_follow_target_position = _get_target_position_offset()
			else:
				_follow_target_position = _get_target_position_offset_distance_direction()


func _set_look_at_position() -> void:
	match look_at_mode:
		LookAtMode.MIMIC:
			_look_at_target_position = global_position - look_at_target.global_basis.z

		LookAtMode.SIMPLE:
			_look_at_target_position =look_at_target.global_position

		LookAtMode.GROUP:
			if not _has_multiple_look_at_targets:
				_look_at_target_position =look_at_targets[_look_at_targets_single_target_index].global_position
			else:
				var bounds: AABB = AABB(look_at_targets[0].global_position, Vector3.ZERO)
				for node in look_at_targets:
					bounds = bounds.expand(node.global_position)
				_look_at_target_position =bounds.get_center()


func _get_target_position_offset() -> Vector3:
	return follow_target.global_position + follow_offset


func _get_target_position_offset_distance() -> Vector3:
	return _get_target_position_offset() + \
	transform.basis.z * follow_distance

# Used in the editor for setting initial Third Person position and angle
func _get_target_position_offset_distance_direction() -> Vector3:
	return _get_target_position_offset() + \
	follow_target.global_basis.z * \
	follow_distance * \
	Quaternion(follow_target.global_basis.x, vertical_rotation_offset) * \
	Quaternion(follow_target.global_basis.y, horizontal_rotation_offset)


func _set_follow_velocity(index: int, value: float) -> void:
	_follow_velocity_ref[index] = value

func _interpolate_position(delta: float) -> void:
	if follow_damping and not Engine.is_editor_hint():
		if not _is_third_person_follow:
			global_position = _follow_target_position
			for i in 3:
				_transform_output.origin[i] = _smooth_damp(
					global_position[i],
					_transform_output.origin[i],
					i,
					_follow_velocity_ref[i],
					_set_follow_velocity,
					follow_damping_value[i],
					delta
				)
		else:
			for i in 3:
				_camera_target.global_position[i] = _smooth_damp(
					_follow_target_position[i],
					_camera_target.global_position[i],
					i,
					_follow_velocity_ref[i],
					_set_follow_velocity,
					follow_damping_value[i],
					delta
				)
			_transform_output.origin = global_position
	else:
		_camera_target.global_position = _follow_target_position
		_transform_output.origin = global_position

	if _is_third_person_follow:
		var target_quat: Quaternion = _look_at_target_quat(_get_target_position_offset(), follow_target.global_basis.y)
		var target_basis: Basis = Basis(target_quat)
		_transform_output.basis = target_basis
		global_basis = target_basis


func _look_at_target_quat(target_position: Vector3, up_direction: Vector3 = Vector3.UP) -> Quaternion:
	var direction: Vector3 = -(target_position - global_position + look_at_offset).normalized()

	var basis_z: Vector3 = direction.normalized()
	var basis_x: Vector3 = up_direction.cross(basis_z)
	var basis_y: Vector3 = basis_z.cross(basis_x.normalized())

	var target_basis: Basis = Basis(basis_x, basis_y, basis_z)

	if target_basis.determinant() == 0:
		if target_basis.z == Vector3.UP:
			global_rotation_degrees.x = -90
		else:
			global_rotation_degrees.x = 90

		_transform_output.basis = global_basis
		return quaternion

	return target_basis.get_rotation_quaternion().normalized()

func _interpolate_rotation(delta: float) -> void:
	if _has_up_target:
		_up = up_target.global_basis.y

	var target_quat: Quaternion = _look_at_target_quat(_look_at_target_position, _up)

	if look_at_damping:
		var current_quat: Quaternion = quaternion.normalized()
		var damping_time: float = max(0.0001, look_at_damping_value)
		var t: float = min(1.0, delta / damping_time)

		var dot: float = current_quat.dot(target_quat)

		if dot < 0.0:
			target_quat = -target_quat
			dot = -dot

		dot = clampf(dot, -1.0, 1.0)

		var theta: float = acos(dot) * t
		var sin_theta: float = sin(theta)
		var sin_theta_total: float = sin(acos(dot))

		if is_zero_approx(sin_theta_total): return

		var ratio_a: float = cos(theta) - dot * sin_theta / sin_theta_total
		var ratio_b: float = sin_theta / sin_theta_total
		var output: Quaternion = current_quat * ratio_a + target_quat * ratio_b

		_transform_output.basis = Basis(output)
		quaternion = output
	else:
		_transform_output.basis = Basis(target_quat)
		quaternion = target_quat


func _smooth_damp(target_axis: float, self_axis: float, index: int, current_velocity: float, set_velocity: Callable, damping_time: float, delta: float) -> float:
		damping_time = maxf(0.0001, damping_time)
		var omega: float = 2 / damping_time
		var x: float = omega * delta
		var exponential: float = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x)
		var diff: float = self_axis - target_axis
		var _target_axis: float = target_axis

		var max_change: float = INF * damping_time
		diff = clampf(diff, -max_change, max_change)
		target_axis = self_axis - diff

		var temp: float = (current_velocity + omega * diff) * delta
		set_velocity.call(index, (current_velocity - omega * temp) * exponential)
		var output: float = target_axis + (diff + temp) * exponential

		## To prevent overshooting
		if (_target_axis - self_axis > 0.0) == (output > _target_axis):
			output = _target_axis
			set_velocity.call(index, (output - _target_axis) / delta)

		return output


func _get_raw_unprojected_position() -> Vector2:
	return get_viewport().get_camera_3d().unproject_position(follow_target.global_position + follow_offset)


func _on_dead_zone_changed() -> void:
	global_position = _get_target_position_offset_distance()


func _get_framed_side_offset() -> Vector2:
	var frame_out_bounds: Vector2

	if viewport_position.x < 0.5 - dead_zone_width / 2:
		# Is outside left edge
		frame_out_bounds.x = -1

	if viewport_position.y < 0.5 - dead_zone_height / 2:
		# Is outside top edge
		frame_out_bounds.y = 1

	if viewport_position.x > 0.5 + dead_zone_width / 2:
		# Is outside right edge
		frame_out_bounds.x = 1

	if viewport_position.y > 0.5001 + dead_zone_height / 2: # 0.501 to resolve an issue where the bottom vertical Dead Zone never becoming 0 when the Dead Zone Vertical parameter is set to 0
		# Is outside bottom edge
		frame_out_bounds.y = -1

	return frame_out_bounds


func _set_layer(current_layers: int, layer_number: int, value: bool) -> int:
	var mask: int = current_layers

	# From https://github.com/godotengine/godot/blob/51991e20143a39e9ef0107163eaf283ca0a761ea/scene/3d/camera_3d.cpp#L638
	if layer_number < 1 or layer_number > 20:
		printerr("Render layer must be between 1 and 20.")
	else:
		if value:
			mask |= 1 << (layer_number - 1)
		else:
			mask &= ~(1 << (layer_number - 1))

	return mask


func _check_visibility() -> void:
	_phantom_camera_manager.pcam_visibility_changed.emit(self)


func _follow_target_tree_exiting(target: Node) -> void:
	if target == follow_target:
		_should_follow = false
	if _follow_targets.has(target):
		_follow_targets.erase(target)


func _should_follow_checker() -> void:
	if follow_mode == FollowMode.NONE:
		_should_follow = false
		return

	if not follow_mode == FollowMode.GROUP:
		if is_instance_valid(follow_target):
			_should_follow = true
		else:
			_should_follow = false


func _follow_targets_size_check() -> void:
	var targets_size: int = 0
	_follow_target_physics_based = false
	_follow_targets = []
	for i in follow_targets.size():
		if follow_targets[i] == null: continue
		if follow_targets[i].is_inside_tree():
			_follow_targets.append(follow_targets[i])
			targets_size += 1
			_follow_targets_single_target_index = i
			_check_physics_body(follow_targets[i])
			if not follow_targets[i].tree_exiting.is_connected(_follow_target_tree_exiting):
				follow_targets[i].tree_exiting.connect(_follow_target_tree_exiting.bind(follow_targets[i]))

	match targets_size:
		0:
			_should_follow = false
			_has_multiple_follow_targets = false
		1:
			_should_follow = true
			_has_multiple_follow_targets = false
		_:
			_should_follow = true
			_has_multiple_follow_targets = true


func _look_at_target_tree_exiting(target: Node) -> void:
	if target == look_at_target:
		_should_look_at = false
	if look_at_targets.has(target):
		erase_look_at_targets(target)

func _up_target_tree_exiting() -> void:
	up_target = null


func _should_look_at_checker() -> void:
	if look_at_mode == LookAtMode.NONE:
		_should_look_at = false
		return

	if not look_at_mode == LookAtMode.GROUP:
		if is_instance_valid(look_at_target):
			_should_look_at = true
		else:
			_should_look_at = false


func _look_at_targets_size_check() -> void:
	var targets_size: int = 0
	_look_at_target_physics_based = false

	for i in look_at_targets.size():
		if is_instance_valid(look_at_targets[i]):
			targets_size += 1
			_look_at_targets_single_target_index = i
			_check_physics_body(look_at_targets[i])
			if not look_at_targets[i].tree_exiting.is_connected(_look_at_target_tree_exiting):
				look_at_targets[i].tree_exiting.connect(_look_at_target_tree_exiting.bind(look_at_targets[i]))

	match targets_size:
		0:
			_should_look_at = false
			_has_multiple_look_at_targets = false
		1:
			_should_look_at = true
			_has_multiple_look_at_targets = false
		_:
			_should_look_at = true
			_has_multiple_look_at_targets = true


func _noise_emitted(emitter_noise_output: Transform3D, emitter_layer: int) -> void:
	if noise_emitter_layer & emitter_layer != 0:
		noise_emitted.emit(emitter_noise_output)


func _check_physics_body(target: Node3D) -> void:
	if target is PhysicsBody3D:
		var show_jitter_tips := ProjectSettings.get_setting("phantom_camera/tips/show_jitter_tips")
		var physics_interpolation_enabled := ProjectSettings.get_setting("physics/common/physics_interpolation")

		## NOTE - Feature Toggle
		if Engine.get_version_info().major == 4 and \
		Engine.get_version_info().minor < 4:
			if show_jitter_tips == null: # Default value is null when referencing custom Project Setting
				print_rich("Following or Looking at a [b]PhysicsBody3D[/b] node will likely result in jitter - on lower physics ticks in particular.")
				print_rich("If possible, will recommend upgrading to Godot 4.4, as it has built-in support for 3D Physics Interpolation, which will mitigate this issue.")
				print_rich("Until then, try following the guide on the [url=https://phantom-camera.dev/support/faq#i-m-seeing-jitter-what-can-i-do]documentation site[/url] for better results.")
				print_rich("This tip can be disabled from within [code]Project Settings / Phantom Camera / Tips / Show Jitter Tips[/code]")
			return
		## NOTE - Only supported in Godot 4.4 or above
		elif not physics_interpolation_enabled and show_jitter_tips == null: # Default value is null when referencing custom Project Setting
			printerr("Physics Interpolation is disabled in the Project Settings, recommend enabling it to smooth out physics-based camera movement")
			print_rich("This tip can be disabled from within [code]Project Settings / Phantom Camera / Tips / Show Jitter Tips[/code]")
		_follow_target_physics_based = true
	else:
		_is_parents_physics(target)
	physics_target_changed.emit()


func _is_parents_physics(target: Node = self) -> void:
	var current_node: Node = target
	while current_node:
		current_node = current_node.get_parent()
		if not current_node is PhysicsBody3D: continue
		_follow_target_physics_based = true


func _camera_resource_changed() -> void:
	camera_3d_resource_changed.emit()

#endregion

#region Public Functions

# TBD
#func get_unprojected_position() -> Vector2:
	#var unprojected_position: Vector2 = _get_raw_unprojected_position()
	#var viewport_width: float = get_viewport().size.x
	#var viewport_height: float = get_viewport().size.y
	#var camera_aspect: Camera3D.KeepAspect = get_viewport().get_camera_3d().keep_aspect
	#var visible_rect_size: Vector2 = get_viewport().size
#
	#unprojected_position = unprojected_position - visible_rect_size / 2
	#if camera_aspect == Camera3D.KeepAspect.KEEP_HEIGHT:
##	print("Landscape View")
		#var aspect_ratio_scale: float = viewport_width / viewport_height
		#unprojected_position.x = (unprojected_position.x / aspect_ratio_scale + 1) / 2
		#unprojected_position.y = (unprojected_position.y + 1) / 2
	#else:
##	print("Portrait View")
		#var aspect_ratio_scale: float = viewport_height / viewport_width
		#unprojected_position.x = (unprojected_position.x + 1) / 2
		#unprojected_position.y = (unprojected_position.y / aspect_ratio_scale + 1) / 2
#
	#return unprojected_position


## Returns the [Transform3D] value based on the [member follow_mode] / [member look_at_mode] target value.
func get_transform_output() -> Transform3D:
	return _transform_output


## Returns the noise [Transform3D] value.
func get_noise_transform() -> Transform3D:
	return _transform_noise


## Emits a noise based on a custom [Transform3D] value.[br]
## Use this function if you wish to make use of external noise patterns from, for example, other addons.
func emit_noise(value: Transform3D) -> void:
	noise_emitted.emit(value)


## Teleports the [param PhantomCamera3D] and [Camera3D] to their designated position,
## bypassing the damping process.
func teleport_position() -> void:
	_follow_velocity_ref = Vector3.ZERO
	_set_follow_position()
	_transform_output.origin = _follow_target_position
	_phantom_camera_manager.pcam_teleport.emit(self)


# TODO: Enum link does link to anywhere is being tracked in: https://github.com/godotengine/godot/issues/106828
## Returns [code]true[/code] if this [param PhantomCamera3D]'s [member follow_mode] is not set to [constant FollowMode.NONE]
## and has a valid [member follow_target].
func is_following() -> bool:
	return _should_follow

# TODO: Enum link does link to anywhere is being tracked in: https://github.com/godotengine/godot/issues/106828
## Returns [code]true[/code] if this [param PhantomCamera3D]'s [member look_at_mode] is not set to [constant LookAtMode.NONE]
## and has a valid [member look_at_target].
func is_looking() -> bool:
	return _should_look_at

#endregion


#region Setter & Getter Functions

## Assigns the value of the [param has_tweened] property.[br]
## [b][color=yellow]Important:[/color][/b] This value can only be changed
## from the [PhantomCameraHost] script.
func set_tween_skip(caller: Node, value: bool) -> void:
	if is_instance_of(caller, PhantomCameraHost):
		_tween_skip = value
	else:
		printerr("Can only be called PhantomCameraHost class")
## Returns the current [param has_tweened] value.
func get_tween_skip() -> bool:
	return _tween_skip


## Assigns new [member priority] value.
func set_priority(value: int) -> void:
	priority = maxi(0, value)
	if not is_node_ready(): return
	if not Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME): return
	Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME).pcam_priority_changed.emit(self)
## Gets current [param Priority] value.
func get_priority() -> int:
	return priority


## Assigns a new [PhantomCameraTween] resource to the [param PhantomCamera3D].
func set_tween_resource(value: PhantomCameraTween) -> void:
	tween_resource = value
## Gets the [param PhantomCameraTween] resource assigned to the [param PhantomCamera3D].
## Returns null if there's nothing assigned to it.
func get_tween_resource() -> PhantomCameraTween:
	return tween_resource

## Assigns a new [param Tween Duration] to the [member tween_resource] value.[br]
## The duration value is in seconds.
func set_tween_duration(value: float) -> void:
	tween_resource.duration = value
## Gets the current [param Tween] Duration value. The duration value is in
## [param seconds].
func get_tween_duration() -> float:
	return tween_resource.duration

## Assigns a new [param Tween Transition] to the [member tween_resource] value.[br]
## The duration value is in seconds.
func set_tween_transition(value: int) -> void:
	tween_resource.transition = value
## Gets the current [param Tween Transition] value.
func get_tween_transition() -> int:
	return tween_resource.transition

## Assigns a new [param Tween Ease] to the [member tween_resource] value.[br]
## The duration value is in seconds.
func set_tween_ease(value: int) -> void:
	tween_resource.ease = value
## Gets the current [param Tween Ease] value.
func get_tween_ease() -> int:
	return tween_resource.ease

## Sets the [param PhantomCamera3D] active state[br]
## [b][color=yellow]Important:[/color][/b] This value can only be changed
## from the [PhantomCameraHost] script.
func set_is_active(node: Node, value: bool) -> void:
	if node is PhantomCameraHost:
		_is_active = value
		if value:
			_should_follow_checker()
	else:
		printerr("PCams can only be set from the PhantomCameraHost")
## Gets current active state of the [param PhantomCamera3D].
## If it returns true, it means the [param PhantomCamera3D] is what the
## [param Camera3D] is currently following.
func is_active() -> bool:
	return _is_active


## Enables or disables the [member tween_on_load].
func set_tween_on_load(value: bool) -> void:
	tween_on_load = value
## Gets the current [member tween_on_load] value.
func get_tween_on_load() -> bool:
	return tween_on_load


## Sets the [member host_layers] value.
func set_host_layers(value: int) -> void:
	host_layers = value
	if is_instance_valid(_phantom_camera_manager):
		_phantom_camera_manager.pcam_host_layer_changed.emit(self)

## Enables or disables a given layer of [member host_layers].
func set_host_layers_value(layer: int, value: bool) -> void:
	host_layers = _set_layer(host_layers, layer, value)

## Gets the current [member host_layers].
func get_host_layers() -> int:
	return host_layers


## Gets the current follow mode as an enum int based on [member FollowMode] enum.[br]
## [b]Note:[/b] Setting [member follow_mode] has purposely not been added.
## A separate [param PhantomCamera3D] instance should be used instead.
func get_follow_mode() -> int:
	return follow_mode


## Assigns a new [Node3D] as the [member follow_target].
func set_follow_target(value: Node3D) -> void:
	if follow_mode == FollowMode.NONE or follow_mode == FollowMode.GROUP: return
	if follow_target == value: return
	follow_target = value
	_follow_target_physics_based = false
	if is_instance_valid(value):
		if follow_mode == FollowMode.PATH:
			if is_instance_valid(follow_path):
				_should_follow = true
			else:
				_should_follow = false
		else:
			_should_follow = true
		_check_physics_body(value)
		if follow_mode == FollowMode.THIRD_PERSON and is_instance_valid(_follow_spring_arm):
			_follow_spring_arm.add_excluded_object(follow_target)
		if not follow_target.tree_exiting.is_connected(_follow_target_tree_exiting):
			follow_target.tree_exiting.connect(_follow_target_tree_exiting.bind(follow_target))
	else:
		if not follow_mode == FollowMode.GROUP:
			_should_follow = false
	follow_target_changed.emit()
	notify_property_list_changed()
## Removes the current [Node3D] [member follow_target].
func erase_follow_target() -> void:
	follow_target = null
## Gets the current Node3D target.
func get_follow_target() -> Node3D:
	return follow_target


## Assigns a new [Path3D] to the [member follow_path] property.
func set_follow_path(value: Path3D) -> void:
	follow_path = value
	if is_instance_valid(follow_path):
		_should_follow_checker()
	else:
		_should_follow = false

## Erases the current [Path3D] from [member follow_path] property.
func erase_follow_path() -> void:
	follow_path = null

## Gets the current [Path3D] from the [member follow_path] property.
func get_follow_path() -> Path3D:
	return follow_path


## Assigns a new [param follow_targets] array value.
func set_follow_targets(value: Array[Node3D]) -> void:
	if not follow_mode == FollowMode.GROUP: return
	if follow_targets == value: return
	follow_targets = value
	_follow_targets_size_check()


## Adds a single [Node3D] to [member follow_targets] array.
func append_follow_targets(value: Node3D) -> void:
	if not is_instance_valid(value):
		printerr(value, " is not a valid Node3D instance")
		return

	if not follow_targets.has(value):
		follow_targets.append(value)
		_follow_targets_size_check()
	else:
		printerr(value, " is already part of Follow Group")

## Adds an Array of type [Node3D] to [member follow_targets] array.
func append_follow_targets_array(value: Array[Node3D]) -> void:
	for target in value:
		if not is_instance_valid(target): continue
		if not follow_targets.has(target):
			follow_targets.append(target)
			_follow_targets_size_check()
		else:
			printerr(value, " is already part of Follow Group")

## Removes [Node3D] from [member follow_targets].
func erase_follow_targets(value: Node3D) -> void:
	follow_targets.erase(value)
	_follow_targets_size_check()


## Gets all [Node3D] from [follow_targets].
func get_follow_targets() -> Array[Node3D]:
	return follow_targets


## Assigns a new [param Vector3] for the [param follow_offset] property.
func set_follow_offset(value: Vector3) -> void:
	var temp_offset: Vector3 = follow_offset
	follow_offset = value

	if follow_axis_lock != FollowLockAxis.NONE:
		temp_offset = temp_offset - value
		match value:
			FollowLockAxis.X:
				_follow_axis_lock_value.x = _transform_output.origin.x + temp_offset.x
			FollowLockAxis.Y:
				_follow_axis_lock_value.y = _transform_output.origin.y + temp_offset.y
			FollowLockAxis.Z:
				_follow_axis_lock_value.z = _transform_output.origin.z + temp_offset.z
			FollowLockAxis.XY:
				_follow_axis_lock_value.x = _transform_output.origin.x + temp_offset.x
				_follow_axis_lock_value.y = _transform_output.origin.y + temp_offset.y
			FollowLockAxis.XZ:
				_follow_axis_lock_value.x = _transform_output.origin.x + temp_offset.x
				_follow_axis_lock_value.z = _transform_output.origin.z + temp_offset.z
			FollowLockAxis.YZ:
				_follow_axis_lock_value.y = _transform_output.origin.y + temp_offset.y
				_follow_axis_lock_value.z = _transform_output.origin.z + temp_offset.z
			FollowLockAxis.XYZ:
				_follow_axis_lock_value.x = _transform_output.origin.x + temp_offset.x
				_follow_axis_lock_value.y = _transform_output.origin.y + temp_offset.y
				_follow_axis_lock_value.z = _transform_output.origin.z + temp_offset.z

## Gets the current [param Vector3] for the [param follow_offset] property.
func get_follow_offset() -> Vector3:
	return follow_offset


## Enables or disables [member follow_damping].
func set_follow_damping(value: bool) -> void:
	follow_damping = value
	notify_property_list_changed()

## Gets the currents [member follow_damping] property.
func get_follow_damping() -> bool:
	return follow_damping


## Assigns new [member follow_damping_value] value.
func set_follow_damping_value(value: Vector3) -> void:
	## TODO - Should be using @export_range once minimum version support is Godot 4.3
	if value.x < 0: value.x = 0
	elif value.y < 0: value.y = 0
	elif value.z < 0: value.z = 0
	follow_damping_value = value

## Gets the currents [member follow_damping_value] value.
func get_follow_damping_value() -> Vector3:
	return follow_damping_value


## Assigns a new [member follow_distance] value.
func set_follow_distance(value: float) -> void:
	follow_distance = value

## Gets [member follow_distance] value.
func get_follow_distance() -> float:
	return follow_distance


## Enables or disables [member auto_follow_distance] when using Group Follow.
func set_auto_follow_distance(value: bool) -> void:
	auto_follow_distance = value
	notify_property_list_changed()

## Gets [member auto_follow_distance] state.
func get_auto_follow_distance() -> bool:
	return auto_follow_distance


## Assigns new [member auto_follow_distance_min] value.
func set_auto_follow_distance_min(value: float) -> void:
	auto_follow_distance_min = value

## Gets [member auto_follow_distance_min] value.
func get_auto_follow_distance_min() -> float:
	return auto_follow_distance_min


## Assigns new [member auto_follow_distance_max] value.
func set_auto_follow_distance_max(value: float) -> void:
	auto_follow_distance_max = value
## Gets [member auto_follow_distance_max] value.
func get_auto_follow_distance_max() -> float:
	return auto_follow_distance_max


## Assigns new [member auto_follow_distance_divisor] value.
func set_auto_follow_distance_divisor(value: float) -> void:
	auto_follow_distance_divisor = value

## Gets [member auto_follow_distance_divisor] value.
func get_auto_follow_distance_divisor() -> float:
	return auto_follow_distance_divisor


## Assigns new rotation (in radians) value to [SpringArm3D] for
## [param ThirdPerson] [enum FollowMode].
func set_third_person_rotation(value: Vector3) -> void:
	if not _is_third_person_follow:
		printerr("Follow Mode is not set to Third Person")
		return
	_follow_spring_arm.rotation = value

## Gets the rotation value (in radians) from the [SpringArm3D] for
## [param ThirdPerson] [enum FollowMode].
func get_third_person_rotation() -> Vector3:
	if not _is_third_person_follow:
		printerr("Follow Mode is not set to Third Person")
		return Vector3.ZERO
	return _follow_spring_arm.rotation


## Assigns new rotation (in degrees) value to [SpringArm3D] for
## [param ThirdPerson] [enum FollowMode].
func set_third_person_rotation_degrees(value: Vector3) -> void:
	if not _is_third_person_follow:
		printerr("Follow Mode is not set to Third Person")
		return
	_follow_spring_arm.rotation_degrees = value

## Gets the rotation value (in degrees) from the [SpringArm3D] for
## [param ThirdPerson] [enum FollowMode].
func get_third_person_rotation_degrees() -> Vector3:
	if not _is_third_person_follow:
		printerr("Follow Mode is not set to Third Person")
		return Vector3.ZERO
	return _follow_spring_arm.rotation_degrees


## Assigns new [Quaternion] value to [SpringArm3D] for [param ThirdPerson]
## [enum FollowMode].
func set_third_person_quaternion(value: Quaternion) -> void:
	if not _is_third_person_follow:
		printerr("Follow Mode is not set to Third Person")
		return
	_follow_spring_arm.quaternion = value

## Gets the [Quaternion] value of the [SpringArm3D] for [param ThirdPerson]
## [enum Follow mode].
func get_third_person_quaternion() -> Quaternion:
	if not _is_third_person_follow:
		printerr("Follow Mode is not set to Third Person")
		return Quaternion.IDENTITY
	return _follow_spring_arm.quaternion


## Assigns a new [member set_vertical_rotation_offset] value.
func set_vertical_rotation_offset(value: float) -> void:
	vertical_rotation_offset = value

## Gets the [member vertical_rotation] value.
func get_vertical_rotation_offset() -> float:
	return vertical_rotation_offset


func set_horizontal_rotation_offset(value: float) -> void:
	horizontal_rotation_offset = value

## Gets the [member horizontal_rotation] value.
func get_horizontal_rotation_offset() -> float:
	return horizontal_rotation_offset


## Assigns a new ThirdPerson [member SpringArm3D.length] value.
func set_spring_length(value: float) -> void:
	follow_distance = value
	if not is_instance_valid(_follow_spring_arm): return
	_follow_spring_arm.spring_length = value

## Gets the [member SpringArm3D.length]
## from a [param ThirdPerson] [enum follow_mode] instance.
func get_spring_length() -> float:
	return follow_distance


## Assigns a new [member collision_mask] to the [SpringArm3D] when [enum FollowMode]
## is set to [param ThirdPerson].
func set_collision_mask(value: int) -> void:
	collision_mask = value
	if not is_instance_valid(_follow_spring_arm): return
	_follow_spring_arm.collision_mask = collision_mask

## Enables or disables a specific [member collision_mask] layer for the
## [SpringArm3D] when [enum FollowMode] is set to [param ThirdPerson].
func set_collision_mask_value(value: int, enabled: bool) -> void:
	collision_mask = _set_layer(collision_mask, value, enabled)
	if not is_instance_valid(_follow_spring_arm): return
	_follow_spring_arm.collision_mask = collision_mask

## Gets [member collision_mask] from the [SpringArm3D] when [enum FollowMode]
## is set to [param ThirdPerson].
func get_collision_mask() -> int:
	return collision_mask


## Assigns a new [SpringArm3D.shape] when [enum FollowMode]
## is set to [param ThirdPerson].
func set_shape(value: Shape3D) -> void:
	shape = value
	if not is_instance_valid(_follow_spring_arm): return
	_follow_spring_arm.shape = shape

## Gets [param ThirdPerson] [member SpringArm3D.shape] value.
func get_shape() -> Shape3D:
	return shape


## Assigns a new [member SpringArm3D.margin] value when [enum FollowMode]
## is set to [param ThirdPerson].
func set_margin(value: float) -> void:
	margin = value
	if not is_instance_valid(_follow_spring_arm): return
	_follow_spring_arm.margin = margin

## Gets the [SpringArm3D.margin] when [enum FollowMode] is set to
## [param ThirdPerson].
func get_margin() -> float:
	return margin


## Gets the current [member look_at_mode]. Value is based on [enum LookAtMode]
## enum.[br]
## Note: To set a new [member look_at_mode], a separate [param PhantomCamera3D] should be used.
func get_look_at_mode() -> int:
	return look_at_mode


## Assigns new [Node3D] as [member look_at_target].
func set_look_at_target(value: Node3D) -> void:
	if look_at_mode == LookAtMode.NONE: return
	if look_at_target == value: return
	look_at_target = value
	if not look_at_mode == LookAtMode.GROUP:
		if is_instance_valid(look_at_target):
			_should_look_at = true
			_check_physics_body(value)
			if not look_at_target.tree_exiting.is_connected(_look_at_target_tree_exiting):
				look_at_target.tree_exiting.connect(_look_at_target_tree_exiting.bind(look_at_target))
		else:
			_should_look_at = false
	elif look_at_targets.size() == 0:
		_should_look_at = false

	look_at_target_changed.emit()
	notify_property_list_changed()

## Gets current [Node3D] from [member look_at_target] property.
func get_look_at_target() -> Node3D:
	return look_at_target


## Sets an array of type [Node3D] to [member set_look_at_targets].
func set_look_at_targets(value: Array[Node3D]) -> void:
	if not look_at_mode == LookAtMode.GROUP: return
	if look_at_targets == value: return
	look_at_targets = value

	_look_at_targets_size_check()
	notify_property_list_changed()

## Appends a [Node3D] to [member look_at_targets] array.
func append_look_at_target(value: Node3D) -> void:
	if not is_instance_valid(value):
		printerr(value, "is an invalid Node3D instance")
		return

	if not look_at_targets.has(value):
		look_at_targets.append(value)
		_look_at_targets_size_check()
	else:
		printerr(value, " is already part of Look At Group")


## Appends an array of type [Node3D] to [member look_at_targets] array.
func append_look_at_targets_array(value: Array[Node3D]) -> void:
	for val in value:
		if not is_instance_valid(val): continue
		if not look_at_targets.has(val):
			look_at_targets.append(val)
			_look_at_targets_size_check()
		else:
			printerr(val, " is already part of Look At Group")

## Removes [Node3D] from [member look_at_targets] array.
func erase_look_at_targets(value: Node3D) -> void:
	if look_at_targets.has(value):
		look_at_targets.erase(value)
		_look_at_targets_size_check()
	else:
		printerr(value, " is not part of Look At Group")


## Removes [Node3D] from [member look_at_targets] array. [br]
## @deprecated: Use [member erase_look_at_targets] instead.
func erase_look_at_targets_member(value: Node3D) -> void:
	printerr("erase_look_at_targets_member is deprecated, use erase_look_at_targets instead")
	erase_look_at_targets(value)

## Gets all the [Node3D] instances in [member look_at_targets].
func get_look_at_targets() -> Array[Node3D]:
	return look_at_targets


## Assigns a new [Vector3] to the [member look_at_offset] value.
func set_look_at_offset(value: Vector3) -> void:
	look_at_offset = value

## Gets the current [member look_at_offset] value.
func get_look_at_offset() -> Vector3:
	return look_at_offset


## Enables or disables [member look_at_damping].
func set_look_at_damping(value: bool) -> void:
	look_at_damping = value
	notify_property_list_changed()

## Gets the currents [member look_at_damping] property.
func get_look_at_damping() -> bool:
	return look_at_damping


## Assigns new [member look_at_damping_value] value.
func set_look_at_damping_value(value: float) -> void:
	look_at_damping_value = value

## Gets the currents [member look_at_damping_value] value.
func get_look_at_damping_value() -> float:
	return look_at_damping_value

## Assigns the Follow Axis.
func set_follow_axis_lock(value: FollowLockAxis) -> void:
	follow_axis_lock = value

	# Wait for the node to be ready before setting lock
	if not is_node_ready(): await ready

	# Prevent axis lock from working in the editor
	if value != FollowLockAxis.NONE and not Engine.is_editor_hint():
		_follow_axis_is_locked = true
		match value:
			FollowLockAxis.X:
				_follow_axis_lock_value.x = _transform_output.origin.x
			FollowLockAxis.Y:
				_follow_axis_lock_value.y = _transform_output.origin.y
			FollowLockAxis.Z:
				_follow_axis_lock_value.z = _transform_output.origin.z
			FollowLockAxis.XY:
				_follow_axis_lock_value.x = _transform_output.origin.x
				_follow_axis_lock_value.y = _transform_output.origin.y
			FollowLockAxis.XZ:
				_follow_axis_lock_value.x = _transform_output.origin.x
				_follow_axis_lock_value.z = _transform_output.origin.z
			FollowLockAxis.YZ:
				_follow_axis_lock_value.y = _transform_output.origin.y
				_follow_axis_lock_value.z = _transform_output.origin.z
			FollowLockAxis.XYZ:
				_follow_axis_lock_value.x = _transform_output.origin.x
				_follow_axis_lock_value.y = _transform_output.origin.y
				_follow_axis_lock_value.z = _transform_output.origin.z
	else:
		_follow_axis_is_locked = false

## Gets the current [member follow_axis_lock] property. Value is based on [enum FollowLockAxis] enum.
func get_follow_axis_lock() -> FollowLockAxis:
	return follow_axis_lock


## Sets the [member up] value.
func set_up(value: Vector3) -> void:
	if value == Vector3.ZERO:
		value = Vector3.UP
		push_warning("Up value cannot be (0, 0, 0), resetting to (0, 1, 0).")

	up = value
	if not _has_up_target:
		_up = value

## Gets the [member up] value.
func get_up() -> Vector3:
	return up


## Sets the [member up_target].
func set_up_target(value: Node3D) -> void:
	up_target = value
	if is_instance_valid(value):
		_has_up_target = true
		if not value.tree_exiting.is_connected(_up_target_tree_exiting):
			value.tree_exiting.connect(_up_target_tree_exiting)
	else:
		_has_up_target = false
		_up = up
	notify_property_list_changed()

## Gets the [member up_target].
func get_up_target() -> Node3D:
	return up_target


## Sets a [PhantomCameraNoise3D] resource.
func set_noise(value: PhantomCameraNoise3D) -> void:
	noise = value
	if value != null:
		_has_noise_resource = true
		noise.set_trauma(1)
	else:
		_has_noise_resource = false
		_transform_noise = Transform3D()

func get_noise() -> PhantomCameraNoise3D:
	return noise

func has_noise_resource() -> bool:
	return _has_noise_resource


## Sets the [member noise_emitter_layer] value.
func set_noise_emitter_layer(value: int) -> void:
	noise_emitter_layer = value

## Enables or disables a given layer of [member noise_emitter_layer].
func set_noise_emitter_layer_value(value: int, enabled: bool) -> void:
	noise_emitter_layer = _set_layer(noise_emitter_layer, value, enabled)

## Returns the [member noise_emitter_layer].
func get_noise_emitter_layer() -> int:
	return noise_emitter_layer


## Sets [member inactive_update_mode] property.
func set_inactive_update_mode(value: int) -> void:
	inactive_update_mode = value

## Gets [member inactive_update_mode] property.
func get_inactive_update_mode() -> int:
	return inactive_update_mode


## Assigns a [Camera3DResource].
func set_camera_3d_resource(value: Camera3DResource) -> void:
	camera_3d_resource = value
	camera_3d_resource_changed.emit()
	if value:
		if not camera_3d_resource.changed.is_connected(_camera_resource_changed):
			camera_3d_resource.changed.connect(_camera_resource_changed)

## Gets the [Camera3DResource].
func get_camera_3d_resource() -> Camera3DResource:
	return camera_3d_resource


func set_keep_aspect(value: int) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a keep_aspect value. No Camera3DResource assigned to ", name)
		return
	keep_aspect = value
	camera_3d_resource_property_changed.emit("keep_aspect", value)

func get_keep_aspect() -> Variant:
	if not camera_3d_resource: return null
	return camera_3d_resource.keep_aspect


## Assigns a new [member Camera3D.cull_mask] value.[br]
## [b]Note:[/b] This will override and make the [param Camera3DResource] unique to
## this [param PhantomCamera3D].
func set_cull_mask(value: int) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a cull_mask value. No Camera3DResource assigned to ", name)
		return
	camera_3d_resource.cull_mask = value
	camera_3d_resource_property_changed.emit("cull_mask", value)

## Enables or disables a specific [member Camera3D.cull_mask] layer.[br]
## [b]Note:[/b] This will override and make the [param Camera3DResource] unique to
## this [param PhantomCamera3D].
func set_cull_mask_value(layer_number: int, value: bool) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a cull_mask value. No Camera3DResource assigned to ", name)
		return
	var mask: int = _set_layer(get_cull_mask(), layer_number, value)
	camera_3d_resource.cull_mask = mask
	camera_3d_resource_property_changed.emit("cull_mask", mask)

## Gets the [member Camera3D.cull_mask] value assigned to the [Camera3DResource].
func get_cull_mask() -> Variant:
	if not camera_3d_resource: return null
	return camera_3d_resource.cull_mask


## Assigns a new [Environment] resource to the [Camera3DResource].
func set_environment(value: Environment) -> void:
	environment = value
	camera_3d_resource_property_changed.emit("environment", value)

## Gets the [Camera3D.environment] value assigned to the [Camera3DResource].
func get_environment() -> Environment:
	return environment


## Assigns a new [CameraAttributes] resource to the [Camera3DResource].
func set_attributes(value: CameraAttributes) -> void:
	attributes = value
	camera_3d_resource_property_changed.emit("attributes", value)

## Gets the [Camera3D.attributes] value assigned to the [Camera3DResource].
func get_attributes() -> CameraAttributes:
	return attributes


## Assigns a new [member Camera3D.h_offset] value.[br]
## [b]Note:[/b] This will override and make the [param Camera3DResource] unique to
## this [param PhantomCamera3D].
func set_h_offset(value: float) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a h_offset value. No Camera3DResource assigned to ", name)
		return
	camera_3d_resource.h_offset = value
	camera_3d_resource_property_changed.emit("h_offset", value)

## Gets the [member Camera3D.h_offset] value assigned to the [param Camera3DResource].
func get_h_offset() -> Variant:
	if not camera_3d_resource: return null
	return camera_3d_resource.h_offset


## Assigns a new [Camera3D.v_offset] value.[br]
## [b]Note:[/b] This will override and make the [param Camera3DResource] unique to
## this [param PhantomCamera3D].
func set_v_offset(value: float) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a v_offset value. No Camera3DResource assigned to ", name)
		return
	camera_3d_resource.v_offset = value
	camera_3d_resource_property_changed.emit("v_offset", value)

## Gets the [member Camera3D.v_offset] value assigned to the [param Camera3DResource].
func get_v_offset() -> Variant:
	if not camera_3d_resource: return null
	return camera_3d_resource.v_offset


## Assigns a new [Camera3D.projection] value.[br]
## [b]Note:[/b] This will override and make the [param Camera3DResource] unique to
## this [param PhantomCamera3D].
func set_projection(value: int) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a projection value. No Camera3DResource assigned to ", name)
		return
	camera_3d_resource.projection = value
	camera_3d_resource_property_changed.emit("projection", value)

## Gets the [member Camera3D.projection] value assigned to the [param Camera3DResource].
func get_projection() -> Variant:
	if not camera_3d_resource: return null
	return camera_3d_resource.projection


## Assigns a new [member Camera3D.fov] value.[br]
## [b]Note:[/b] This will override and make the [param Camera3DResource] unique to
## this [param PhantomCamera3D].
func set_fov(value: float) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a fov value. No Camera3DResource assigned to ", name)
		return
	camera_3d_resource.fov = value
	camera_3d_resource_property_changed.emit("fov", value)

## Gets the [member Camera3D.fov] value assigned to the [param Camera3DResource].
func get_fov() -> Variant:
	if not camera_3d_resource: return null
	return camera_3d_resource.fov


## Assigns a new [member Camera3D.size] value.[br]
## [b]Note:[/b] This will override and make the [param Camera3DResource] unique to
## this [param PhantomCamera3D].
func set_size(value: float) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a size value. No Camera3DResource assigned to ", name)
		return
	camera_3d_resource.size = value
	camera_3d_resource_property_changed.emit("size", value)

## Gets the [member Camera3D.size] value assigned to the [param Camera3DResource].
func get_size() -> Variant:
	if not camera_3d_resource: return null
	return camera_3d_resource.size


## Assigns a new [member Camera3D.frustum_offset] value.[br]
## [b]Note:[/b] This will override and make the [param Camera3DResource] unique to
## this [param PhantomCamera3D].
func set_frustum_offset(value: Vector2) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a frustum_offset value. No Camera3DResource assigned to ", name)
		return
	camera_3d_resource.frustum_offset = value
	camera_3d_resource_property_changed.emit("frustum_offset", value)

## Gets the [member Camera3D.frustum_offset] value assigned to the [param Camera3DResource].
func get_frustum_offset() -> Variant:
	if not camera_3d_resource: return null
	return camera_3d_resource.frustum_offset


## Assigns a new [member Camera3D.near] value.[br]
## [b]Note:[/b] This will override and make the [param Camera3DResource] unique to
## this [param PhantomCamera3D].
func set_near(value: float) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a near value. No Camera3DResource assigned to ", name)
		return
	camera_3d_resource.near = value
	camera_3d_resource_property_changed.emit("near", value)

## Gets the [member Camera3D.near] value assigned to the [param Camera3DResource].
func get_near() -> Variant:
	if not camera_3d_resource: return null
	return camera_3d_resource.near


## Assigns a new [member Camera3D.far] value.[br]
## [b]Note:[/b] This will override and make the [param Camera3DResource] unique to
## this [param PhantomCamera3D].
func set_far(value: float) -> void:
	if not camera_3d_resource:
		printerr("Can't assign a far value. No Camera3DResource assigned to ", name)
		return
	camera_3d_resource.far = value
	camera_3d_resource_property_changed.emit("far", value)

## Gets the [member Camera3D.far] value assigned to the [param Camera3DResource].
func get_far() -> Variant:
	if not camera_3d_resource: return null
	return camera_3d_resource.far


func get_follow_target_physics_based() -> bool:
	return _follow_target_physics_based


func get_class() -> String:
	return "PhantomCamera3D"


func is_class(value) -> bool:
	return value == "PhantomCamera3D"

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd ---
@tool
extends RefCounted

#region Constants

#const PhantomCameraHost: Script = preload("res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd")

const CAMERA_2D_NODE_NAME: StringName = "Camera2D"
const CAMERA_3D_NODE_NAME: StringName = "Camera3D"
const PCAM_HOST_NODE_NAME: StringName = "PhantomCameraHost"
const PCAM_MANAGER_NODE_NAME: String = "PhantomCameraManager" # TODO - Convert to StringName once https://github.com/godotengine/godot/pull/72702 is merged
const PCAM_2D_NODE_NAME: StringName = "PhantomCamera2D"
const PCAM_3D_NODE_NAME: StringName = "PhantomCamera3D"
const PCAM_HOST: StringName = "phantom_camera_host"

const COLOR_2D: Color = Color("8DA5F3")
const COLOR_3D: Color = Color("FC7F7F")
const COLOR_PCAM: Color = Color("3AB99A")
const COLOR_PCAM_33: Color = Color("3ab99a33")
const PCAM_HOST_COLOR: Color = Color("E0E0E0")

#endregion

#region Group Names

const PCAM_GROUP_NAME: StringName = "phantom_camera_group"
const PCAM_HOST_GROUP_NAME: StringName = "phantom_camera_host_group"

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_noise_emitter_2d.gd ---
@tool
@icon("res://addons/phantom_camera/icons/phantom_camera_noise_emitter_2d.svg")
class_name PhantomCameraNoiseEmitter2D
extends Node2D

## Emits positional and rotational noise to active [PhantomCamera2D]s and its corresponding [Camera2D].
##
## Is a node meant to apply positional and rotational noise, also referred to as shake, to the [Camera2D].
## It is designed for use cases such as when hitting or when being hit, earthquakes or to add a
## bit of slight movement to the camera to make it feel less static.
## The emitter can affect multiple [PhantomCamera2D] in a given scene based on which [member noise_emitter_layer]
## are enabled by calling its [method emit] function. At least one corresponding layer has to be
## set on the [PhantomCamera2D] and the emitter node.

const _constants = preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd")

#region Exported Proerpties

## The [PhantomCameraNoise2D] resource that defines the noise pattern.
@export var noise: PhantomCameraNoise2D = null:
	set = set_noise,
	get = get_noise

## If true, previews the noise in the editor - can be seen in the viewfinder.
@export var preview: bool = false:
	set(value):
		preview = value
		_play = value
	get:
		return preview

## If true, repeats the noise indefinitely once started. Otherwise, it will only be triggered once. [br]
@export var continuous: bool = false:
	set = set_continuous,
	get = get_continuous

## Determines how long the noise should take to reach full [member intensity] once started.[br]
## The value is set in [b]seconds[/b].
@export_exp_easing("positive_only", "suffix: s") var growth_time: float = 0:
	set = set_growth_time,
	get = get_growth_time

## Sets the duration for the camera noise if [member continuous] is set to [b]false[/b].[br][br]
## The value is set in [b]seconds[/b].
@export_range(0, 10, 0.001, "or_greater", "suffix: s") var duration: float = 1.0:
	set = set_duration,
	get = get_duration

## Determines how long the noise should take to come to a full stop.[br]
## The value is set in [b]seconds[/b].
@export_exp_easing("attenuation", "positive_only", "suffix: s") var decay_time: float = 0:
	set = set_decay_time,
	get = get_decay_time

## Enabled layers will affect [PhantomCamera2D] nodes with at least one corresponding layer enabled.[br]
## Enabling multiple corresponding layers on the same [PhantomCamera2D] causes no additional effect.
@export_flags_2d_render var noise_emitter_layer: int = 1:
	set = set_noise_emitter_layer,
	get = get_noise_emitter_layer

#endregion


#region Private Variables

var _play: bool = false:
	set(value):
		_play = value
		if value:
			_elasped_play_time = 0
			_decay_countdown = 0
			_play = true
			_should_grow = true
			_start_duration_countdown = false
			_should_decay = false
		else:
			_should_decay = true
			if noise.randomize_noise_seed:
				noise.noise_seed = randi() & 1000
			else:
				noise.reset_noise_time()
	get:
		return _play

var _start_duration_countdown: bool = false

var _decay_countdown: float = 0

var _should_grow: bool = false

var _should_decay: bool = false

var _elasped_play_time: float = 0

var _noise_output: Transform2D = Transform2D()

# NOTE - Temp solution until Godot has better plugin autoload recognition out-of-the-box.
var _phantom_camera_manager: Node

#endregion

#region Private Functions

func _get_configuration_warnings() -> PackedStringArray:
	if noise == null:
		return ["Noise resource is required in order to trigger emitter."]
	else:
		return []


func _validate_property(property) -> void:
	if property.name == "duration" and continuous:
		property.usage = PROPERTY_USAGE_NO_EDITOR


func _enter_tree() -> void:
	_phantom_camera_manager = get_tree().root.get_node(_constants.PCAM_MANAGER_NODE_NAME)


func _process(delta: float) -> void:
	if not _play and not _should_decay: return
	if noise == null:
		printerr("Noise resource missing in ", name)
		_play = false
		return

	_elasped_play_time += delta

	if _should_grow:
		noise.set_trauma(minf(_elasped_play_time / growth_time, 1))
		if _elasped_play_time >= growth_time:
			_should_grow = false
			_start_duration_countdown = true
			noise.set_trauma(1)
	else:
		noise.set_trauma(1)

	if not continuous:
		if _start_duration_countdown:
			if _elasped_play_time >= duration + growth_time:
				_should_decay = true
				_start_duration_countdown = false

	if _should_decay:
		_decay_countdown += delta
		noise.set_trauma(maxf(1 - (_decay_countdown / decay_time), 0))
		if _decay_countdown >= decay_time:
			noise.set_trauma(0)
			_play = false
			preview = false
			_should_decay = false
			_elasped_play_time = 0
			_decay_countdown = 0

	_noise_output = noise.get_noise_transform(delta)
	_phantom_camera_manager.noise_2d_emitted.emit(_noise_output, noise_emitter_layer)


func _set_layer(current_layers: int, layer_number: int, value: bool) -> int:
	var mask: int = current_layers

	# From https://github.com/godotengine/godot/blob/51991e20143a39e9ef0107163eaf283ca0a761ea/scene/3d/camera_3d.cpp#L638
	if layer_number < 1 or layer_number > 20:
		printerr("Layer must be between 1 and 20.")
	else:
		if value:
			mask |= 1 << (layer_number - 1)
		else:
			mask &= ~(1 << (layer_number - 1))

	return mask

#endregion


#region Public Functions

## Emits noise to the [PhantomCamera2D]s that has at least one matching layers.
func emit() -> void:
	if _play: _play = false
	_play = true

## Returns the state for the emitter. If true, the emitter is currently emitting.
func is_emitting() -> bool:
	return _play

## Stops the emitter from emitting noise.
func stop(should_decay: bool = true) -> void:
	if should_decay:
		_should_decay = true
	else:
		_play = false

## Toggles the emitter on and off.
func toggle() -> void:
	_play = !_play

#endregion


#region Setter & Getter Functions

## Sets the [member noise] resource.
func set_noise(value: PhantomCameraNoise2D) -> void:
	noise = value
	update_configuration_warnings()

## Returns the [member noise] resource.
func get_noise() -> PhantomCameraNoise2D:
	return noise


## Sets the [member continous] value.
func set_continuous(value: bool) -> void:
	continuous = value
	notify_property_list_changed()

## Gets the [member continous] value.
func get_continuous() -> bool:
	return continuous


## Sets the [member growth_time] value.
func set_growth_time(value: float) -> void:
	growth_time = value

## Returns the [member growth_time] value.
func get_growth_time() -> float:
	return growth_time


## Sets the [member duration] value.
func set_duration(value: float) -> void:
	duration = value
	if duration == 0:
		duration = 0.001

## Returns the [member duration] value.
func get_duration() -> float:
	return duration


## Sets the [member decay_time] value.
func set_decay_time(value: float) -> void:
	decay_time = value

## Returns the [member decay_time] value.
func get_decay_time() -> float:
	return decay_time


## Sets the [member noise_emitter_layer] value.
func set_noise_emitter_layer(value: int) -> void:
	noise_emitter_layer = value

## Enables or disables a given layer of [member noise_emitter_layer].
func set_noise_emitter_value(value: int, enabled: bool) -> void:
	noise_emitter_layer = _set_layer(noise_emitter_layer, value, enabled)

## Returns the [member noise_emitter_layer] value.
func get_noise_emitter_layer() -> int:
	return noise_emitter_layer

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_noise_emitter_3d.gd ---
@tool
@icon("res://addons/phantom_camera/icons/phantom_camera_noise_emitter_3d.svg")
class_name PhantomCameraNoiseEmitter3D
extends Node3D

## Emits positional and rotational noise to active [PhantomCamera3D]s and its corresponding [Camera3D].
##
## Is a node meant to apply positional and rotational noise, also referred to as shake, to the [Camera3D].
## It is designed for use cases such as when hitting or when being hit, earthquakes or to add a
## bit of slight movement to the camera to make it feel less static.
## The emitter can affect multiple [PhantomCamera3D] in a given scene based on which [member noise_emitter_layer]
## are enabled by calling its [method emit] function. At least one corresponding layer has to be
## set on the [PhantomCamera3D] and the emitter node.

const _constants = preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd")

#region Exported Properties

## The [PhantomCameraNoise3D] resource that defines the noise pattern.
@export var noise: PhantomCameraNoise3D = null:
	set = set_noise,
	get = get_noise

## If true, previews the noise in the Viewfinder.
@export var preview: bool = false:
	set(value):
		preview = value
		_play = value
	get:
		return preview

## If true, repeats the noise indefinitely once started.Otherwise, it will only be triggered once. [br]
## [b]Note:[/b] This will always be enabled if the resource is assigned the the [PhantomCamera3D]'s
## [member PhantomCamera3D.noise] property.
@export var continuous: bool = false:
	set = set_continuous,
	get = get_continuous

## Determines how long the noise should take to reach full [member intensity] once started.[br]
## The value is set in [b]seconds[/b].
@export_exp_easing("positive_only", "suffix: s") var growth_time: float = 0:
	set = set_growth_time,
	get = get_growth_time

## Sets the duration for the camera noise if [member loop] is set to false.[br]
## If the duration is [param 0] then [member continous] becomes enabled.[br]
## The value is set in [b]seconds[/b].
@export_range(0, 10, 0.001, "or_greater", "suffix: s") var duration: float = 1.0:
	set = set_duration,
	get = get_duration

## Determines how long the noise should take to come to a full stop.[br]
## The value is set in [b]seconds[/b].
@export_exp_easing("attenuation", "positive_only", "suffix: s") var decay_time: float = 0:
	set = set_decay_time,
	get = get_decay_time

## Enabled layers will affect [PhantomCamera3D] nodes with at least one corresponding layer enabled.[br]
## Enabling multiple corresponding layers on the same [PhantomCamera3D] causes no additional effect.
@export_flags_3d_render var noise_emitter_layer: int = 1:
	set = set_noise_emitter_layer,
	get = get_noise_emitter_layer

#endregion

#region Private Variables

var _play: bool = false:
	set(value):
		_play = value
		if value:
			_elasped_play_time = 0
			_decay_countdown = 0
			_play = true
			_should_grow = true
			_start_duration_countdown = false
			_should_decay = false
		else:
			_should_decay = true
			if noise.randomize_noise_seed:
				noise.noise_seed = randi() & 1000
			else:
				noise.reset_noise_time()
	get:
		return _play

var _start_duration_countdown: bool = false

var _decay_countdown: float = 0

var _should_grow: bool = false

var _should_decay: bool = false

var _elasped_play_time: float = 0

var _noise_output: Transform3D = Transform3D()

# NOTE - Temp solution until Godot has better plugin autoload recognition out-of-the-box.
var _phantom_camera_manager: Node

#endregion

#region Private Functions

func _get_configuration_warnings() -> PackedStringArray:
	if noise == null:
		return ["Noise resource is required in order to trigger emitter."]
	else:
		return []


func _validate_property(property) -> void:
	if property.name == "duration" and continuous:
		property.usage = PROPERTY_USAGE_NO_EDITOR


func _enter_tree() -> void:
	_phantom_camera_manager = get_tree().root.get_node(_constants.PCAM_MANAGER_NODE_NAME)


func _process(delta: float) -> void:
	if not _play and not _should_decay: return
	if noise == null:
		printerr("Noise resource missing in ", name)
		_play = false
		return

	_elasped_play_time += delta

	if _should_grow:
		noise.set_trauma(minf(_elasped_play_time / growth_time, 1))
		if _elasped_play_time >= growth_time:
			_should_grow = false
			_start_duration_countdown = true
			noise.set_trauma(1)

	if not continuous:
		if _start_duration_countdown:
			if _elasped_play_time >= duration + growth_time:
				_should_decay = true
				_start_duration_countdown = false

	if _should_decay:
		_decay_countdown += delta
		noise.set_trauma(maxf(1 - (_decay_countdown / decay_time), 0))
		if _decay_countdown >= decay_time:
			noise.set_trauma(0)
			_play = false
			preview = false
			_should_decay = false
			_elasped_play_time = 0
			_decay_countdown = 0

	_noise_output = noise.get_noise_transform(delta)
	_phantom_camera_manager.noise_3d_emitted.emit(_noise_output, noise_emitter_layer)


func _set_layer(current_layers: int, layer_number: int, value: bool) -> int:
	var mask: int = current_layers

	# From https://github.com/godotengine/godot/blob/51991e20143a39e9ef0107163eaf283ca0a761ea/scene/3d/camera_3d.cpp#L638
	if layer_number < 1 or layer_number > 20:
		printerr("Layer must be between 1 and 20.")
	else:
		if value:
			mask |= 1 << (layer_number - 1)
		else:
			mask &= ~(1 << (layer_number - 1))

	return mask

#endregion

#region Public Functions

## Emits noise to the [PhantomCamera3D]s that has at least one matching layers.
func emit() -> void:
	if _play: _play = false
	_play = true


## Returns the state for the emitter. If true, the emitter is currently emitting.
func is_emitting() -> bool:
	return _play


## Stops the emitter from emitting noise.
func stop(should_decay: bool = true) -> void:
	if should_decay:
		_should_decay = true
	else:
		_play = false


## Toggles the emitter on and off.[br]
func toggle() -> void:
	_play = !_play

#endregion

#region Setter & Getter Functions

## Sets the [member noise] resource.
func set_noise(value: PhantomCameraNoise3D) -> void:
	noise = value
	update_configuration_warnings()

## Returns the [member noise] resource.
func get_noise() -> PhantomCameraNoise3D:
	return noise


## Sets the [member continous] value.
func set_continuous(value: bool) -> void:
	continuous = value
	notify_property_list_changed()

## Gets the [member continous] value.
func get_continuous() -> bool:
	return continuous


## Sets the [member growth_time] value.
func set_growth_time(value: float) -> void:
	growth_time = value

## Returns the [member growth_time] value.
func get_growth_time() -> float:
	return growth_time


## Sets the [member duration] value.
func set_duration(value: float) -> void:
	duration = value
	if duration == 0:
		duration = 0.001

## Returns the [member duration] value.
func get_duration() -> float:
	return duration


## Sets the [member decay_time] value.
func set_decay_time(value: float) -> void:
	decay_time = value

## Returns the [member decay_time] value.
func get_decay_time() -> float:
	return decay_time


## Sets the [member noise_emitter_layer] value.
func set_noise_emitter_layer(value: int) -> void:
	noise_emitter_layer = value

## Enables or disables a given layer of [member noise_emitter_layer].
func set_noise_emitter_value(value: int, enabled: bool) -> void:
	noise_emitter_layer = _set_layer(noise_emitter_layer, value, enabled)

## Returns the [member noise_emitter_layer] value.
func get_noise_emitter_layer() -> int:
	return noise_emitter_layer

	#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera_host/PhantomCameraHost.cs ---
using Godot;

#nullable enable

namespace PhantomCamera;

public enum InterpolationMode
{
    Auto,
    Idle,
    Physics
}

public static class PhantomCameraHostExtensions
{
    public static PhantomCameraHost AsPhantomCameraHost(this Node node)
    {
        return new PhantomCameraHost(node);
    }
}

public class PhantomCameraHost()
{
    public Node Node { get; } = null!;

    public PhantomCameraHost(Node node) : this()
    {
        Node = node;

        _callablePCamBecameActive = Callable.From<Node>(pCam => PCamBecameActive?.Invoke(pCam));
        _callablePCamBecameInactive = Callable.From<Node>(pCam => PCamBecameInactive?.Invoke(pCam));

        Node.Connect(SignalName.PCamBecameActive, _callablePCamBecameActive);
        Node.Connect(SignalName.PCamBecameInactive, _callablePCamBecameInactive);
    }

    ~PhantomCameraHost()
    {
        Node.Disconnect(SignalName.PCamBecameActive, _callablePCamBecameActive);
        Node.Disconnect(SignalName.PCamBecameInactive, _callablePCamBecameInactive);
    }

    public delegate void PCamBecameActiveEventHandler(Node pCam);
    public delegate void PCamBecameInactiveEventHandler(Node pCam);

    public event PCamBecameActiveEventHandler? PCamBecameActive;
    public event PCamBecameInactiveEventHandler? PCamBecameInactive;


    private readonly Callable _callablePCamBecameActive;
    private readonly Callable _callablePCamBecameInactive;
    // For when Godot becomes the minimum version
    // public InterpolationMode InterpolationMode
    // {
    //      get => (InterpolationMode)(int)Node.Call(MethodName.GetInterpolationMode);
    //      set => Node.Call(MethodName.SetInterpolationMode, (int)value);
    // }

    public int HostLayers
    {
        get => (int)Node.Call(PhantomCamera.MethodName.GetHostLayers);
        set => Node.Call(PhantomCamera.MethodName.SetHostLayers, value);
    }

    public void SetHostLayersValue(int layer, bool value) => Node.Call(MethodName.SetHostLayersValue, layer, value);

    public Camera2D? Camera2D => (Camera2D?)Node.Get(PropertyName.Camera2D);

    public Camera3D? Camera3D => (Camera3D?)Node.Get(PropertyName.Camera3D);

    public InterpolationMode InterpolationMode
    {
        get => (InterpolationMode)(int)Node.Call(MethodName.GetInterpolationMode);
        set => Node.Call(MethodName.SetInterpolationMode, (int)value);
    }

    public bool TriggerPhantomCameraTween => (bool)Node.Call(MethodName.GetTriggerPhantomCameraTween);

    public ActivePhantomCameraQueryResult? GetActivePhantomCamera()
    {
        var result = Node.Call(MethodName.GetActivePhantomCamera);
        return result.VariantType == Variant.Type.Nil ? null : new ActivePhantomCameraQueryResult(result.AsGodotObject());
    }

    public static class PropertyName
    {
        public const string Camera2D = "camera_2d";
        public const string Camera3D = "camera_3d";
    }

    public static class MethodName
    {
        public const string GetActivePhantomCamera = "get_active_pcam";
        public const string GetTriggerPhantomCameraTween = "get_trigger_pcam_tween";

        public const string GetInterpolationMode = "get_interpolation_mode";
        public const string SetInterpolationMode = "set_interpolation_mode";

        public const string SetHostLayersValue = "set_host_layers_value";
    }

    public static class SignalName
    {
        public const string PCamBecameActive = "pcam_became_active";
        public const string PCamBecameInactive = "pcam_became_inactive";
    }
}

public class ActivePhantomCameraQueryResult(GodotObject godotObject)
{
    public bool Is2D => godotObject.IsClass("Node2D") || ((Node)godotObject).Name.ToString().Contains("PhantomCamera2D")
                                               || ((Node)godotObject).Name.ToString().Contains("PCam2D")
                                               || ((Node)godotObject).Name.ToString().Contains("2D");

    public bool Is3D => godotObject.IsClass("Node3D") || ((Node)godotObject).Name.ToString().Contains("PhantomCamera3D")
                                               || ((Node)godotObject).Name.ToString().Contains("PCam3D")
                                               || ((Node)godotObject).Name.ToString().Contains("3D");

    public PhantomCamera2D? AsPhantomCamera2D()
    {
        return Is2D ? new PhantomCamera2D(godotObject) : null;
    }

    public PhantomCamera3D? AsPhantomCamera3D()
    {
        return Is3D ? new PhantomCamera3D(godotObject) : null;
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/phantom_camera_host/phantom_camera_host.gd ---
@tool
@icon("res://addons/phantom_camera/icons/phantom_camera_host.svg")
class_name PhantomCameraHost
extends Node

## Controls a scene's [Camera2D] (2D scenes) and [Camera3D] (3D scenes).
##
## All instantiated [param PhantomCameras] in a scene are assigned to a specific layer, where a
## PhantomCameraHost will react to those that corresponds. It is what determines which [param PhantomCamera] should
## be active.

#region Constants

const _constants := preload("res://addons/phantom_camera/scripts/phantom_camera/phantom_camera_constants.gd")

#endregion


#region Signals

## Updates the viewfinder [param dead zones] sizes.[br]
## [b]Note:[/b] This is only being used in the editor viewfinder UI.
#signal update_editor_viewfinder
signal viewfinder_update(check_framed_view: bool)
signal viewfinder_disable_dead_zone

## Used internally to check if the [param PhantomCameraHost] is valid.
## The result will be visible in the viewfinder when multiple instances are present.
signal has_error()

## Emitted when a new [param PhantomCamera] becomes active and assigned to this [param PhantomCameraHost].
signal pcam_became_active(pcam: Node)

## Emitted when the currently active [param PhantomCamera] goes from being active to inactive.
signal pcam_became_inactive(pcam: Node)

#endregion


#region Enums

## Dictates whether if [param PhantomCameraHost]'s logic should be called in the physics or idle (process) frames.
enum InterpolationMode {
	AUTO    = 0, ## Automatically sets the [param Camera]'s logic to run in either physics or idle (process) frames depending on its active [param PhantomCamera]'s [param Follow] / [param Look At] Target
	IDLE    = 1, ## Always run the [param Camera] logic in idle (process) frames
	PHYSICS = 2, ## Always run the [param Camera] logic in physics frames
}

#endregion


#region Public Variables

## Determines which [PhantomCamera2D] / [PhantomCamera3D] nodes this [param PhantomCameraHost] should recognise.
## At least one corresponding layer needs to be set on the [param PhantomCamera] for the [param PhantomCameraHost] node to work.
@export_flags_2d_render var host_layers: int = 1:
	set = set_host_layers,
	get = get_host_layers

## Determines whether the [PhantomCamera2D] / [PhantomCamera3D] nodes this [param PhantomCameraHost] controls should use physics interpolation or not.
@export var interpolation_mode: InterpolationMode = InterpolationMode.AUTO:
	set = set_interpolation_mode,
	get = get_interpolation_mode

#endregion


#region Private Variables

var _active_pcam_2d: PhantomCamera2D = null
var _active_pcam_3d: Node = null ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
var _active_pcam_priority: int = -1
var _active_pcam_missing: bool = true
var _active_pcam_has_damping: bool = false
var _follow_target_physics_based: bool = false

var _prev_active_pcam_2d_transform: Transform2D = Transform2D()
var _prev_active_pcam_3d_transform: Transform3D = Transform3D()

var _trigger_pcam_tween: bool = false
var _tween_elapsed_time: float = 0
var _tween_duration: float = 0
var _tween_is_instant: bool = false

var _multiple_pcam_hosts: bool = false

var _is_child_of_camera: bool = false
var _is_2d: bool = false

var _viewfinder_node: Control = null
var _viewfinder_needed_check: bool = true

var _camera_zoom: Vector2 = Vector2.ONE

#region Camera3DResource

var _prev_cam_attributes: CameraAttributes = null
var _cam_attribute_type: int = 0 # 0 = CameraAttributesPractical, 1 = CameraAttributesPhysical
var _cam_attribute_changed: bool = false
var _cam_attribute_assigned: bool = false

#region CameraAttributes
var _prev_cam_auto_exposure_scale: float = 0.4
var _cam_auto_exposure_scale_changed: bool = false

var _prev_cam_auto_exposure_speed: float = 0.5
var _cam_auto_exposure_speed_changed: bool = false

var _prev_cam_exposure_multiplier: float = 1.0
var _cam_exposure_multiplier_changed: bool = false

var _prev_cam_exposure_sensitivity: float = 100.0
var _cam_exposure_sensitivity_changed: bool = false

#region CameraAttributesPractical
var _prev_cam_exposure_min_sensitivity: float = 0.0
var _cam_exposure_min_sensitivity_changed: bool = false

var _prev_cam_exposure_max_sensitivity: float = 800.0
var _cam_exposure_max_sensitivity_changed: bool = false

var _prev_cam_dof_blur_amount: float = 0.1
var _cam_dof_blur_amount_changed: bool = false

var _cam_dof_blur_far_distance_default: float = 10
var _prev_cam_dof_blur_far_distance: float = _cam_dof_blur_far_distance_default
var _cam_dof_blur_far_distance_changed: bool = false

var _cam_dof_blur_far_transition_default: float = 5
var _prev_cam_dof_blur_far_transition: float = _cam_dof_blur_far_transition_default
var _cam_dof_blur_far_transition_changed: bool = false

var _cam_dof_blur_near_distance_default: float = 2
var _prev_cam_dof_blur_near_distance: float = _cam_dof_blur_near_distance_default
var _cam_dof_blur_near_distance_changed: bool = false

var _cam_dof_blur_near_transition_default: float = 1
var _prev_cam_dof_blur_near_transition: float = _cam_dof_blur_near_transition_default
var _cam_dof_blur_near_transition_changed: bool = false
#endregion

#region CameraAttributesPhysical
var _prev_cam_exposure_min_exposure_value: float = 10.0
var _cam_exposure_min_exposure_value_changed: bool = false

var _prev_cam_exposure_max_exposure_value: float = -8.0
var _cam_exposure_max_exposure_value_changed: bool = false

var _prev_cam_exposure_aperture: float = 16.0
var _cam_exposure_aperture_changed: bool = false

var _prev_cam_exposure_shutter_speed: float = 100.0
var _cam_exposure_shutter_speed_changed: bool = false

var _prev_cam_frustum_far: float = 4000.0
var _cam_frustum_far_changed: bool = false

var _prev_cam_frustum_focal_length: float = 35.0
var _cam_frustum_focal_length_changed: bool = false

var _prev_cam_frustum_near: float = 0.05
var _cam_frustum_near_changed: bool = false

var _prev_cam_frustum_focus_distance: float = 10.0
var _cam_frustum_focus_distance_changed: bool = false

#endregion

var _prev_cam_h_offset: float = 0
var _cam_h_offset_changed: bool = false

var _prev_cam_v_offset: float = 0
var _cam_v_offset_changed: bool = false

var _prev_cam_fov: float = 75
var _cam_fov_changed: bool = false

var _prev_cam_size: float = 1
var _cam_size_changed: bool = false

var _prev_cam_frustum_offset: Vector2 = Vector2.ZERO
var _cam_frustum_offset_changed: bool = false

var _prev_cam_near: float = 0.05
var _cam_near_changed: bool = false

var _prev_cam_far: float = 4000
var _cam_far_changed: bool = false

#endregion

var _active_pcam_2d_glob_transform: Transform2D = Transform2D()
var _active_pcam_3d_glob_transform: Transform3D = Transform3D()

var _has_noise_emitted: bool = false
var _reset_noise_offset_2d: bool = false
var _noise_emitted_output_2d: Transform2D = Transform2D()
var _noise_emitted_output_3d: Transform3D = Transform3D()

#endregion

# NOTE - Temp solution until Godot has better plugin autoload recognition out-of-the-box.
var _phantom_camera_manager: Node = null

#region Public Variables

var show_warning: bool = false

## For 2D scenes, is the [Camera2D] instance the [param PhantomCameraHost] controls.
var camera_2d: Camera2D = null

## For 3D scenes, is the [Camera3D] instance the [param PhantomCameraHost] controls.
var camera_3d: Node = null ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.

#endregion

#region Private Functions

## TBD - For when Godot 4.3 becomes a minimum version
#func _validate_property(property: Dictionary) -> void:
	#if property.name == "interpolation_mode" and get_parent() is Node3D:
		#property.usage = PROPERTY_USAGE_NO_EDITOR


func _get_configuration_warnings() -> PackedStringArray:
	var parent: Node = get_parent()
	var first_pcam_host_child: PhantomCameraHost

	if _is_2d:
		if not parent is Camera2D:
			show_warning = true
			has_error.emit()
			return["Needs to be a child of a Camera2D in order to work."]
	else:
		if not parent.is_class("Camera3D"): ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
			show_warning = true
			has_error.emit()
			return["Needs to be a child of a Camera3D in order to work."]

	for child in parent.get_children():
		if not child is PhantomCameraHost: continue
		if not is_instance_valid(first_pcam_host_child):
			first_pcam_host_child = child
			continue
		elif not first_pcam_host_child == self:
			show_warning = true
			has_error.emit()
			return["Only the first PhantomCameraHost child will be used."]
		child.update_configuration_warnings()

	show_warning = false
	has_error.emit()
	return[]


func _enter_tree() -> void:
	var parent: Node = get_parent()
	if parent is Camera2D or parent.is_class("Camera3D"): ## Note: To support disable_3d export templates for 2D projects, this is purposely not strongly typed.
		_phantom_camera_manager = get_tree().root.get_node(_constants.PCAM_MANAGER_NODE_NAME)
		_phantom_camera_manager.pcam_host_added(self)

		_is_child_of_camera = true
		if parent is Camera2D:
			_is_2d = true
			camera_2d = parent
			## Force applies position smoothing to be disabled
			## This is to prevent overlap with the interpolation of the PCam2D.
			camera_2d.set_position_smoothing_enabled(false)
		else:
			_is_2d = false
			camera_3d = parent

		if _is_2d:
			if not _phantom_camera_manager.get_phantom_camera_2ds().is_empty():
				for pcam in _phantom_camera_manager.get_phantom_camera_2ds():
					_pcam_added_to_scene(pcam)

			if not _phantom_camera_manager.limit_2d_changed.is_connected(_update_limit_2d):
				_phantom_camera_manager.limit_2d_changed.connect(_update_limit_2d)
			if not _phantom_camera_manager.draw_limit_2d.is_connected(_draw_limit_2d):
				_phantom_camera_manager.draw_limit_2d.connect(_draw_limit_2d)

		else:
			if not _phantom_camera_manager.get_phantom_camera_3ds().is_empty():
				for pcam in _phantom_camera_manager.get_phantom_camera_3ds():
					_pcam_added_to_scene(pcam)


func _exit_tree() -> void:
	if is_instance_valid(_phantom_camera_manager):
		_phantom_camera_manager.pcam_host_removed(self)


func _ready() -> void:
	# Waits for the first process tick to finish before initializing any logic
	# This should help with avoiding ocassional erratic camera movement upon running a scene
	await get_tree().process_frame

	process_priority = 300
	process_physics_priority = 300

	# PCam Host Signals
	if Engine.has_singleton(_constants.PCAM_MANAGER_NODE_NAME):
		_phantom_camera_manager = Engine.get_singleton(_constants.PCAM_MANAGER_NODE_NAME)
		_phantom_camera_manager.pcam_host_layer_changed.connect(_pcam_host_layer_changed)

		# PCam Signals
		_phantom_camera_manager.pcam_added_to_scene.connect(_pcam_added_to_scene)
		_phantom_camera_manager.pcam_removed_from_scene.connect(_pcam_removed_from_scene)

		_phantom_camera_manager.pcam_priority_changed.connect(pcam_priority_updated)
		_phantom_camera_manager.pcam_priority_override.connect(_pcam_priority_override)

		_phantom_camera_manager.pcam_visibility_changed.connect(_pcam_visibility_changed)

		_phantom_camera_manager.pcam_teleport.connect(_pcam_teleported)

		if _is_2d:
			if not _phantom_camera_manager.limit_2d_changed.is_connected(_update_limit_2d):
				_phantom_camera_manager.limit_2d_changed.connect(_update_limit_2d)
			if not _phantom_camera_manager.draw_limit_2d.is_connected(_draw_limit_2d):
				_phantom_camera_manager.draw_limit_2d.connect(_draw_limit_2d)
	else:
		printerr("Could not find Phantom Camera Manager singleton")
		printerr("Make sure the addon is enable or that the singleton hasn't been disabled inside Project Settings / Globals")

	_find_pcam_with_highest_priority()

	if _is_2d:
		camera_2d.offset = Vector2.ZERO
		if not is_instance_valid(_active_pcam_2d): return
		_active_pcam_2d_glob_transform = _active_pcam_2d.get_transform_output()
	else:
		if not is_instance_valid(_active_pcam_3d): return
		_active_pcam_3d_glob_transform = _active_pcam_3d.get_transform_output()


func _pcam_host_layer_changed(pcam: Node) -> void:
	if _pcam_is_in_host_layer(pcam):
		_check_pcam_priority(pcam)
	else:
		if _is_2d:
			if _active_pcam_2d == pcam:
				_active_pcam_missing = true
				_active_pcam_2d = null
				_active_pcam_priority = -1
				pcam.set_is_active(self, false)
		else:
			if _active_pcam_3d == pcam:
				_active_pcam_missing = true
				_active_pcam_3d = null
				_active_pcam_priority = -1
				pcam.set_is_active(self, false)
		_find_pcam_with_highest_priority()


func _pcam_is_in_host_layer(pcam: Node) -> bool:
	if pcam.host_layers & host_layers != 0: return true
	return false


func _find_pcam_with_highest_priority() -> void:
	var pcam_list: Array
	if _is_2d:
		pcam_list = _phantom_camera_manager.phantom_camera_2ds
	else:
		pcam_list = _phantom_camera_manager.phantom_camera_3ds

	for pcam in pcam_list:
		_check_pcam_priority(pcam)


func _check_pcam_priority(pcam: Node) -> void:
	if not _pcam_is_in_host_layer(pcam): return
	if not pcam.visible: return # Prevents hidden PCams from becoming active
	if pcam.get_priority() > _active_pcam_priority:
		_assign_new_active_pcam(pcam)
		_active_pcam_missing = false
	else:
		pcam.set_tween_skip(self, false)


func _assign_new_active_pcam(pcam: Node) -> void:
	# Only checks if the scene tree is still present.
	# Prevents a few errors and checks from happening if the scene is exited.
	if not is_inside_tree(): return
	var no_previous_pcam: bool
	if is_instance_valid(_active_pcam_2d) or is_instance_valid(_active_pcam_3d):
		if OS.has_feature("debug"):
			viewfinder_disable_dead_zone.emit()

		if _is_2d:
			_prev_active_pcam_2d_transform = camera_2d.global_transform
			_active_pcam_2d.queue_redraw()
			_active_pcam_2d.set_is_active(self, false)
			_active_pcam_2d.became_inactive.emit()
			pcam_became_inactive.emit(_active_pcam_2d)

			if _active_pcam_2d.physics_target_changed.is_connected(_check_pcam_physics):
				_active_pcam_2d.physics_target_changed.disconnect(_check_pcam_physics)

			if _active_pcam_2d.noise_emitted.is_connected(_noise_emitted_2d):
				_active_pcam_2d.noise_emitted.disconnect(_noise_emitted_2d)

			if _trigger_pcam_tween:
				_active_pcam_2d.tween_interrupted.emit(pcam)
		else:
			_prev_active_pcam_3d_transform = camera_3d.global_transform
			_active_pcam_3d.set_is_active(self, false)
			_active_pcam_3d.became_inactive.emit()
			pcam_became_inactive.emit(_active_pcam_3d)

			if _active_pcam_3d.physics_target_changed.is_connected(_check_pcam_physics):
				_active_pcam_3d.physics_target_changed.disconnect(_check_pcam_physics)

			if _active_pcam_3d.noise_emitted.is_connected(_noise_emitted_3d):
				_active_pcam_3d.noise_emitted.disconnect(_noise_emitted_3d)

			if _active_pcam_3d.camera_3d_resource_changed.is_connected(_camera_3d_resource_changed):
				_active_pcam_3d.camera_3d_resource_changed.disconnect(_camera_3d_resource_changed)

			if _active_pcam_3d.camera_3d_resource_property_changed.is_connected(_camera_3d_resource_property_changed):
				_active_pcam_3d.camera_3d_resource_property_changed.disconnect(_camera_3d_resource_property_changed)

			if _trigger_pcam_tween:
				_active_pcam_3d.tween_interrupted.emit(pcam)

			if camera_3d.attributes != null:
				var _attributes: CameraAttributes = camera_3d.attributes

				_prev_cam_exposure_multiplier = _attributes.exposure_multiplier
				_prev_cam_auto_exposure_scale = _attributes.auto_exposure_scale
				_prev_cam_auto_exposure_speed = _attributes.auto_exposure_speed

				if camera_3d.attributes is CameraAttributesPractical:
					_attributes = _attributes as CameraAttributesPractical

					_prev_cam_dof_blur_amount = _attributes.dof_blur_amount

					if _attributes.dof_blur_far_enabled:
						_prev_cam_dof_blur_far_distance = _attributes.dof_blur_far_distance
						_prev_cam_dof_blur_far_transition = _attributes.dof_blur_far_transition
					else:
						_prev_cam_dof_blur_far_distance = _cam_dof_blur_far_distance_default
						_prev_cam_dof_blur_far_transition = _cam_dof_blur_far_transition_default

					if _attributes.dof_blur_near_enabled:
						_prev_cam_dof_blur_near_distance = _attributes.dof_blur_near_distance
						_prev_cam_dof_blur_near_transition = _attributes.dof_blur_near_transition
					else:
						_prev_cam_dof_blur_near_distance = _cam_dof_blur_near_distance_default
						_prev_cam_dof_blur_near_transition = _cam_dof_blur_near_transition_default

					if _attributes.auto_exposure_enabled:
						_prev_cam_exposure_max_sensitivity = _attributes.auto_exposure_max_sensitivity
						_prev_cam_exposure_min_sensitivity = _attributes.auto_exposure_min_sensitivity

				elif camera_3d.attributes is CameraAttributesPhysical:
					_attributes = _attributes as CameraAttributesPhysical

					_prev_cam_frustum_focus_distance = _attributes.frustum_focus_distance
					_prev_cam_frustum_focal_length = _attributes.frustum_focal_length
					_prev_cam_frustum_far = _attributes.frustum_far
					_prev_cam_frustum_near = _attributes.frustum_near
					_prev_cam_exposure_aperture = _attributes.exposure_aperture
					_prev_cam_exposure_shutter_speed = _attributes.exposure_shutter_speed

					if _attributes.auto_exposure_enabled:
						_prev_cam_exposure_min_exposure_value = _attributes.auto_exposure_min_exposure_value
						_prev_cam_exposure_max_exposure_value = _attributes.auto_exposure_max_exposure_value

			_prev_cam_h_offset = camera_3d.h_offset
			_prev_cam_v_offset = camera_3d.v_offset
			_prev_cam_fov = camera_3d.fov
			_prev_cam_size = camera_3d.size
			_prev_cam_frustum_offset = camera_3d.frustum_offset
			_prev_cam_near = camera_3d.near
			_prev_cam_far = camera_3d.far

	else:
		no_previous_pcam = true

	## Assign newly active pcam
	if _is_2d:
		_active_pcam_2d = pcam
		_active_pcam_priority = _active_pcam_2d.priority
		_active_pcam_has_damping = _active_pcam_2d.follow_damping
		_tween_duration = _active_pcam_2d.tween_duration

		if not _active_pcam_2d.physics_target_changed.is_connected(_check_pcam_physics):
			_active_pcam_2d.physics_target_changed.connect(_check_pcam_physics)

		if not _active_pcam_2d.noise_emitted.is_connected(_noise_emitted_2d):
			_active_pcam_2d.noise_emitted.connect(_noise_emitted_2d)
	else:
		_active_pcam_3d = pcam
		_active_pcam_priority = _active_pcam_3d.priority
		_active_pcam_has_damping = _active_pcam_3d.follow_damping
		_tween_duration = _active_pcam_3d.tween_duration

		if not Engine.is_editor_hint():
			# Assigns a default shape to SpringArm3D node is none is supplied
			if _active_pcam_3d.follow_mode == _active_pcam_3d.FollowMode.THIRD_PERSON:
				if not _active_pcam_3d.shape:

					var pyramid_shape_data = Engine.get_singleton("PhysicsServer3D").call("shape_get_data",
						camera_3d.get_pyramid_shape_rid()
					)
					var shape = ClassDB.instantiate("ConvexPolygonShape3D")
					shape.points = pyramid_shape_data
					_active_pcam_3d.shape = shape

		if not _active_pcam_3d.physics_target_changed.is_connected(_check_pcam_physics):
			_active_pcam_3d.physics_target_changed.connect(_check_pcam_physics)

		if not _active_pcam_3d.noise_emitted.is_connected(_noise_emitted_3d):
			_active_pcam_3d.noise_emitted.connect(_noise_emitted_3d)

		if not _active_pcam_3d.camera_3d_resource_changed.is_connected(_camera_3d_resource_changed):
			_active_pcam_3d.camera_3d_resource_changed.connect(_camera_3d_resource_changed)

		if not _active_pcam_3d.camera_3d_resource_property_changed.is_connected(_camera_3d_resource_property_changed):
			_active_pcam_3d.camera_3d_resource_property_changed.connect(_camera_3d_resource_property_changed)

		# Checks if the Camera3DResource has changed from the previous active PCam3D
		if _active_pcam_3d.camera_3d_resource:
			# Signal to detect if the Camera3D properties are being changed in the inspector
			# This is to prevent accidential misalignment between the Camera3D and Camera3DResource
			if Engine.is_editor_hint():
				if not Engine.get_singleton(&"EditorInterface").get_inspector().property_edited.is_connected(_camera_3d_edited):
					Engine.get_singleton(&"EditorInterface").get_inspector().property_edited.connect(_camera_3d_edited)
			if _prev_cam_h_offset != _active_pcam_3d.h_offset:
				_cam_h_offset_changed = true
			if _prev_cam_v_offset != _active_pcam_3d.v_offset:
				_cam_v_offset_changed = true
			if _prev_cam_fov != _active_pcam_3d.fov:
				_cam_fov_changed = true
			if _prev_cam_size != _active_pcam_3d.size:
				_cam_size_changed = true
			if _prev_cam_frustum_offset != _active_pcam_3d.frustum_offset:
				_cam_frustum_offset_changed = true
			if _prev_cam_near != _active_pcam_3d.near:
				_cam_near_changed = true
			if _prev_cam_far != _active_pcam_3d.far:
				_cam_far_changed = true
		else:
			_cam_h_offset_changed = false
			_cam_v_offset_changed = false
			_cam_fov_changed = false
			_cam_size_changed = false
			_cam_frustum_offset_changed = false
			_cam_near_changed = false
			_cam_far_changed = false
			_cam_attribute_changed = false
			if Engine.is_editor_hint():
				if Engine.get_singleton(&"EditorInterface").get_inspector().property_edited.is_connected(_camera_3d_edited):
					Engine.get_singleton(&"EditorInterface").get_inspector().property_edited.disconnect(_camera_3d_edited)

		if _active_pcam_3d.attributes == null:
			_cam_attribute_changed = false
		else:
			if _prev_cam_attributes != _active_pcam_3d.attributes:
				_prev_cam_attributes = _active_pcam_3d.attributes
				_cam_attribute_changed = true
				var _attributes: CameraAttributes = _active_pcam_3d.attributes

				if _prev_cam_auto_exposure_scale != _attributes.auto_exposure_scale:
					_cam_auto_exposure_scale_changed = true
				if _prev_cam_auto_exposure_speed != _attributes.auto_exposure_speed:
					_cam_auto_exposure_speed_changed = true
				if _prev_cam_exposure_multiplier != _attributes.exposure_multiplier:
					_cam_exposure_multiplier_changed = true
				if _prev_cam_exposure_sensitivity != _attributes.exposure_sensitivity:
					_cam_exposure_sensitivity_changed = true

				if _attributes is CameraAttributesPractical:
					_cam_attribute_type = 0

					if camera_3d.attributes == null:
						camera_3d.attributes = CameraAttributesPractical.new()
						camera_3d.attributes = _active_pcam_3d.attributes.duplicate()
						_cam_attribute_assigned = true

					if _prev_cam_exposure_min_sensitivity != _attributes.auto_exposure_min_sensitivity:
						_cam_exposure_min_sensitivity_changed = true
					if _prev_cam_exposure_max_sensitivity != _attributes.auto_exposure_max_sensitivity:
						_cam_exposure_max_sensitivity_changed = true

					if _prev_cam_dof_blur_amount != _attributes.dof_blur_amount:
						_cam_dof_blur_amount_changed = true

					if _prev_cam_dof_blur_far_distance != _attributes.dof_blur_far_distance:
						_cam_dof_blur_far_distance_changed = true
						camera_3d.attributes.dof_blur_far_enabled = true
					if _prev_cam_dof_blur_far_transition != _attributes.dof_blur_far_transition:
						_cam_dof_blur_far_transition_changed = true
						camera_3d.attributes.dof_blur_far_enabled = true

					if _prev_cam_dof_blur_near_distance != _attributes.dof_blur_near_distance:
						_cam_dof_blur_near_distance_changed = true
						camera_3d.attributes.dof_blur_near_enabled = true
					if _prev_cam_dof_blur_near_transition != _attributes.dof_blur_near_transition:
						_cam_dof_blur_near_transition_changed = true
						camera_3d.attributes.dof_blur_near_enabled = true
				elif _attributes is CameraAttributesPhysical:
					_cam_attribute_type = 1

					if camera_3d.attributes == null:
						camera_3d.attributes = CameraAttributesPhysical.new()
						camera_3d.attributes = _active_pcam_3d.attributes.duplicate()

					if _prev_cam_exposure_min_exposure_value != _attributes.auto_exposure_min_exposure_value:
						_cam_exposure_min_exposure_value_changed = true
					if _prev_cam_exposure_max_exposure_value != _attributes.auto_exposure_max_exposure_value:
						_cam_exposure_max_exposure_value_changed = true

					if _prev_cam_exposure_aperture != _attributes.exposure_aperture:
						_cam_exposure_aperture_changed = true
					if _prev_cam_exposure_shutter_speed != _attributes.exposure_shutter_speed:
						_cam_exposure_shutter_speed_changed = true

					if _prev_cam_frustum_far != _attributes.frustum_far:
						_cam_frustum_far_changed = true

					if _prev_cam_frustum_focal_length != _attributes.frustum_focal_length:
						_cam_frustum_focal_length_changed = true

					if _prev_cam_frustum_focus_distance != _attributes.frustum_focus_distance:
						_cam_frustum_focus_distance_changed = true

					if _prev_cam_frustum_near != _attributes.frustum_near:
						_cam_frustum_near_changed = true

	if OS.has_feature("debug"):
		viewfinder_update.emit(false)

	if _is_2d:
		if _active_pcam_2d.show_viewfinder_in_play:
			_viewfinder_needed_check = true

		_active_pcam_2d.set_is_active(self, true)
		_active_pcam_2d.became_active.emit()
		pcam_became_active.emit(_active_pcam_2d)
		_camera_zoom = camera_2d.zoom
	else:
		if _active_pcam_3d.show_viewfinder_in_play:
			_viewfinder_needed_check = true

		_active_pcam_3d.set_is_active(self, true)
		_active_pcam_3d.became_active.emit()
		pcam_became_active.emit(_active_pcam_3d)
		if _active_pcam_3d.camera_3d_resource:
			camera_3d.keep_aspect = _active_pcam_3d.keep_aspect
			camera_3d.cull_mask = _active_pcam_3d.cull_mask
			camera_3d.projection = _active_pcam_3d.projection

	if no_previous_pcam:
		if _is_2d:
			_prev_active_pcam_2d_transform = _active_pcam_2d.get_transform_output()
		else:
			_prev_active_pcam_3d_transform = _active_pcam_3d.get_transform_output()

	if pcam.get_tween_skip() or pcam.tween_duration == 0:
		_tween_elapsed_time = pcam.tween_duration
		if Engine.get_version_info().major == 4 and \
		Engine.get_version_info().minor >= 3:
			_tween_is_instant = true
	else:
		_tween_elapsed_time = 0

	_check_pcam_physics()

	_trigger_pcam_tween = true


func _check_pcam_physics() -> void:
	if _is_2d:
		if _active_pcam_2d.get_follow_target_physics_based() and interpolation_mode != InterpolationMode.IDLE:
			_follow_target_physics_based = true
			camera_2d.reset_physics_interpolation()
			camera_2d.physics_interpolation_mode = Node.PHYSICS_INTERPOLATION_MODE_ON
			if ProjectSettings.get_setting("physics/common/physics_interpolation"):
				camera_2d.process_callback = Camera2D.CAMERA2D_PROCESS_PHYSICS # Prevents a warning
			else:
				camera_2d.process_callback = Camera2D.CAMERA2D_PROCESS_IDLE
		else:
			_follow_target_physics_based = false
			camera_2d.physics_interpolation_mode = Node.PHYSICS_INTERPOLATION_MODE_INHERIT
			if get_tree().physics_interpolation:
				camera_2d.process_callback = Camera2D.CAMERA2D_PROCESS_PHYSICS # Prevents a warning
			else:
				camera_2d.process_callback = Camera2D.CAMERA2D_PROCESS_IDLE
	else:
		## NOTE - Only supported in Godot 4.4 or later
		if Engine.get_version_info().major == 4 and \
		Engine.get_version_info().minor >= 4:
			if (get_tree().physics_interpolation or _active_pcam_3d.get_follow_target_physics_based()) and interpolation_mode != InterpolationMode.IDLE:
				#if get_tree().physics_interpolation or _active_pcam_3d.get_follow_target_physics_based():
				_follow_target_physics_based = true
				camera_3d.reset_physics_interpolation()
				camera_3d.physics_interpolation_mode = Node.PHYSICS_INTERPOLATION_MODE_ON
			else:
				_follow_target_physics_based = false
				camera_3d.physics_interpolation_mode = Node.PHYSICS_INTERPOLATION_MODE_INHERIT


## TODO - For 0.8 release
#func _find_pcam_with_highest_priority() -> void:
	#var highest_priority_pcam: Node
	#for pcam in _pcam_list:
		#if not pcam.visible: continue # Prevents hidden PCams from becoming active
		#if pcam.priority > _active_pcam_priority:
			#_active_pcam_priority = pcam.priority
			#highest_priority_pcam = pcam
		#pcam.set_has_tweened(self, false)
#
		#_active_pcam_missing = false
#
	#if is_instance_valid(highest_priority_pcam):
		#_assign_new_active_pcam(highest_priority_pcam)
	#else:
		#_active_pcam_missing = true


func _process(delta: float) -> void:
	if _active_pcam_missing: return

	if not _follow_target_physics_based: _tween_follow_checker(delta)


func _physics_process(delta: float) -> void:
	if _active_pcam_missing or not _follow_target_physics_based: return
	_tween_follow_checker(delta)


func _tween_follow_checker(delta: float) -> void:
	if _is_2d:
		if not is_instance_valid(_active_pcam_2d):
			_active_pcam_missing = true
			return

		_active_pcam_2d.process_logic(delta)
		_active_pcam_2d_glob_transform = _active_pcam_2d.get_transform_output()

		if _reset_noise_offset_2d:
			camera_2d.offset = Vector2.ZERO # Resets noise position
			_reset_noise_offset_2d = false
	else:
		if not is_instance_valid(_active_pcam_3d):
			_active_pcam_missing = true
			return

		_active_pcam_3d.process_logic(delta)
		_active_pcam_3d_glob_transform = _active_pcam_3d.get_transform_output()

	if not _trigger_pcam_tween:
		# Rechecks physics target if PCam transitioned with an instant tween
		if _tween_is_instant:
			_check_pcam_physics()
			_tween_is_instant = false
		_pcam_follow(delta)
	else:
		_pcam_tween(delta)

	# Camera Noise
	if _is_2d:
		if not _has_noise_emitted and not _active_pcam_2d.has_noise_resource(): return
		camera_2d.offset += _active_pcam_2d.get_noise_transform().origin + _noise_emitted_output_2d.origin
		if camera_2d.ignore_rotation and _noise_emitted_output_2d.get_rotation() != 0:
			push_warning(camera_2d.name, " has ignore_rotation enabled. Uncheck the property if you want to apply rotational noise.")
		else:
			camera_2d.rotation += _active_pcam_2d.get_noise_transform().get_rotation() + _noise_emitted_output_2d.get_rotation()
		_has_noise_emitted = false
		_reset_noise_offset_2d = true
	else:
		if not _has_noise_emitted and not _active_pcam_3d.has_noise_resource(): return
		camera_3d.global_transform *= _active_pcam_3d.get_noise_transform() * _noise_emitted_output_3d
		_has_noise_emitted = false


func _pcam_follow(_delta: float) -> void:
	if _active_pcam_missing or not _is_child_of_camera: return

	if _is_2d:
		if _active_pcam_2d.snap_to_pixel:
			var snap_to_pixel_glob_transform: Transform2D = _active_pcam_2d_glob_transform
			snap_to_pixel_glob_transform.origin = snap_to_pixel_glob_transform.origin.round()
			camera_2d.global_transform = snap_to_pixel_glob_transform
		else:
			camera_2d.global_transform = _active_pcam_2d_glob_transform
		camera_2d.zoom = _active_pcam_2d.zoom
	else:
		camera_3d.global_transform = _active_pcam_3d_glob_transform

	if _viewfinder_needed_check:
		_show_viewfinder_in_play()
		_viewfinder_needed_check = false

	if Engine.is_editor_hint():
		if not _is_2d:
			# TODO - Signal-based solution pending merge of: https://github.com/godotengine/godot/pull/99729
			if _active_pcam_3d.attributes != null:
				camera_3d.attributes = _active_pcam_3d.attributes.duplicate()

			# TODO - Signal-based solution pending merge of: https://github.com/godotengine/godot/pull/99873
			if _active_pcam_3d.environment != null:
				camera_3d.environment = _active_pcam_3d.environment.duplicate()


func _noise_emitted_2d(noise_output: Transform2D) -> void:
	_noise_emitted_output_2d = noise_output
	_has_noise_emitted = true


func _noise_emitted_3d(noise_output: Transform3D) -> void:
	_noise_emitted_output_3d = noise_output
	_has_noise_emitted = true


func _camera_3d_resource_changed() -> void:
	if _active_pcam_3d.camera_3d_resource:
		if Engine.is_editor_hint():
			if not Engine.get_singleton(&"EditorInterface").get_inspector().property_edited.is_connected(_camera_3d_edited):
				Engine.get_singleton(&"EditorInterface").get_inspector().property_edited.connect(_camera_3d_edited)
		camera_3d.keep_aspect = _active_pcam_3d.keep_aspect
		camera_3d.cull_mask = _active_pcam_3d.cull_mask
		camera_3d.h_offset = _active_pcam_3d.h_offset
		camera_3d.v_offset = _active_pcam_3d.v_offset
		camera_3d.projection = _active_pcam_3d.projection
		camera_3d.fov = _active_pcam_3d.fov
		camera_3d.size = _active_pcam_3d.size
		camera_3d.frustum_offset = _active_pcam_3d.frustum_offset
		camera_3d.near = _active_pcam_3d.near
		camera_3d.far = _active_pcam_3d.far
	else:
		if Engine.is_editor_hint():
			if Engine.get_singleton(&"EditorInterface").get_inspector().property_edited.is_connected(_camera_3d_edited):
				Engine.get_singleton(&"EditorInterface").get_inspector().property_edited.disconnect(_camera_3d_edited)

func _camera_3d_edited(value: String) -> void:
	if not Engine.get_singleton(&"EditorInterface").get_inspector().get_edited_object() == camera_3d: return
	camera_3d.set(value, _active_pcam_3d.camera_3d_resource.get(value))
	push_warning("Camera3D properties are being overridden by ", _active_pcam_3d.name, "'s Camera3DResource")

func _camera_3d_resource_property_changed(property: StringName, value: Variant) -> void:
	camera_3d.set(property, value)


func _pcam_tween(delta: float) -> void:
	# TODO - Should be optimised
	# Run at the first tween frame
	if _tween_elapsed_time == 0:
		if _is_2d:
			_active_pcam_2d.tween_started.emit()
			_active_pcam_2d.reset_limit()
		else:
			_active_pcam_3d.tween_started.emit()

	_tween_elapsed_time = min(_tween_duration, _tween_elapsed_time + delta)

	if _is_2d:
		_active_pcam_2d.is_tweening.emit()
		var interpolation_destination: Vector2 = _tween_interpolate_value(
			_prev_active_pcam_2d_transform.origin,
			_active_pcam_2d_glob_transform.origin,
			_active_pcam_2d.tween_duration,
			_active_pcam_2d.tween_transition,
			_active_pcam_2d.tween_ease
		)

		if _active_pcam_2d.snap_to_pixel:
			camera_2d.global_position = interpolation_destination.round()
		else:
			camera_2d.global_position = interpolation_destination

		camera_2d.rotation = _tween_interpolate_value(
			_prev_active_pcam_2d_transform.get_rotation(),
			_active_pcam_2d_glob_transform.get_rotation(),
			_active_pcam_2d.tween_duration,
			_active_pcam_2d.tween_transition,
			_active_pcam_2d.tween_ease
		)
		camera_2d.zoom = _tween_interpolate_value(
			_camera_zoom,
			_active_pcam_2d.zoom,
			_active_pcam_2d.tween_duration,
			_active_pcam_2d.tween_transition,
			_active_pcam_2d.tween_ease
		)
	else:
		_active_pcam_3d.is_tweening.emit()
		camera_3d.global_position = _tween_interpolate_value(
			_prev_active_pcam_3d_transform.origin,
			_active_pcam_3d_glob_transform.origin,
			_active_pcam_3d.tween_duration,
			_active_pcam_3d.tween_transition,
			_active_pcam_3d.tween_ease
		)

		var prev_active_pcam_3d_quat: Quaternion = Quaternion(_prev_active_pcam_3d_transform.basis.orthonormalized())
		camera_3d.quaternion = \
			Tween.interpolate_value(
				prev_active_pcam_3d_quat, \
				prev_active_pcam_3d_quat.inverse() * Quaternion(_active_pcam_3d_glob_transform.basis.orthonormalized()),
				_tween_elapsed_time, \
				_active_pcam_3d.tween_duration, \
				_active_pcam_3d.tween_transition,
				_active_pcam_3d.tween_ease
			)

		if _cam_attribute_changed:
			if _active_pcam_3d.attributes.auto_exposure_enabled:
				if _cam_auto_exposure_scale_changed:
					camera_3d.attributes.auto_exposure_scale = \
						_tween_interpolate_value(
						_prev_cam_auto_exposure_scale,
						_active_pcam_3d.attributes.auto_exposure_scale,
						_active_pcam_3d.tween_duration,
						_active_pcam_3d.tween_transition,
						_active_pcam_3d.tween_ease
					)
				if _cam_auto_exposure_speed_changed:
					camera_3d.attributes.auto_exposure_speed = \
						_tween_interpolate_value(
						_prev_cam_auto_exposure_scale,
						_active_pcam_3d.attributes.auto_exposure_scale,
						_active_pcam_3d.tween_duration,
						_active_pcam_3d.tween_transition,
						_active_pcam_3d.tween_ease
					)

			if _cam_attribute_type == 0: # CameraAttributePractical
				if _active_pcam_3d.attributes.auto_exposure_enabled:
					if _cam_exposure_min_sensitivity_changed:
						camera_3d.attributes.auto_exposure_min_sensitivity = \
							_tween_interpolate_value(
							_prev_cam_exposure_min_sensitivity,
							_active_pcam_3d.attributes.auto_exposure_min_sensitivity,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
					if _cam_exposure_max_sensitivity_changed:
						camera_3d.attributes.auto_exposure_max_sensitivity = \
							_tween_interpolate_value(
							_prev_cam_exposure_max_sensitivity,
							_active_pcam_3d.attributes.auto_exposure_max_sensitivity,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_dof_blur_amount_changed:
					camera_3d.attributes.dof_blur_amount = \
						_tween_interpolate_value(
							_prev_cam_dof_blur_amount,
							_active_pcam_3d.attributes.dof_blur_amount,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_dof_blur_far_distance_changed:
					camera_3d.attributes.dof_blur_far_distance = \
						_tween_interpolate_value(
							_prev_cam_dof_blur_far_distance,
							_active_pcam_3d.attributes.dof_blur_far_distance,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_dof_blur_far_transition_changed:
					camera_3d.attributes.dof_blur_far_transition = \
						_tween_interpolate_value(
							_prev_cam_dof_blur_far_transition,
							_active_pcam_3d.attributes.dof_blur_far_transition,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_dof_blur_near_distance_changed:
					camera_3d.attributes.dof_blur_near_distance = \
						_tween_interpolate_value(
							_prev_cam_dof_blur_near_distance,
							_active_pcam_3d.attributes.dof_blur_near_distance,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_dof_blur_near_transition_changed:
					camera_3d.attributes.dof_blur_near_transition = \
						_tween_interpolate_value(
							_prev_cam_dof_blur_near_transition,
							_active_pcam_3d.attributes.dof_blur_near_transition,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
			elif _cam_attribute_type == 1: # CameraAttributePhysical
				if _cam_dof_blur_near_transition_changed:
					camera_3d.attributes.auto_exposure_max_exposure_value = \
						_tween_interpolate_value(
							_prev_cam_exposure_max_exposure_value,
							_active_pcam_3d.attributes.auto_exposure_max_exposure_value,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_exposure_min_exposure_value_changed:
					camera_3d.attributes.auto_exposure_min_exposure_value = \
						_tween_interpolate_value(
							_prev_cam_exposure_min_exposure_value,
							_active_pcam_3d.attributes.auto_exposure_min_exposure_value,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_exposure_aperture_changed:
					camera_3d.attributes.exposure_aperture = \
						_tween_interpolate_value(
							_prev_cam_exposure_aperture,
							_active_pcam_3d.attributes.exposure_aperture,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_exposure_shutter_speed_changed:
					camera_3d.attributes.exposure_shutter_speed = \
						_tween_interpolate_value(
							_prev_cam_exposure_shutter_speed,
							_active_pcam_3d.attributes.exposure_shutter_speed,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_frustum_far_changed:
					camera_3d.attributes.frustum_far = \
						_tween_interpolate_value(
							_prev_cam_frustum_far,
							_active_pcam_3d.attributes.frustum_far,
							_active_pcam_3d.tween_duration(),
							_active_pcam_3d.tween_transition(),
							_active_pcam_3d.tween_ease
						)
				if _cam_frustum_near_changed:
					camera_3d.attributes.frustum_near = \
						_tween_interpolate_value(
							_prev_cam_frustum_far,
							_active_pcam_3d.attributes.frustum_near,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_frustum_focal_length_changed:
					camera_3d.attributes.frustum_focal_length = \
						_tween_interpolate_value(
							_prev_cam_frustum_focal_length,
							_active_pcam_3d.attributes.frustum_focal_length,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)
				if _cam_frustum_focus_distance_changed:
					camera_3d.attributes.frustum_focus_distance = \
						_tween_interpolate_value(
							_prev_cam_frustum_focus_distance,
							_active_pcam_3d.attributes.frustum_focus_distance,
							_active_pcam_3d.tween_duration,
							_active_pcam_3d.tween_transition,
							_active_pcam_3d.tween_ease
						)

		if _cam_h_offset_changed:
			camera_3d.h_offset = \
				_tween_interpolate_value(
					_prev_cam_h_offset,
					_active_pcam_3d.h_offset,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_v_offset_changed:
			camera_3d.v_offset = \
				_tween_interpolate_value(
					_prev_cam_v_offset,
					_active_pcam_3d.v_offset,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_fov_changed:
			camera_3d.fov = \
				_tween_interpolate_value(
					_prev_cam_fov,
					_active_pcam_3d.fov,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_size_changed:
			camera_3d.size = \
				_tween_interpolate_value(
					_prev_cam_size,
					_active_pcam_3d.size,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_frustum_offset_changed:
			camera_3d.frustum_offset = \
				_tween_interpolate_value(
					_prev_cam_frustum_offset,
					_active_pcam_3d.frustum_offset,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_near_changed:
			camera_3d.near = \
				_tween_interpolate_value(
					_prev_cam_near,
					_active_pcam_3d.near,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

		if _cam_far_changed:
			camera_3d.far = \
				_tween_interpolate_value(
					_prev_cam_far,
					_active_pcam_3d.far,
					_active_pcam_3d.tween_duration,
					_active_pcam_3d.tween_transition,
					_active_pcam_3d.tween_ease
				)

	# Forcefully disables physics interpolation when tweens are instant
	if _tween_is_instant:
			if _is_2d:
				camera_2d.physics_interpolation_mode = Node.PHYSICS_INTERPOLATION_MODE_OFF
				camera_2d.reset_physics_interpolation()
			else:
				if Engine.get_version_info().major == 4 and \
				Engine.get_version_info().minor >= 4:
					camera_3d.physics_interpolation_mode = Node.PHYSICS_INTERPOLATION_MODE_OFF
					camera_3d.reset_physics_interpolation()

	if _tween_elapsed_time < _tween_duration: return

	_trigger_pcam_tween = false
	_tween_elapsed_time = 0
	viewfinder_update.emit(true)

	if _is_2d:
		_active_pcam_2d.update_limit_all_sides()
		_active_pcam_2d.tween_completed.emit()
		_active_pcam_2d.set_tween_skip(self, false)
		if Engine.is_editor_hint():
			_active_pcam_2d.queue_redraw()
	else:
		if _active_pcam_3d.camera_3d_resource and _active_pcam_3d.attributes != null:
			if _cam_attribute_type == 0:
				if not _active_pcam_3d.attributes.dof_blur_far_enabled:
					camera_3d.attributes.dof_blur_far_enabled = false
				if not _active_pcam_3d.attributes.dof_blur_near_enabled:
					camera_3d.attributes.dof_blur_near_enabled = false
		_cam_h_offset_changed = false
		_cam_v_offset_changed = false
		_cam_fov_changed = false
		_cam_size_changed = false
		_cam_frustum_offset_changed = false
		_cam_near_changed = false
		_cam_far_changed = false
		_cam_attribute_changed = false

		_active_pcam_3d.set_tween_skip(self, false)
		_active_pcam_3d.tween_completed.emit()


func _tween_interpolate_value(from: Variant, to: Variant, duration: float, transition_type: int, ease_type: int) -> Variant:
	return Tween.interpolate_value(
		from, \
		to - from,
		_tween_elapsed_time, \
		duration, \
		transition_type,
		ease_type,
	)


func _show_viewfinder_in_play() -> void:
	# Don't show the viewfinder in the actual editor or project builds
	if Engine.is_editor_hint() or !OS.has_feature("editor"): return

	# Default the viewfinder node to be hidden
	if is_instance_valid(_viewfinder_node):
		_viewfinder_node.visible = false

	if _is_2d:
		if not _active_pcam_2d.show_viewfinder_in_play: return
		if _active_pcam_2d.follow_mode != _active_pcam_2d.FollowMode.FRAMED: return
	else:
		if not _active_pcam_3d.show_viewfinder_in_play: return
		if _active_pcam_3d.follow_mode != _active_pcam_2d.FollowMode.FRAMED: return

	var canvas_layer: CanvasLayer = CanvasLayer.new()
	get_tree().get_root().add_child(canvas_layer)

	# Instantiate the viewfinder scene if it isn't already
	if not is_instance_valid(_viewfinder_node):
		var _viewfinder_scene := load("res://addons/phantom_camera/panel/viewfinder/viewfinder_panel.tscn")
		_viewfinder_node = _viewfinder_scene.instantiate()
		canvas_layer.add_child(_viewfinder_node)

	_viewfinder_node.visible = true
	_viewfinder_node.update_dead_zone()


func _update_limit_2d(side: int, limit: int) -> void:
	if is_instance_valid(camera_2d):
		camera_2d.set_limit(side, limit)

func _draw_limit_2d(enabled: bool) -> void:
	camera_2d.set_limit_drawing_enabled(enabled)


## Called when a [param PhantomCamera] is added to the scene.[br]
## [b]Note:[/b] This can only be called internally from a [param PhantomCamera] node.
func _pcam_added_to_scene(pcam: Node) -> void:
	if not pcam.is_node_ready(): await pcam.ready
	_check_pcam_priority(pcam)


## Called when a [param PhantomCamera] is removed from the scene.[br]
## [b]Note:[/b] This can only be called internally from a
## [param PhantomCamera] node.
func _pcam_removed_from_scene(pcam: Node) -> void:
	if _is_2d:
		if pcam == _active_pcam_2d:
			_active_pcam_2d = null
			_active_pcam_missing = true
			_active_pcam_priority = -1
			_find_pcam_with_highest_priority()
	else:
		if pcam == _active_pcam_3d:
			_active_pcam_3d = null
			_active_pcam_missing = true
			_active_pcam_priority = -1
			_find_pcam_with_highest_priority()


func _pcam_visibility_changed(pcam: Node) -> void:
	if pcam == _active_pcam_2d or pcam == _active_pcam_3d:
		_active_pcam_priority = -1
		_find_pcam_with_highest_priority()
		return
	_check_pcam_priority(pcam)


func _pcam_teleported(pcam: Node) -> void:
	if _is_2d:
		if not pcam == _active_pcam_2d: return
		if not is_instance_valid(camera_2d): return
		camera_2d.global_position = _active_pcam_2d.get_transform_output().origin
		camera_2d.reset_physics_interpolation()
	else:
		if not pcam == _active_pcam_3d: return
		if not is_instance_valid(camera_3d): return
		camera_3d.global_position = _active_pcam_3d.get_transform_output().origin
		camera_3d.reset_physics_interpolation()


func _set_layer(current_layers: int, layer_number: int, value: bool) -> int:
	var mask: int = current_layers

	# From https://github.com/godotengine/godot/blob/51991e20143a39e9ef0107163eaf283ca0a761ea/scene/3d/camera_3d.cpp#L638
	if layer_number < 1 or layer_number > 20:
		printerr("Render layer must be between 1 and 20.")
	else:
		if value:
			mask |= 1 << (layer_number - 1)
		else:
			mask &= ~(1 << (layer_number - 1))

	return mask

#endregion

#region Public Functions

## Triggers a recalculation to determine which PhantomCamera has the highest priority.
func pcam_priority_updated(pcam: Node) -> void:
	if not is_instance_valid(pcam): return
	if not _pcam_is_in_host_layer(pcam): return

	if pcam == _active_pcam_2d or pcam == _active_pcam_3d:
		if not pcam.visible:
			refresh_pcam_list_priorty()

	if Engine.is_editor_hint():
		if _is_2d:
			if not is_instance_valid(_active_pcam_2d): return
			if _active_pcam_2d.priority_override: return
		else:
			if not is_instance_valid(_active_pcam_3d): return
			if _active_pcam_3d.priority_override: return

	var current_pcam_priority: int = pcam.priority

	if current_pcam_priority >= _active_pcam_priority:
		if _is_2d:
			if pcam != _active_pcam_2d:
				_assign_new_active_pcam(pcam)
		else:
			if pcam != _active_pcam_3d:
				_assign_new_active_pcam(pcam)
		pcam.set_tween_skip(self, false)
		_active_pcam_missing = false

	if pcam == _active_pcam_2d or pcam == _active_pcam_3d:
		if current_pcam_priority <= _active_pcam_priority:
			_active_pcam_priority = current_pcam_priority
			_find_pcam_with_highest_priority()
		else:
			_active_pcam_priority = current_pcam_priority


## Updates the viewfinder when a [param PhantomCamera] has its
## [param priority_ovrride] enabled.[br]
## [b]Note:[/b] This only affects the editor.
func _pcam_priority_override(pcam: Node, should_override: bool) -> void:
	if not Engine.is_editor_hint(): return
	if not _pcam_is_in_host_layer(pcam): return
	if should_override:
		if _is_2d:
			if is_instance_valid(_active_pcam_2d):
				if _active_pcam_2d.priority_override:
					_active_pcam_2d.priority_override = false
		else:
			if is_instance_valid(_active_pcam_3d):
				if _active_pcam_3d.priority_override:
					_active_pcam_3d.priority_override = false
		_assign_new_active_pcam(pcam)
	else:
		_find_pcam_with_highest_priority()

	viewfinder_update.emit(false)


## Updates the viewfinder when a [param PhantomCamera] has its
## [param priority_ovrride] disabled.[br]
## [b]Note:[/b] This only affects the editor.
func pcam_priority_override_disabled() -> void:
	viewfinder_update.emit(false)


## Returns the currently active [param PhantomCamera]
func get_active_pcam() -> Node:
	if _is_2d:
		return _active_pcam_2d
	else:
		return _active_pcam_3d


## Returns whether if a [param PhantomCamera] should tween when it becomes
## active. If it's already active, the value will always be false.
## [b]Note:[/b] This can only be called internally from a
## [param PhantomCamera] node.
func get_trigger_pcam_tween() -> bool:
	return _trigger_pcam_tween


## Refreshes the [param PhantomCamera] list and checks for the highest priority. [br]
## [b]Note:[/b] This should [b]not[/b] be necessary to call manually.
func refresh_pcam_list_priorty() -> void:
	_active_pcam_priority = -1
	_find_pcam_with_highest_priority()

#endregion

#region Setters / Getters

func set_interpolation_mode(value: int) -> void:
	interpolation_mode = value
	if is_inside_tree():
		_check_pcam_physics()
func get_interpolation_mode() -> int:
	return interpolation_mode

## Sets the [member host_layers] value.
func set_host_layers(value: int) -> void:
	host_layers = value

	if not _is_child_of_camera: return

	if not _active_pcam_missing:
		if _is_2d:
			_pcam_host_layer_changed(_active_pcam_2d)
		else:
			_pcam_host_layer_changed(_active_pcam_3d)
	else:
		_find_pcam_with_highest_priority()

## Enables or disables a given layer of [member host_layers].
func set_host_layers_value(layer: int, value: bool) -> void:
	host_layers = _set_layer(host_layers, layer, value)

## Returns the [member host_layers] value.
func get_host_layers() -> int:
	return host_layers

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/resources/Camera3DResource.cs ---
using Godot;

namespace PhantomCamera;

public enum KeepAspect
{
    KeepWidth,
    KeepHeight
}

public enum ProjectionType
{
    Perspective,
    Orthogonal,
    Frustum
}

public class Camera3DResource(Resource resource)
{
    public readonly Resource Resource = resource;

    public KeepAspect KeepAspect
    {
        get => (KeepAspect)(int)Resource.Call(MethodName.GetKeepAspect);
        set => Resource.Call(MethodName.SetKeepAspect, (int)value);
    }

    public int CullMask
    {
        get => (int)Resource.Call(MethodName.GetCullMask);
        set => Resource.Call(MethodName.SetCullMask, value);
    }

    public void SetCullMaskValue(int layer, bool value) => Resource.Call(MethodName.SetCullMaskValue, layer, value);

    public float HOffset
    {
        get => (float)Resource.Call(MethodName.GetHOffset);
        set => Resource.Call(MethodName.SetHOffset, value);
    }

    public float VOffset
    {
        get => (float)Resource.Call(MethodName.GetVOffset);
        set => Resource.Call(MethodName.SetVOffset, value);
    }

    public ProjectionType Projection
    {
        get => (ProjectionType)(int)Resource.Call(MethodName.GetProjection);
        set => Resource.Call(MethodName.SetProjection, (int)value);
    }

    public float Fov
    {
        get => (float)Resource.Call(MethodName.GetFov);
        set => Resource.Call(MethodName.SetFov, Mathf.Clamp(value, 1, 179));
    }

    public float Size
    {
        get => (float)Resource.Call(MethodName.GetSize);
        set => Resource.Call(MethodName.SetSize, Mathf.Clamp(value, 0.001f, float.PositiveInfinity));
    }

    public Vector2 FrustumOffset
    {
        get => (Vector2)Resource.Call(MethodName.GetFrustumOffset);
        set => Resource.Call(MethodName.SetFrustumOffset, value);
    }

    public float Near
    {
        get => (float)Resource.Call(MethodName.GetNear);
        set => Resource.Call(MethodName.SetNear, Mathf.Clamp(value, 0.001f, float.PositiveInfinity));
    }

    public float Far
    {
        get => (float)Resource.Call(MethodName.GetFar);
        set => Resource.Call(MethodName.SetFar, Mathf.Clamp(value, 0.01f, float.PositiveInfinity));
    }

    public static class MethodName
    {
        public const string GetKeepAspect = "get_keep_aspect";
        public const string SetKeepAspect = "set_keep_aspect";

        public const string GetCullMask = "get_cull_mask";
        public const string SetCullMask = "set_cull_mask";
        public const string SetCullMaskValue = "set_cull_mask_value";

        public const string GetHOffset = "get_h_offset";
        public const string SetHOffset = "set_h_offset";

        public const string GetVOffset = "get_v_offset";
        public const string SetVOffset = "set_v_offset";

        public const string GetProjection = "get_projection";
        public const string SetProjection = "set_projection";

        public const string GetFov = "get_fov";
        public const string SetFov = "set_fov";

        public const string GetSize = "get_size";
        public const string SetSize = "set_size";

        public const string GetFrustumOffset = "get_frustum_offset";
        public const string SetFrustumOffset = "set_frustum_offset";

        public const string GetNear = "get_near";
        public const string SetNear = "set_near";

        public const string GetFar = "get_far";
        public const string SetFar = "set_far";
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/resources/camera_3d_resource.gd ---
@tool
@icon("res://addons/phantom_camera/icons/phantom_camera_camera_3d_resource.svg")
class_name Camera3DResource
extends Resource

## Resource for [PhantomCamera3D] to override various [Camera3D] properties.
##
## The overrides defined here will be applied to the [Camera3D] upon the
## [PhantomCamera3D] becoming active.

enum KeepAspect {
	KEEP_WIDTH = 0, ## Preserves the horizontal aspect ratio; also known as Vert- scaling. This is usually the best option for projects running in portrait mode, as taller aspect ratios will benefit from a wider vertical FOV.
	KEEP_HEIGHT = 1, ## Preserves the vertical aspect ratio; also known as Hor+ scaling. This is usually the best option for projects running in landscape mode, as wider aspect ratios will automatically benefit from a wider horizontal FOV.
}

enum ProjectionType {
	PERSPECTIVE = 	0, ## Perspective projection. Objects on the screen becomes smaller when they are far away.
	ORTHOGONAL = 	1, ## Orthogonal projection, also known as orthographic projection. Objects remain the same size on the screen no matter how far away they are.
	FRUSTUM = 		2, ## Frustum projection. This mode allows adjusting frustum_offset to create "tilted frustum" effects.
}

## Overrides [member Camera3D.keep_aspect].
@export var keep_aspect: KeepAspect = KeepAspect.KEEP_HEIGHT:
	set(value):
		keep_aspect = value
		emit_changed()
	get:
		return keep_aspect

## Overrides [member Camera3D.cull_mask].
@export_flags_3d_render var cull_mask: int = 1048575:
	set(value):
		cull_mask = value
		emit_changed()
	get:
		return cull_mask

## Overrides [member Camera3D.h_offset].
@export_range(0, 1, 0.001, "or_greater", "or_less", "hide_slider", "suffix:m") var h_offset: float = 0:
	set(value):
		h_offset = value
		emit_changed()
	get:
		return h_offset

## Overrides [member Camera3D.v_offset].
@export_range(0, 1, 0.001, "or_greater", "or_less", "hide_slider", "suffix:m") var v_offset: float = 0:
	set(value):
		v_offset = value
		emit_changed()

## Overrides [member Camera3D.projection].
@export var projection: ProjectionType = ProjectionType.PERSPECTIVE:
	set(value):
		projection = value
		notify_property_list_changed()
		emit_changed()
	get:
		return projection

## Overrides [member Camera3D.fov].
@export_range(1, 179, 0.1, "degrees") var fov: float = 75:
	set(value):
		fov = value
		emit_changed()
	get:
		return fov

## Overrides [member Camera3D.size].
@export_range(0.001, 100, 0.001, "suffix:m", "or_greater") var size: float = 1:
	set(value):
		size = value
		emit_changed()
	get:
		return size

## Overrides [member Camera3d.frustum_offset].
@export var frustum_offset: Vector2 = Vector2.ZERO:
	set(value):
		frustum_offset = value
		emit_changed()
	get:
		return frustum_offset

## Overrides [member Camera3D.near].
@export_range(0.001, 10, 0.001, "suffix:m", "or_greater") var near: float = 0.05:
	set(value):
		near = value
		emit_changed()
	get:
		return near

## Overrides [member Camera3D.far].
@export_range(0.01, 4000, 0.001, "suffix:m","or_greater") var far: float = 4000:
	set(value):
		far = value
		emit_changed()
	get:
		return far


func _validate_property(property: Dictionary) -> void:
	if property.name == "fov" and not projection == ProjectionType.PERSPECTIVE:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "size" and projection == ProjectionType.PERSPECTIVE:
		property.usage = PROPERTY_USAGE_NO_EDITOR

	if property.name == "frustum_offset" and not projection == ProjectionType.FRUSTUM:
		property.usage = PROPERTY_USAGE_NO_EDITOR

--- SCRIPT: res://addons/phantom_camera/scripts/resources/PhantomCameraNoise2D.cs ---
using Godot;

namespace PhantomCamera.Noise;

public class PhantomCameraNoise2D(Resource resource)
{
    public readonly Resource Resource = resource;

    public float Amplitude
    {
        get => (float)Resource.Call(MethodName.GetAmplitude);
        set => Resource.Call(MethodName.SetAmplitude, value);
    }

    public float Frequency
    {
        get => (float)Resource.Call(MethodName.GetFrequency);
        set => Resource.Call(MethodName.SetFrequency, value);
    }

    public bool RandomizeNoiseSeed
    {
        get => (bool)Resource.Call(MethodName.GetRandomizeNoiseSeed);
        set => Resource.Call(MethodName.SetRandomizeNoiseSeed, value);
    }

    public int NoiseSeed
    {
        get => (int)Resource.Call(MethodName.GetNoiseSeed);
        set => Resource.Call(MethodName.SetNoiseSeed, value);
    }

    public bool RotationalNoise
    {
        get => (bool)Resource.Call(MethodName.GetRotationalNoise);
        set => Resource.Call(MethodName.SetRotationalNoise, value);
    }

    public bool PositionalNoise
    {
        get => (bool)Resource.Call(MethodName.GetPositionalNoise);
        set => Resource.Call(MethodName.SetPositionalNoise, value);
    }

    public float RotationalMultiplier
    {
        get => (float)Resource.Call(MethodName.GetRotationalMultiplier);
        set => Resource.Call(MethodName.SetRotationalMultiplier, value);
    }

    public float PositionalMultiplierX
    {
        get => (float)Resource.Call(MethodName.GetPositionalMultiplierX);
        set => Resource.Call(MethodName.SetPositionalMultiplierX, value);
    }

    public float PositionalMultiplierY
    {
        get => (float)Resource.Call(MethodName.GetPositionalMultiplierY);
        set => Resource.Call(MethodName.SetPositionalMultiplierY, value);
    }

    public static class MethodName
    {
        public const string GetAmplitude = "get_amplitude";
        public const string SetAmplitude = "set_amplitude";

        public const string GetFrequency = "get_frequency";
        public const string SetFrequency = "set_frequency";

        public const string GetRandomizeNoiseSeed = "get_randomize_noise_seed";
        public const string SetRandomizeNoiseSeed = "set_randomize_noise_seed";

        public const string GetNoiseSeed = "get_noise_seed";
        public const string SetNoiseSeed = "set_noise_seed";

        public const string GetRotationalNoise = "get_rotational_noise";
        public const string SetRotationalNoise = "set_rotational_noise";

        public const string GetPositionalNoise = "get_positional_noise";
        public const string SetPositionalNoise = "set_positional_noise";

        public const string GetRotationalMultiplier = "get_rotational_multiplier";
        public const string SetRotationalMultiplier = "set_rotational_multiplier";

        public const string GetPositionalMultiplierX = "get_positional_multiplier_x";
        public const string SetPositionalMultiplierX = "set_positional_multiplier_x";

        public const string GetPositionalMultiplierY = "get_positional_multiplier_y";
        public const string SetPositionalMultiplierY = "set_positional_multiplier_y";
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/resources/PhantomCameraNoise3D.cs ---
using Godot;

namespace PhantomCamera.Noise;

public class PhantomCameraNoise3D(Resource resource)
{
    public readonly Resource Resource = resource;

    public float Amplitude
    {
        get => (float)Resource.Call(MethodName.GetAmplitude);
        set => Resource.Call(MethodName.SetAmplitude, value);
    }

    public float Frequency
    {
        get => (float)Resource.Call(MethodName.GetFrequency);
        set => Resource.Call(MethodName.SetFrequency, value);
    }

    public bool RandomizeNoiseSeed
    {
        get => (bool)Resource.Call(MethodName.GetRandomizeNoiseSeed);
        set => Resource.Call(MethodName.SetRandomizeNoiseSeed, value);
    }

    public int NoiseSeed
    {
        get => (int)Resource.Call(MethodName.GetNoiseSeed);
        set => Resource.Call(MethodName.SetNoiseSeed, value);
    }

    public bool RotationalNoise
    {
        get => (bool)Resource.Call(MethodName.GetRotationalNoise);
        set => Resource.Call(MethodName.SetRotationalNoise, value);
    }

    public bool PositionalNoise
    {
        get => (bool)Resource.Call(MethodName.GetPositionalNoise);
        set => Resource.Call(MethodName.SetPositionalNoise, value);
    }

    public float RotationalMultiplierX
    {
        get => (float)Resource.Call(MethodName.GetRotationalMultiplierX);
        set => Resource.Call(MethodName.SetRotationalMultiplierX, value);
    }

    public float RotationalMultiplierY
    {
        get => (float)Resource.Call(MethodName.GetRotationalMultiplierY);
        set => Resource.Call(MethodName.SetRotationalMultiplierY, value);
    }

    public float RotationalMultiplierZ
    {
        get => (float)Resource.Call(MethodName.GetRotationalMultiplierZ);
        set => Resource.Call(MethodName.SetRotationalMultiplierZ, value);
    }

    public float PositionalMultiplierX
    {
        get => (float)Resource.Call(MethodName.GetPositionalMultiplierX);
        set => Resource.Call(MethodName.SetPositionalMultiplierX, value);
    }

    public float PositionalMultiplierY
    {
        get => (float)Resource.Call(MethodName.GetPositionalMultiplierY);
        set => Resource.Call(MethodName.SetPositionalMultiplierY, value);
    }

    public float PositionalMultiplierZ
    {
        get => (float)Resource.Call(MethodName.GetPositionalMultiplierZ);
        set => Resource.Call(MethodName.SetPositionalMultiplierZ, value);
    }

    public static class MethodName
    {
        public const string GetAmplitude = "get_amplitude";
        public const string SetAmplitude = "set_amplitude";

        public const string GetFrequency = "get_frequency";
        public const string SetFrequency = "set_frequency";

        public const string GetRandomizeNoiseSeed = "get_randomize_noise_seed";
        public const string SetRandomizeNoiseSeed = "set_randomize_noise_seed";

        public const string GetNoiseSeed = "get_noise_seed";
        public const string SetNoiseSeed = "set_noise_seed";

        public const string GetRotationalNoise = "get_rotational_noise";
        public const string SetRotationalNoise = "set_rotational_noise";

        public const string GetPositionalNoise = "get_positional_noise";
        public const string SetPositionalNoise = "set_positional_noise";

        public const string GetRotationalMultiplierX = "get_rotational_multiplier_x";
        public const string SetRotationalMultiplierX = "set_rotational_multiplier_x";

        public const string GetRotationalMultiplierY = "get_rotational_multiplier_y";
        public const string SetRotationalMultiplierY = "set_rotational_multiplier_y";

        public const string GetRotationalMultiplierZ = "get_rotational_multiplier_z";
        public const string SetRotationalMultiplierZ = "set_rotational_multiplier_z";

        public const string GetPositionalMultiplierX = "get_positional_multiplier_x";
        public const string SetPositionalMultiplierX = "set_positional_multiplier_x";

        public const string GetPositionalMultiplierY = "get_positional_multiplier_y";
        public const string SetPositionalMultiplierY = "set_positional_multiplier_y";

        public const string GetPositionalMultiplierZ = "get_positional_multiplier_z";
        public const string SetPositionalMultiplierZ = "set_positional_multiplier_z";
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/resources/PhantomCameraTween.cs ---
using Godot;

namespace PhantomCamera;

public enum TransitionType
{
    Linear,
    Sine,
    Quint,
    Quart,
    Quad,
    Expo,
    Elastic,
    Cubic,
    Circ,
    Bounce,
    Back
}

public enum EaseType
{
    EaseIn,
    EaseOut,
    EaseInOut,
    EaseOutIn
}

public static class PhantomCameraTweenExtensions
{
    public static PhantomCameraTween AsPhantomCameraTween(this Resource resource)
    {
        return new PhantomCameraTween(resource);
    }
}

public class PhantomCameraTween(Resource tweenResource)
{
    public Resource Resource { get; } = tweenResource;

    public float Duration
    {
        get => (float)Resource.Get(PropertyName.Duration);
        set => Resource.Set(PropertyName.Duration, value);
    }

    public TransitionType Transition
    {
        get => (TransitionType)(int)Resource.Get(PropertyName.Transition);
        set => Resource.Set(PropertyName.Transition, (int)value);
    }

    public EaseType Ease
    {
        get => (EaseType)(int)Resource.Get(PropertyName.Ease);
        set => Resource.Set(PropertyName.Ease, (int)value);
    }

    public static class PropertyName
    {
        public const string Duration = "duration";
        public const string Transition = "transition";
        public const string Ease = "ease";
    }
}

--- SCRIPT: res://addons/phantom_camera/scripts/resources/phantom_camera_noise_2d.gd ---
@tool
@icon("res://addons/phantom_camera/icons/phantom_camera_noise_resource.svg")
class_name PhantomCameraNoise2D
extends Resource

## A resource type used to apply noise, or shake, to [Camera2D]s that have a [PhantomCameraHost] as a child.
##
## Is a resource type that defines, calculates and outputs the noise values to a [Camera2D] through active
## [PhantomCamera3D].[br]
## It can be applied to either [PhantomCameraNoiseEmitter2D] or a [PhantomCamera2D] noise property directly

#region Exported Properties

## Defines the size of the noise pattern.[br]
## Higher values will increase the range the noise can reach.
@export_range(0, 1000, 0.001, "or_greater") var amplitude: float = 10:
	set = set_amplitude,
	get = get_amplitude

## Sets the density of the noise pattern.[br]
## Higher values will result in more erratic noise.
@export_range(0, 10, 0.001, "or_greater") var frequency: float = 0.5:
	set = set_frequency,
	get = get_frequency

## If true, randomizes the noise pattern every time the noise is run.[br]
## If disabled, [member seed] can be used to define a fixed noise pattern.
@export var randomize_noise_seed: bool = true:
	set = set_randomize_noise_seed,
	get = get_randomize_noise_seed

## Sets a predetermined seed noise value.[br]
## Useful if wanting to achieve a persistent noise pattern every time the noise is emitted.
@export var noise_seed: int = 0:
	set = set_noise_seed,
	get = get_noise_seed

## Enables noise changes to the [member Camera2D.offset] position.
@export var positional_noise: bool = true:
	set = set_positional_noise,
	get = get_positional_noise

## Enables noise changes to the [Camera2D]'s rotation.
@export var rotational_noise: bool = false:
	set = set_rotational_noise,
	get = get_rotational_noise

@export_group("Positional Multiplier")
## Multiplies positional noise amount in the X-axis.[br]
## Set the value to [param 0] to disable noise in the axis.
@export_range(0, 1, 0.001, "or_greater") var positional_multiplier_x: float = 1:
	set = set_positional_multiplier_x,
	get = get_positional_multiplier_x

## Multiplies positional noise amount in the Y-axis.[br]
## Set the value to [param 0] to disable noise in the axis.
@export_range(0, 1, 0.001, "or_greater") var positional_multiplier_y: float = 1:
	set = set_positional_multiplier_y,
	get = get_positional_multiplier_y

@export_group("Rotational Multiplier")
## Multiplies rotational noise amount.
@export_range(0, 1, 0.001, "or_greater") var rotational_multiplier: float = 1:
	set = set_rotational_multiplier,
	get = get_rotational_multiplier

#endregion

#region Private Variables

var _noise_algorithm: FastNoiseLite = FastNoiseLite.new()

var _noise_positional_multiplier: Vector2 = Vector2(
	positional_multiplier_x,
	positional_multiplier_y
)

var _trauma: float = 0.0:
	set(value):
		_trauma = value

var _noise_time: float = 0.0

#endregion

#region Private Functions

func _init():
	_noise_algorithm.noise_type = FastNoiseLite.TYPE_PERLIN
	if randomize_noise_seed: _noise_algorithm.seed = randi()
	_noise_algorithm.frequency = frequency


func _validate_property(property: Dictionary) -> void:
	if randomize_noise_seed and property.name == "noise_seed":
		property.usage = PROPERTY_USAGE_NO_EDITOR

	if not rotational_noise and property.name == "rotational_multiplier":
			property.usage = PROPERTY_USAGE_NO_EDITOR

	if not positional_noise:
		match property.name:
			"positional_multiplier_x", \
			"positional_multiplier_y":
				property.usage = PROPERTY_USAGE_NO_EDITOR


func _get_noise_from_seed(noise_seed: int) -> float:
	return _noise_algorithm.get_noise_2d(noise_seed, _noise_time) * amplitude


func set_trauma(value: float) -> void:
	_trauma = value

#endregion

#region Public Functions

func get_noise_transform(delta: float) -> Transform2D:
	var output_position: Vector2 = Vector2.ZERO
	var output_rotation: float = 0.0
	_noise_time += delta
	_trauma = maxf(_trauma, 0.0)

	if positional_noise:
		for i in 2:
			output_position[i] = _noise_positional_multiplier[i] * pow(_trauma, 2) * _get_noise_from_seed(i + noise_seed)
	if rotational_noise:
		output_rotation = rotational_multiplier / 100 * pow(_trauma, 2) * _get_noise_from_seed(noise_seed)

	return Transform2D(output_rotation, output_position)


func reset_noise_time() -> void:
	_noise_time = 0

#endregion

#region Setters & Getters

## Sets the [member amplitude] value.
func set_amplitude(value: float) -> void:
	amplitude =value

## Returns the [member amplitude] value.
func get_amplitude() -> float:
	return amplitude


## Sets the [member frequency] value.
func set_frequency(value: float) -> void:
	frequency = value
	_noise_algorithm.frequency = value

## Returns the [member frequency] value.
func get_frequency() -> float:
	return frequency


## Sets the [member randomize_seed] value.
func set_randomize_noise_seed(value: int) -> void:
	randomize_noise_seed = value
	if value: _noise_algorithm.seed = randi()
	notify_property_list_changed()

## Returns the [member randomize_seed] value.
func get_randomize_noise_seed() -> int:
	return randomize_noise_seed


## Sets the [member randomize_seed] value.
func set_noise_seed(value: int) -> void:
	noise_seed = value

## Returns the [member seed] value.
func get_noise_seed() -> int:
	return noise_seed


## Sets the [member positional_noise] value.
func set_positional_noise(value: bool) -> void:
	positional_noise = value
	notify_property_list_changed()

## Returns the [member positional_noise] value.
func get_positional_noise() -> bool:
	return positional_noise


## Sets the [member rotational_noise] value.
func set_rotational_noise(value: bool) -> void:
	rotational_noise = value
	notify_property_list_changed()

## Returns the [member rotational_noise] value.
func get_rotational_noise() -> bool:
	return rotational_noise


## Sets the [member positional_multiplier_x] value.
func set_positional_multiplier_x(value: float) -> void:
	positional_multiplier_x = value
	_noise_positional_multiplier.x = value

## Returns the [member positional_multiplier_x] value.
func get_positional_multiplier_x() -> float:
	return positional_multiplier_x


## Sets the [member positional_multiplier_y] value.
func set_positional_multiplier_y(value: float) -> void:
	positional_multiplier_y = value
	_noise_positional_multiplier.y = value

## Returns the [member positional_multiplier_y] value.
func get_positional_multiplier_y() -> float:
	return positional_multiplier_y


## Sets the [member rotational_multiplier] value.
func set_rotational_multiplier(value: float) -> void:
	rotational_multiplier = value

## Returns the [member rotational_multiplier] value.
func get_rotational_multiplier() -> float:
	return rotational_multiplier

#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/resources/phantom_camera_noise_3d.gd ---
@tool
@icon("res://addons/phantom_camera/icons/phantom_camera_noise_resource.svg")
class_name PhantomCameraNoise3D
extends Resource

## A resource type used to apply noise, or shake, to [Camera3D]s that have a [PhantomCameraHost] as a child.
##
## Is a resource type that defines, calculates and outputs the noise values to a [Camera3D] through active
## [PhantomCamera3D].[br]
## It can be applied to either [PhantomCameraNoiseEmitter3D] or a [PhantomCamera3D] noise property directly

#region Exported Properties

## Defines the size of the noise pattern.[br]
## Higher values will increase the range the noise can reach.
@export_range(0, 100, 0.001, "or_greater") var amplitude: float = 10:
	set = set_amplitude,
	get = get_amplitude

## Sets the density of the noise pattern.[br]
## Higher values will result in more erratic noise.
@export_range(0, 10, 0.001, "or_greater") var frequency: float = 0.2:
	set = set_frequency,
	get = get_frequency

## If true, randomizes the noise pattern every time the noise is run.[br]
## If disabled, [member seed] can be used to define a fixed noise pattern.
@export var randomize_noise_seed: bool = true:
	set = set_randomize_noise_seed,
	get = get_randomize_noise_seed

## Sets a predetermined seed noise value.[br]
## Useful if wanting to achieve a persistent noise pattern every time the noise is emitted.
@export var noise_seed: int = 0:
	set = set_noise_seed,
	get = get_noise_seed

## Enables noise changes to the [Camera3D]'s rotation.
@export var rotational_noise: bool = true:
	set = set_rotational_noise,
	get = get_rotational_noise

## Enables noise changes to the camera's position.[br][br]
## [b]Important[/b][br]This can cause geometry clipping if the camera gets too close while this is active.
@export var positional_noise: bool = false:
	set = set_positional_noise,
	get = get_positional_noise

@export_group("Rotational Multiplier")
## Multiplies rotational noise amount in the X-axis.[br]
## Set the value to [param 0] to disable noise in the axis.
@export_range(0, 1, 0.001, "or_greater") var rotational_multiplier_x: float = 1:
	set = set_rotational_multiplier_x,
	get = get_rotational_multiplier_x

## Multiplies rotational noise amount in the Y-axis.[br]
## Set the value to [param 0] to disable noise in the axis.
@export_range(0, 1, 0.001, "or_greater") var rotational_multiplier_y: float = 1:
	set = set_rotational_multiplier_y,
	get = get_rotational_multiplier_y

## Multiplies rotational noise amount in the Z-axis.[br]
## Set the value to [param 0] to disable noise in the axis.
@export_range(0, 1, 0.001, "or_greater") var rotational_multiplier_z: float = 1:
	set = set_rotational_multiplier_z,
	get = get_rotational_multiplier_z

@export_group("Positional Multiplier")
## Multiplies positional noise amount in the X-axis.[br]
## Set the value to [param 0] to disable noise in the axis.[br]
## [b]Note:[/b] Rotational Offset is recommended to avoid potential camera clipping with the environment.
@export_range(0, 1, 0.001, "or_greater") var positional_multiplier_x: float = 1:
	set = set_positional_multiplier_x,
	get = get_positional_multiplier_x

## Multiplies positional noise amount in the Y-axis.[br]
## Set the value to [param 0] to disable noise in the axis.[br]
## [b]Note:[/b] Rotational Offset is recommended to avoid potential camera clipping with the environment.
@export_range(0, 1, 0.001, "or_greater") var positional_multiplier_y: float = 1:
	set = set_positional_multiplier_y,
	get = get_positional_multiplier_y

## Multiplies positional noise amount in the Z-axis.[br]
## Set the value to [param 0] to disable noise in the axis.[br]
## [b]Note:[/b] Rotational Offset is recommended to avoid potential camera clipping with the environment.
@export_range(0, 1, 0.001, "or_greater") var positional_multiplier_z: float = 1:
	set = set_positional_multiplier_z,
	get = get_positional_multiplier_z

#endregion

#region Private Variables

var _noise_algorithm: FastNoiseLite = FastNoiseLite.new()

var _noise_rotational_multiplier: Vector3 = Vector3(
	rotational_multiplier_x,
	rotational_multiplier_y,
	rotational_multiplier_z,
)

var _noise_positional_multiplier: Vector3 = Vector3(
	positional_multiplier_x,
	positional_multiplier_y,
	positional_multiplier_z,
)

var _trauma: float = 0.0:
	set(value):
		_trauma = value
		if _trauma == 0.0:
			_noise_time = 0.0

var _noise_time: float = 0.0

#endregion

#region Private Functions

func _init():
	_noise_algorithm.noise_type = FastNoiseLite.TYPE_PERLIN

	if randomize_noise_seed: _noise_algorithm.seed = randi()
	_noise_algorithm.frequency = frequency


func _validate_property(property: Dictionary) -> void:
	if randomize_noise_seed and property.name == "noise_seed":
		property.usage = PROPERTY_USAGE_NO_EDITOR

	if not rotational_noise:
		match property.name:
			"rotational_multiplier_x", \
			"rotational_multiplier_y", \
			"rotational_multiplier_z":
				property.usage = PROPERTY_USAGE_NO_EDITOR

	if not positional_noise:
		match property.name:
			"positional_multiplier_x", \
			"positional_multiplier_y", \
			"positional_multiplier_z":
				property.usage = PROPERTY_USAGE_NO_EDITOR


func _get_noise_from_seed(noise_seed: int) -> float:
	return _noise_algorithm.get_noise_2d(noise_seed, _noise_time) * amplitude


func set_trauma(value: float) -> void:
	_trauma = value

#endregion

#region Public Functions

func get_noise_transform(delta: float) -> Transform3D:
	var output_rotation: Vector3 = Vector3.ZERO
	var output_position: Vector3 = Vector3.ZERO
	_noise_time += delta
	_trauma = maxf(_trauma, 0.0)

	for i in 3:
		if rotational_noise:
			output_rotation[i] = deg_to_rad(
				_noise_rotational_multiplier[i] * pow(_trauma, 2) * _get_noise_from_seed(i + noise_seed)
			)

		if positional_noise:
			output_position[i] += _noise_positional_multiplier[i] / 10 * \
			pow(_trauma, 2) * _get_noise_from_seed(i + noise_seed)

	return Transform3D(Quaternion.from_euler(output_rotation), output_position)


func reset_noise_time() -> void:
	_noise_time = 0

#endregion

#region Setters & Getters

## Sets the [member amplitude] value.
func set_amplitude(value: float) -> void:
	amplitude =value

## Returns the [member amplitude] value.
func get_amplitude() -> float:
	return amplitude


## Sets the [member frequency] value.
func set_frequency(value: float) -> void:
	frequency = value
	_noise_algorithm.frequency = value

## Returns the [member frequency] value.
func get_frequency() -> float:
	return frequency


## Sets the [member randomize_seed] value.
func set_randomize_noise_seed(value: int) -> void:
	randomize_noise_seed = value
	if value: _noise_algorithm.seed = randi()
	notify_property_list_changed()

## Returns the [member randomize_seed] value.
func get_randomize_noise_seed() -> int:
	return randomize_noise_seed


## Sets the [member randomize_seed] value.
func set_noise_seed(value: int) -> void:
	noise_seed = value

## Returns the [member seed] value.
func get_noise_seed() -> int:
	return noise_seed


## Sets the [member positional_noise] value.
func set_positional_noise(value: bool) -> void:
	positional_noise = value
	notify_property_list_changed()

## Returns the [member positional_noise] value.
func get_positional_noise() -> bool:
	return positional_noise


## Sets the [member rotational_noise] value.
func set_rotational_noise(value: bool) -> void:
	rotational_noise = value
	notify_property_list_changed()

## Returns the [member rotational_noise] value.
func get_rotational_noise() -> bool:
	return rotational_noise


## Sets the [member positional_multiplier_x] value.
func set_positional_multiplier_x(value: float) -> void:
	positional_multiplier_x = value
	_noise_positional_multiplier.x = value

## Returns the [member positional_multiplier_x] value.
func get_positional_multiplier_x() -> float:
	return positional_multiplier_x


## Sets the [member positional_multiplier_y] value.
func set_positional_multiplier_y(value: float) -> void:
	positional_multiplier_y = value
	_noise_positional_multiplier.y = value

## Returns the [member positional_multiplier_y] value.
func get_positional_multiplier_y() -> float:
	return positional_multiplier_y


## Sets the [member positional_multiplier_z] value.
func set_positional_multiplier_z(value: float) -> void:
	positional_multiplier_z = value
	_noise_positional_multiplier.z = value

## Returns the [member positional_multiplier_z] value.
func get_positional_multiplier_z() -> float:
	return positional_multiplier_z


## Sets the [member rotational_multiplier_x] value.
func set_rotational_multiplier_x(value: float) -> void:
	rotational_multiplier_x = value
	_noise_rotational_multiplier.x = value

## Returns the [member rotational_multiplier_x] value.
func get_rotational_multiplier_x() -> float:
	return rotational_multiplier_x


## Sets the [member rotational_multiplier_y] value.
func set_rotational_multiplier_y(value: float) -> void:
	rotational_multiplier_y = value
	_noise_rotational_multiplier.y = value

## Returns the [member rotational_multiplier_y] value.
func get_rotational_multiplier_y() -> float:
	return rotational_multiplier_y


## Sets the [member rotational_multiplier_z] value.
func set_rotational_multiplier_z(value: float) -> void:
	rotational_multiplier_z = value
	_noise_rotational_multiplier.z = value

## Returns the [member rotational_multiplier_z] value.
func get_rotational_multiplier_z() -> float:
	return rotational_multiplier_z

	#endregion

--- SCRIPT: res://addons/phantom_camera/scripts/resources/tween_resource.gd ---
@icon("res://addons/phantom_camera/icons/phantom_camera_tween.svg")
class_name PhantomCameraTween
extends Resource

## Tweening resource for [PhantomCamera2D] and [PhantomCamera3D].
##
## Defines how [param PhantomCameras] transition between one another.
## Changing the tween values for a given [param PhantomCamera] determines how
## transitioning to that instance will look like.

enum TransitionType {
	LINEAR 	= 0, ## The animation is interpolated linearly.
	SINE 	= 1, ## The animation is interpolated using a sine function.
	QUINT 	= 2, ## The animation is interpolated with a quintic (to the power of 5) function.
	QUART 	= 3, ## The animation is interpolated with a quartic (to the power of 4) function.
	QUAD 	= 4, ## The animation is interpolated with a quadratic (to the power of 2) function.
	EXPO 	= 5, ## The animation is interpolated with an exponential (to the power of x) function.
	ELASTIC = 6, ## The animation is interpolated with elasticity, wiggling around the edges.
	CUBIC 	= 7, ## The animation is interpolated with a cubic (to the power of 3) function.
	CIRC 	= 8, ## The animation is interpolated with a function using square roots.
	BOUNCE 	= 9, ## The animation is interpolated by bouncing at the end.
	BACK 	= 10, ## The animation is interpolated backing out at ends.
#	CUSTOM 	= 11,
#	NONE 	= 12,
}

enum EaseType {
	EASE_IN 	= 0, ## The interpolation starts slowly and speeds up towards the end.
	EASE_OUT 	= 1, ## The interpolation starts quickly and slows down towards the end.
	EASE_IN_OUT = 2, ## A combination of EASE_IN and EASE_OUT. The interpolation is slowest at both ends.
	EASE_OUT_IN = 3, ## A combination of EASE_IN and EASE_OUT. The interpolation is fastest at both ends.
}

## The time it takes to tween to this PhantomCamera in [param seconds].
@export var duration: float = 1.0

## The transition bezier type for the tween. The options are defined in the [enum TransitionType].
@export var transition: TransitionType = TransitionType.LINEAR

## The ease type for the tween. The options are defined in the [enum EaseType].
@export var ease: EaseType = EaseType.EASE_IN_OUT

--- SCRIPT: res://Data/HideoutProgressionData.gd ---
# res://data/HideoutProgressionData.gd
class_name HideoutProgressionData
extends Resource

## The Gold cost for each upgrade. Element 0 is the cost to go from level 1 to 2, etc.
@export var upgrade_costs: Array[int] = [100, 250]
## The maximum level the hideout can reach.
@export var max_level: int = 3

--- SCRIPT: res://Data/MissionSaveState.gd ---
# res://data/MissionSaveState.gd
class_name MissionSaveState
extends Resource

## A dictionary where keys are unique object_ids and values are their state.
@export var collected_objects: Dictionary = {}
## The global position of the last activated checkpoint.
@export var checkpoint_position: Vector2 = Vector2.ZERO

--- SCRIPT: res://Enemies/Guard/Guard.gd ---
# res://Enemies/Guard/Guard.gd
extends CharacterBody2D

@export var speed: float = 50.0

@export_group("Visuals")
@export var vision_cone_neutral_color: Color = Color(1, 1, 1, 0.2)
@export var vision_cone_suspicious_color: Color = Color(1, 1, 0, 0.25)
@export var vision_cone_alert_color: Color = Color(1, 0, 0, 0.3)

var direction: int = 1
var is_player_in_cone: bool = false

@onready var animated_sprite: AnimatedSprite2D = $AnimatedSprite2D
@onready var ledge_check_ray: RayCast2D = $LedgeCheckRay
@onready var wall_check_ray: RayCast2D = $WallCheckRay
@onready var ground_check_ray: RayCast2D = $GroundCheckRay # ADD THIS LINE
@onready var turn_cooldown_timer: Timer = $TurnCooldownTimer
@onready var state_machine = $StateMachine
@onready var vision_cone_area: Area2D = $VisionCone2D/VisionConeArea
@onready var vision_cone_renderer: Polygon2D = $VisionCone2D/VisionConeRenderer


func _ready() -> void:
	vision_cone_area.body_entered.connect(_on_vision_cone_body_entered)
	vision_cone_area.body_exited.connect(_on_vision_cone_body_exited)
	state_machine.call_deferred("initialize")


func _physics_process(delta: float) -> void:
	if state_machine.current_state:
		state_machine.current_state.process_physics(delta)
	
	move_and_slide()


func turn_around() -> void:
	direction *= -1
	turn_cooldown_timer.start(0.2)


func _on_vision_cone_body_entered(body: Node2D) -> void:
	if body.is_in_group("player"):
		is_player_in_cone = true


func _on_vision_cone_body_exited(body: Node2D) -> void:
	if body.is_in_group("player"):
		is_player_in_cone = false

--- SCRIPT: res://Enemies/Guard/States/caught_state.gd ---
# res://Enemies/Guard/States/caught_state.gd
extends GuardState

# This state does nothing. Its only purpose is to stop the guard
# from running the patrol logic after the player is caught.
func enter() -> void:
	pass

func process_physics(_delta: float) -> void:
	pass

--- SCRIPT: res://Enemies/Guard/States/guard_state.gd ---
# res://Enemies/Guard/States/guard_state.gd
class_name GuardState
extends Node

var state_machine: Node
@onready var guard: CharacterBody2D = get_owner() as CharacterBody2D

func enter() -> void:
	pass

func exit() -> void:
	pass

func process_physics(_delta: float) -> void:
	pass

--- SCRIPT: res://Enemies/Guard/States/guard_state_machine.gd ---
# res://Enemies/Guard/States/guard_state_machine.gd
class_name GuardStateMachine
extends Node

@export var initial_state: GuardState

var current_state: GuardState
var states: Dictionary = {}


func initialize():
	for child in get_children():
		if child is GuardState:
			states[child.name] = child
			child.state_machine = self

	if initial_state:
		current_state = initial_state
		current_state.enter()


# ADD THIS ENTIRE FUNCTION
func change_state(new_state_name: String):
	# Don't change to the same state.
	if current_state and current_state.name == new_state_name:
		return

	# Call the exit function on the current state before switching.
	if current_state:
		current_state.exit()
	
	# Find the new state in our dictionary of children.
	var new_state = states.get(new_state_name)
	if new_state:
		current_state = new_state
		current_state.enter()
	else:
		printerr("Guard State Machine Error: State '", new_state_name, "' not found.")

--- SCRIPT: res://Enemies/Guard/States/patrol_state.gd ---
# res://Enemies/Guard/States/patrol_state.gd
extends GuardState

var _detection_progress: float = 0.0
@onready var vision_cone_node: Node2D = guard.get_node("VisionCone2D")
@onready var ground_check_ray: RayCast2D = guard.get_node("GroundCheckRay")


func enter() -> void:
	_detection_progress = 0.0
	guard.animated_sprite.play("walk")


func process_physics(delta: float) -> void:
	guard.velocity.y += delta * 1200.0

	if ground_check_ray.is_colliding() and guard.turn_cooldown_timer.is_stopped():
		if not guard.ledge_check_ray.is_colliding() or guard.wall_check_ray.is_colliding():
			guard.turn_around()
			
	guard.velocity.x = guard.speed * guard.direction

	var is_facing_left = (guard.direction < 0)
	guard.animated_sprite.flip_h = is_facing_left
	
	guard.ledge_check_ray.position.x = abs(guard.ledge_check_ray.position.x) * guard.direction
	guard.wall_check_ray.target_position.x = abs(guard.wall_check_ray.target_position.x) * guard.direction
	
	vision_cone_node.rotation_degrees = 90 if is_facing_left else -90
	
	if guard.is_player_in_cone and not get_tree().get_first_node_in_group("player").is_invisible:
		_detection_progress += delta / 1.5
	else:
		_detection_progress -= delta / 1.5
	
	_detection_progress = clamp(_detection_progress, 0.0, 1.0)
	
	var target_color: Color
	if _detection_progress < 0.5:
		target_color = guard.vision_cone_neutral_color.lerp(guard.vision_cone_suspicious_color, _detection_progress * 2)
	else:
		target_color = guard.vision_cone_suspicious_color.lerp(guard.vision_cone_alert_color, (_detection_progress - 0.5) * 2)

	guard.vision_cone_renderer.color = target_color

	if _detection_progress >= 1.0:
		# THE FIX: Emit the signal AND immediately change to an inert state.
		EventBus.player_detected.emit()
		state_machine.change_state("CaughtState")

--- SCRIPT: res://Interactables/Campfire.gd ---
# res://Interactables/Campfire/Campfire.gd
extends StaticBody2D

@onready var _interactable: Interactable = $Interactable

func _ready() -> void:
	assert(is_instance_valid(_interactable), "Campfire scene must have an Interactable child node.")
	_interactable.interacted.connect(_on_interacted)

	if OS.is_debug_build():
		_verify_prompt_cost()

func _on_interacted() -> void:
	GameManager.try_upgrade_hideout()

func _verify_prompt_cost() -> void:
	if not is_instance_valid(GameManager.hideout_progression_data):
		return

	var current_level = GameManager.hideout_level
	var max_level = GameManager.hideout_progression_data.max_level

	if current_level < max_level:
		var real_cost: int = GameManager.hideout_progression_data.upgrade_costs[current_level - 1]
		var prompt_text: String = _interactable.prompt_message

		var regex = RegEx.new()
		regex.compile("(\\d+)")
		var result = regex.search(prompt_text)

		if result:
			var text_cost = int(result.get_string())
			if text_cost != real_cost:
				# MODIFIED: Print a clear error and then pause the game.
				printerr("BREAKPOINT: Campfire UI cost (%d) does not match the actual upgrade cost (%d). Update the prompt text or the variable in GameManager.tscn." % [text_cost, real_cost])
				
		else:
			# MODIFIED: Print a clear error and then pause the game.
			printerr("BREAKPOINT: Campfire prompt message does not contain a number to verify against the upgrade cost.")
			

--- SCRIPT: res://Interactables/Chest/Chest.gd ---
# res://Interactables/Chest/Chest.gd
extends StaticBody2D

@export var gold_amount: int = 10
@export var floating_text_scene: PackedScene
@export var text_spawn_offset: Vector2 = Vector2(0, -20)

@onready var animated_sprite: AnimatedSprite2D = $AnimatedSprite2D
@onready var _interactable: Interactable = $InteractionArea
@onready var _persistence_component: PersistenceComponent = $PersistenceComponent


func _ready() -> void:
	_interactable.interacted.connect(_on_interacted)

func _on_interacted() -> void:
	animated_sprite.play("open")
	await animated_sprite.animation_finished
	
	EventBus.gold_collected.emit(gold_amount)
	
	if floating_text_scene:
		var floating_text_instance = floating_text_scene.instantiate()
		get_tree().current_scene.add_child(floating_text_instance)
		floating_text_instance.global_position = self.global_position + text_spawn_offset
		floating_text_instance.show_text("+%d Gold" % gold_amount)
	
	_persistence_component.mark_collected({"is_collected": true})

# This function is called by the PersistenceComponent if the chest has saved data.
func _apply_persistent_state(state: Dictionary) -> void:
	if state.get("is_collected", false):
		# If this chest was already collected, just remove it from the scene.
		queue_free()

--- SCRIPT: res://Interactables/Interactable.gd ---
# res://Interactables/Interactable.gd
class_name Interactable
extends Area2D

signal interacted

@export var prompt_message: String = "Interact"
@export var prompt_vertical_offset: float = -40.0 ## Negative values move it up
@export var interaction_duration: float = 1.0 # Time in seconds to hold

# This function is called by the player/manager.
func perform_interaction():
	interacted.emit()

--- SCRIPT: res://Interactables/MissionBoard.gd ---
# res://World/MissionBoard.gd
extends StaticBody2D

@onready var _interactable: Interactable = $Interactable

func _ready() -> void:
	_interactable.interacted.connect(_on_interacted)

func _on_interacted() -> void:
	# Announce the user wants to start the mission.
	EventBus.start_mission_requested.emit("village_outskirts")

--- SCRIPT: res://Interactables/PersistenceComponent.gd ---
# res://Interactables/PersistenceComponent.gd
@tool
extends Node
class_name PersistenceComponent

# A unique identifier for this object. Use the button below to generate one.
@export var object_id: String = ""

# This creates a "button" in the Inspector to generate a new ID.
@export var generate_new_id: bool = false:
	set(value):
		if value:
			# Generate a new ID based on a hash of the time and node path.
			# This is guaranteed to be unique enough for our purposes.
			var new_id = "obj_" + str(str(get_path()).hash()) + str(Time.get_ticks_usec())
			object_id = new_id
			print("Generated new Object ID: ", new_id)


var _owner: Node

func _ready() -> void:
	# This code only runs when the game is playing, not in the editor.
	if Engine.is_editor_hint():
		return

	_owner = get_parent()

	if object_id.is_empty():
		push_warning("Persistent object has no ID and will not be saved: " + str(_owner.name))
		set_process(false)
		set_physics_process(false)
		return

	# Ask the GameManager if this object has a previously saved state.
	var state = GameManager.get_persistent_state(object_id)
	if state != null:
		# If it does, apply that state.
		_apply_state(state)

# Called by the owner (e.g., the Chest or Prisoner) when it has been interacted with.
func mark_collected(state: Dictionary) -> void:
	if Engine.is_editor_hint() or object_id.is_empty():
		return
	GameManager.set_persistent_state(object_id, state)
	# We call _apply_state here to immediately trigger the collected behavior (like queue_free).
	_apply_state(state)

# This function tells the owner what to do with the saved data.
func _apply_state(state: Dictionary) -> void:
	# The owner node is responsible for implementing this method to handle its own state.
	if _owner.has_method("_apply_persistent_state"):
		_owner._apply_persistent_state(state)

--- SCRIPT: res://Interactables/Prisoner/Prisoner.gd ---
# res://Interactables/Prisoner/Prisoner.gd
extends StaticBody2D

@onready var _interactable: Interactable = $Interactable
@onready var _persistence_component: PersistenceComponent = $PersistenceComponent
@onready var animated_sprite: AnimatedSprite2D = $AnimatedSprite2D ## NEW: Add reference to the sprite
@onready var animation_player = $AnimationPlayer
func _ready() -> void:
	_interactable.interacted.connect(_on_interactable_interacted)

func _on_interactable_interacted() -> void:
	# NEW: Play the rescued animation and wait for it to finish.
	animation_player.play("rescued")
	await animated_sprite.animation_finished
	
	EventBus.villager_rescued.emit()
	_persistence_component.mark_collected({"is_rescued": true})

# This function is called by the PersistenceComponent if the prisoner has saved data.
func _apply_persistent_state(state: Dictionary) -> void:
	if state.get("is_rescued", false):
		# If this prisoner was already rescued, remove them from the scene.
		queue_free()

--- SCRIPT: res://Interactables/RescuedVillager/RescuedVillager.gd ---
# res://Interactables/RescuedVillager/RescuedVillager.gd
extends StaticBody2D

@export_multiline var dialogue_message: String = "Thank you!"

@onready var _collision_shape: CollisionShape2D = $CollisionShape2D
@onready var _interactable: Interactable = $InteractionArea

func _ready() -> void:
	_interactable.interacted.connect(_on_interacted)
	GameManager.resources_updated.connect(update_visibility)
	update_visibility()


func _on_interacted() -> void:
	EventBus.show_dialogue.emit(dialogue_message)


func update_visibility() -> void:
	
	
	if GameManager.villagers <= 0:
		# Hide and disable everything with the most reliable methods.
		hide()
		_collision_shape.set_deferred("disabled", true)
		_interactable.monitoring = false
		
		# THE DEFINITIVE FIX: Directly disable the interaction area's collision shape.
		# This is a more direct command to the physics server.
		_interactable.get_node("CollisionShape2D").set_deferred("disabled", true)
	else:
		# Show and enable everything.
		show()
		_collision_shape.set_deferred("disabled", false)
		_interactable.monitoring = true
		_interactable.get_node("CollisionShape2D").set_deferred("disabled", false)

--- SCRIPT: res://Levels/Hideout.gd ---
# res://Levels/Hideout/Hideout.gd
extends Node2D

@export var archer_placeholder_scene: PackedScene

# --- Node References (Corrected Paths from Scene Root) ---
@onready var gold_label: Label = $CanvasLayer/GUI/ResourceDisplay/PanelContainer/HBoxContainer/GoldLabel
@onready var villager_label: Label = $CanvasLayer/GUI/ResourceDisplay/PanelContainer/HBoxContainer/VillagerLabel
@onready var archer_label: Label = $CanvasLayer/GUI/ResourceDisplay/PanelContainer/HBoxContainer/ArcherLabel
@onready var train_archer_button: Button = $CanvasLayer/GUI/TrainArcherButton
@onready var archery_range: Node2D = $ArcheryRange


func _ready() -> void:
	train_archer_button.pressed.connect(_on_train_archer_button_pressed)
	GameManager.resources_updated.connect(update_visuals)
	update_visuals()


func update_visuals() -> void:
	# This function can be called by a signal before _ready() completes.
	# We wait for the 'ready' signal to ensure all @onready vars are set.
	if not is_node_ready(): # FIX: Use is_node_ready() for Godot 4.
		await ready

	gold_label.text = "Gold: " + str(GameManager.gold)
	villager_label.text = "Villagers: " + str(GameManager.villagers)
	archer_label.text = "Archers: " + str(GameManager.archers)
	
	train_archer_button.disabled = not (GameManager.gold >= 10 and GameManager.villagers > 0)
	
	for child in archery_range.get_children():
		child.queue_free()
		
	if archer_placeholder_scene:
		for i in range(GameManager.archers):
			var archer = archer_placeholder_scene.instantiate()
			archer.position.x = i * 50 
			archery_range.add_child(archer)


func _on_train_archer_button_pressed() -> void:
	EventBus.train_archer_requested.emit()

--- SCRIPT: res://Levels/level.gd ---
# res://Levels/Level.gd
extends Node2D

# This script can be used for level-specific logic in the future,
# but it no longer needs to handle global mission state signals.
func _ready() -> void:
	pass

--- SCRIPT: res://Player/Data/CameraStats.gd ---
# res://Player/Data/CameraStats.gd
class_name CameraStats
extends Resource

@export_group("Camera Tuning")
@export var horizontal_deadzone: float = 80.0 ## The horizontal space the player can move before the camera follows. Larger is looser, smaller is tighter.
@export var vertical_deadzone: float = 50.0 ## The vertical space the player can move before the camera follows. Good for ignoring small jumps.
@export var smoothing_speed: float = 6.0 ## The main speed at which the camera catches up to the player. Higher is snappier, lower is smoother.
@export var fall_speed_multiplier: float = 2.0 ## Increases camera speed when player is falling to prevent them from going off-screen.
@export var look_offset: float = 100.0 ## How far the camera shifts up/down when holding the look inputs.
@export var look_speed: float = 4.0 ## How quickly the camera moves to the look_offset position.
@export var lookahead_distance: float = 120.0 ## How far the camera shifts in the direction of movement.
@export var facing_offset: float = 50.0 ## The horizontal offset applied when the player is standing still, based on facing direction.
@export var ledge_peek_offset: float = 100.0 ## How far the camera automatically shifts down when the player is near a ledge.
@export var wall_slide_peek_offset: float = 80.0 ## The vertical offset applied when the player is sliding on a wall.
@export var recenter_speed: float = 2.0 ## How quickly the camera returns to center after looking around.

@export_group("Vertical Lookahead")
@export var upward_velocity_threshold: float = 200.0 ## The upward speed the player must exceed to trigger the lookahead.
@export var vertical_lookahead_amount: float = -100.0 ## The vertical offset (negative is up) to apply when lookahead is active.
@export var vertical_lookahead_speed: float = 4.0 ## The speed at which the camera moves to the lookahead position.

--- SCRIPT: res://Player/Data/PlayerStats.gd ---
class_name PlayerStats
extends Resource

@export_group("Movement & Physics")
@export var speed: float = 350.0
@export var air_control_acceleration: float = 250.0
@export var terminal_velocity: float = 750.0
@export var acceleration_smoothness: float = 0.1
@export var friction_smoothness: float = 0.3

@export_group("Jumping & Gravity")
@export var jump_height: float = 120.0
@export var time_to_apex: float = 0.5
@export var fall_gravity: float = 2400.0
@export var jump_cut_multiplier: float = 0.3

@export_group("Abilities")
@export var glide_velocity: float = 300.0
@export var blink_dash_enabled: bool = false
@export var slide_duration: float = 0.4
@export var standing_slide_speed: float = 375.0
@export var slide_friction: float = 0.01
@export var skid_duration: float = 0.25
@export var skid_friction: float = 0.25
@export var wall_slip_duration: float = 0.08
@export var wall_slide_friction: float = 80.0
@export var crouch_speed_multiplier: float = 0.5
@export var wall_slide_jump_horizontal_velocity: float = 600.0
@export var wall_slide_jump_vertical_velocity: float = -600.0
@export var wall_stick_jump_horizontal_velocity: float = 900.0
@export var wall_stick_jump_vertical_velocity: float = -400.0
@export var dash_end_velocity_multiplier: float = 0.3
@export var invisibility_duration: float = 2.0
@export var invisibility_cooldown: float = 5.0
@export var wall_kick_horizontal_velocity: float = 700.0 ## NEW: Horizontal speed of the kick-off.
@export var wall_kick_vertical_velocity: float = -200.0 ## NEW: Small upward boost during kick-off.
@export var wall_kick_duration: float = 0.25 ## NEW: How long the kick-off state lasts.

@export_group("Game Feel & Timers")
@export var coyote_time_duration: float = 0.2
@export var wall_coyote_time_duration: float = 0.18
@export var jump_buffer_duration: float = 0.1
@export var dash_freeze_duration: float = 0.08
@export var fall_zoom_delay: float = 0.3
@export var wall_detach_hang_time: float = 0.2
@export var wall_detach_gravity_scale: float = 0.5

# --- Calculated Values ---
var jump_velocity: float
var jump_gravity: float
var charged_jump_velocity: float


func _init() -> void:
	if time_to_apex > 0:
		jump_gravity = (2 * jump_height) / (time_to_apex * time_to_apex)
		jump_velocity = -jump_gravity * time_to_apex
		charged_jump_velocity = jump_velocity * 1.5
	else:
		jump_gravity = 1200.0
		jump_velocity = -600.0
		charged_jump_velocity = -900.0

--- SCRIPT: res://Player/PlayerCamera.gd ---
# res://Player/PlayerCamera.gd
extends Camera2D

@export var stats: CameraStats

# --- Node References ---
var _player: CharacterBody2D
@onready var _ground_ray: RayCast2D = get_parent().get_node("GroundRay")
@onready var _ledge_ray: RayCast2D = get_parent().get_node("LedgeRay")

# --- Internal State ---
var _target_position: Vector2 = Vector2.ZERO
var _last_known_ground_y: float = 0.0
var _current_offset: Vector2 = Vector2.ZERO


func _ready() -> void:
	_player = get_parent()
	assert(is_instance_valid(_player), "PlayerCamera must be a child of a valid player node.")
	
	global_position = _player.global_position
	_target_position = _player.global_position
	_last_known_ground_y = _player.global_position.y

	call_deferred("_setup_level_limits")


func _setup_level_limits() -> void:
	var boundary_nodes = get_tree().get_nodes_in_group("camera_boundary")
	if boundary_nodes.is_empty(): return

	var boundary_area: Area2D = boundary_nodes[0]
	var shape_node: CollisionShape2D = boundary_area.get_node("CollisionShape2D")
	var global_rect: Rect2 = shape_node.get_global_transform() * shape_node.shape.get_rect()
	
	self.limit_left = int(global_rect.position.x)
	self.limit_top = int(global_rect.position.y)
	self.limit_right = int(global_rect.end.x)
	self.limit_bottom = int(global_rect.end.y)


func _physics_process(delta: float) -> void:
	if not is_instance_valid(_player) or not is_instance_valid(stats): 
		return
	
	var facing_direction = 1.0 if not _player.animated_sprite.flip_h else -1.0
	var horizontal_offset = 0.0
	var move_input = Input.get_axis("left", "right")
	
	if move_input != 0:
		horizontal_offset = move_input * nvl(stats.lookahead_distance, 120.0)
	else:
		horizontal_offset = facing_direction * nvl(stats.facing_offset, 50.0)
	
	var base_target_x = _player.global_position.x + horizontal_offset
	var base_target_y = _calculate_stable_vertical_target()
	_target_position = Vector2(base_target_x, base_target_y)
	
	_update_dynamic_offset(delta)
	
	var final_target = _target_position + _current_offset
	var smoothing = nvl(stats.smoothing_speed, 6.0)
	self.global_position = self.global_position.lerp(final_target, delta * smoothing)


func _update_dynamic_offset(delta: float) -> void:
	var diff = self.global_position - _target_position
	var target_offset = Vector2.ZERO
	
	if diff.x > stats.horizontal_deadzone:
		target_offset.x = diff.x - stats.horizontal_deadzone
	elif diff.x < -stats.horizontal_deadzone:
		target_offset.x = diff.x + stats.horizontal_deadzone
	
	if _player.velocity.y < -stats.upward_velocity_threshold:
		target_offset.y = stats.vertical_lookahead_amount
		_current_offset = _current_offset.lerp(target_offset, delta * stats.vertical_lookahead_speed)
		return 
	
	if diff.y > stats.vertical_deadzone:
		target_offset.y = diff.y - stats.vertical_deadzone
	elif diff.y < -stats.vertical_deadzone:
		target_offset.y = diff.y + stats.vertical_deadzone

	if _player.velocity.y > 200:
		target_offset.y = lerp(target_offset.y, diff.y, delta * stats.smoothing_speed * stats.fall_speed_multiplier)

	var current_player_state = _player.get_current_state_name()
	
	if current_player_state == "OnWallState":
		target_offset.y = stats.wall_slide_peek_offset
	else:
		var look_input = Input.get_axis("up", "down")
		target_offset.y += look_input * stats.look_offset
	
	_current_offset = _current_offset.lerp(target_offset, delta * stats.look_speed)


func _calculate_stable_vertical_target() -> float:
	# --- REFACTORED LEDGE PEEK LOGIC ---
	# First, correctly position the ledge ray based on player facing direction.
	var facing_direction = 1.0 if not _player.animated_sprite.flip_h else -1.0
	_ledge_ray.position.x = abs(_ledge_ray.position.x) * facing_direction
	
	# The one condition to check for a peek is if the player is on the floor AND the ledge ray is not touching anything.
	var is_at_ledge = _player.is_on_floor() and not _ledge_ray.is_colliding()

	if is_at_ledge:
		# If we are at a ledge, find the ground position and return the peek offset.
		if _ground_ray.is_colliding():
			_last_known_ground_y = _ground_ray.get_collision_point().y
			return _last_known_ground_y + stats.ledge_peek_offset

	# --- DEFAULT BEHAVIOR (If not at a ledge) ---
	# If on the floor, update the last known ground position.
	if _player.is_on_floor() and _ground_ray.is_colliding():
		_last_known_ground_y = _ground_ray.get_collision_point().y
		return _last_known_ground_y

	# If airborne, use the deadzone logic based on the last known ground position.
	var vertical_diff = _player.global_position.y - _last_known_ground_y
	if abs(vertical_diff) < stats.vertical_deadzone:
		return _last_known_ground_y
	else:
		return _player.global_position.y - (stats.vertical_deadzone * sign(vertical_diff))


func nvl(value, if_null):
	if value == null:
		return if_null
	return value

--- SCRIPT: res://Player/PlayerInteraction.gd ---
# res://Player/PlayerInteraction.gd
extends Area2D

func _ready() -> void:
	area_entered.connect(_on_area_entered)
	area_exited.connect(_on_area_exited)


func _on_area_entered(area: Area2D) -> void:
	if area is Interactable:
		Loggie.info("Entered area of: " + area.get_parent().name, "interaction")
		InteractionManager.register_interactable(area)


func _on_area_exited(area: Area2D) -> void:
	if area is Interactable:
		Loggie.info("Exited area of: " + area.get_parent().name, "interaction")
		InteractionManager.unregister_interactable(area)

--- SCRIPT: res://Player/PlayerModularControl/AnimationController.gd ---
extends Node2D

# Get a reference to the AnimatedSprite2D node, which is a sibling of this node.
@onready var animated_sprite = get_parent().get_node("AnimatedSprite2D")
# -- A variable to hold a reference to the main player script --
var player

# --- Get the parent reference when the node is ready ---
func _ready():
	# We get the parent node so we can access its "States" enum
	player = get_parent()

# This is the main public function that our player script will call every frame.
# It needs to know the player's current state, velocity, and wall normal to make decisions.
func update_animation(current_state, current_velocity, wall_normal, input_direction_x):
	# This new structure is much clearer. We handle special cases first.
	match current_state:
		player.States.ON_WALL, player.States.WALL_SLIP:
			animated_sprite.play("wall slide")
			# Flip is based on the wall's direction, not input.
			animated_sprite.flip_h = wall_normal.x < 0

		player.States.WALL_STICKING:
			animated_sprite.play("wall hang")
			# This flip logic makes the player face away from the wall.
			animated_sprite.flip_h = wall_normal.x > 0

		# The default case handles all other "normal" states.
		_:
			# First, determine the animation to play.
			match current_state:
				player.States.IDLE:
					animated_sprite.play("idle")
				player.States.RUNNING:
					animated_sprite.play("run")
				player.States.JUMPING:
					animated_sprite.play("jump")
				player.States.FALLING, player.States.WALL_DETACH:
					animated_sprite.play("fall")
				player.States.LANDING, player.States.DASH_PREPARE:
					animated_sprite.play("crouch")
				player.States.SKIDDING:
					animated_sprite.play("turn")
				player.States.SLIDING:
					animated_sprite.play("slide")
				player.States.DASHING:
					animated_sprite.play("jump") # Or a dedicated dash animation
				player.States.CROUCHING:
					if abs(current_velocity.x) > 10:
						animated_sprite.play("crouch walk")
					else:
						animated_sprite.play("crouch")
			# Second, for all these normal states, flip the sprite based on input.
			if input_direction_x > 0:
				animated_sprite.flip_h = false
			elif input_direction_x < 0:
				animated_sprite.flip_h = true

--- SCRIPT: res://Player/PlayerScript.gd ---
# PlayerScript.gd
extends CharacterBody2D

@export var stats: PlayerStats
@export_group("VFX")
@export var dash_start_vfx: VFXData

# ... (enum, signals, constants, etc. are the same) ...
enum States {IDLE, RUNNING, JUMPING, FALLING, GLIDING, ON_WALL, WALL_STICKING, DASHING, UNSTICKING, CROUCHING, LANDING, DASH_PREPARE, WALL_SLIP, SKIDDING, SLIDING, WALL_DETACH, WALL_KICK}
signal long_fall_started
signal long_fall_ended
signal gliding_started
signal gliding_ended
const MAX_JUMPS = 2
const WALL_STICK_DURATION = 2.0
const JUMP_CHARGE_DURATION = 1.0
const LANDING_DURATION = 0.15
const COMBO_STATES: Array[String] = ["Jumping", "OnWall", "Dashing", "Sliding"]
var current_jumps = 0
var can_dash: bool = true
var can_wall_stick: bool = true
var can_standing_slide: bool = true
var is_jump_charged: bool = false
var jump_buffered: bool = false
var is_long_fall: bool = false
var is_invisible: bool = false
var can_go_invisible: bool = true
var last_wall_normal: Vector2
var _combo_chain: Array[String] = []
var _interact_held: bool = false
@onready var state_machine = $StateMachine
@onready var dash_timer = $Timers/DashTimer
@onready var dash_cooldown_timer = $Timers/DashCooldownTimer
@onready var wall_stick_timer = $Timers/WallStickTimer
@onready var standing_collision = $StandingCollision
@onready var crouching_collision = $CrouchingCollision
@onready var wall_slide_collision = $WallSlideCollision
@onready var crouch_timer = $Timers/CrouchTimer
@onready var land_timer = $Timers/LandTimer
@onready var coyote_timer = $Timers/CoyoteTimer
@onready var jump_buffer_timer = $Timers/JumpBufferTimer
@onready var animated_sprite = $AnimatedSprite2D
@onready var dash_freeze_timer = $Timers/DashFreezeTimer
@onready var fall_zoom_timer = $Timers/FallZoomTimer
@onready var wall_slip_timer = $Timers/WallSlipTimer
@onready var skid_timer = $Timers/SkidTimer
@onready var wall_coyote_timer = $Timers/WallCoyoteTimer
@onready var slide_timer = $Timers/SlideTimer
@onready var standing_slide_cooldown_timer = $Timers/StandingSlideCooldownTimer
@onready var head_clearance_ray = $HeadClearanceRaycast
@onready var animation_controller = $AnimationController
@onready var vfx = $VFX
@onready var wall_detach_timer = $Timers/WallDetachTimer
@onready var invisibility_timer = $Timers/InvisibilityTimer
@onready var invisibility_cooldown_timer = $Timers/InvisibilityCooldownTimer
@onready var wall_check_ray_right: RayCast2D = $WallCheckRayRight
@onready var wall_check_ray_left: RayCast2D = $WallCheckRayLeft
@onready var animation_player: AnimationPlayer = $AnimationPlayer
@onready var combo_timer: Timer = $Timers/ComboTimer
@onready var combo_reset_timer: Timer = $Timers/ComboResetTimer
@onready var ground_ray: RayCast2D = $GroundRay
@onready var dash_particles: GPUParticles2D = $DashParticles
@onready var wall_kick_timer = $Timers/WallKickTimer

# ... (_ready, _process, _physics_process are the same) ...
func _ready():
	assert(is_instance_valid(stats), "PlayerStats resource must be assigned to the Player in the Inspector!")
	wall_kick_timer.timeout.connect(_on_wall_kick_timer_timeout)
	dash_timer.timeout.connect(_on_dash_timer_timeout)
	dash_cooldown_timer.timeout.connect(_on_dash_cooldown_timer_timeout)
	wall_stick_timer.timeout.connect(_on_wall_stick_timer_timeout)
	crouch_timer.timeout.connect(_on_crouch_timer_timeout)
	land_timer.timeout.connect(_on_land_timer_timeout)
	coyote_timer.timeout.connect(_on_coyote_timer_timeout)
	jump_buffer_timer.timeout.connect(_on_jump_buffer_timer_timeout)
	dash_freeze_timer.timeout.connect(_on_dash_freeze_timer_timeout)
	fall_zoom_timer.timeout.connect(_on_fall_zoom_timer_timeout)
	wall_slip_timer.timeout.connect(_on_wall_slip_timer_timeout)
	skid_timer.timeout.connect(_on_skid_timer_timeout)
	wall_coyote_timer.timeout.connect(_on_wall_coyote_timer_timeout)
	slide_timer.timeout.connect(_on_slide_timer_timeout)
	standing_slide_cooldown_timer.timeout.connect(_on_standing_slide_cooldown_timer_timeout)
	wall_detach_timer.timeout.connect(_on_wall_detach_timer_timeout)
	invisibility_timer.timeout.connect(_on_invisibility_timer_timeout)
	invisibility_cooldown_timer.timeout.connect(_on_invisibility_cooldown_timer_timeout)
	combo_timer.timeout.connect(_on_combo_timer_timeout)
	combo_reset_timer.timeout.connect(_on_combo_reset_timer_timeout)
	state_machine.state_changed.connect(_on_state_changed)
	state_machine.call_deferred("initialize")
func _process(_delta: float) -> void:
	if Input.is_action_just_pressed("pause"):
		EventBus.pause_menu_requested.emit()
func _physics_process(_delta: float):
	if not GameManager.is_gameplay_active:
		return
	if not is_instance_valid(stats):
		return
	velocity.y = min(velocity.y, stats.terminal_velocity)
	_handle_global_inputs()
	move_and_slide()


func _on_dash_freeze_timer_timeout():
	state_machine.change_state("Dashing")
	var dash_direction = Vector2(1 if not animated_sprite.flip_h else -1, 0)

	if is_instance_valid(dash_start_vfx):
		vfx.play_effect(dash_start_vfx)

	vfx.play_dash_effects(dash_particles)
	
	assert(stats.dash_duration > 0, "Dash Duration in PlayerStats cannot be zero.")
	var dash_speed = stats.dash_distance / stats.dash_duration
	
	velocity.x = dash_direction.x * dash_speed
	velocity.y = 0
	dash_timer.start(stats.dash_duration)

# ... (many functions are the same) ...
func _handle_global_inputs():
	if Input.is_action_just_pressed("dash") and can_dash:
		state_machine.change_state("DashPrepare")
	if Input.is_action_just_pressed("invisibility") and can_go_invisible:
		_enter_invisibility()
func enter_jump_state():
	coyote_timer.stop()
	fall_zoom_timer.stop()
	set_standing_collision()
	velocity.y = stats.jump_velocity
	current_jumps += 1
func wall_jump(wall_normal_override: Vector2 = Vector2.ZERO):
	wall_stick_timer.stop()
	wall_coyote_timer.stop()
	var wall_normal = wall_normal_override if wall_normal_override != Vector2.ZERO else get_wall_normal()
	if Input.is_action_pressed("shift") and can_wall_stick:
		velocity.y = stats.wall_stick_jump_vertical_velocity
		velocity.x = wall_normal.x * stats.wall_stick_jump_horizontal_velocity
	else:
		velocity.y = stats.wall_slide_jump_vertical_velocity
		velocity.x = wall_normal.x * stats.wall_slide_jump_horizontal_velocity
	can_wall_stick = true
	current_jumps = 1
func _start_wall_coyote_time():
	last_wall_normal = get_wall_normal()
	wall_coyote_timer.start(stats.wall_coyote_time_duration)
	wall_detach_timer.start(stats.wall_detach_hang_time)
	can_wall_stick = true
	fall_zoom_timer.start(stats.fall_zoom_delay)
func is_head_clear() -> bool:
	return not head_clearance_ray.is_colliding()
func set_standing_collision():
	standing_collision.disabled = false
	crouching_collision.disabled = true
	wall_slide_collision.disabled = true
func set_crouching_collision():
	standing_collision.disabled = true
	crouching_collision.disabled = false
	wall_slide_collision.disabled = true
func set_wall_slide_collision():
	standing_collision.disabled = true
	crouching_collision.disabled = true
	wall_slide_collision.disabled = false
func _enter_invisibility():
	is_invisible = true
	can_go_invisible = false
	invisibility_timer.start(stats.invisibility_duration)
	invisibility_cooldown_timer.start(stats.invisibility_cooldown)
	animated_sprite.modulate.a = 0.5
func _on_dash_timer_timeout():
	end_dash()
	state_machine.change_state("Falling")
func _on_dash_cooldown_timer_timeout():
	can_dash = true
func _on_wall_stick_timer_timeout():
	if state_machine.current_state.name == "WallStickingState":
		state_machine.change_state("OnWall")
func _on_crouch_timer_timeout():
	is_jump_charged = true
func _on_coyote_timer_timeout():
	if current_jumps == 0:
		current_jumps = 1
func _on_jump_buffer_timer_timeout():
	jump_buffered = false
func _on_invisibility_timer_timeout():
	is_invisible = false
	animated_sprite.modulate.a = 1.0
func _on_invisibility_cooldown_timer_timeout():
	can_go_invisible = true
func _on_land_timer_timeout():
	if state_machine.current_state.name == "LandingState":
		state_machine.change_state("Idle")
func _on_fall_zoom_timer_timeout():
	if not is_on_floor():
		is_long_fall = true
		long_fall_started.emit()
func _on_wall_slip_timer_timeout():
	if state_machine.current_state.name == "WallSlipState":
		state_machine.change_state("WallSticking")
func _on_skid_timer_timeout():
	if state_machine.current_state.name == "SkiddingState":
		state_machine.change_state("Running")
func _on_wall_coyote_timer_timeout():
	pass
func _on_slide_timer_timeout():
	if state_machine.current_state.name == "SlidingState":
		if is_head_clear():
			if Input.is_action_pressed("down"):
				state_machine.change_state("Crouching")
			else:
				state_machine.change_state("Idle")
		else:
			state_machine.change_state("Crouching")
func _on_standing_slide_cooldown_timer_timeout():
	can_standing_slide = true
func _on_wall_detach_timer_timeout():
	if state_machine.current_state.name == "WallDetachState":
		state_machine.change_state("Falling")
func _unhandled_input(event: InputEvent) -> void:
	if not GameManager.is_gameplay_active: return
	if event.is_action_pressed("interact_world"):
		EventBus.interaction_started.emit()
	elif event.is_action_released("interact_world"):
		EventBus.interaction_cancelled.emit()
func end_dash() -> void:
	if state_machine.current_state.name != "DashingState":
		return
	vfx.stop_dash_effects(dash_particles)
	# TODO: Add dash_cooldown to PlayerStats resource
	var dash_cooldown = 0.5
	dash_cooldown_timer.start(dash_cooldown)
func _on_state_changed(new_state_name: String) -> void:
	if new_state_name in COMBO_STATES:
		combo_reset_timer.stop()
		if not new_state_name in _combo_chain:
			_add_move_to_combo(new_state_name)
	elif new_state_name in ["Idle", "Running"]:
		combo_reset_timer.start(1.5)

func _add_move_to_combo(move_name: String) -> void:
	combo_timer.start(1.0)
	_combo_chain.append(move_name)
	
	Loggie.info(str("Combo Chain: ", _combo_chain), "combo")

	if _combo_chain.size() >= 3:
		EventBus.flow_combo_success.emit()
		Loggie.info("--- FLOW COMBO SUCCESS! ---", "combo")

func _reset_combo() -> void:
	if not _combo_chain.is_empty():
		_combo_chain.clear()
		Loggie.info("Combo Reset.", "combo")

func _on_combo_timer_timeout() -> void:
	_reset_combo()

func _on_combo_reset_timer_timeout() -> void:
	_reset_combo()

func get_current_state_name() -> String:
	if state_machine and is_instance_valid(state_machine.current_state):
		return state_machine.current_state.name
	return ""
	
func _on_wall_kick_timer_timeout() -> void:
	if state_machine.current_state.name == "WallKickState":
		state_machine.change_state("Falling")

--- SCRIPT: res://Player/States/CrouchingState.gd ---
# res://Player/States/CrouchingState.gd
extends State

func enter() -> void:
	player.set_crouching_collision()
	player.crouch_timer.start(player.JUMP_CHARGE_DURATION)
	player.is_jump_charged = false


func exit() -> void:
	player.crouch_timer.stop()
	if player.is_head_clear():
		player.set_standing_collision()


func process_physics(_delta: float) -> void:
	# THE ROBUST FIX: We are only truly "falling" if we are not on the floor
	# AND we have downward vertical velocity. This prevents the one-frame flicker.
	if not player.is_on_floor() and player.velocity.y > 0:
		state_machine.change_state("Falling")
		return

	var input_x: float = Input.get_axis("left", "right")

	var target_velocity_x = input_x * player.stats.speed * player.stats.crouch_speed_multiplier
	player.velocity.x = lerp(player.velocity.x, target_velocity_x, player.stats.acceleration_smoothness)
	
	if Input.is_action_just_pressed("slide") and player.can_standing_slide:
		state_machine.change_state("Sliding")
	elif Input.is_action_just_pressed("jump"):
		if player.is_head_clear():
			if player.is_jump_charged:
				player.velocity.y = player.stats.charged_jump_velocity
			else:
				player.velocity.y = player.stats.jump_velocity
			player.current_jumps = 1
			state_machine.change_state("Jumping")
	
	elif not Input.is_action_pressed("down"):
		if player.is_head_clear():
			state_machine.change_state("Idle")
			
	player.animation_controller.update_animation(
		player.States.CROUCHING, player.velocity, Vector2.ZERO, input_x
	)

--- SCRIPT: res://Player/States/DashingState.gd ---
# res://Player/States/DashingState.gd
extends State

func enter() -> void:
	player.animation_controller.update_animation(player.States.DASHING, player.velocity, Vector2.ZERO, 0)


func process_physics(_delta: float) -> void:
	if not player.stats.blink_dash_enabled and player.is_on_wall():
		# If we hit a wall, do the cleanup...
		player.end_dash()
		# ...and then transition directly to the OnWallState.
		state_machine.change_state("OnWall")
		return

--- SCRIPT: res://Player/States/DashPrepareState.gd ---
# DashPrepareState.gd
extends State

@export var dash_prepare_vfx: VFXData

func enter():
	player.can_dash = false
	player.velocity = Vector2.ZERO
	player.dash_freeze_timer.start(player.stats.dash_freeze_duration)

	if dash_prepare_vfx:
		player.vfx.play_effect(dash_prepare_vfx)

	var input_x = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.DASH_PREPARE, player.velocity, Vector2.ZERO, input_x)

func process_physics(_delta):
	# This state is controlled by a timer.
	pass

--- SCRIPT: res://Player/States/FallingState.gd ---
# res://Player/States/FallingState.gd
extends State

@export var wall_jump_vfx: VFXData

func enter() -> void:
	var input_x: float = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.FALLING, player.velocity, Vector2.ZERO, input_x)

func process_physics(delta: float) -> void:
	var input_x: float = Input.get_axis("left", "right")

	# Physics logic
	if not player.is_on_floor():
		player.velocity.y += player.stats.fall_gravity * delta
	player.velocity.x = move_toward(player.velocity.x, input_x * player.stats.speed, player.stats.air_control_acceleration)

	# --- Check for transitions ---
	if Input.is_action_pressed("up"):
		state_machine.change_state("Gliding")
		return

	# --- FIX: Check for slide input on landing ---
	elif player.is_on_floor():
		if Input.is_action_pressed("slide"):
			state_machine.change_state("Sliding")
		else:
			state_machine.change_state("Landing")
		return

	elif player.is_on_wall():
		if not (sign(player.get_wall_normal().x) == sign(input_x)):
			state_machine.change_state("OnWall")
			return

	elif Input.is_action_just_pressed("jump"):
		if player.wall_check_ray_right.is_colliding():
			player.wall_jump(Vector2(-1, 0))
			if wall_jump_vfx:
				player.vfx.play_effect(wall_jump_vfx)
			state_machine.change_state("Jumping")
			return
		elif player.wall_check_ray_left.is_colliding():
			player.wall_jump(Vector2(1, 0))
			if wall_jump_vfx:
				player.vfx.play_effect(wall_jump_vfx)
			state_machine.change_state("Jumping")
			return

		if not player.wall_coyote_timer.is_stopped():
			player.wall_jump(player.last_wall_normal)
			if wall_jump_vfx:
				player.vfx.play_effect(wall_jump_vfx)
			state_machine.change_state("Jumping")
			return
		elif player.current_jumps < player.MAX_JUMPS:
			state_machine.change_state("Jumping")
			return
		else:
			player.jump_buffered = true
			player.jump_buffer_timer.start(player.stats.jump_buffer_duration)

	player.animation_controller.update_animation(player.States.FALLING, player.velocity, Vector2.ZERO, input_x)

--- SCRIPT: res://Player/States/GlidingState.gd ---
# res://Player/States/GlidingState.gd
extends State

func enter() -> void:
	# Announce that gliding has started.
	player.gliding_started.emit()
	var input_x: float = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.GLIDING, player.velocity, Vector2.ZERO, input_x)

func exit() -> void:
	# Announce that gliding has ended.
	player.gliding_ended.emit()

func process_physics(_delta: float) -> void:
	var input_x: float = Input.get_axis("left", "right")

	player.velocity.y = player.stats.glide_velocity
	player.velocity.x = move_toward(player.velocity.x, input_x * player.stats.speed, 150)

	if player.is_on_floor():
		state_machine.change_state("Landing")
	elif player.is_on_wall():
		state_machine.change_state("OnWall")
	elif Input.is_action_just_released("up"):
		state_machine.change_state("Falling")
	elif Input.is_action_just_pressed("jump"):
		if player.current_jumps < player.MAX_JUMPS:
			state_machine.change_state("Jumping")
		else:
			player.jump_buffered = true
			player.jump_buffer_timer.start(player.stats.jump_buffer_duration)

--- SCRIPT: res://Player/States/Idle.gd ---
# IdleState.gd
extends State

func enter() -> void:
	var input_x: float = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.IDLE, player.velocity, Vector2.ZERO, input_x)


func process_physics(_delta: float) -> void:
	player.velocity.x = lerp(player.velocity.x, 0.0, player.stats.friction_smoothness)
	
	var input_x: float = Input.get_axis("left", "right")
	
	if Input.is_action_just_pressed("jump"):
		state_machine.change_state("Jumping")
	elif Input.is_action_just_pressed("slide") and player.can_standing_slide:
		state_machine.change_state("Sliding")
	elif Input.is_action_pressed("down"):
		state_machine.change_state("Crouching")
	elif input_x != 0:
		state_machine.change_state("Running")
	elif not player.is_on_floor():
		player.coyote_timer.start(player.stats.coyote_time_duration)
		player.fall_zoom_timer.start(player.stats.fall_zoom_delay)
		state_machine.change_state("Falling")

--- SCRIPT: res://Player/States/JumpingState.gd ---
# res://Player/States/JumpingState.gd
extends State

@export var jump_vfx: VFXData


func enter() -> void:
	player.enter_jump_state()

	# This is the only animation call we need here.
	# The AnimationPlayer will handle the rest of the sequence.
	player.animation_player.play("jump_stretch")

	if jump_vfx:
		player.vfx.play_effect(jump_vfx)

func exit() -> void:
	player.animation_player.play("RESET")

func process_physics(delta: float) -> void:
	var input_x: float = Input.get_axis("left", "right")
	var gravity: float = player.stats.jump_gravity if player.velocity.y < 0 else player.stats.fall_gravity

	player.velocity.y += gravity * delta
	player.velocity.x = move_toward(player.velocity.x, input_x * player.stats.speed, player.stats.air_control_acceleration)

	if player.is_on_wall():
		if not (sign(player.get_wall_normal().x) == sign(input_x)):
			state_machine.change_state("OnWall")
			return

	if player.velocity.y > 0:
		state_machine.change_state("Falling")
		return
	elif Input.is_action_just_released("jump") and player.velocity.y < 0:
		player.velocity.y *= player.stats.jump_cut_multiplier

	player.animation_controller.update_animation(player.States.JUMPING, player.velocity, Vector2.ZERO, input_x)

--- SCRIPT: res://Player/States/LandingState.gd ---
# res://Player/States/LandingState.gd
extends State

@export var land_vfx: VFXData

func enter() -> void:
	player.current_jumps = 0
	if player.is_long_fall:
		player.is_long_fall = false
		player.long_fall_ended.emit()

	# Play the squish animation from the AnimationPlayer.
	player.animation_player.play("land_squish")

	# Simultaneously, play the crouch animation on the AnimatedSprite2D.
	var input_x: float = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.LANDING, player.velocity, Vector2.ZERO, input_x)

	if land_vfx:
		player.vfx.play_effect(land_vfx)

func exit() -> void:
	pass

func process_physics(_delta: float) -> void:
	# The state transition is handled by the "land_squish" animation's Call Method Track.
	if Input.is_action_just_pressed("jump") or player.jump_buffered:
		player.jump_buffered = false
		player.jump_buffer_timer.stop()
		state_machine.change_state("Jumping")
		return

	player.velocity.x = lerp(player.velocity.x, 0.0, player.stats.friction_smoothness)

--- SCRIPT: res://Player/States/OnWallState.gd ---
# res://Player/States/OnWallState.gd
extends State

@export var wall_slide_vfx: VFXData
@export var wall_jump_vfx: VFXData

@onready var vfx_timer: Timer = $VFXTimer

func _ready() -> void:
	vfx_timer.timeout.connect(_on_particle_timer_timeout)

func enter() -> void:
	var wall_normal = player.get_wall_normal()

	# The AnimationPlayer now handles all visual offsets.
	if wall_normal.x > 0:
		player.animation_player.play("wall_slide_offset_left")
	else:
		player.animation_player.play("wall_slide_offset_right")

	player.set_wall_slide_collision()
	player.current_jumps = 0
	var input_x: float = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.ON_WALL, player.velocity, wall_normal, input_x)

	vfx_timer.start()

func process_physics(delta: float) -> void:
	var input_x: float = Input.get_axis("left", "right")
	var wall_normal = player.get_wall_normal()

	# This state now only handles a simple vertical wall jump.
	if Input.is_action_just_pressed("jump"):
		player.wall_jump()
		if wall_jump_vfx:
			player.vfx.play_effect(wall_jump_vfx)
		state_machine.change_state("Falling")
		return

	player.velocity.y = move_toward(player.velocity.y, player.stats.wall_slide_friction, player.stats.fall_gravity * delta)
	player.velocity.x = -wall_normal.x * 5.0

	if Input.is_action_pressed("shift") and player.can_wall_stick:
		state_machine.change_state("WallSlip")
	elif not player.is_on_wall() or (wall_normal.x * input_x > 0 and sign(input_x) != sign(wall_normal.x)):
		player._start_wall_coyote_time()
		state_machine.change_state("WallDetach")
	elif player.is_on_floor():
		state_machine.change_state("Idle")

func exit() -> void:
	vfx_timer.stop()
	player.animation_player.play("RESET")

func _on_particle_timer_timeout() -> void:
	if wall_slide_vfx:
		player.vfx.play_effect(wall_slide_vfx)

--- SCRIPT: res://Player/States/RunningState.gd ---
# res://Player/States/RunningState.gd
extends State

func enter() -> void:
	var input_x: float = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.RUNNING, player.velocity, Vector2.ZERO, input_x)

func process_physics(_delta: float) -> void:
	var input_x: float = Input.get_axis("left", "right")

	# THE FIX: Check for the slide input before checking for a skid.
	if Input.is_action_just_pressed("slide"):
		state_machine.change_state("Sliding")
		return

	# --- Original Logic ---
	if input_x != 0 and sign(input_x) != sign(player.velocity.x) and abs(player.velocity.x) > 100:
		state_machine.change_state("Skidding")
		return

	player.velocity.x = lerp(player.velocity.x, input_x * player.stats.speed, player.stats.acceleration_smoothness)

	if input_x == 0:
		state_machine.change_state("Idle")
	elif Input.is_action_just_pressed("jump"):
		state_machine.change_state("Jumping")
	elif not player.is_on_floor():
		player.coyote_timer.start(player.stats.coyote_time_duration)
		player.fall_zoom_timer.start(player.stats.fall_zoom_delay)
		state_machine.change_state("Falling")

--- SCRIPT: res://Player/States/SkiddingState.gd ---
# res://Player/States/SkiddingState.gd
extends State

@export var skid_vfx: VFXData

func enter() -> void:
	player.skid_timer.start(player.stats.skid_duration)
	var input_x: float = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.SKIDDING, player.velocity, Vector2.ZERO, -input_x)

	if is_instance_valid(skid_vfx):
		player.vfx.play_effect(skid_vfx)

func exit() -> void:
	player.skid_timer.stop()

func process_physics(_delta: float) -> void:
	# Use stats resource for physics values
	player.velocity.x = lerp(player.velocity.x, 0.0, player.stats.skid_friction)
	
	if player.skid_timer.is_stopped():
		state_machine.change_state("Running")
	elif Input.is_action_just_pressed("jump"):
		state_machine.change_state("Jumping")

--- SCRIPT: res://Player/States/SlidingState.gd ---
# res://Player/States/SlidingState.gd
extends State

@export var slide_vfx: VFXData

func enter() -> void:
	player.slide_timer.start(player.stats.slide_duration)
	player.set_crouching_collision()

	# Check if this is a standing slide and apply cooldown if necessary.
	if abs(player.velocity.x) < 10.0:
		var direction = 1.0 if not player.animated_sprite.flip_h else -1.0
		player.velocity.x = player.stats.standing_slide_speed * direction
		
		player.can_standing_slide = false
		player.standing_slide_cooldown_timer.start(1.0)

	var input_x: float = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.SLIDING, player.velocity, Vector2.ZERO, input_x)

	if is_instance_valid(slide_vfx):
		player.vfx.play_effect(slide_vfx)


func exit() -> void:
	player.slide_timer.stop()
	if player.is_head_clear():
		player.set_standing_collision()


func process_physics(_delta: float) -> void:
	# --- Apply friction and handle falling off ledges ---
	player.velocity.x = lerp(player.velocity.x, 0.0, player.stats.slide_friction)
	if not player.ground_ray.is_colliding():
		state_machine.change_state("Falling")
		return

	# --- Determine if the player WANTS to or SHOULD stop sliding ---
	var wants_to_exit_slide = Input.is_action_just_released("slide")
	var must_exit_slide = player.slide_timer.is_stopped()

	# --- Handle Jumping out of a slide ---
	# A player can always try to jump out of a slide.
	if Input.is_action_just_pressed("jump"):
		# But only if their head is clear.
		if player.is_head_clear():
			state_machine.change_state("Jumping")
		# If head is not clear, the jump input is ignored and we continue sliding.
		return

	# --- Handle Exiting the slide by stopping or timer timeout ---
	if wants_to_exit_slide or must_exit_slide:
		# We can only exit the slide if the player's head is clear.
		if player.is_head_clear():
			# If head is clear, transition to the appropriate state based on input.
			if Input.is_action_pressed("down"):
				state_machine.change_state("Crouching")
			else:
				state_machine.change_state("Idle")
		# If head is NOT clear, we do nothing and let the slide continue,
		# effectively extending it until the player emerges from the tunnel.

--- SCRIPT: res://Player/States/State.gd ---
# State.gd
class_name State
extends Node

# A reference to the parent state machine.
var state_machine: Node

# A reference to the player character. We get this from the owner.
@onready var player: CharacterBody2D = get_owner()

## This virtual function is called when the state is entered.
func enter():
	pass # To be overridden by child states.

## This virtual function is called when the state is exited.
func exit():
	pass # To be overridden by child states.

## This virtual function runs during the _input() process.
func process_input(_event: InputEvent):
	pass # To be overridden by child states.

## This virtual function runs during the _physics_process().
func process_physics(_delta: float):
	pass # To be overridden by child states.

--- SCRIPT: res://Player/States/StateMachine.gd ---
# StateMachine.gd
class_name StateMachine
extends Node

@export var initial_state: NodePath
signal state_changed(new_state_name: String)

var current_state: State
var states: Dictionary = {}

func initialize():
	for child in get_children():
		if child is State:
			states[child.name] = child
			child.state_machine = self
	
	if initial_state:
		current_state = get_node(initial_state)
		current_state.enter()

func change_state(state_name: String):
	var new_state_node_name = state_name + "State"

	if current_state and current_state.name == new_state_node_name:
		return
	
	Loggie.info("Changing state from '%s' to '%s'" % [current_state.name if current_state else "null", new_state_node_name], "player_state")
	
	if current_state:
		current_state.exit()
	
	var new_state = states.get(new_state_node_name)
	if new_state:
		current_state = new_state
		current_state.enter()
		state_changed.emit(state_name)
	else:
		Loggie.error("State '" + new_state_node_name + "' not found in StateMachine.", "player_state")

func _input(event: InputEvent):
	if current_state:
		current_state.process_input(event)

func _physics_process(delta: float):
	if current_state:
		current_state.process_physics(delta)

--- SCRIPT: res://Player/States/UnstickingState.gd ---
# res://Player/States/UnstickingState.gd
extends State

func enter() -> void:
	player.animation_controller.update_animation(player.States.UNSTICKING, player.velocity, Vector2.ZERO, 0)

func process_physics(delta: float) -> void:
	var last_dash_direction: Vector2 = Vector2(1 if not player.animated_sprite.flip_h else -1, 0)
	# Use stats resource for physics values
	player.global_position -= last_dash_direction * player.stats.speed * delta

	if not player.test_move(player.transform, Vector2.ZERO):
		player.velocity = -last_dash_direction * player.stats.speed * player.stats.dash_end_velocity_multiplier
		player.dash_cooldown_timer.start(player.DASH_COOLDOWN)
		state_machine.change_state("Falling")

--- SCRIPT: res://Player/States/WallDetachState.gd ---
# res://Player/States/WallDetachState.gd
extends State

func enter() -> void:
	var input_x: float = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.WALL_DETACH, player.velocity, Vector2.ZERO, input_x)

func process_physics(delta: float) -> void:
	var input_x: float = Input.get_axis("left", "right")
	
	# Use stats resource for physics values
	player.velocity.y += player.stats.fall_gravity * player.stats.wall_detach_gravity_scale * delta
	player.velocity.x = move_toward(player.velocity.x, input_x * player.stats.speed, player.stats.air_control_acceleration)
	
	if Input.is_action_just_pressed("jump"):
		if not player.wall_coyote_timer.is_stopped():
			player.wall_jump(player.last_wall_normal)
			player.wall_detach_timer.stop()
			state_machine.change_state("Falling")
		else:
			player.jump_buffered = true
			player.jump_buffer_timer.start(player.stats.jump_buffer_duration)
	elif player.wall_detach_timer.is_stopped():
		state_machine.change_state("Falling")

--- SCRIPT: res://Player/States/WallKickState.gd ---
# res://Player/States/WallKickState.gd
extends State

@export var wall_kick_vfx: VFXData

func enter() -> void:
	var wall_normal = player.get_wall_normal()
	var input_x = Input.get_axis("left", "right")
	
	# Apply the horizontal and vertical kick-off velocities from our stats resource
	player.velocity.x = wall_normal.x * player.stats.wall_kick_horizontal_velocity
	player.velocity.y = player.stats.wall_kick_vertical_velocity
	
	# Start the timer that will end this state
	player.wall_kick_timer.start(player.stats.wall_kick_duration)
	
	# --- NEW: Add VFX and Animations ---
	# Set the player's animation pose to the "jump" animation, same as the dash.
	player.animation_controller.update_animation(player.States.DASHING, player.velocity, wall_normal, input_x)
	
	# Play the initial kick-off puff effect using our new resource.
	if is_instance_valid(wall_kick_vfx):
		player.vfx.play_effect(wall_kick_vfx)
	
	# Start the sustained dash particle trail.
	player.vfx.play_dash_effects(player.dash_particles)


func process_physics(delta: float) -> void:
	# Apply gravity while in the kick-off state
	player.velocity.y += player.stats.fall_gravity * delta
	
	# Transition to FallingState if we hit a ceiling
	if player.is_on_ceiling():
		state_machine.change_state("Falling")


func exit() -> void:
	# --- NEW: Stop the particle trail when the state ends. ---
	player.vfx.stop_dash_effects(player.dash_particles)
	player.wall_kick_timer.stop()

--- SCRIPT: res://Player/States/WallSlipState.gd ---
# res://Player/States/WallSlipState.gd
extends State

func enter() -> void:
	player.wall_slip_timer.start(player.stats.wall_slip_duration)
	var input_x: float = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.WALL_SLIP, player.velocity, player.get_wall_normal(),input_x )

func exit() -> void:
	player.wall_slip_timer.stop()

func process_physics(delta: float) -> void:
	# Use stats resource for physics values
	player.velocity.y = move_toward(player.velocity.y, player.stats.wall_slide_friction, player.stats.fall_gravity * delta)
	player.velocity.x = -player.get_wall_normal().x * 5.0

	if player.wall_slip_timer.is_stopped():
		player.can_wall_stick = false
		player.wall_stick_timer.start(player.WALL_STICK_DURATION)
		state_machine.change_state("WallSticking")
	elif not Input.is_action_pressed("shift"):
		state_machine.change_state("OnWall")
	elif Input.is_action_just_pressed("jump"):
		player.wall_jump()
		state_machine.change_state("Falling")
	elif not player.is_on_wall():
		player._start_wall_coyote_time()
		state_machine.change_state("WallDetach")

--- SCRIPT: res://Player/States/WallStickingState.gd ---
# WallStickingState.gd
extends State

func enter():
	var wall_normal = player.get_wall_normal()
	
	if wall_normal.x > 0:
		player.animation_player.play("wall_stick_offset_left")
	else:
		player.animation_player.play("wall_stick_offset_right")
	
	var input_x = Input.get_axis("left", "right")
	player.animation_controller.update_animation(player.States.WALL_STICKING, player.velocity, player.get_wall_normal(), input_x)

func process_physics(_delta):
	player.velocity.y = 1.0
	player.velocity.x = -player.get_wall_normal().x * 5.0

	var input_x: float = Input.get_axis("left", "right")
	var wall_normal = player.get_wall_normal()

	if Input.is_action_just_pressed("jump"):
		# NEW: Check for kick-off input here
		if GameManager.wall_kick_unlocked and input_x != 0 and sign(input_x) == sign(wall_normal.x):
			state_machine.change_state("WallKick")
		else:
			# If not kicking off, perform a normal stick jump
			player.wall_jump()
			# We can add a VFX for the stick jump here later if we want.
			state_machine.change_state("Falling")
		return

	elif not Input.is_action_pressed("shift"):
		player.wall_stick_timer.stop()
		state_machine.change_state("OnWall")
	elif not player.is_on_wall():
		player.wall_stick_timer.stop()
		player._start_wall_coyote_time()
		state_machine.change_state("WallDetach")
	elif player.is_on_floor():
		player.wall_stick_timer.stop()
		state_machine.change_state("Idle")

--- SCRIPT: res://Singletons/EventBus.gd ---
# res://Singletons/EventBus.gd
extends Node

# --- Player & Resources ---
signal gold_collected(amount: int)
signal villager_rescued
signal train_archer_requested
signal sound_created(position: Vector2, range: float)
signal flow_combo_success

# --- Mission State ---
signal mission_started
signal mission_objective_completed
signal mission_succeeded
signal mission_failed
signal player_detected
signal player_died
signal checkpoint_set(position: Vector2)

# --- UI & Game Flow ---
signal pause_toggled
signal pause_menu_requested
signal interaction_started # Player has pressed the button
signal interaction_cancelled # Player has released the button
signal interaction_succeeded # InteractionManager confirms the hold was completed
signal interaction_progress_updated(progress: float) # InteractionManager broadcasts hold progress
signal show_dialogue(message: String)
signal return_to_hideout_requested
signal start_mission_requested(mission_key: String)
signal new_game_requested
signal continue_game_requested

--- SCRIPT: res://Singletons/GameManager.gd ---
# res://Singletons/GameManager.gd

extends Node

signal resources_updated
signal checkpoint_set
signal hideout_upgraded

@export var hideout_progression_data: HideoutProgressionData ## The resource file containing upgrade costs for the hideout.

# --- Resource-based State Management ---
var session_state: MissionSaveState
var checkpoint_state: MissionSaveState

# --- Player Resources & Progress ---
var gold: int = 0
var villagers: int = 0
var archers: int = 0
var hideout_level: int = 1
var wall_kick_unlocked: bool = false

# --- Gameplay State ---
var is_gameplay_active: bool = true
var mission_objective_complete: bool = false

const SAVE_FILE_PATH = "user://savegame.json"

func _ready() -> void:
	load_game()
	EventBus.gold_collected.connect(_on_gold_collected)
	EventBus.villager_rescued.connect(_on_villager_rescued)
	EventBus.train_archer_requested.connect(_on_train_archer_requested)
	EventBus.mission_started.connect(_on_mission_started)
	EventBus.mission_objective_completed.connect(_on_mission_objective_completed)
	EventBus.player_detected.connect(_on_player_detected)
	EventBus.pause_toggled.connect(_on_pause_toggled)
	EventBus.player_died.connect(_on_player_died)

func try_upgrade_hideout() -> void:
	assert(is_instance_valid(hideout_progression_data), "HideoutProgressionData resource must be assigned to GameManager!")

	if hideout_level >= hideout_progression_data.max_level:
		Loggie.info("Hideout is already at max level.", "hideout")
		return

	var cost_index = hideout_level - 1
	if cost_index >= hideout_progression_data.upgrade_costs.size():
		Loggie.error("Not enough upgrade cost entries in HideoutProgressionData.", "hideout")
		return

	var cost = hideout_progression_data.upgrade_costs[cost_index]

	if gold >= cost:
		gold -= cost
		hideout_level += 1
		Loggie.info("SUCCESS: Hideout upgraded to level %d" % hideout_level, "hideout")
		hideout_upgraded.emit()
		save_game()
	else:
		Loggie.info("FAILED: Not enough gold to upgrade. Need %d, have %d" % [cost, gold], "hideout")


# --- Persistence API ---
func get_persistent_state(object_id: String) -> Dictionary:
	if session_state and session_state.collected_objects.has(object_id):
		return session_state.collected_objects[object_id]
	return {}

func set_persistent_state(object_id: String, state: Dictionary) -> void:
	if session_state:
		session_state.collected_objects[object_id] = state

func save_checkpoint_data() -> void:
	if session_state:
		checkpoint_state = session_state.duplicate(true)
		Loggie.info("Checkpoint data saved.", "checkpoint")

# --- Event Handlers ---
func _on_mission_started() -> void:
	mission_objective_complete = false
	session_state = MissionSaveState.new()
	checkpoint_state = null

func _on_player_died() -> void:
	if checkpoint_state:
		session_state = checkpoint_state.duplicate(true)
		Loggie.info("Session state restored from checkpoint.", "game_state")
	else:
		session_state = MissionSaveState.new()
		Loggie.info("No checkpoint found. Starting with fresh session state.", "game_state")
		
	if not SceneManager.current_scene_key.is_empty():
		SceneManager.change_scene(SceneManager.current_scene_key)

func set_checkpoint(pos: Vector2) -> void:
	if session_state:
		session_state.checkpoint_position = pos
	EventBus.checkpoint_set.emit(pos)

func _on_gold_collected(amount: int) -> void:
	gold += amount
	save_game()

func _on_villager_rescued() -> void:
	villagers += 1
	mission_objective_complete = true
	save_game()

func _on_train_archer_requested() -> void:
	if gold >= 10 and villagers > 0:
		gold -= 10
		villagers -= 1
		archers += 1
		save_game()

func _on_mission_objective_completed() -> void:
	EventBus.mission_succeeded.emit()

func _on_player_detected() -> void:
	EventBus.mission_failed.emit()

func _on_pause_toggled(is_paused: bool) -> void:
	get_tree().paused = is_paused
	is_gameplay_active = not is_paused

# --- Save/Load System ---
func reset_game_data() -> void:
	gold = 0
	villagers = 0
	archers = 0
	hideout_level = 1
	wall_kick_unlocked = false
	if FileAccess.file_exists(SAVE_FILE_PATH):
		DirAccess.remove_absolute(SAVE_FILE_PATH)
	resources_updated.emit()

func save_game():
	var save_data = {
		"gold": gold,
		"villagers": villagers,
		"archers": archers,
		"hideout_level": hideout_level,
		"wall_kick_unlocked": wall_kick_unlocked
	}
	var file = FileAccess.open(SAVE_FILE_PATH, FileAccess.WRITE)
	file.store_string(JSON.stringify(save_data))
	resources_updated.emit()

func load_game():
	if not FileAccess.file_exists(SAVE_FILE_PATH):
		return
		
	var file = FileAccess.open(SAVE_FILE_PATH, FileAccess.READ)
	var content = file.get_as_text()
	var data = JSON.parse_string(content)
	
	if data:
		gold = data.get("gold", 0)
		villagers = data.get("villagers", 0)
		archers = data.get("archers", 0)
		hideout_level = data.get("hideout_level", 1)
		wall_kick_unlocked = data.get("wall_kick_unlocked", false)
		resources_updated.emit()

--- SCRIPT: res://Singletons/InteractionManager.gd ---
# res://Singletons/InteractionManager.gd
extends Node

signal show_prompt(interactable)
signal hide_prompt

var _current_interactable: Interactable = null
var _is_holding: bool = false
var _hold_progress: float = 0.0

func _ready() -> void:
	EventBus.interaction_started.connect(_on_interaction_started)
	EventBus.interaction_cancelled.connect(_on_interaction_cancelled)
	EventBus.mission_started.connect(clear_interactable)

func _process(delta: float) -> void:
	if _is_holding and is_instance_valid(_current_interactable):
		_hold_progress += delta
		
		var duration = _current_interactable.interaction_duration
		if duration <= 0:
			duration = 0.01

		var progress_percentage = _hold_progress / duration
		EventBus.interaction_progress_updated.emit(progress_percentage)
		
		if _hold_progress >= duration:
			var object_name = _current_interactable.get_parent().name
			Loggie.info("Interaction SUCCEEDED for '%s'." % object_name, "interaction")
			_current_interactable.perform_interaction()
			EventBus.interaction_succeeded.emit()
			_reset_hold_state()

func clear_interactable() -> void:
	_current_interactable = null
	hide_prompt.emit()
	_reset_hold_state()

func register_interactable(interactable: Interactable) -> void:
	_current_interactable = interactable
	show_prompt.emit(_current_interactable)
	Loggie.info("Registered '%s' as current interactable." % interactable.get_parent().name, "interaction")

func unregister_interactable(interactable: Interactable) -> void:
	if _current_interactable == interactable:
		Loggie.info("Unregistered '%s'." % interactable.get_parent().name, "interaction")
		_current_interactable = null
		_reset_hold_state()
		hide_prompt.emit()

func _on_interaction_started() -> void:
	if is_instance_valid(_current_interactable):
		_is_holding = true
		Loggie.info("Interaction hold STARTED.", "interaction")

func _on_interaction_cancelled() -> void:
	if _is_holding:
		Loggie.info("Interaction hold CANCELLED.", "interaction")
	_reset_hold_state()

func _reset_hold_state() -> void:
	if not _is_holding and _hold_progress == 0.0:
		return
	_is_holding = false
	_hold_progress = 0.0
	EventBus.interaction_progress_updated.emit(0.0)

--- SCRIPT: res://Singletons/SceneEntry.gd ---
# res://Singletons/SceneEntry.gd
# This is a custom Resource script. It simply acts as a data container
# to hold a key-value pair for our scene management system.
# The Godot editor's Inspector understands resources, so it will let us
# edit these properties visually.

class_name SceneEntry
extends Resource

@export var key: String = ""
@export var scene: PackedScene

--- SCRIPT: res://Singletons/SceneManager.gd ---
# res://Singletons/SceneManager.gd
extends CanvasLayer

@export var scene_entries: Array[SceneEntry]
@export var player_scene: PackedScene

var _scene_map: Dictionary = {}
var current_scene_key: String = ""
@onready var animation_player: AnimationPlayer = $AnimationPlayer


func _ready() -> void:
	for entry in scene_entries:
		if entry and entry.scene and not entry.key.is_empty():
			_scene_map[entry.key] = entry.scene
		else:
			Loggie.error("SceneManager: Invalid entry in scene_entries array.", "setup")

	EventBus.new_game_requested.connect(_load_hideout_scene)
	EventBus.continue_game_requested.connect(_load_hideout_scene)
	EventBus.return_to_hideout_requested.connect(_load_hideout_scene)
	EventBus.start_mission_requested.connect(func(mission_key): change_scene(mission_key))


func _load_hideout_scene() -> void:
	var hideout_key = "hideout_" + str(GameManager.hideout_level)
	change_scene(hideout_key)


func change_scene(scene_key: String) -> void:
	current_scene_key = scene_key
	Loggie.info("Changing scene to: '%s'" % scene_key, "game_state")
	
	var ui_to_close = UIManager.close_current_ui()
	if is_instance_valid(ui_to_close):
		await ui_to_close.tree_exited
		
	animation_player.play("fade_to_black")
	await animation_player.animation_finished

	var scene_to_load: PackedScene = _scene_map[scene_key]
	get_tree().change_scene_to_packed(scene_to_load)
	
	await get_tree().process_frame
	
	var new_scene = get_tree().current_scene
	if new_scene.has_signal("level_generated"):
		new_scene.level_generated.connect(_spawn_player, CONNECT_ONE_SHOT)
	else:
		_spawn_player()
	
	animation_player.play("fade_from_black")


func _spawn_player() -> void:
	if not player_scene:
		Loggie.error("SceneManager Error: player_scene not set in Inspector!", "setup")
		return

	var current_scene = get_tree().current_scene
	
	var spawn_point_node = current_scene.find_child("PlayerSpawnPoint", true, false)
	if not is_instance_valid(spawn_point_node):
		Loggie.error("SceneManager Error: No PlayerSpawnPoint found in scene '%s'" % current_scene.name, "level")
		return
		
	var spawn_position: Vector2
	if GameManager.session_state and GameManager.session_state.checkpoint_position != Vector2.ZERO:
		spawn_position = GameManager.session_state.checkpoint_position
		Loggie.info("Spawning player at checkpoint: " + str(spawn_position), "game_state")
	else:
		spawn_position = spawn_point_node.global_position
		Loggie.info("Spawning player at default spawn point: " + str(spawn_position), "game_state")
		
	var player_instance = player_scene.instantiate()
	player_instance.global_position = spawn_position
	current_scene.add_child(player_instance)
	await get_tree().process_frame

--- SCRIPT: res://tests/test_game_manager.gd ---
# res://Debugging/TestScripts/test_game_manager.gd
extends GutTest

var game_manager

func before_each():
	game_manager = GameManager
	game_manager.gold = 0
	game_manager.villagers = 0
	game_manager.archers = 0


func test_gold_collected_updates_correctly():
	game_manager._on_gold_collected(15)
	assert_eq(game_manager.gold, 15, "Gold should be 15 after collecting 15.")

func test_train_archer_succeeds_with_resources():
	game_manager.gold = 20
	game_manager.villagers = 5
	game_manager._on_train_archer_requested()
	assert_eq(game_manager.gold, 10, "Gold should be reduced by 10.")
	assert_eq(game_manager.villagers, 4, "Villagers should be reduced by 1.")
	assert_eq(game_manager.archers, 1, "Archers should increase to 1.")

func test_train_archer_fails_without_enough_gold():
	game_manager.gold = 5
	game_manager.villagers = 5
	game_manager._on_train_archer_requested()
	assert_eq(game_manager.gold, 5, "Gold should not change on failure.")
	assert_eq(game_manager.villagers, 5, "Villagers should not change on failure.")
	assert_eq(game_manager.archers, 0, "Archers should not increase on failure.")

func test_train_archer_fails_without_enough_villagers():
	game_manager.gold = 20
	game_manager.villagers = 0
	game_manager._on_train_archer_requested()
	assert_eq(game_manager.gold, 20, "Gold should not change on failure.")
	assert_eq(game_manager.villagers, 0, "Villagers should not change on failure.")
	assert_eq(game_manager.archers, 0, "Archers should not increase on failure.")

--- SCRIPT: res://tests/test_persistence.gd ---
# res://tests/test_persistence.gd
extends GutTest

# Test-double for our persistence component to isolate GameManager logic.
class MockPersistenceComponent extends Node:
	var object_id: String
	var applied_state: Dictionary = {}
	func apply_state(state: Dictionary):
		applied_state = state

# We need a direct reference to the singleton for testing.
var game_manager

func before_each():
	game_manager = GameManager
	# Clear out any state from previous tests.
	game_manager._persistent_objects_session.clear()
	game_manager._persistent_objects_checkpoint.clear()

func test_set_and_get_persistent_state():
	var state = {"is_collected": true}
	game_manager.set_persistent_state("test_id_01", state)
	assert_eq(game_manager.get_persistent_state("test_id_01"), state, "Should retrieve the exact state that was set.")
	assert_null(game_manager.get_persistent_state("non_existent_id"), "Should return null for an unknown ID.")

func test_checkpoint_saves_session_data():
	game_manager.set_persistent_state("chest_01", {"is_collected": true})
	game_manager.save_checkpoint_data()
	assert_eq(game_manager._persistent_objects_checkpoint.size(), 1, "Checkpoint data should have one entry.")
	assert_true(game_manager._persistent_objects_checkpoint.has("chest_01"), "Checkpoint data should contain the collected chest's ID.")

func test_player_death_restores_checkpoint_data():
	# 1. Collect an object and save at a checkpoint.
	game_manager.set_persistent_state("chest_01", {"is_collected": true})
	game_manager.save_checkpoint_data()
	
	# 2. Collect another object but DON'T save at a checkpoint.
	game_manager.set_persistent_state("prisoner_01", {"is_rescued": true})
	assert_eq(game_manager._persistent_objects_session.size(), 2, "Session should have two objects before death.")
	
	# 3. Simulate player death (scene change is mocked).
	game_manager._on_player_died() # This should restore the checkpoint data.
	
	# 4. Assert the state is correct after respawn.
	assert_eq(game_manager._persistent_objects_session.size(), 1, "Session should revert to one object after death.")
	assert_true(game_manager._persistent_objects_session.has("chest_01"), "The checkpointed chest should still be in the session.")
	assert_false(game_manager._persistent_objects_session.has("prisoner_01"), "The non-checkpointed prisoner should be gone.")

func test_new_mission_clears_all_persistence_data():
	game_manager.set_persistent_state("chest_01", {"is_collected": true})
	game_manager.save_checkpoint_data()
	game_manager.set_persistent_state("prisoner_01", {"is_rescued": true})
	
	# Act: Start a new mission
	game_manager._on_mission_started()
	
	# Assert: Both dictionaries should be empty.
	assert_true(game_manager._persistent_objects_session.is_empty(), "Session data should be empty on new mission.")
	assert_true(game_manager._persistent_objects_checkpoint.is_empty(), "Checkpoint data should be empty on new mission.")

--- SCRIPT: res://tests/test_scene_manager.gd ---
# res://tests/test_scene_manager.gd
extends GutTest

# This script will contain all the automated tests for our SceneManager singleton.

var scene_manager

# This special GUT function runs before each test to ensure a clean slate.
func before_each():
	# Get a direct reference to the SceneManager singleton.
	scene_manager = SceneManager
	# Reset its state so one test doesn't interfere with another.
	scene_manager.current_scene_key = ""
	
# --- TEST CASES ---

# This is our "vaccine" for the KillZone bug.
# Its only job is to prove that the change_scene function correctly
# updates the current_scene_key variable.
func test_change_scene_updates_current_scene_key():
	# 1. ARRANGE: We have our fresh scene_manager from before_each().
	
	# 2. ACT: We call the function we want to test with a sample key.
	#    NOTE: We are NOT actually changing scenes here. GUT runs in a
	#    separate environment, so this call only executes the LOGIC
	#    inside the function without the visual parts.
	scene_manager.change_scene("village_outskirts")
	
	# 3. ASSERT: We check if the result is what we expect.
	#    This line says: "Assert that the scene_manager's current_scene_key
	#    is now equal to 'village_outskirts'."
	assert_eq(scene_manager.current_scene_key, "village_outskirts", "current_scene_key should be set after change_scene is called.")

--- SCRIPT: res://UserInterface/detection_meter.gd ---
extends ProgressBar

# This function is called by the Guard to update the meter's fill amount.
# It expects a value between 0.0 (empty) and 1.0 (full).
func update_progress(progress: float):
	# Set the value of the progress bar.
	value = progress
	
	# If the meter is empty, hide it. Otherwise, show it.
	if progress <= 0:
		hide()
	else:
		show()

--- SCRIPT: res://UserInterface/DialogueBox.gd ---
# res://UserInterface/DialogueBox.gd
extends CanvasLayer

# THE FIX: Add this line to declare the signal.
signal closed

@onready var _label: Label = $MarginContainer/Panel/Label

func _unhandled_input(event: InputEvent) -> void:
	# When the dialogue is visible, wait for an action to close it.
	if event.is_action_pressed("interact") or event.is_action_pressed("jump"):
		# Mark the input as handled so it doesn't trigger anything else.
		get_viewport().set_input_as_handled()
		# Announce that this dialogue is now closed.
		closed.emit()
		# Remove the dialogue box from the scene.
		queue_free()


# This is the public function the UIManager will call to set the text.
func display_message(message: String) -> void:
	_label.text = message
	# We make it visible here, now that it starts hidden by default.
	show()

--- SCRIPT: res://UserInterface/FloatingText.gd ---
# res://UserInterface/FloatingText.gd
extends Label

@export var float_height: float = 50.0

func show_text(text_to_show: String) -> void:
	text = text_to_show
	# Make the text start slightly transparent
	modulate.a = 0.0

	var tween = create_tween()
	# Chain the animations together
	# 1. Fade in over 0.2 seconds
	tween.tween_property(self, "modulate:a", 1.0, 0.2)
	# 2. Move up by 50 pixels over 1 second
	tween.tween_property(self, "position:y", position.y - float_height, 1.0).set_ease(Tween.EASE_OUT)
	# 3. Simultaneously, fade out during the last 0.5 seconds of the move
	tween.parallel().tween_property(self, "modulate:a", 0.0, 0.5).set_delay(0.5)

	# When the entire animation sequence is finished, delete the node.
	tween.finished.connect(queue_free)

--- SCRIPT: res://UserInterface/InteractionUI.gd ---
# res://UserInterface/InteractionUI.gd
extends Control

# --- Configuration ---
@export_group("Interaction Fill")
@export var default_panel_color: Color = Color("2d2d2d") # A dark grey
@export var fill_panel_color: Color = Color("ffffff")    # White
# The global vertical_offset has been removed from this script.

# --- Node References ---
@onready var _label: Label = $Panel/Label
@onready var _panel: PanelContainer = $Panel
@onready var _hold_progress_bar: ProgressBar = $Panel/HoldProgressBar

# --- Internal State ---
# We now type-hint this as an Interactable to make the code clearer.
var _target_object: Interactable = null
var _panel_stylebox: StyleBoxFlat

func _ready() -> void:
	hide()
	_hold_progress_bar.visible = false
	
	var base_stylebox = _panel.get_theme_stylebox("panel")
	if base_stylebox is StyleBoxFlat:
		_panel_stylebox = base_stylebox.duplicate(true)
		_panel.add_theme_stylebox_override("panel", _panel_stylebox)
	else:
		printerr("InteractionUI Error: Panel's theme style is not a StyleBoxFlat. Cannot change color.")

	EventBus.interaction_progress_updated.connect(_on_interaction_progress_updated)
	InteractionManager.show_prompt.connect(_on_show_prompt)
	InteractionManager.hide_prompt.connect(hide_prompt)

func _on_show_prompt(interactable: Interactable) -> void:
	_target_object = interactable
	_label.text = interactable.prompt_message
	
	if is_instance_valid(_panel_stylebox):
		_panel_stylebox.bg_color = default_panel_color
		
	show()

func hide_prompt() -> void:
	_target_object = null
	hide()

func _process(_delta: float) -> void:
	if is_instance_valid(_target_object) and visible:
		var screen_pos := get_viewport().get_canvas_transform() * _target_object.global_position
		
		# THE KEY CHANGE: We now read the offset from the target object itself.
		var offset_vector = Vector2(0, _target_object.prompt_vertical_offset)
		_panel.global_position = (screen_pos - (_panel.size / 2.0)) + offset_vector
	else:
		hide()

func _on_interaction_progress_updated(progress: float) -> void:
	if is_instance_valid(_panel_stylebox):
		_panel_stylebox.bg_color = default_panel_color.lerp(fill_panel_color, progress)

--- SCRIPT: res://UserInterface/MissionFailedScreen.gd ---
# res://UserInterface/MissionFailedScreen.gd
extends CanvasLayer

@onready var _return_button: Button = $MarginContainer/VBoxContainer/ReturnButton

func _ready() -> void:
	

	_return_button.pressed.connect(_on_return_button_pressed)
	_return_button.grab_focus()

func _input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_accept"):
		_on_return_button_pressed()

func _on_return_button_pressed() -> void:
	_return_button.disabled = true
	EventBus.return_to_hideout_requested.emit()

--- SCRIPT: res://UserInterface/MissionSuccessScreen.gd ---
# res://UserInterface/MissionSuccessScreen.gd
extends CanvasLayer

@onready var _return_button: Button = $MarginContainer/VBoxContainer/ReturnButton

func _ready() -> void:
	_return_button.pressed.connect(_on_return_button_pressed)
	_return_button.grab_focus()


func _on_return_button_pressed() -> void:
	# No longer calls UIManager. It just announces what the user wants
	EventBus.return_to_hideout_requested.emit()

--- SCRIPT: res://UserInterface/PauseMenu.gd ---
# res://UserInterface/PauseMenu.gd
extends CanvasLayer

@onready var _resume_button: Button = $MarginContainer/VBoxContainer/ResumeButton
@onready var _quit_button: Button = $MarginContainer/VBoxContainer/QuitButton

func _ready() -> void:
	_resume_button.pressed.connect(_on_resume_button_pressed)
	_quit_button.pressed.connect(_on_quit_button_pressed)
	_resume_button.grab_focus()
	
func _on_resume_button_pressed() -> void:
	# Announce the intent to unpause the game.
	EventBus.pause_toggled.emit(false)

func _on_quit_button_pressed() -> void:
	# This button's only job is to announce the user's intent on the EventBus.
	# The SceneManager will hear this and handle the entire process of
	# closing the UI and changing the scene.
	EventBus.return_to_hideout_requested.emit()

--- SCRIPT: res://UserInterface/TitleScreen.gd ---
# res://UserInterface/TitleScreen.gd
extends Control

@onready var _new_game_button: Button = $CenterContainer/VBoxContainer/NewGameButton
@onready var _continue_button: Button = $CenterContainer/VBoxContainer/ContinueButton

func _ready() -> void:
	_new_game_button.pressed.connect(_on_new_game_button_pressed)
	_continue_button.pressed.connect(_on_continue_button_pressed)
	
	if FileAccess.file_exists(GameManager.SAVE_FILE_PATH):
		_continue_button.disabled = false
		# If the continue button is available, make it the default.
		_continue_button.grab_focus()
	else:
		_continue_button.disabled = true
		# Otherwise, make the New Game button the default.
		_new_game_button.grab_focus()
		
func _on_new_game_button_pressed() -> void:
	GameManager.reset_game_data()
	# CORRECTED: Announce the user's intent on the EventBus.
	EventBus.new_game_requested.emit()

func _on_continue_button_pressed() -> void:
	# CORRECTED: Announce the user's intent on the EventBus.
	EventBus.continue_game_requested.emit()

--- SCRIPT: res://UserInterface/UIManager.gd ---
# res://UserInterface/UIManager.gd
extends CanvasLayer

var _ui_scenes: Dictionary = {
	"PauseMenu": "res://UserInterface/PauseMenu.tscn",
	"MissionSuccessScreen": "res://UserInterface/MissionSuccessScreen.tscn",
	"MissionFailedScreen": "res://UserInterface/MissionFailedScreen.tscn"
}
var _dialogue_box_path: String = "res://UserInterface/DialogueBox.tscn"
# We still need the path to create the instance.
var _interaction_ui_path: String = "res://UserInterface/InteractionUI.tscn"

var _current_ui: CanvasLayer = null
# We no longer need to hold a reference to the instance here,
# as it will manage itself after being added to the scene.

func _ready() -> void:
	EventBus.mission_succeeded.connect(_on_mission_succeeded)
	EventBus.mission_failed.connect(_on_mission_failed)
	EventBus.pause_toggled.connect(_on_pause_toggled)
	EventBus.show_dialogue.connect(_on_show_dialogue)
	EventBus.pause_menu_requested.connect(_on_pause_menu_requested)

	# --- THE FIX IS HERE ---
	# The UIManager's job is to create the UI, but that's it.
	# We no longer connect to the InteractionManager's signals here.
	var interaction_scene: PackedScene = load(_interaction_ui_path)
	if interaction_scene:
		var interaction_ui_instance = interaction_scene.instantiate()
		add_child(interaction_ui_instance)
	# The InteractionUI.gd script will handle its own signal connections in its own _ready() function.

# --- ALL OF THE FOLLOWING FUNCTIONS HAVE BEEN REMOVED ---
# func _on_show_prompt(...)
# func _on_hide_prompt(...)

func _on_pause_menu_requested():
	if not _current_ui:
		_show_ui("PauseMenu")

func _on_pause_toggled(is_pausing: bool) -> void:
	if not is_pausing:
		if _current_ui and _current_ui.get_script().get_path().contains("PauseMenu.gd"):
			_close_ui()

func _on_show_dialogue(message: String) -> void:
	if _current_ui: return
	var dialogue_scene: PackedScene = load(_dialogue_box_path)
	if dialogue_scene:
		var dialogue_instance = dialogue_scene.instantiate()
		_current_ui = dialogue_instance
		_current_ui.closed.connect(_on_dialogue_closed)
		add_child(dialogue_instance)
		dialogue_instance.display_message(message)
		EventBus.pause_toggled.emit(true)

func _on_dialogue_closed() -> void:
	_current_ui = null
	EventBus.pause_toggled.emit(false)

func _show_ui(ui_name: String) -> void:
	if _current_ui: return
	var scene_path = _ui_scenes.get(ui_name)
	if not scene_path:
		printerr("UIManager Error: UI scene '", ui_name, "' not found.")
		return
	var loaded_scene: PackedScene = load(scene_path)
	if loaded_scene:
		_current_ui = loaded_scene.instantiate()
		add_child(_current_ui)
		EventBus.pause_toggled.emit(true)

func _close_ui() -> void:
	if is_instance_valid(_current_ui):
		_current_ui.queue_free()
		_current_ui = null
		EventBus.pause_toggled.emit(false)

func _on_mission_succeeded() -> void:
	_show_ui("MissionSuccessScreen")

func _on_mission_failed() -> void:
	_show_ui("MissionFailedScreen")

func close_current_ui() -> Node:
	if is_instance_valid(_current_ui):
		var ui_node_to_close = _current_ui
		_close_ui()
		return ui_node_to_close
	return null

--- SCRIPT: res://VFX/AnimatedEffect.gd ---
# res://VFX/AnimatedEffect.gd
extends AnimatedSprite2D

# This script plays a specified animation once, then removes itself from the scene.
# It makes our visual effects reusable and self-managing.

func _ready() -> void:
	# Connect the animation_finished signal to our cleanup function.
	# This is the most reliable way to know when the effect is done.
	animation_finished.connect(_on_animation_finished)


# This is the main public function that other scripts will call.
# It tells the effect which animation to play.
func play_effect(animation_name: String, speed: float = 1.0) -> void:
	# The third argument, "from_end", should be true if speed is negative.
	play(animation_name, speed, speed < 0)


func _on_animation_finished() -> void:
	# Once the animation is complete, remove the node from the scene tree.
	queue_free()

--- SCRIPT: res://VFX/DustPuff.gd ---
# res://VFX/DustPuff.gd
extends GPUParticles2D

# This script makes the particle effect automatically
# remove itself from the scene after it has finished playing.

func _ready() -> void:
	# The 'finished' signal is emitted by GPUParticles2D when all particles
	# have died. This is perfect for a one-shot effect.
	finished.connect(_on_finished)


func _on_finished() -> void:
	# Once the signal is received, we simply queue the node for deletion.
	queue_free()

--- SCRIPT: res://VFX/VFXData/VFXData.gd ---
# res://VFX/VFXData/VFXData.gd
class_name VFXData
extends Resource

@export_group("Core Properties")
@export var effect_scene: PackedScene
@export var animation_name: String = ""
@export var playback_speed: float = 1.0

@export_group("Spawning Behavior")
@export var spawn_marker_name: String = "FootSpawner"
@export var position_offset: Vector2 = Vector2.ZERO
@export var flip_h_with_player: bool = false
@export var flip_h_with_wall: bool = false
@export var rotate_with_wall_normal: bool = false
@export var rotation_degrees: float = 0.0
@export var scale: Vector2 = Vector2.ONE

@export_group("Extra Effects")
## The strength of the camera zoom punch. 0 = no punch, 0.1 = 10% zoom.
@export var camera_punch_intensity: float = 0.0

--- SCRIPT: res://VFX/VFXManager.gd ---
# res://VFX/VFXManager.gd
extends Node2D

@onready var player: CharacterBody2D = get_parent() as CharacterBody2D
@onready var camera: Camera2D = player.get_node("PlayerCamera")

# --- Generic, Resource-Based Function for one-shot effects ---
func play_effect(vfx_data: VFXData) -> void:
	if not is_instance_valid(vfx_data) or not is_instance_valid(vfx_data.effect_scene):
		return

	var effect: AnimatedSprite2D = vfx_data.effect_scene.instantiate()
	get_tree().root.add_child(effect)

	# ... (positioning, scaling, flipping logic is the same) ...
	var spawn_marker: Marker2D = player.get_node_or_null(vfx_data.spawn_marker_name)
	var spawn_pos: Vector2
	if is_instance_valid(spawn_marker):
		spawn_pos = spawn_marker.global_position
	else:
		spawn_pos = player.global_position
	effect.scale = vfx_data.scale
	if vfx_data.flip_h_with_player:
		var direction = -1.0 if player.animated_sprite.flip_h else 1.0
		effect.flip_h = player.animated_sprite.flip_h
		spawn_pos.x += vfx_data.position_offset.x * direction
		spawn_pos.y += vfx_data.position_offset.y
	elif vfx_data.flip_h_with_wall:
		var wall_normal = player.get_wall_normal()
		effect.flip_h = wall_normal.x < 0
	else:
		spawn_pos += vfx_data.position_offset
	effect.global_position = spawn_pos
	if vfx_data.rotate_with_wall_normal and player.is_on_wall():
		var wall_normal = player.get_wall_normal()
		effect.rotation_degrees = -90 if wall_normal.x > 0 else 90
	else:
		effect.rotation_degrees = vfx_data.rotation_degrees
		
	# --- NEW: Generic Camera Punch Logic ---
	if vfx_data.camera_punch_intensity > 0.0:
		_trigger_camera_punch(vfx_data.camera_punch_intensity)

	# --- Play ---
	if effect.has_method("play_effect"):
		effect.play_effect(vfx_data.animation_name, vfx_data.playback_speed)


# --- Specific Functions for Sustained Effects (like Dash) ---
func play_dash_effects(particles: GPUParticles2D) -> void:
	if not is_instance_valid(particles): return
	# The camera punch is no longer triggered here.
	var dash_direction = Vector2(1 if not player.animated_sprite.flip_h else -1, 0)
	particles.scale.x = dash_direction.x
	particles.emitting = true

func stop_dash_effects(particles: GPUParticles2D) -> void:
	if not is_instance_valid(particles): return
	particles.emitting = false
	particles.scale.x = 1

func _trigger_camera_punch(intensity: float) -> void:
	if not is_instance_valid(camera):
		return
	var tween = create_tween().set_trans(Tween.TRANS_QUAD)
	# Use the intensity from the VFXData resource.
	var zoomed_in_vec = camera.zoom * (1.0 + intensity)
	tween.tween_property(camera, "zoom", zoomed_in_vec, 0.1).set_ease(Tween.EASE_OUT)
	tween.tween_property(camera, "zoom", camera.zoom, 0.1).set_ease(Tween.EASE_IN)

--- SCRIPT: res://World/Checkpoint.gd ---
# res://World/Checkpoint.gd
extends Area2D

signal checkpoint_activated(position: Vector2)

@export var respawn_point: NodePath

@onready var _respawn_marker: Marker2D = get_node_or_null(respawn_point) as Marker2D


func _ready() -> void:
	body_entered.connect(_on_body_entered)


func _on_body_entered(body: Node) -> void:
	if body.is_in_group("player"):
		assert(is_instance_valid(_respawn_marker), "RespawnPoint NodePath must be set on Checkpoint in the editor.")
		var respawn_pos: Vector2 = _respawn_marker.global_position
		
		checkpoint_activated.emit(respawn_pos)
		GameManager.set_checkpoint(respawn_pos)
		GameManager.save_checkpoint_data()
		Loggie.info("Checkpoint activated. Respawn at: " + str(respawn_pos), "checkpoint")

--- SCRIPT: res://World/ExitZone.gd ---
# res://World/exit_zone.gd
extends Area2D

func _ready() -> void:
	body_entered.connect(_on_body_entered)


func _on_body_entered(body: Node) -> void:
	if body.is_in_group("player"):
		# Check the GameManager's state to see if we can exit.
		if GameManager.mission_objective_complete:
			# Announce that the objective is complete. The GameManager will
			# hear this and trigger the mission success sequence.
			EventBus.mission_objective_completed.emit()
			
			$CollisionShape2D.set_deferred("disabled", true)

--- SCRIPT: res://World/KillZone.gd ---
# res://World/Killzone.gd
extends Area2D

func _ready() -> void:
	body_entered.connect(_on_body_entered)


func _on_body_entered(body: Node) -> void:
	if body.is_in_group("player"):
		Loggie.info("Player entered KillZone. Emitting player_died signal.", "game_state")
		EventBus.player_died.emit()
--- END OF CODEBASE ---

---
